'use strict';

var obsidian = require('obsidian');
var require$$0 = require('util');
var buffer = require('buffer');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var require$$0__default = /*#__PURE__*/_interopDefaultLegacy(require$$0);
var buffer__default = /*#__PURE__*/_interopDefaultLegacy(buffer);

var AsyncLock = function (opts) {
	opts = opts || {};

	this.Promise = opts.Promise || Promise;

	// format: {key : [fn, fn]}
	// queues[key] = null indicates no job running for key
	this.queues = Object.create(null);

	// lock is reentrant for same domain
	this.domainReentrant = opts.domainReentrant || false;
	if (this.domainReentrant) {
		if (typeof process === 'undefined' || typeof process.domain === 'undefined') {
			throw new Error(
				'Domain-reentrant locks require `process.domain` to exist. Please flip `opts.domainReentrant = false`, ' +
				'use a NodeJS version that still implements Domain, or install a browser polyfill.');
		}
		// domain of current running func {key : fn}
		this.domains = Object.create(null);
	}

	this.timeout = opts.timeout || AsyncLock.DEFAULT_TIMEOUT;
	if (opts.maxPending === Infinity || (Number.isInteger(opts.maxPending) && opts.maxPending >= 0)) {
		this.maxPending = opts.maxPending;
	} else {
		this.maxPending = AsyncLock.DEFAULT_MAX_PENDING;
	}
};

AsyncLock.DEFAULT_TIMEOUT = 0; //Never
AsyncLock.DEFAULT_MAX_PENDING = 1000;

/**
 * Acquire Locks
 *
 * @param {String|Array} key 	resource key or keys to lock
 * @param {function} fn 	async function
 * @param {function} cb 	callback function, otherwise will return a promise
 * @param {Object} opts 	options
 */
AsyncLock.prototype.acquire = function (key, fn, cb, opts) {
	if (Array.isArray(key)) {
		return this._acquireBatch(key, fn, cb, opts);
	}

	if (typeof (fn) !== 'function') {
		throw new Error('You must pass a function to execute');
	}

	// faux-deferred promise using new Promise() (as Promise.defer is deprecated)
	var deferredResolve = null;
	var deferredReject = null;
	var deferred = null;

	if (typeof (cb) !== 'function') {
		opts = cb;
		cb = null;

		// will return a promise
		deferred = new this.Promise(function(resolve, reject) {
			deferredResolve = resolve;
			deferredReject = reject;
		});
	}

	opts = opts || {};

	var resolved = false;
	var timer = null;
	var self = this;

	var done = function (locked, err, ret) {
		if (locked) {
			if (self.queues[key].length === 0) {
				delete self.queues[key];
			}
			if (self.domainReentrant) {
				delete self.domains[key];
			}
		}

		if (!resolved) {
			if (!deferred) {
				if (typeof (cb) === 'function') {
					cb(err, ret);
				}
			}
			else {
				//promise mode
				if (err) {
					deferredReject(err);
				}
				else {
					deferredResolve(ret);
				}
			}
			resolved = true;
		}

		if (locked) {
			//run next func
			if (!!self.queues[key] && self.queues[key].length > 0) {
				self.queues[key].shift()();
			}
		}
	};

	var exec = function (locked) {
		if (resolved) { // may due to timed out
			return done(locked);
		}

		if (timer) {
			clearTimeout(timer);
			timer = null;
		}

		if (self.domainReentrant && locked) {
			self.domains[key] = process.domain;
		}

		// Callback mode
		if (fn.length === 1) {
			var called = false;
			fn(function (err, ret) {
				if (!called) {
					called = true;
					done(locked, err, ret);
				}
			});
		}
		else {
			// Promise mode
			self._promiseTry(function () {
				return fn();
			})
			.then(function(ret){
				done(locked, undefined, ret);
			}, function(error){
				done(locked, error);
			});
		}
	};
	if (self.domainReentrant && !!process.domain) {
		exec = process.domain.bind(exec);
	}

	if (!self.queues[key]) {
		self.queues[key] = [];
		exec(true);
	}
	else if (self.domainReentrant && !!process.domain && process.domain === self.domains[key]) {
		// If code is in the same domain of current running task, run it directly
		// Since lock is re-enterable
		exec(false);
	}
	else if (self.queues[key].length >= self.maxPending) {
		done(false, new Error('Too much pending tasks'));
	}
	else {
		var taskFn = function () {
			exec(true);
		};
		if (opts.skipQueue) {
			self.queues[key].unshift(taskFn);
		} else {
			self.queues[key].push(taskFn);
		}

		var timeout = opts.timeout || self.timeout;
		if (timeout) {
			timer = setTimeout(function () {
				timer = null;
				done(false, new Error('async-lock timed out'));
			}, timeout);
		}
	}

	if (deferred) {
		return deferred;
	}
};

/*
 * Below is how this function works:
 *
 * Equivalent code:
 * self.acquire(key1, function(cb){
 *     self.acquire(key2, function(cb){
 *         self.acquire(key3, fn, cb);
 *     }, cb);
 * }, cb);
 *
 * Equivalent code:
 * var fn3 = getFn(key3, fn);
 * var fn2 = getFn(key2, fn3);
 * var fn1 = getFn(key1, fn2);
 * fn1(cb);
 */
AsyncLock.prototype._acquireBatch = function (keys, fn, cb, opts) {
	if (typeof (cb) !== 'function') {
		opts = cb;
		cb = null;
	}

	var self = this;
	var getFn = function (key, fn) {
		return function (cb) {
			self.acquire(key, fn, cb, opts);
		};
	};

	var fnx = fn;
	keys.reverse().forEach(function (key) {
		fnx = getFn(key, fnx);
	});

	if (typeof (cb) === 'function') {
		fnx(cb);
	}
	else {
		return new this.Promise(function (resolve, reject) {
			// check for promise mode in case keys is empty array
			if (fnx.length === 1) {
				fnx(function (err, ret) {
					if (err) {
						reject(err);
					}
					else {
						resolve(ret);
					}
				});
			} else {
				resolve(fnx());
			}
		});
	}
};

/*
 *	Whether there is any running or pending asyncFunc
 *
 *	@param {String} key
 */
AsyncLock.prototype.isBusy = function (key) {
	if (!key) {
		return Object.keys(this.queues).length > 0;
	}
	else {
		return !!this.queues[key];
	}
};

/**
 * Promise.try() implementation to become independent of Q-specific methods
 */
AsyncLock.prototype._promiseTry = function(fn) {
	try {
		return this.Promise.resolve(fn());
	} catch (e) {
		return this.Promise.reject(e);
	}
};

var lib$1 = AsyncLock;

var asyncLock = lib$1;

function createCommonjsModule(fn) {
  var module = { exports: {} };
	return fn(module, module.exports), module.exports;
}

var inherits_browser = createCommonjsModule(function (module) {
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor;
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor;
      var TempCtor = function () {};
      TempCtor.prototype = superCtor.prototype;
      ctor.prototype = new TempCtor();
      ctor.prototype.constructor = ctor;
    }
  };
}
});

var inherits = createCommonjsModule(function (module) {
try {
  var util = require$$0__default['default'];
  /* istanbul ignore next */
  if (typeof util.inherits !== 'function') throw '';
  module.exports = util.inherits;
} catch (e) {
  /* istanbul ignore next */
  module.exports = inherits_browser;
}
});

/* eslint-disable node/no-deprecated-api */

var safeBuffer = createCommonjsModule(function (module, exports) {
var Buffer = buffer__default['default'].Buffer;

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key];
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer__default['default'];
} else {
  // Copy properties from require('buffer')
  copyProps(buffer__default['default'], exports);
  exports.Buffer = SafeBuffer;
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer);

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
};

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size);
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding);
    } else {
      buf.fill(fill);
    }
  } else {
    buf.fill(0);
  }
  return buf
};

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
};

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer__default['default'].SlowBuffer(size)
};
});

var Buffer$2 = safeBuffer.Buffer;

// prototype class for hash functions
function Hash (blockSize, finalSize) {
  this._block = Buffer$2.alloc(blockSize);
  this._finalSize = finalSize;
  this._blockSize = blockSize;
  this._len = 0;
}

Hash.prototype.update = function (data, enc) {
  if (typeof data === 'string') {
    enc = enc || 'utf8';
    data = Buffer$2.from(data, enc);
  }

  var block = this._block;
  var blockSize = this._blockSize;
  var length = data.length;
  var accum = this._len;

  for (var offset = 0; offset < length;) {
    var assigned = accum % blockSize;
    var remainder = Math.min(length - offset, blockSize - assigned);

    for (var i = 0; i < remainder; i++) {
      block[assigned + i] = data[offset + i];
    }

    accum += remainder;
    offset += remainder;

    if ((accum % blockSize) === 0) {
      this._update(block);
    }
  }

  this._len += length;
  return this
};

Hash.prototype.digest = function (enc) {
  var rem = this._len % this._blockSize;

  this._block[rem] = 0x80;

  // zero (rem + 1) trailing bits, where (rem + 1) is the smallest
  // non-negative solution to the equation (length + 1 + (rem + 1)) === finalSize mod blockSize
  this._block.fill(0, rem + 1);

  if (rem >= this._finalSize) {
    this._update(this._block);
    this._block.fill(0);
  }

  var bits = this._len * 8;

  // uint32
  if (bits <= 0xffffffff) {
    this._block.writeUInt32BE(bits, this._blockSize - 4);

  // uint64
  } else {
    var lowBits = (bits & 0xffffffff) >>> 0;
    var highBits = (bits - lowBits) / 0x100000000;

    this._block.writeUInt32BE(highBits, this._blockSize - 8);
    this._block.writeUInt32BE(lowBits, this._blockSize - 4);
  }

  this._update(this._block);
  var hash = this._hash();

  return enc ? hash.toString(enc) : hash
};

Hash.prototype._update = function () {
  throw new Error('_update must be implemented by subclass')
};

var hash = Hash;

/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
 * in FIPS PUB 180-1
 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for details.
 */

var Buffer$1 = safeBuffer.Buffer;

var K = [
  0x5a827999, 0x6ed9eba1, 0x8f1bbcdc | 0, 0xca62c1d6 | 0
];

var W = new Array(80);

function Sha1 () {
  this.init();
  this._w = W;

  hash.call(this, 64, 56);
}

inherits(Sha1, hash);

Sha1.prototype.init = function () {
  this._a = 0x67452301;
  this._b = 0xefcdab89;
  this._c = 0x98badcfe;
  this._d = 0x10325476;
  this._e = 0xc3d2e1f0;

  return this
};

function rotl1 (num) {
  return (num << 1) | (num >>> 31)
}

function rotl5 (num) {
  return (num << 5) | (num >>> 27)
}

function rotl30 (num) {
  return (num << 30) | (num >>> 2)
}

function ft (s, b, c, d) {
  if (s === 0) return (b & c) | ((~b) & d)
  if (s === 2) return (b & c) | (b & d) | (c & d)
  return b ^ c ^ d
}

Sha1.prototype._update = function (M) {
  var W = this._w;

  var a = this._a | 0;
  var b = this._b | 0;
  var c = this._c | 0;
  var d = this._d | 0;
  var e = this._e | 0;

  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4);
  for (; i < 80; ++i) W[i] = rotl1(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16]);

  for (var j = 0; j < 80; ++j) {
    var s = ~~(j / 20);
    var t = (rotl5(a) + ft(s, b, c, d) + e + W[j] + K[s]) | 0;

    e = d;
    d = c;
    c = rotl30(b);
    b = a;
    a = t;
  }

  this._a = (a + this._a) | 0;
  this._b = (b + this._b) | 0;
  this._c = (c + this._c) | 0;
  this._d = (d + this._d) | 0;
  this._e = (e + this._e) | 0;
};

Sha1.prototype._hash = function () {
  var H = Buffer$1.allocUnsafe(20);

  H.writeInt32BE(this._a | 0, 0);
  H.writeInt32BE(this._b | 0, 4);
  H.writeInt32BE(this._c | 0, 8);
  H.writeInt32BE(this._d | 0, 12);
  H.writeInt32BE(this._e | 0, 16);

  return H
};

var sha1 = Sha1;

/* crc32.js (C) 2014-present SheetJS -- http://sheetjs.com */

var crc32$1 = createCommonjsModule(function (module, exports) {
(function (factory) {
	/*jshint ignore:start */
	/*eslint-disable */
	if(typeof DO_NOT_EXPORT_CRC === 'undefined') {
		{
			factory(exports);
		}
	} else {
		factory({});
	}
	/*eslint-enable */
	/*jshint ignore:end */
}(function(CRC32) {
CRC32.version = '1.2.0';
/* see perf/crc32table.js */
/*global Int32Array */
function signed_crc_table() {
	var c = 0, table = new Array(256);

	for(var n =0; n != 256; ++n){
		c = n;
		c = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));
		c = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));
		c = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));
		c = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));
		c = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));
		c = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));
		c = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));
		c = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));
		table[n] = c;
	}

	return typeof Int32Array !== 'undefined' ? new Int32Array(table) : table;
}

var T = signed_crc_table();
function crc32_bstr(bstr, seed) {
	var C = seed ^ -1, L = bstr.length - 1;
	for(var i = 0; i < L;) {
		C = (C>>>8) ^ T[(C^bstr.charCodeAt(i++))&0xFF];
		C = (C>>>8) ^ T[(C^bstr.charCodeAt(i++))&0xFF];
	}
	if(i === L) C = (C>>>8) ^ T[(C ^ bstr.charCodeAt(i))&0xFF];
	return C ^ -1;
}

function crc32_buf(buf, seed) {
	if(buf.length > 10000) return crc32_buf_8(buf, seed);
	var C = seed ^ -1, L = buf.length - 3;
	for(var i = 0; i < L;) {
		C = (C>>>8) ^ T[(C^buf[i++])&0xFF];
		C = (C>>>8) ^ T[(C^buf[i++])&0xFF];
		C = (C>>>8) ^ T[(C^buf[i++])&0xFF];
		C = (C>>>8) ^ T[(C^buf[i++])&0xFF];
	}
	while(i < L+3) C = (C>>>8) ^ T[(C^buf[i++])&0xFF];
	return C ^ -1;
}

function crc32_buf_8(buf, seed) {
	var C = seed ^ -1, L = buf.length - 7;
	for(var i = 0; i < L;) {
		C = (C>>>8) ^ T[(C^buf[i++])&0xFF];
		C = (C>>>8) ^ T[(C^buf[i++])&0xFF];
		C = (C>>>8) ^ T[(C^buf[i++])&0xFF];
		C = (C>>>8) ^ T[(C^buf[i++])&0xFF];
		C = (C>>>8) ^ T[(C^buf[i++])&0xFF];
		C = (C>>>8) ^ T[(C^buf[i++])&0xFF];
		C = (C>>>8) ^ T[(C^buf[i++])&0xFF];
		C = (C>>>8) ^ T[(C^buf[i++])&0xFF];
	}
	while(i < L+7) C = (C>>>8) ^ T[(C^buf[i++])&0xFF];
	return C ^ -1;
}

function crc32_str(str, seed) {
	var C = seed ^ -1;
	for(var i = 0, L=str.length, c, d; i < L;) {
		c = str.charCodeAt(i++);
		if(c < 0x80) {
			C = (C>>>8) ^ T[(C ^ c)&0xFF];
		} else if(c < 0x800) {
			C = (C>>>8) ^ T[(C ^ (192|((c>>6)&31)))&0xFF];
			C = (C>>>8) ^ T[(C ^ (128|(c&63)))&0xFF];
		} else if(c >= 0xD800 && c < 0xE000) {
			c = (c&1023)+64; d = str.charCodeAt(i++)&1023;
			C = (C>>>8) ^ T[(C ^ (240|((c>>8)&7)))&0xFF];
			C = (C>>>8) ^ T[(C ^ (128|((c>>2)&63)))&0xFF];
			C = (C>>>8) ^ T[(C ^ (128|((d>>6)&15)|((c&3)<<4)))&0xFF];
			C = (C>>>8) ^ T[(C ^ (128|(d&63)))&0xFF];
		} else {
			C = (C>>>8) ^ T[(C ^ (224|((c>>12)&15)))&0xFF];
			C = (C>>>8) ^ T[(C ^ (128|((c>>6)&63)))&0xFF];
			C = (C>>>8) ^ T[(C ^ (128|(c&63)))&0xFF];
		}
	}
	return C ^ -1;
}
CRC32.table = T;
// $FlowIgnore
CRC32.bstr = crc32_bstr;
// $FlowIgnore
CRC32.buf = crc32_buf;
// $FlowIgnore
CRC32.str = crc32_str;
}));
});

var common = createCommonjsModule(function (module, exports) {


var TYPED_OK =  (typeof Uint8Array !== 'undefined') &&
                (typeof Uint16Array !== 'undefined') &&
                (typeof Int32Array !== 'undefined');

function _has(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
}

exports.assign = function (obj /*from1, from2, from3, ...*/) {
  var sources = Array.prototype.slice.call(arguments, 1);
  while (sources.length) {
    var source = sources.shift();
    if (!source) { continue; }

    if (typeof source !== 'object') {
      throw new TypeError(source + 'must be non-object');
    }

    for (var p in source) {
      if (_has(source, p)) {
        obj[p] = source[p];
      }
    }
  }

  return obj;
};


// reduce buffer size, avoiding mem copy
exports.shrinkBuf = function (buf, size) {
  if (buf.length === size) { return buf; }
  if (buf.subarray) { return buf.subarray(0, size); }
  buf.length = size;
  return buf;
};


var fnTyped = {
  arraySet: function (dest, src, src_offs, len, dest_offs) {
    if (src.subarray && dest.subarray) {
      dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
      return;
    }
    // Fallback to ordinary array
    for (var i = 0; i < len; i++) {
      dest[dest_offs + i] = src[src_offs + i];
    }
  },
  // Join array of chunks to single array.
  flattenChunks: function (chunks) {
    var i, l, len, pos, chunk, result;

    // calculate data length
    len = 0;
    for (i = 0, l = chunks.length; i < l; i++) {
      len += chunks[i].length;
    }

    // join chunks
    result = new Uint8Array(len);
    pos = 0;
    for (i = 0, l = chunks.length; i < l; i++) {
      chunk = chunks[i];
      result.set(chunk, pos);
      pos += chunk.length;
    }

    return result;
  }
};

var fnUntyped = {
  arraySet: function (dest, src, src_offs, len, dest_offs) {
    for (var i = 0; i < len; i++) {
      dest[dest_offs + i] = src[src_offs + i];
    }
  },
  // Join array of chunks to single array.
  flattenChunks: function (chunks) {
    return [].concat.apply([], chunks);
  }
};


// Enable/Disable typed arrays use, for testing
//
exports.setTyped = function (on) {
  if (on) {
    exports.Buf8  = Uint8Array;
    exports.Buf16 = Uint16Array;
    exports.Buf32 = Int32Array;
    exports.assign(exports, fnTyped);
  } else {
    exports.Buf8  = Array;
    exports.Buf16 = Array;
    exports.Buf32 = Array;
    exports.assign(exports, fnUntyped);
  }
};

exports.setTyped(TYPED_OK);
});

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

/* eslint-disable space-unary-ops */



/* Public constants ==========================================================*/
/* ===========================================================================*/


//var Z_FILTERED          = 1;
//var Z_HUFFMAN_ONLY      = 2;
//var Z_RLE               = 3;
var Z_FIXED$1               = 4;
//var Z_DEFAULT_STRATEGY  = 0;

/* Possible values of the data_type field (though see inflate()) */
var Z_BINARY              = 0;
var Z_TEXT                = 1;
//var Z_ASCII             = 1; // = Z_TEXT
var Z_UNKNOWN$1             = 2;

/*============================================================================*/


function zero$1(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }

// From zutil.h

var STORED_BLOCK = 0;
var STATIC_TREES = 1;
var DYN_TREES    = 2;
/* The three kinds of block type */

var MIN_MATCH$1    = 3;
var MAX_MATCH$1    = 258;
/* The minimum and maximum match lengths */

// From deflate.h
/* ===========================================================================
 * Internal compression state.
 */

var LENGTH_CODES$1  = 29;
/* number of length codes, not counting the special END_BLOCK code */

var LITERALS$1      = 256;
/* number of literal bytes 0..255 */

var L_CODES$1       = LITERALS$1 + 1 + LENGTH_CODES$1;
/* number of Literal or Length codes, including the END_BLOCK code */

var D_CODES$1       = 30;
/* number of distance codes */

var BL_CODES$1      = 19;
/* number of codes used to transfer the bit lengths */

var HEAP_SIZE$1     = 2 * L_CODES$1 + 1;
/* maximum heap size */

var MAX_BITS$1      = 15;
/* All codes must not exceed MAX_BITS bits */

var Buf_size      = 16;
/* size of bit buffer in bi_buf */


/* ===========================================================================
 * Constants
 */

var MAX_BL_BITS = 7;
/* Bit length codes must not exceed MAX_BL_BITS bits */

var END_BLOCK   = 256;
/* end of block literal code */

var REP_3_6     = 16;
/* repeat previous bit length 3-6 times (2 bits of repeat count) */

var REPZ_3_10   = 17;
/* repeat a zero length 3-10 times  (3 bits of repeat count) */

var REPZ_11_138 = 18;
/* repeat a zero length 11-138 times  (7 bits of repeat count) */

/* eslint-disable comma-spacing,array-bracket-spacing */
var extra_lbits =   /* extra bits for each length code */
  [0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0];

var extra_dbits =   /* extra bits for each distance code */
  [0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13];

var extra_blbits =  /* extra bits for each bit length code */
  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7];

var bl_order =
  [16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];
/* eslint-enable comma-spacing,array-bracket-spacing */

/* The lengths of the bit length codes are sent in order of decreasing
 * probability, to avoid transmitting the lengths for unused bit length codes.
 */

/* ===========================================================================
 * Local data. These are initialized only once.
 */

// We pre-fill arrays with 0 to avoid uninitialized gaps

var DIST_CODE_LEN = 512; /* see definition of array dist_code below */

// !!!! Use flat array instead of structure, Freq = i*2, Len = i*2+1
var static_ltree  = new Array((L_CODES$1 + 2) * 2);
zero$1(static_ltree);
/* The static literal tree. Since the bit lengths are imposed, there is no
 * need for the L_CODES extra codes used during heap construction. However
 * The codes 286 and 287 are needed to build a canonical tree (see _tr_init
 * below).
 */

var static_dtree  = new Array(D_CODES$1 * 2);
zero$1(static_dtree);
/* The static distance tree. (Actually a trivial tree since all codes use
 * 5 bits.)
 */

var _dist_code    = new Array(DIST_CODE_LEN);
zero$1(_dist_code);
/* Distance codes. The first 256 values correspond to the distances
 * 3 .. 258, the last 256 values correspond to the top 8 bits of
 * the 15 bit distances.
 */

var _length_code  = new Array(MAX_MATCH$1 - MIN_MATCH$1 + 1);
zero$1(_length_code);
/* length code for each normalized match length (0 == MIN_MATCH) */

var base_length   = new Array(LENGTH_CODES$1);
zero$1(base_length);
/* First normalized length for each code (0 = MIN_MATCH) */

var base_dist     = new Array(D_CODES$1);
zero$1(base_dist);
/* First normalized distance for each code (0 = distance of 1) */


function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {

  this.static_tree  = static_tree;  /* static tree or NULL */
  this.extra_bits   = extra_bits;   /* extra bits for each code or NULL */
  this.extra_base   = extra_base;   /* base index for extra_bits */
  this.elems        = elems;        /* max number of elements in the tree */
  this.max_length   = max_length;   /* max bit length for the codes */

  // show if `static_tree` has data or dummy - needed for monomorphic objects
  this.has_stree    = static_tree && static_tree.length;
}


var static_l_desc;
var static_d_desc;
var static_bl_desc;


function TreeDesc(dyn_tree, stat_desc) {
  this.dyn_tree = dyn_tree;     /* the dynamic tree */
  this.max_code = 0;            /* largest code with non zero frequency */
  this.stat_desc = stat_desc;   /* the corresponding static tree */
}



function d_code(dist) {
  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
}


/* ===========================================================================
 * Output a short LSB first on the stream.
 * IN assertion: there is enough room in pendingBuf.
 */
function put_short(s, w) {
//    put_byte(s, (uch)((w) & 0xff));
//    put_byte(s, (uch)((ush)(w) >> 8));
  s.pending_buf[s.pending++] = (w) & 0xff;
  s.pending_buf[s.pending++] = (w >>> 8) & 0xff;
}


/* ===========================================================================
 * Send a value on a given number of bits.
 * IN assertion: length <= 16 and value fits in length bits.
 */
function send_bits(s, value, length) {
  if (s.bi_valid > (Buf_size - length)) {
    s.bi_buf |= (value << s.bi_valid) & 0xffff;
    put_short(s, s.bi_buf);
    s.bi_buf = value >> (Buf_size - s.bi_valid);
    s.bi_valid += length - Buf_size;
  } else {
    s.bi_buf |= (value << s.bi_valid) & 0xffff;
    s.bi_valid += length;
  }
}


function send_code(s, c, tree) {
  send_bits(s, tree[c * 2]/*.Code*/, tree[c * 2 + 1]/*.Len*/);
}


/* ===========================================================================
 * Reverse the first len bits of a code, using straightforward code (a faster
 * method would use a table)
 * IN assertion: 1 <= len <= 15
 */
function bi_reverse(code, len) {
  var res = 0;
  do {
    res |= code & 1;
    code >>>= 1;
    res <<= 1;
  } while (--len > 0);
  return res >>> 1;
}


/* ===========================================================================
 * Flush the bit buffer, keeping at most 7 bits in it.
 */
function bi_flush(s) {
  if (s.bi_valid === 16) {
    put_short(s, s.bi_buf);
    s.bi_buf = 0;
    s.bi_valid = 0;

  } else if (s.bi_valid >= 8) {
    s.pending_buf[s.pending++] = s.bi_buf & 0xff;
    s.bi_buf >>= 8;
    s.bi_valid -= 8;
  }
}


/* ===========================================================================
 * Compute the optimal bit lengths for a tree and update the total bit length
 * for the current block.
 * IN assertion: the fields freq and dad are set, heap[heap_max] and
 *    above are the tree nodes sorted by increasing frequency.
 * OUT assertions: the field len is set to the optimal bit length, the
 *     array bl_count contains the frequencies for each bit length.
 *     The length opt_len is updated; static_len is also updated if stree is
 *     not null.
 */
function gen_bitlen(s, desc)
//    deflate_state *s;
//    tree_desc *desc;    /* the tree descriptor */
{
  var tree            = desc.dyn_tree;
  var max_code        = desc.max_code;
  var stree           = desc.stat_desc.static_tree;
  var has_stree       = desc.stat_desc.has_stree;
  var extra           = desc.stat_desc.extra_bits;
  var base            = desc.stat_desc.extra_base;
  var max_length      = desc.stat_desc.max_length;
  var h;              /* heap index */
  var n, m;           /* iterate over the tree elements */
  var bits;           /* bit length */
  var xbits;          /* extra bits */
  var f;              /* frequency */
  var overflow = 0;   /* number of elements with bit length too large */

  for (bits = 0; bits <= MAX_BITS$1; bits++) {
    s.bl_count[bits] = 0;
  }

  /* In a first pass, compute the optimal bit lengths (which may
   * overflow in the case of the bit length tree).
   */
  tree[s.heap[s.heap_max] * 2 + 1]/*.Len*/ = 0; /* root of the heap */

  for (h = s.heap_max + 1; h < HEAP_SIZE$1; h++) {
    n = s.heap[h];
    bits = tree[tree[n * 2 + 1]/*.Dad*/ * 2 + 1]/*.Len*/ + 1;
    if (bits > max_length) {
      bits = max_length;
      overflow++;
    }
    tree[n * 2 + 1]/*.Len*/ = bits;
    /* We overwrite tree[n].Dad which is no longer needed */

    if (n > max_code) { continue; } /* not a leaf node */

    s.bl_count[bits]++;
    xbits = 0;
    if (n >= base) {
      xbits = extra[n - base];
    }
    f = tree[n * 2]/*.Freq*/;
    s.opt_len += f * (bits + xbits);
    if (has_stree) {
      s.static_len += f * (stree[n * 2 + 1]/*.Len*/ + xbits);
    }
  }
  if (overflow === 0) { return; }

  // Trace((stderr,"\nbit length overflow\n"));
  /* This happens for example on obj2 and pic of the Calgary corpus */

  /* Find the first bit length which could increase: */
  do {
    bits = max_length - 1;
    while (s.bl_count[bits] === 0) { bits--; }
    s.bl_count[bits]--;      /* move one leaf down the tree */
    s.bl_count[bits + 1] += 2; /* move one overflow item as its brother */
    s.bl_count[max_length]--;
    /* The brother of the overflow item also moves one step up,
     * but this does not affect bl_count[max_length]
     */
    overflow -= 2;
  } while (overflow > 0);

  /* Now recompute all bit lengths, scanning in increasing frequency.
   * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
   * lengths instead of fixing only the wrong ones. This idea is taken
   * from 'ar' written by Haruhiko Okumura.)
   */
  for (bits = max_length; bits !== 0; bits--) {
    n = s.bl_count[bits];
    while (n !== 0) {
      m = s.heap[--h];
      if (m > max_code) { continue; }
      if (tree[m * 2 + 1]/*.Len*/ !== bits) {
        // Trace((stderr,"code %d bits %d->%d\n", m, tree[m].Len, bits));
        s.opt_len += (bits - tree[m * 2 + 1]/*.Len*/) * tree[m * 2]/*.Freq*/;
        tree[m * 2 + 1]/*.Len*/ = bits;
      }
      n--;
    }
  }
}


/* ===========================================================================
 * Generate the codes for a given tree and bit counts (which need not be
 * optimal).
 * IN assertion: the array bl_count contains the bit length statistics for
 * the given tree and the field len is set for all tree elements.
 * OUT assertion: the field code is set for all tree elements of non
 *     zero code length.
 */
function gen_codes(tree, max_code, bl_count)
//    ct_data *tree;             /* the tree to decorate */
//    int max_code;              /* largest code with non zero frequency */
//    ushf *bl_count;            /* number of codes at each bit length */
{
  var next_code = new Array(MAX_BITS$1 + 1); /* next code value for each bit length */
  var code = 0;              /* running code value */
  var bits;                  /* bit index */
  var n;                     /* code index */

  /* The distribution counts are first used to generate the code values
   * without bit reversal.
   */
  for (bits = 1; bits <= MAX_BITS$1; bits++) {
    next_code[bits] = code = (code + bl_count[bits - 1]) << 1;
  }
  /* Check that the bit counts in bl_count are consistent. The last code
   * must be all ones.
   */
  //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,
  //        "inconsistent bit counts");
  //Tracev((stderr,"\ngen_codes: max_code %d ", max_code));

  for (n = 0;  n <= max_code; n++) {
    var len = tree[n * 2 + 1]/*.Len*/;
    if (len === 0) { continue; }
    /* Now reverse the bits */
    tree[n * 2]/*.Code*/ = bi_reverse(next_code[len]++, len);

    //Tracecv(tree != static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ",
    //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));
  }
}


/* ===========================================================================
 * Initialize the various 'constant' tables.
 */
function tr_static_init() {
  var n;        /* iterates over tree elements */
  var bits;     /* bit counter */
  var length;   /* length value */
  var code;     /* code value */
  var dist;     /* distance index */
  var bl_count = new Array(MAX_BITS$1 + 1);
  /* number of codes at each bit length for an optimal tree */

  // do check in _tr_init()
  //if (static_init_done) return;

  /* For some embedded targets, global variables are not initialized: */
/*#ifdef NO_INIT_GLOBAL_POINTERS
  static_l_desc.static_tree = static_ltree;
  static_l_desc.extra_bits = extra_lbits;
  static_d_desc.static_tree = static_dtree;
  static_d_desc.extra_bits = extra_dbits;
  static_bl_desc.extra_bits = extra_blbits;
#endif*/

  /* Initialize the mapping length (0..255) -> length code (0..28) */
  length = 0;
  for (code = 0; code < LENGTH_CODES$1 - 1; code++) {
    base_length[code] = length;
    for (n = 0; n < (1 << extra_lbits[code]); n++) {
      _length_code[length++] = code;
    }
  }
  //Assert (length == 256, "tr_static_init: length != 256");
  /* Note that the length 255 (match length 258) can be represented
   * in two different ways: code 284 + 5 bits or code 285, so we
   * overwrite length_code[255] to use the best encoding:
   */
  _length_code[length - 1] = code;

  /* Initialize the mapping dist (0..32K) -> dist code (0..29) */
  dist = 0;
  for (code = 0; code < 16; code++) {
    base_dist[code] = dist;
    for (n = 0; n < (1 << extra_dbits[code]); n++) {
      _dist_code[dist++] = code;
    }
  }
  //Assert (dist == 256, "tr_static_init: dist != 256");
  dist >>= 7; /* from now on, all distances are divided by 128 */
  for (; code < D_CODES$1; code++) {
    base_dist[code] = dist << 7;
    for (n = 0; n < (1 << (extra_dbits[code] - 7)); n++) {
      _dist_code[256 + dist++] = code;
    }
  }
  //Assert (dist == 256, "tr_static_init: 256+dist != 512");

  /* Construct the codes of the static literal tree */
  for (bits = 0; bits <= MAX_BITS$1; bits++) {
    bl_count[bits] = 0;
  }

  n = 0;
  while (n <= 143) {
    static_ltree[n * 2 + 1]/*.Len*/ = 8;
    n++;
    bl_count[8]++;
  }
  while (n <= 255) {
    static_ltree[n * 2 + 1]/*.Len*/ = 9;
    n++;
    bl_count[9]++;
  }
  while (n <= 279) {
    static_ltree[n * 2 + 1]/*.Len*/ = 7;
    n++;
    bl_count[7]++;
  }
  while (n <= 287) {
    static_ltree[n * 2 + 1]/*.Len*/ = 8;
    n++;
    bl_count[8]++;
  }
  /* Codes 286 and 287 do not exist, but we must include them in the
   * tree construction to get a canonical Huffman tree (longest code
   * all ones)
   */
  gen_codes(static_ltree, L_CODES$1 + 1, bl_count);

  /* The static distance tree is trivial: */
  for (n = 0; n < D_CODES$1; n++) {
    static_dtree[n * 2 + 1]/*.Len*/ = 5;
    static_dtree[n * 2]/*.Code*/ = bi_reverse(n, 5);
  }

  // Now data ready and we can init static trees
  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS$1 + 1, L_CODES$1, MAX_BITS$1);
  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0,          D_CODES$1, MAX_BITS$1);
  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0,         BL_CODES$1, MAX_BL_BITS);

  //static_init_done = true;
}


/* ===========================================================================
 * Initialize a new block.
 */
function init_block(s) {
  var n; /* iterates over tree elements */

  /* Initialize the trees. */
  for (n = 0; n < L_CODES$1;  n++) { s.dyn_ltree[n * 2]/*.Freq*/ = 0; }
  for (n = 0; n < D_CODES$1;  n++) { s.dyn_dtree[n * 2]/*.Freq*/ = 0; }
  for (n = 0; n < BL_CODES$1; n++) { s.bl_tree[n * 2]/*.Freq*/ = 0; }

  s.dyn_ltree[END_BLOCK * 2]/*.Freq*/ = 1;
  s.opt_len = s.static_len = 0;
  s.last_lit = s.matches = 0;
}


/* ===========================================================================
 * Flush the bit buffer and align the output on a byte boundary
 */
function bi_windup(s)
{
  if (s.bi_valid > 8) {
    put_short(s, s.bi_buf);
  } else if (s.bi_valid > 0) {
    //put_byte(s, (Byte)s->bi_buf);
    s.pending_buf[s.pending++] = s.bi_buf;
  }
  s.bi_buf = 0;
  s.bi_valid = 0;
}

/* ===========================================================================
 * Copy a stored block, storing first the length and its
 * one's complement if requested.
 */
function copy_block(s, buf, len, header)
//DeflateState *s;
//charf    *buf;    /* the input data */
//unsigned len;     /* its length */
//int      header;  /* true if block header must be written */
{
  bi_windup(s);        /* align on byte boundary */

  if (header) {
    put_short(s, len);
    put_short(s, ~len);
  }
//  while (len--) {
//    put_byte(s, *buf++);
//  }
  common.arraySet(s.pending_buf, s.window, buf, len, s.pending);
  s.pending += len;
}

/* ===========================================================================
 * Compares to subtrees, using the tree depth as tie breaker when
 * the subtrees have equal frequency. This minimizes the worst case length.
 */
function smaller(tree, n, m, depth) {
  var _n2 = n * 2;
  var _m2 = m * 2;
  return (tree[_n2]/*.Freq*/ < tree[_m2]/*.Freq*/ ||
         (tree[_n2]/*.Freq*/ === tree[_m2]/*.Freq*/ && depth[n] <= depth[m]));
}

/* ===========================================================================
 * Restore the heap property by moving down the tree starting at node k,
 * exchanging a node with the smallest of its two sons if necessary, stopping
 * when the heap property is re-established (each father smaller than its
 * two sons).
 */
function pqdownheap(s, tree, k)
//    deflate_state *s;
//    ct_data *tree;  /* the tree to restore */
//    int k;               /* node to move down */
{
  var v = s.heap[k];
  var j = k << 1;  /* left son of k */
  while (j <= s.heap_len) {
    /* Set j to the smallest of the two sons: */
    if (j < s.heap_len &&
      smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
      j++;
    }
    /* Exit if v is smaller than both sons */
    if (smaller(tree, v, s.heap[j], s.depth)) { break; }

    /* Exchange v with the smallest son */
    s.heap[k] = s.heap[j];
    k = j;

    /* And continue down the tree, setting j to the left son of k */
    j <<= 1;
  }
  s.heap[k] = v;
}


// inlined manually
// var SMALLEST = 1;

/* ===========================================================================
 * Send the block data compressed using the given Huffman trees
 */
function compress_block(s, ltree, dtree)
//    deflate_state *s;
//    const ct_data *ltree; /* literal tree */
//    const ct_data *dtree; /* distance tree */
{
  var dist;           /* distance of matched string */
  var lc;             /* match length or unmatched char (if dist == 0) */
  var lx = 0;         /* running index in l_buf */
  var code;           /* the code to send */
  var extra;          /* number of extra bits to send */

  if (s.last_lit !== 0) {
    do {
      dist = (s.pending_buf[s.d_buf + lx * 2] << 8) | (s.pending_buf[s.d_buf + lx * 2 + 1]);
      lc = s.pending_buf[s.l_buf + lx];
      lx++;

      if (dist === 0) {
        send_code(s, lc, ltree); /* send a literal byte */
        //Tracecv(isgraph(lc), (stderr," '%c' ", lc));
      } else {
        /* Here, lc is the match length - MIN_MATCH */
        code = _length_code[lc];
        send_code(s, code + LITERALS$1 + 1, ltree); /* send the length code */
        extra = extra_lbits[code];
        if (extra !== 0) {
          lc -= base_length[code];
          send_bits(s, lc, extra);       /* send the extra length bits */
        }
        dist--; /* dist is now the match distance - 1 */
        code = d_code(dist);
        //Assert (code < D_CODES, "bad d_code");

        send_code(s, code, dtree);       /* send the distance code */
        extra = extra_dbits[code];
        if (extra !== 0) {
          dist -= base_dist[code];
          send_bits(s, dist, extra);   /* send the extra distance bits */
        }
      } /* literal or match pair ? */

      /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */
      //Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,
      //       "pendingBuf overflow");

    } while (lx < s.last_lit);
  }

  send_code(s, END_BLOCK, ltree);
}


/* ===========================================================================
 * Construct one Huffman tree and assigns the code bit strings and lengths.
 * Update the total bit length for the current block.
 * IN assertion: the field freq is set for all tree elements.
 * OUT assertions: the fields len and code are set to the optimal bit length
 *     and corresponding code. The length opt_len is updated; static_len is
 *     also updated if stree is not null. The field max_code is set.
 */
function build_tree(s, desc)
//    deflate_state *s;
//    tree_desc *desc; /* the tree descriptor */
{
  var tree     = desc.dyn_tree;
  var stree    = desc.stat_desc.static_tree;
  var has_stree = desc.stat_desc.has_stree;
  var elems    = desc.stat_desc.elems;
  var n, m;          /* iterate over heap elements */
  var max_code = -1; /* largest code with non zero frequency */
  var node;          /* new node being created */

  /* Construct the initial heap, with least frequent element in
   * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
   * heap[0] is not used.
   */
  s.heap_len = 0;
  s.heap_max = HEAP_SIZE$1;

  for (n = 0; n < elems; n++) {
    if (tree[n * 2]/*.Freq*/ !== 0) {
      s.heap[++s.heap_len] = max_code = n;
      s.depth[n] = 0;

    } else {
      tree[n * 2 + 1]/*.Len*/ = 0;
    }
  }

  /* The pkzip format requires that at least one distance code exists,
   * and that at least one bit should be sent even if there is only one
   * possible code. So to avoid special checks later on we force at least
   * two codes of non zero frequency.
   */
  while (s.heap_len < 2) {
    node = s.heap[++s.heap_len] = (max_code < 2 ? ++max_code : 0);
    tree[node * 2]/*.Freq*/ = 1;
    s.depth[node] = 0;
    s.opt_len--;

    if (has_stree) {
      s.static_len -= stree[node * 2 + 1]/*.Len*/;
    }
    /* node is 0 or 1 so it does not have extra bits */
  }
  desc.max_code = max_code;

  /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
   * establish sub-heaps of increasing lengths:
   */
  for (n = (s.heap_len >> 1/*int /2*/); n >= 1; n--) { pqdownheap(s, tree, n); }

  /* Construct the Huffman tree by repeatedly combining the least two
   * frequent nodes.
   */
  node = elems;              /* next internal node of the tree */
  do {
    //pqremove(s, tree, n);  /* n = node of least frequency */
    /*** pqremove ***/
    n = s.heap[1/*SMALLEST*/];
    s.heap[1/*SMALLEST*/] = s.heap[s.heap_len--];
    pqdownheap(s, tree, 1/*SMALLEST*/);
    /***/

    m = s.heap[1/*SMALLEST*/]; /* m = node of next least frequency */

    s.heap[--s.heap_max] = n; /* keep the nodes sorted by frequency */
    s.heap[--s.heap_max] = m;

    /* Create a new node father of n and m */
    tree[node * 2]/*.Freq*/ = tree[n * 2]/*.Freq*/ + tree[m * 2]/*.Freq*/;
    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
    tree[n * 2 + 1]/*.Dad*/ = tree[m * 2 + 1]/*.Dad*/ = node;

    /* and insert the new node in the heap */
    s.heap[1/*SMALLEST*/] = node++;
    pqdownheap(s, tree, 1/*SMALLEST*/);

  } while (s.heap_len >= 2);

  s.heap[--s.heap_max] = s.heap[1/*SMALLEST*/];

  /* At this point, the fields freq and dad are set. We can now
   * generate the bit lengths.
   */
  gen_bitlen(s, desc);

  /* The field len is now set, we can generate the bit codes */
  gen_codes(tree, max_code, s.bl_count);
}


/* ===========================================================================
 * Scan a literal or distance tree to determine the frequencies of the codes
 * in the bit length tree.
 */
function scan_tree(s, tree, max_code)
//    deflate_state *s;
//    ct_data *tree;   /* the tree to be scanned */
//    int max_code;    /* and its largest code of non zero frequency */
{
  var n;                     /* iterates over all tree elements */
  var prevlen = -1;          /* last emitted length */
  var curlen;                /* length of current code */

  var nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */

  var count = 0;             /* repeat count of the current code */
  var max_count = 7;         /* max repeat count */
  var min_count = 4;         /* min repeat count */

  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  tree[(max_code + 1) * 2 + 1]/*.Len*/ = 0xffff; /* guard */

  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;

    if (++count < max_count && curlen === nextlen) {
      continue;

    } else if (count < min_count) {
      s.bl_tree[curlen * 2]/*.Freq*/ += count;

    } else if (curlen !== 0) {

      if (curlen !== prevlen) { s.bl_tree[curlen * 2]/*.Freq*/++; }
      s.bl_tree[REP_3_6 * 2]/*.Freq*/++;

    } else if (count <= 10) {
      s.bl_tree[REPZ_3_10 * 2]/*.Freq*/++;

    } else {
      s.bl_tree[REPZ_11_138 * 2]/*.Freq*/++;
    }

    count = 0;
    prevlen = curlen;

    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;

    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;

    } else {
      max_count = 7;
      min_count = 4;
    }
  }
}


/* ===========================================================================
 * Send a literal or distance tree in compressed form, using the codes in
 * bl_tree.
 */
function send_tree(s, tree, max_code)
//    deflate_state *s;
//    ct_data *tree; /* the tree to be scanned */
//    int max_code;       /* and its largest code of non zero frequency */
{
  var n;                     /* iterates over all tree elements */
  var prevlen = -1;          /* last emitted length */
  var curlen;                /* length of current code */

  var nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */

  var count = 0;             /* repeat count of the current code */
  var max_count = 7;         /* max repeat count */
  var min_count = 4;         /* min repeat count */

  /* tree[max_code+1].Len = -1; */  /* guard already set */
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }

  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;

    if (++count < max_count && curlen === nextlen) {
      continue;

    } else if (count < min_count) {
      do { send_code(s, curlen, s.bl_tree); } while (--count !== 0);

    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        send_code(s, curlen, s.bl_tree);
        count--;
      }
      //Assert(count >= 3 && count <= 6, " 3_6?");
      send_code(s, REP_3_6, s.bl_tree);
      send_bits(s, count - 3, 2);

    } else if (count <= 10) {
      send_code(s, REPZ_3_10, s.bl_tree);
      send_bits(s, count - 3, 3);

    } else {
      send_code(s, REPZ_11_138, s.bl_tree);
      send_bits(s, count - 11, 7);
    }

    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;

    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;

    } else {
      max_count = 7;
      min_count = 4;
    }
  }
}


/* ===========================================================================
 * Construct the Huffman tree for the bit lengths and return the index in
 * bl_order of the last bit length code to send.
 */
function build_bl_tree(s) {
  var max_blindex;  /* index of last bit length code of non zero freq */

  /* Determine the bit length frequencies for literal and distance trees */
  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);

  /* Build the bit length tree: */
  build_tree(s, s.bl_desc);
  /* opt_len now includes the length of the tree representations, except
   * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
   */

  /* Determine the number of bit length codes to send. The pkzip format
   * requires that at least 4 bit length codes be sent. (appnote.txt says
   * 3 but the actual value used is 4.)
   */
  for (max_blindex = BL_CODES$1 - 1; max_blindex >= 3; max_blindex--) {
    if (s.bl_tree[bl_order[max_blindex] * 2 + 1]/*.Len*/ !== 0) {
      break;
    }
  }
  /* Update opt_len to include the bit length tree and counts */
  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
  //Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
  //        s->opt_len, s->static_len));

  return max_blindex;
}


/* ===========================================================================
 * Send the header for a block using dynamic Huffman trees: the counts, the
 * lengths of the bit length codes, the literal tree and the distance tree.
 * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
 */
function send_all_trees(s, lcodes, dcodes, blcodes)
//    deflate_state *s;
//    int lcodes, dcodes, blcodes; /* number of codes for each tree */
{
  var rank;                    /* index in bl_order */

  //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");
  //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,
  //        "too many codes");
  //Tracev((stderr, "\nbl counts: "));
  send_bits(s, lcodes - 257, 5); /* not +255 as stated in appnote.txt */
  send_bits(s, dcodes - 1,   5);
  send_bits(s, blcodes - 4,  4); /* not -3 as stated in appnote.txt */
  for (rank = 0; rank < blcodes; rank++) {
    //Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
    send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1]/*.Len*/, 3);
  }
  //Tracev((stderr, "\nbl tree: sent %ld", s->bits_sent));

  send_tree(s, s.dyn_ltree, lcodes - 1); /* literal tree */
  //Tracev((stderr, "\nlit tree: sent %ld", s->bits_sent));

  send_tree(s, s.dyn_dtree, dcodes - 1); /* distance tree */
  //Tracev((stderr, "\ndist tree: sent %ld", s->bits_sent));
}


/* ===========================================================================
 * Check if the data type is TEXT or BINARY, using the following algorithm:
 * - TEXT if the two conditions below are satisfied:
 *    a) There are no non-portable control characters belonging to the
 *       "black list" (0..6, 14..25, 28..31).
 *    b) There is at least one printable character belonging to the
 *       "white list" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).
 * - BINARY otherwise.
 * - The following partially-portable control characters form a
 *   "gray list" that is ignored in this detection algorithm:
 *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).
 * IN assertion: the fields Freq of dyn_ltree are set.
 */
function detect_data_type(s) {
  /* black_mask is the bit mask of black-listed bytes
   * set bits 0..6, 14..25, and 28..31
   * 0xf3ffc07f = binary 11110011111111111100000001111111
   */
  var black_mask = 0xf3ffc07f;
  var n;

  /* Check for non-textual ("black-listed") bytes. */
  for (n = 0; n <= 31; n++, black_mask >>>= 1) {
    if ((black_mask & 1) && (s.dyn_ltree[n * 2]/*.Freq*/ !== 0)) {
      return Z_BINARY;
    }
  }

  /* Check for textual ("white-listed") bytes. */
  if (s.dyn_ltree[9 * 2]/*.Freq*/ !== 0 || s.dyn_ltree[10 * 2]/*.Freq*/ !== 0 ||
      s.dyn_ltree[13 * 2]/*.Freq*/ !== 0) {
    return Z_TEXT;
  }
  for (n = 32; n < LITERALS$1; n++) {
    if (s.dyn_ltree[n * 2]/*.Freq*/ !== 0) {
      return Z_TEXT;
    }
  }

  /* There are no "black-listed" or "white-listed" bytes:
   * this stream either is empty or has tolerated ("gray-listed") bytes only.
   */
  return Z_BINARY;
}


var static_init_done = false;

/* ===========================================================================
 * Initialize the tree data structures for a new zlib stream.
 */
function _tr_init(s)
{

  if (!static_init_done) {
    tr_static_init();
    static_init_done = true;
  }

  s.l_desc  = new TreeDesc(s.dyn_ltree, static_l_desc);
  s.d_desc  = new TreeDesc(s.dyn_dtree, static_d_desc);
  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);

  s.bi_buf = 0;
  s.bi_valid = 0;

  /* Initialize the first block of the first file: */
  init_block(s);
}


/* ===========================================================================
 * Send a stored block
 */
function _tr_stored_block(s, buf, stored_len, last)
//DeflateState *s;
//charf *buf;       /* input block */
//ulg stored_len;   /* length of input block */
//int last;         /* one if this is the last block for a file */
{
  send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);    /* send block type */
  copy_block(s, buf, stored_len, true); /* with header */
}


/* ===========================================================================
 * Send one empty static block to give enough lookahead for inflate.
 * This takes 10 bits, of which 7 may remain in the bit buffer.
 */
function _tr_align(s) {
  send_bits(s, STATIC_TREES << 1, 3);
  send_code(s, END_BLOCK, static_ltree);
  bi_flush(s);
}


/* ===========================================================================
 * Determine the best encoding for the current block: dynamic trees, static
 * trees or store, and output the encoded block to the zip file.
 */
function _tr_flush_block(s, buf, stored_len, last)
//DeflateState *s;
//charf *buf;       /* input block, or NULL if too old */
//ulg stored_len;   /* length of input block */
//int last;         /* one if this is the last block for a file */
{
  var opt_lenb, static_lenb;  /* opt_len and static_len in bytes */
  var max_blindex = 0;        /* index of last bit length code of non zero freq */

  /* Build the Huffman trees unless a stored block is forced */
  if (s.level > 0) {

    /* Check if the file is binary or text */
    if (s.strm.data_type === Z_UNKNOWN$1) {
      s.strm.data_type = detect_data_type(s);
    }

    /* Construct the literal and distance trees */
    build_tree(s, s.l_desc);
    // Tracev((stderr, "\nlit data: dyn %ld, stat %ld", s->opt_len,
    //        s->static_len));

    build_tree(s, s.d_desc);
    // Tracev((stderr, "\ndist data: dyn %ld, stat %ld", s->opt_len,
    //        s->static_len));
    /* At this point, opt_len and static_len are the total bit lengths of
     * the compressed block data, excluding the tree representations.
     */

    /* Build the bit length tree for the above two trees, and get the index
     * in bl_order of the last bit length code to send.
     */
    max_blindex = build_bl_tree(s);

    /* Determine the best encoding. Compute the block lengths in bytes. */
    opt_lenb = (s.opt_len + 3 + 7) >>> 3;
    static_lenb = (s.static_len + 3 + 7) >>> 3;

    // Tracev((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u ",
    //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,
    //        s->last_lit));

    if (static_lenb <= opt_lenb) { opt_lenb = static_lenb; }

  } else {
    // Assert(buf != (char*)0, "lost buf");
    opt_lenb = static_lenb = stored_len + 5; /* force a stored block */
  }

  if ((stored_len + 4 <= opt_lenb) && (buf !== -1)) {
    /* 4: two words for the lengths */

    /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
     * Otherwise we can't have processed more than WSIZE input bytes since
     * the last block flush, because compression would have been
     * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
     * transform a block into a stored block.
     */
    _tr_stored_block(s, buf, stored_len, last);

  } else if (s.strategy === Z_FIXED$1 || static_lenb === opt_lenb) {

    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
    compress_block(s, static_ltree, static_dtree);

  } else {
    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
    compress_block(s, s.dyn_ltree, s.dyn_dtree);
  }
  // Assert (s->compressed_len == s->bits_sent, "bad compressed size");
  /* The above check is made mod 2^32, for files larger than 512 MB
   * and uLong implemented on 32 bits.
   */
  init_block(s);

  if (last) {
    bi_windup(s);
  }
  // Tracev((stderr,"\ncomprlen %lu(%lu) ", s->compressed_len>>3,
  //       s->compressed_len-7*last));
}

/* ===========================================================================
 * Save the match info and tally the frequency counts. Return true if
 * the current block must be flushed.
 */
function _tr_tally(s, dist, lc)
//    deflate_state *s;
//    unsigned dist;  /* distance of matched string */
//    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */
{
  //var out_length, in_length, dcode;

  s.pending_buf[s.d_buf + s.last_lit * 2]     = (dist >>> 8) & 0xff;
  s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;

  s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;
  s.last_lit++;

  if (dist === 0) {
    /* lc is the unmatched char */
    s.dyn_ltree[lc * 2]/*.Freq*/++;
  } else {
    s.matches++;
    /* Here, lc is the match length - MIN_MATCH */
    dist--;             /* dist = match distance - 1 */
    //Assert((ush)dist < (ush)MAX_DIST(s) &&
    //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&
    //       (ush)d_code(dist) < (ush)D_CODES,  "_tr_tally: bad match");

    s.dyn_ltree[(_length_code[lc] + LITERALS$1 + 1) * 2]/*.Freq*/++;
    s.dyn_dtree[d_code(dist) * 2]/*.Freq*/++;
  }

// (!) This block is disabled in zlib defaults,
// don't enable it for binary compatibility

//#ifdef TRUNCATE_BLOCK
//  /* Try to guess if it is profitable to stop the current block here */
//  if ((s.last_lit & 0x1fff) === 0 && s.level > 2) {
//    /* Compute an upper bound for the compressed length */
//    out_length = s.last_lit*8;
//    in_length = s.strstart - s.block_start;
//
//    for (dcode = 0; dcode < D_CODES; dcode++) {
//      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);
//    }
//    out_length >>>= 3;
//    //Tracev((stderr,"\nlast_lit %u, in %ld, out ~%ld(%ld%%) ",
//    //       s->last_lit, in_length, out_length,
//    //       100L - out_length*100L/in_length));
//    if (s.matches < (s.last_lit>>1)/*int /2*/ && out_length < (in_length>>1)/*int /2*/) {
//      return true;
//    }
//  }
//#endif

  return (s.last_lit === s.lit_bufsize - 1);
  /* We avoid equality with lit_bufsize because of wraparound at 64K
   * on 16 bit machines and because stored blocks are restricted to
   * 64K-1 bytes.
   */
}

var _tr_init_1  = _tr_init;
var _tr_stored_block_1 = _tr_stored_block;
var _tr_flush_block_1  = _tr_flush_block;
var _tr_tally_1 = _tr_tally;
var _tr_align_1 = _tr_align;

var trees = {
	_tr_init: _tr_init_1,
	_tr_stored_block: _tr_stored_block_1,
	_tr_flush_block: _tr_flush_block_1,
	_tr_tally: _tr_tally_1,
	_tr_align: _tr_align_1
};

// Note: adler32 takes 12% for level 0 and 2% for level 6.
// It isn't worth it to make additional optimizations as in original.
// Small size is preferable.

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

function adler32(adler, buf, len, pos) {
  var s1 = (adler & 0xffff) |0,
      s2 = ((adler >>> 16) & 0xffff) |0,
      n = 0;

  while (len !== 0) {
    // Set limit ~ twice less than 5552, to keep
    // s2 in 31-bits, because we force signed ints.
    // in other case %= will fail.
    n = len > 2000 ? 2000 : len;
    len -= n;

    do {
      s1 = (s1 + buf[pos++]) |0;
      s2 = (s2 + s1) |0;
    } while (--n);

    s1 %= 65521;
    s2 %= 65521;
  }

  return (s1 | (s2 << 16)) |0;
}


var adler32_1 = adler32;

// Note: we can't get significant speed boost here.
// So write code to minimize size - no pregenerated tables
// and array tools dependencies.

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

// Use ordinary array, since untyped makes no boost here
function makeTable() {
  var c, table = [];

  for (var n = 0; n < 256; n++) {
    c = n;
    for (var k = 0; k < 8; k++) {
      c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));
    }
    table[n] = c;
  }

  return table;
}

// Create table on load. Just 255 signed longs. Not a problem.
var crcTable = makeTable();


function crc32(crc, buf, len, pos) {
  var t = crcTable,
      end = pos + len;

  crc ^= -1;

  for (var i = pos; i < end; i++) {
    crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];
  }

  return (crc ^ (-1)); // >>> 0;
}


var crc32_1 = crc32;

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

var messages = {
  2:      'need dictionary',     /* Z_NEED_DICT       2  */
  1:      'stream end',          /* Z_STREAM_END      1  */
  0:      '',                    /* Z_OK              0  */
  '-1':   'file error',          /* Z_ERRNO         (-1) */
  '-2':   'stream error',        /* Z_STREAM_ERROR  (-2) */
  '-3':   'data error',          /* Z_DATA_ERROR    (-3) */
  '-4':   'insufficient memory', /* Z_MEM_ERROR     (-4) */
  '-5':   'buffer error',        /* Z_BUF_ERROR     (-5) */
  '-6':   'incompatible version' /* Z_VERSION_ERROR (-6) */
};

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.







/* Public constants ==========================================================*/
/* ===========================================================================*/


/* Allowed flush values; see deflate() and inflate() below for details */
var Z_NO_FLUSH$1      = 0;
var Z_PARTIAL_FLUSH = 1;
//var Z_SYNC_FLUSH    = 2;
var Z_FULL_FLUSH    = 3;
var Z_FINISH$2        = 4;
var Z_BLOCK$1         = 5;
//var Z_TREES         = 6;


/* Return codes for the compression/decompression functions. Negative values
 * are errors, positive values are used for special but normal events.
 */
var Z_OK$2            = 0;
var Z_STREAM_END$2    = 1;
//var Z_NEED_DICT     = 2;
//var Z_ERRNO         = -1;
var Z_STREAM_ERROR$1  = -2;
var Z_DATA_ERROR$1    = -3;
//var Z_MEM_ERROR     = -4;
var Z_BUF_ERROR$1     = -5;
//var Z_VERSION_ERROR = -6;


/* compression levels */
//var Z_NO_COMPRESSION      = 0;
//var Z_BEST_SPEED          = 1;
//var Z_BEST_COMPRESSION    = 9;
var Z_DEFAULT_COMPRESSION$1 = -1;


var Z_FILTERED            = 1;
var Z_HUFFMAN_ONLY        = 2;
var Z_RLE                 = 3;
var Z_FIXED               = 4;
var Z_DEFAULT_STRATEGY$1    = 0;

/* Possible values of the data_type field (though see inflate()) */
//var Z_BINARY              = 0;
//var Z_TEXT                = 1;
//var Z_ASCII               = 1; // = Z_TEXT
var Z_UNKNOWN             = 2;


/* The deflate compression method */
var Z_DEFLATED$2  = 8;

/*============================================================================*/


var MAX_MEM_LEVEL = 9;
/* Maximum value for memLevel in deflateInit2 */
var MAX_WBITS$1 = 15;
/* 32K LZ77 window */
var DEF_MEM_LEVEL = 8;


var LENGTH_CODES  = 29;
/* number of length codes, not counting the special END_BLOCK code */
var LITERALS      = 256;
/* number of literal bytes 0..255 */
var L_CODES       = LITERALS + 1 + LENGTH_CODES;
/* number of Literal or Length codes, including the END_BLOCK code */
var D_CODES       = 30;
/* number of distance codes */
var BL_CODES      = 19;
/* number of codes used to transfer the bit lengths */
var HEAP_SIZE     = 2 * L_CODES + 1;
/* maximum heap size */
var MAX_BITS  = 15;
/* All codes must not exceed MAX_BITS bits */

var MIN_MATCH = 3;
var MAX_MATCH = 258;
var MIN_LOOKAHEAD = (MAX_MATCH + MIN_MATCH + 1);

var PRESET_DICT = 0x20;

var INIT_STATE = 42;
var EXTRA_STATE = 69;
var NAME_STATE = 73;
var COMMENT_STATE = 91;
var HCRC_STATE = 103;
var BUSY_STATE = 113;
var FINISH_STATE = 666;

var BS_NEED_MORE      = 1; /* block not completed, need more input or more output */
var BS_BLOCK_DONE     = 2; /* block flush performed */
var BS_FINISH_STARTED = 3; /* finish started, need only more output at next deflate */
var BS_FINISH_DONE    = 4; /* finish done, accept no more input or output */

var OS_CODE = 0x03; // Unix :) . Don't detect, use this default.

function err(strm, errorCode) {
  strm.msg = messages[errorCode];
  return errorCode;
}

function rank(f) {
  return ((f) << 1) - ((f) > 4 ? 9 : 0);
}

function zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }


/* =========================================================================
 * Flush as much pending output as possible. All deflate() output goes
 * through this function so some applications may wish to modify it
 * to avoid allocating a large strm->output buffer and copying into it.
 * (See also read_buf()).
 */
function flush_pending(strm) {
  var s = strm.state;

  //_tr_flush_bits(s);
  var len = s.pending;
  if (len > strm.avail_out) {
    len = strm.avail_out;
  }
  if (len === 0) { return; }

  common.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);
  strm.next_out += len;
  s.pending_out += len;
  strm.total_out += len;
  strm.avail_out -= len;
  s.pending -= len;
  if (s.pending === 0) {
    s.pending_out = 0;
  }
}


function flush_block_only(s, last) {
  trees._tr_flush_block(s, (s.block_start >= 0 ? s.block_start : -1), s.strstart - s.block_start, last);
  s.block_start = s.strstart;
  flush_pending(s.strm);
}


function put_byte(s, b) {
  s.pending_buf[s.pending++] = b;
}


/* =========================================================================
 * Put a short in the pending buffer. The 16-bit value is put in MSB order.
 * IN assertion: the stream state is correct and there is enough room in
 * pending_buf.
 */
function putShortMSB(s, b) {
//  put_byte(s, (Byte)(b >> 8));
//  put_byte(s, (Byte)(b & 0xff));
  s.pending_buf[s.pending++] = (b >>> 8) & 0xff;
  s.pending_buf[s.pending++] = b & 0xff;
}


/* ===========================================================================
 * Read a new buffer from the current input stream, update the adler32
 * and total number of bytes read.  All deflate() input goes through
 * this function so some applications may wish to modify it to avoid
 * allocating a large strm->input buffer and copying from it.
 * (See also flush_pending()).
 */
function read_buf(strm, buf, start, size) {
  var len = strm.avail_in;

  if (len > size) { len = size; }
  if (len === 0) { return 0; }

  strm.avail_in -= len;

  // zmemcpy(buf, strm->next_in, len);
  common.arraySet(buf, strm.input, strm.next_in, len, start);
  if (strm.state.wrap === 1) {
    strm.adler = adler32_1(strm.adler, buf, len, start);
  }

  else if (strm.state.wrap === 2) {
    strm.adler = crc32_1(strm.adler, buf, len, start);
  }

  strm.next_in += len;
  strm.total_in += len;

  return len;
}


/* ===========================================================================
 * Set match_start to the longest match starting at the given string and
 * return its length. Matches shorter or equal to prev_length are discarded,
 * in which case the result is equal to prev_length and match_start is
 * garbage.
 * IN assertions: cur_match is the head of the hash chain for the current
 *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1
 * OUT assertion: the match length is not greater than s->lookahead.
 */
function longest_match(s, cur_match) {
  var chain_length = s.max_chain_length;      /* max hash chain length */
  var scan = s.strstart; /* current string */
  var match;                       /* matched string */
  var len;                           /* length of current match */
  var best_len = s.prev_length;              /* best match length so far */
  var nice_match = s.nice_match;             /* stop if match long enough */
  var limit = (s.strstart > (s.w_size - MIN_LOOKAHEAD)) ?
      s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0/*NIL*/;

  var _win = s.window; // shortcut

  var wmask = s.w_mask;
  var prev  = s.prev;

  /* Stop when cur_match becomes <= limit. To simplify the code,
   * we prevent matches with the string of window index 0.
   */

  var strend = s.strstart + MAX_MATCH;
  var scan_end1  = _win[scan + best_len - 1];
  var scan_end   = _win[scan + best_len];

  /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
   * It is easy to get rid of this optimization if necessary.
   */
  // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");

  /* Do not waste too much time if we already have a good match: */
  if (s.prev_length >= s.good_match) {
    chain_length >>= 2;
  }
  /* Do not look for matches beyond the end of the input. This is necessary
   * to make deflate deterministic.
   */
  if (nice_match > s.lookahead) { nice_match = s.lookahead; }

  // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");

  do {
    // Assert(cur_match < s->strstart, "no future");
    match = cur_match;

    /* Skip to next match if the match length cannot increase
     * or if the match length is less than 2.  Note that the checks below
     * for insufficient lookahead only occur occasionally for performance
     * reasons.  Therefore uninitialized memory will be accessed, and
     * conditional jumps will be made that depend on those values.
     * However the length of the match is limited to the lookahead, so
     * the output of deflate is not affected by the uninitialized values.
     */

    if (_win[match + best_len]     !== scan_end  ||
        _win[match + best_len - 1] !== scan_end1 ||
        _win[match]                !== _win[scan] ||
        _win[++match]              !== _win[scan + 1]) {
      continue;
    }

    /* The check at best_len-1 can be removed because it will be made
     * again later. (This heuristic is not always a win.)
     * It is not necessary to compare scan[2] and match[2] since they
     * are always equal when the other bytes match, given that
     * the hash keys are equal and that HASH_BITS >= 8.
     */
    scan += 2;
    match++;
    // Assert(*scan == *match, "match[2]?");

    /* We check for insufficient lookahead only every 8th comparison;
     * the 256th check will be made at strstart+258.
     */
    do {
      /*jshint noempty:false*/
    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             scan < strend);

    // Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");

    len = MAX_MATCH - (strend - scan);
    scan = strend - MAX_MATCH;

    if (len > best_len) {
      s.match_start = cur_match;
      best_len = len;
      if (len >= nice_match) {
        break;
      }
      scan_end1  = _win[scan + best_len - 1];
      scan_end   = _win[scan + best_len];
    }
  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);

  if (best_len <= s.lookahead) {
    return best_len;
  }
  return s.lookahead;
}


/* ===========================================================================
 * Fill the window when the lookahead becomes insufficient.
 * Updates strstart and lookahead.
 *
 * IN assertion: lookahead < MIN_LOOKAHEAD
 * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD
 *    At least one byte has been read, or avail_in == 0; reads are
 *    performed for at least two bytes (required for the zip translate_eol
 *    option -- not supported here).
 */
function fill_window(s) {
  var _w_size = s.w_size;
  var p, n, m, more, str;

  //Assert(s->lookahead < MIN_LOOKAHEAD, "already enough lookahead");

  do {
    more = s.window_size - s.lookahead - s.strstart;

    // JS ints have 32 bit, block below not needed
    /* Deal with !@#$% 64K limit: */
    //if (sizeof(int) <= 2) {
    //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {
    //        more = wsize;
    //
    //  } else if (more == (unsigned)(-1)) {
    //        /* Very unlikely, but possible on 16 bit machine if
    //         * strstart == 0 && lookahead == 1 (input done a byte at time)
    //         */
    //        more--;
    //    }
    //}


    /* If the window is almost full and there is insufficient lookahead,
     * move the upper half to the lower one to make room in the upper half.
     */
    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {

      common.arraySet(s.window, s.window, _w_size, _w_size, 0);
      s.match_start -= _w_size;
      s.strstart -= _w_size;
      /* we now have strstart >= MAX_DIST */
      s.block_start -= _w_size;

      /* Slide the hash table (could be avoided with 32 bit values
       at the expense of memory usage). We slide even when level == 0
       to keep the hash table consistent if we switch back to level > 0
       later. (Using level 0 permanently is not an optimal usage of
       zlib, so we don't care about this pathological case.)
       */

      n = s.hash_size;
      p = n;
      do {
        m = s.head[--p];
        s.head[p] = (m >= _w_size ? m - _w_size : 0);
      } while (--n);

      n = _w_size;
      p = n;
      do {
        m = s.prev[--p];
        s.prev[p] = (m >= _w_size ? m - _w_size : 0);
        /* If n is not on any hash chain, prev[n] is garbage but
         * its value will never be used.
         */
      } while (--n);

      more += _w_size;
    }
    if (s.strm.avail_in === 0) {
      break;
    }

    /* If there was no sliding:
     *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
     *    more == window_size - lookahead - strstart
     * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
     * => more >= window_size - 2*WSIZE + 2
     * In the BIG_MEM or MMAP case (not yet supported),
     *   window_size == input_size + MIN_LOOKAHEAD  &&
     *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
     * Otherwise, window_size == 2*WSIZE so more >= 2.
     * If there was sliding, more >= WSIZE. So in all cases, more >= 2.
     */
    //Assert(more >= 2, "more < 2");
    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
    s.lookahead += n;

    /* Initialize the hash value now that we have some input: */
    if (s.lookahead + s.insert >= MIN_MATCH) {
      str = s.strstart - s.insert;
      s.ins_h = s.window[str];

      /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */
      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + 1]) & s.hash_mask;
//#if MIN_MATCH != 3
//        Call update_hash() MIN_MATCH-3 more times
//#endif
      while (s.insert) {
        /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;

        s.prev[str & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = str;
        str++;
        s.insert--;
        if (s.lookahead + s.insert < MIN_MATCH) {
          break;
        }
      }
    }
    /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
     * but this is not important since only literal bytes will be emitted.
     */

  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);

  /* If the WIN_INIT bytes after the end of the current data have never been
   * written, then zero those bytes in order to avoid memory check reports of
   * the use of uninitialized (or uninitialised as Julian writes) bytes by
   * the longest match routines.  Update the high water mark for the next
   * time through here.  WIN_INIT is set to MAX_MATCH since the longest match
   * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.
   */
//  if (s.high_water < s.window_size) {
//    var curr = s.strstart + s.lookahead;
//    var init = 0;
//
//    if (s.high_water < curr) {
//      /* Previous high water mark below current data -- zero WIN_INIT
//       * bytes or up to end of window, whichever is less.
//       */
//      init = s.window_size - curr;
//      if (init > WIN_INIT)
//        init = WIN_INIT;
//      zmemzero(s->window + curr, (unsigned)init);
//      s->high_water = curr + init;
//    }
//    else if (s->high_water < (ulg)curr + WIN_INIT) {
//      /* High water mark at or above current data, but below current data
//       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up
//       * to end of window, whichever is less.
//       */
//      init = (ulg)curr + WIN_INIT - s->high_water;
//      if (init > s->window_size - s->high_water)
//        init = s->window_size - s->high_water;
//      zmemzero(s->window + s->high_water, (unsigned)init);
//      s->high_water += init;
//    }
//  }
//
//  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,
//    "not enough room for search");
}

/* ===========================================================================
 * Copy without compression as much as possible from the input stream, return
 * the current block state.
 * This function does not insert new strings in the dictionary since
 * uncompressible data is probably not useful. This function is used
 * only for the level=0 compression option.
 * NOTE: this function should be optimized to avoid extra copying from
 * window to pending_buf.
 */
function deflate_stored(s, flush) {
  /* Stored blocks are limited to 0xffff bytes, pending_buf is limited
   * to pending_buf_size, and each stored block has a 5 byte header:
   */
  var max_block_size = 0xffff;

  if (max_block_size > s.pending_buf_size - 5) {
    max_block_size = s.pending_buf_size - 5;
  }

  /* Copy as much as possible from input to output: */
  for (;;) {
    /* Fill the window as much as possible: */
    if (s.lookahead <= 1) {

      //Assert(s->strstart < s->w_size+MAX_DIST(s) ||
      //  s->block_start >= (long)s->w_size, "slide too late");
//      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||
//        s.block_start >= s.w_size)) {
//        throw  new Error("slide too late");
//      }

      fill_window(s);
      if (s.lookahead === 0 && flush === Z_NO_FLUSH$1) {
        return BS_NEED_MORE;
      }

      if (s.lookahead === 0) {
        break;
      }
      /* flush the current block */
    }
    //Assert(s->block_start >= 0L, "block gone");
//    if (s.block_start < 0) throw new Error("block gone");

    s.strstart += s.lookahead;
    s.lookahead = 0;

    /* Emit a stored block if pending_buf will be full: */
    var max_start = s.block_start + max_block_size;

    if (s.strstart === 0 || s.strstart >= max_start) {
      /* strstart == 0 is possible when wraparound on 16-bit machine */
      s.lookahead = s.strstart - max_start;
      s.strstart = max_start;
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/


    }
    /* Flush if we may have to slide, otherwise block_start may become
     * negative and the data will be gone:
     */
    if (s.strstart - s.block_start >= (s.w_size - MIN_LOOKAHEAD)) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }

  s.insert = 0;

  if (flush === Z_FINISH$2) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }

  if (s.strstart > s.block_start) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }

  return BS_NEED_MORE;
}

/* ===========================================================================
 * Compress as much as possible from the input stream, return the current
 * block state.
 * This function does not perform lazy evaluation of matches and inserts
 * new strings in the dictionary only for unmatched strings or for short
 * matches. It is used only for the fast compression options.
 */
function deflate_fast(s, flush) {
  var hash_head;        /* head of the hash chain */
  var bflush;           /* set if current block must be flushed */

  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the next match, plus MIN_MATCH bytes to insert the
     * string following the next match.
     */
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$1) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break; /* flush the current block */
      }
    }

    /* Insert the string window[strstart .. strstart+2] in the
     * dictionary, and set hash_head to the head of the hash chain:
     */
    hash_head = 0/*NIL*/;
    if (s.lookahead >= MIN_MATCH) {
      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
      /***/
    }

    /* Find the longest match, discarding those <= prev_length.
     * At this point we have always match_length < MIN_MATCH
     */
    if (hash_head !== 0/*NIL*/ && ((s.strstart - hash_head) <= (s.w_size - MIN_LOOKAHEAD))) {
      /* To simplify the code, we prevent matches with the string
       * of window index 0 (in particular we have to avoid a match
       * of the string with itself at the start of the input file).
       */
      s.match_length = longest_match(s, hash_head);
      /* longest_match() sets match_start */
    }
    if (s.match_length >= MIN_MATCH) {
      // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only

      /*** _tr_tally_dist(s, s.strstart - s.match_start,
                     s.match_length - MIN_MATCH, bflush); ***/
      bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);

      s.lookahead -= s.match_length;

      /* Insert new strings in the hash table only if the match length
       * is not too large. This saves time but degrades compression.
       */
      if (s.match_length <= s.max_lazy_match/*max_insert_length*/ && s.lookahead >= MIN_MATCH) {
        s.match_length--; /* string at strstart already in table */
        do {
          s.strstart++;
          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
          /***/
          /* strstart never exceeds WSIZE-MAX_MATCH, so there are
           * always MIN_MATCH bytes ahead.
           */
        } while (--s.match_length !== 0);
        s.strstart++;
      } else
      {
        s.strstart += s.match_length;
        s.match_length = 0;
        s.ins_h = s.window[s.strstart];
        /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */
        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + 1]) & s.hash_mask;

//#if MIN_MATCH != 3
//                Call UPDATE_HASH() MIN_MATCH-3 more times
//#endif
        /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not
         * matter since it will be recomputed at next deflate call.
         */
      }
    } else {
      /* No match, output a literal byte */
      //Tracevv((stderr,"%c", s.window[s.strstart]));
      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);

      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = ((s.strstart < (MIN_MATCH - 1)) ? s.strstart : MIN_MATCH - 1);
  if (flush === Z_FINISH$2) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
}

/* ===========================================================================
 * Same as above, but achieves better compression. We use a lazy
 * evaluation for matches: a match is finally adopted only if there is
 * no better match at the next window position.
 */
function deflate_slow(s, flush) {
  var hash_head;          /* head of hash chain */
  var bflush;              /* set if current block must be flushed */

  var max_insert;

  /* Process the input block. */
  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the next match, plus MIN_MATCH bytes to insert the
     * string following the next match.
     */
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$1) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) { break; } /* flush the current block */
    }

    /* Insert the string window[strstart .. strstart+2] in the
     * dictionary, and set hash_head to the head of the hash chain:
     */
    hash_head = 0/*NIL*/;
    if (s.lookahead >= MIN_MATCH) {
      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
      /***/
    }

    /* Find the longest match, discarding those <= prev_length.
     */
    s.prev_length = s.match_length;
    s.prev_match = s.match_start;
    s.match_length = MIN_MATCH - 1;

    if (hash_head !== 0/*NIL*/ && s.prev_length < s.max_lazy_match &&
        s.strstart - hash_head <= (s.w_size - MIN_LOOKAHEAD)/*MAX_DIST(s)*/) {
      /* To simplify the code, we prevent matches with the string
       * of window index 0 (in particular we have to avoid a match
       * of the string with itself at the start of the input file).
       */
      s.match_length = longest_match(s, hash_head);
      /* longest_match() sets match_start */

      if (s.match_length <= 5 &&
         (s.strategy === Z_FILTERED || (s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096/*TOO_FAR*/))) {

        /* If prev_match is also MIN_MATCH, match_start is garbage
         * but we will ignore the current match anyway.
         */
        s.match_length = MIN_MATCH - 1;
      }
    }
    /* If there was a match at the previous step and the current
     * match is not better, output the previous match:
     */
    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
      max_insert = s.strstart + s.lookahead - MIN_MATCH;
      /* Do not insert strings in hash table beyond this. */

      //check_match(s, s.strstart-1, s.prev_match, s.prev_length);

      /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,
                     s.prev_length - MIN_MATCH, bflush);***/
      bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
      /* Insert in hash table all strings up to the end of the match.
       * strstart-1 and strstart are already inserted. If there is not
       * enough lookahead, the last two strings are not inserted in
       * the hash table.
       */
      s.lookahead -= s.prev_length - 1;
      s.prev_length -= 2;
      do {
        if (++s.strstart <= max_insert) {
          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
          /***/
        }
      } while (--s.prev_length !== 0);
      s.match_available = 0;
      s.match_length = MIN_MATCH - 1;
      s.strstart++;

      if (bflush) {
        /*** FLUSH_BLOCK(s, 0); ***/
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
        /***/
      }

    } else if (s.match_available) {
      /* If there was no match at the previous position, output a
       * single literal. If there was a match but the current match
       * is longer, truncate the previous match to a single literal.
       */
      //Tracevv((stderr,"%c", s->window[s->strstart-1]));
      /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
      bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);

      if (bflush) {
        /*** FLUSH_BLOCK_ONLY(s, 0) ***/
        flush_block_only(s, false);
        /***/
      }
      s.strstart++;
      s.lookahead--;
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    } else {
      /* There is no previous match to compare with, wait for
       * the next step to decide.
       */
      s.match_available = 1;
      s.strstart++;
      s.lookahead--;
    }
  }
  //Assert (flush != Z_NO_FLUSH, "no flush?");
  if (s.match_available) {
    //Tracevv((stderr,"%c", s->window[s->strstart-1]));
    /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
    bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);

    s.match_available = 0;
  }
  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
  if (flush === Z_FINISH$2) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }

  return BS_BLOCK_DONE;
}


/* ===========================================================================
 * For Z_RLE, simply look for runs of bytes, generate matches only of distance
 * one.  Do not maintain a hash table.  (It will be regenerated if this run of
 * deflate switches away from Z_RLE.)
 */
function deflate_rle(s, flush) {
  var bflush;            /* set if current block must be flushed */
  var prev;              /* byte at distance one to match */
  var scan, strend;      /* scan goes up to strend for length of run */

  var _win = s.window;

  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the longest run, plus one for the unrolled loop.
     */
    if (s.lookahead <= MAX_MATCH) {
      fill_window(s);
      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH$1) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) { break; } /* flush the current block */
    }

    /* See how many times the previous byte repeats */
    s.match_length = 0;
    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
      scan = s.strstart - 1;
      prev = _win[scan];
      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
        strend = s.strstart + MAX_MATCH;
        do {
          /*jshint noempty:false*/
        } while (prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 scan < strend);
        s.match_length = MAX_MATCH - (strend - scan);
        if (s.match_length > s.lookahead) {
          s.match_length = s.lookahead;
        }
      }
      //Assert(scan <= s->window+(uInt)(s->window_size-1), "wild scan");
    }

    /* Emit match if have run of MIN_MATCH or longer, else emit literal */
    if (s.match_length >= MIN_MATCH) {
      //check_match(s, s.strstart, s.strstart - 1, s.match_length);

      /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/
      bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);

      s.lookahead -= s.match_length;
      s.strstart += s.match_length;
      s.match_length = 0;
    } else {
      /* No match, output a literal byte */
      //Tracevv((stderr,"%c", s->window[s->strstart]));
      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);

      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH$2) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
}

/* ===========================================================================
 * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.
 * (It will be regenerated if this run of deflate switches away from Huffman.)
 */
function deflate_huff(s, flush) {
  var bflush;             /* set if current block must be flushed */

  for (;;) {
    /* Make sure that we have a literal to write. */
    if (s.lookahead === 0) {
      fill_window(s);
      if (s.lookahead === 0) {
        if (flush === Z_NO_FLUSH$1) {
          return BS_NEED_MORE;
        }
        break;      /* flush the current block */
      }
    }

    /* Output a literal byte */
    s.match_length = 0;
    //Tracevv((stderr,"%c", s->window[s->strstart]));
    /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
    bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
    s.lookahead--;
    s.strstart++;
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH$2) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
}

/* Values for max_lazy_match, good_match and max_chain_length, depending on
 * the desired pack level (0..9). The values given below have been tuned to
 * exclude worst case performance for pathological files. Better values may be
 * found for specific files.
 */
function Config(good_length, max_lazy, nice_length, max_chain, func) {
  this.good_length = good_length;
  this.max_lazy = max_lazy;
  this.nice_length = nice_length;
  this.max_chain = max_chain;
  this.func = func;
}

var configuration_table;

configuration_table = [
  /*      good lazy nice chain */
  new Config(0, 0, 0, 0, deflate_stored),          /* 0 store only */
  new Config(4, 4, 8, 4, deflate_fast),            /* 1 max speed, no lazy matches */
  new Config(4, 5, 16, 8, deflate_fast),           /* 2 */
  new Config(4, 6, 32, 32, deflate_fast),          /* 3 */

  new Config(4, 4, 16, 16, deflate_slow),          /* 4 lazy matches */
  new Config(8, 16, 32, 32, deflate_slow),         /* 5 */
  new Config(8, 16, 128, 128, deflate_slow),       /* 6 */
  new Config(8, 32, 128, 256, deflate_slow),       /* 7 */
  new Config(32, 128, 258, 1024, deflate_slow),    /* 8 */
  new Config(32, 258, 258, 4096, deflate_slow)     /* 9 max compression */
];


/* ===========================================================================
 * Initialize the "longest match" routines for a new zlib stream
 */
function lm_init(s) {
  s.window_size = 2 * s.w_size;

  /*** CLEAR_HASH(s); ***/
  zero(s.head); // Fill with NIL (= 0);

  /* Set the default configuration parameters:
   */
  s.max_lazy_match = configuration_table[s.level].max_lazy;
  s.good_match = configuration_table[s.level].good_length;
  s.nice_match = configuration_table[s.level].nice_length;
  s.max_chain_length = configuration_table[s.level].max_chain;

  s.strstart = 0;
  s.block_start = 0;
  s.lookahead = 0;
  s.insert = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  s.ins_h = 0;
}


function DeflateState() {
  this.strm = null;            /* pointer back to this zlib stream */
  this.status = 0;            /* as the name implies */
  this.pending_buf = null;      /* output still pending */
  this.pending_buf_size = 0;  /* size of pending_buf */
  this.pending_out = 0;       /* next pending byte to output to the stream */
  this.pending = 0;           /* nb of bytes in the pending buffer */
  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */
  this.gzhead = null;         /* gzip header information to write */
  this.gzindex = 0;           /* where in extra, name, or comment */
  this.method = Z_DEFLATED$2; /* can only be DEFLATED */
  this.last_flush = -1;   /* value of flush param for previous deflate call */

  this.w_size = 0;  /* LZ77 window size (32K by default) */
  this.w_bits = 0;  /* log2(w_size)  (8..16) */
  this.w_mask = 0;  /* w_size - 1 */

  this.window = null;
  /* Sliding window. Input bytes are read into the second half of the window,
   * and move to the first half later to keep a dictionary of at least wSize
   * bytes. With this organization, matches are limited to a distance of
   * wSize-MAX_MATCH bytes, but this ensures that IO is always
   * performed with a length multiple of the block size.
   */

  this.window_size = 0;
  /* Actual size of window: 2*wSize, except when the user input buffer
   * is directly used as sliding window.
   */

  this.prev = null;
  /* Link to older string with same hash index. To limit the size of this
   * array to 64K, this link is maintained only for the last 32K strings.
   * An index in this array is thus a window index modulo 32K.
   */

  this.head = null;   /* Heads of the hash chains or NIL. */

  this.ins_h = 0;       /* hash index of string to be inserted */
  this.hash_size = 0;   /* number of elements in hash table */
  this.hash_bits = 0;   /* log2(hash_size) */
  this.hash_mask = 0;   /* hash_size-1 */

  this.hash_shift = 0;
  /* Number of bits by which ins_h must be shifted at each input
   * step. It must be such that after MIN_MATCH steps, the oldest
   * byte no longer takes part in the hash key, that is:
   *   hash_shift * MIN_MATCH >= hash_bits
   */

  this.block_start = 0;
  /* Window position at the beginning of the current output block. Gets
   * negative when the window is moved backwards.
   */

  this.match_length = 0;      /* length of best match */
  this.prev_match = 0;        /* previous match */
  this.match_available = 0;   /* set if previous match exists */
  this.strstart = 0;          /* start of string to insert */
  this.match_start = 0;       /* start of matching string */
  this.lookahead = 0;         /* number of valid bytes ahead in window */

  this.prev_length = 0;
  /* Length of the best match at previous step. Matches not greater than this
   * are discarded. This is used in the lazy match evaluation.
   */

  this.max_chain_length = 0;
  /* To speed up deflation, hash chains are never searched beyond this
   * length.  A higher limit improves compression ratio but degrades the
   * speed.
   */

  this.max_lazy_match = 0;
  /* Attempt to find a better match only when the current match is strictly
   * smaller than this value. This mechanism is used only for compression
   * levels >= 4.
   */
  // That's alias to max_lazy_match, don't use directly
  //this.max_insert_length = 0;
  /* Insert new strings in the hash table only if the match length is not
   * greater than this length. This saves time but degrades compression.
   * max_insert_length is used only for compression levels <= 3.
   */

  this.level = 0;     /* compression level (1..9) */
  this.strategy = 0;  /* favor or force Huffman coding*/

  this.good_match = 0;
  /* Use a faster search when the previous match is longer than this */

  this.nice_match = 0; /* Stop searching when current match exceeds this */

              /* used by trees.c: */

  /* Didn't use ct_data typedef below to suppress compiler warning */

  // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */
  // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */
  // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */

  // Use flat array of DOUBLE size, with interleaved fata,
  // because JS does not support effective
  this.dyn_ltree  = new common.Buf16(HEAP_SIZE * 2);
  this.dyn_dtree  = new common.Buf16((2 * D_CODES + 1) * 2);
  this.bl_tree    = new common.Buf16((2 * BL_CODES + 1) * 2);
  zero(this.dyn_ltree);
  zero(this.dyn_dtree);
  zero(this.bl_tree);

  this.l_desc   = null;         /* desc. for literal tree */
  this.d_desc   = null;         /* desc. for distance tree */
  this.bl_desc  = null;         /* desc. for bit length tree */

  //ush bl_count[MAX_BITS+1];
  this.bl_count = new common.Buf16(MAX_BITS + 1);
  /* number of codes at each bit length for an optimal tree */

  //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */
  this.heap = new common.Buf16(2 * L_CODES + 1);  /* heap used to build the Huffman trees */
  zero(this.heap);

  this.heap_len = 0;               /* number of elements in the heap */
  this.heap_max = 0;               /* element of largest frequency */
  /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.
   * The same heap array is used to build all trees.
   */

  this.depth = new common.Buf16(2 * L_CODES + 1); //uch depth[2*L_CODES+1];
  zero(this.depth);
  /* Depth of each subtree used as tie breaker for trees of equal frequency
   */

  this.l_buf = 0;          /* buffer index for literals or lengths */

  this.lit_bufsize = 0;
  /* Size of match buffer for literals/lengths.  There are 4 reasons for
   * limiting lit_bufsize to 64K:
   *   - frequencies can be kept in 16 bit counters
   *   - if compression is not successful for the first block, all input
   *     data is still in the window so we can still emit a stored block even
   *     when input comes from standard input.  (This can also be done for
   *     all blocks if lit_bufsize is not greater than 32K.)
   *   - if compression is not successful for a file smaller than 64K, we can
   *     even emit a stored file instead of a stored block (saving 5 bytes).
   *     This is applicable only for zip (not gzip or zlib).
   *   - creating new Huffman trees less frequently may not provide fast
   *     adaptation to changes in the input data statistics. (Take for
   *     example a binary file with poorly compressible code followed by
   *     a highly compressible string table.) Smaller buffer sizes give
   *     fast adaptation but have of course the overhead of transmitting
   *     trees more frequently.
   *   - I can't count above 4
   */

  this.last_lit = 0;      /* running index in l_buf */

  this.d_buf = 0;
  /* Buffer index for distances. To simplify the code, d_buf and l_buf have
   * the same number of elements. To use different lengths, an extra flag
   * array would be necessary.
   */

  this.opt_len = 0;       /* bit length of current block with optimal trees */
  this.static_len = 0;    /* bit length of current block with static trees */
  this.matches = 0;       /* number of string matches in current block */
  this.insert = 0;        /* bytes at end of window left to insert */


  this.bi_buf = 0;
  /* Output buffer. bits are inserted starting at the bottom (least
   * significant bits).
   */
  this.bi_valid = 0;
  /* Number of valid bits in bi_buf.  All bits above the last valid bit
   * are always zero.
   */

  // Used for window memory init. We safely ignore it for JS. That makes
  // sense only for pointers and memory check tools.
  //this.high_water = 0;
  /* High water mark offset in window for initialized bytes -- bytes above
   * this are set to zero in order to avoid memory check warnings when
   * longest match routines access bytes past the input.  This is then
   * updated to the new high water mark.
   */
}


function deflateResetKeep(strm) {
  var s;

  if (!strm || !strm.state) {
    return err(strm, Z_STREAM_ERROR$1);
  }

  strm.total_in = strm.total_out = 0;
  strm.data_type = Z_UNKNOWN;

  s = strm.state;
  s.pending = 0;
  s.pending_out = 0;

  if (s.wrap < 0) {
    s.wrap = -s.wrap;
    /* was made negative by deflate(..., Z_FINISH); */
  }
  s.status = (s.wrap ? INIT_STATE : BUSY_STATE);
  strm.adler = (s.wrap === 2) ?
    0  // crc32(0, Z_NULL, 0)
  :
    1; // adler32(0, Z_NULL, 0)
  s.last_flush = Z_NO_FLUSH$1;
  trees._tr_init(s);
  return Z_OK$2;
}


function deflateReset(strm) {
  var ret = deflateResetKeep(strm);
  if (ret === Z_OK$2) {
    lm_init(strm.state);
  }
  return ret;
}


function deflateSetHeader(strm, head) {
  if (!strm || !strm.state) { return Z_STREAM_ERROR$1; }
  if (strm.state.wrap !== 2) { return Z_STREAM_ERROR$1; }
  strm.state.gzhead = head;
  return Z_OK$2;
}


function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
  if (!strm) { // === Z_NULL
    return Z_STREAM_ERROR$1;
  }
  var wrap = 1;

  if (level === Z_DEFAULT_COMPRESSION$1) {
    level = 6;
  }

  if (windowBits < 0) { /* suppress zlib wrapper */
    wrap = 0;
    windowBits = -windowBits;
  }

  else if (windowBits > 15) {
    wrap = 2;           /* write gzip wrapper instead */
    windowBits -= 16;
  }


  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED$2 ||
    windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||
    strategy < 0 || strategy > Z_FIXED) {
    return err(strm, Z_STREAM_ERROR$1);
  }


  if (windowBits === 8) {
    windowBits = 9;
  }
  /* until 256-byte window bug fixed */

  var s = new DeflateState();

  strm.state = s;
  s.strm = strm;

  s.wrap = wrap;
  s.gzhead = null;
  s.w_bits = windowBits;
  s.w_size = 1 << s.w_bits;
  s.w_mask = s.w_size - 1;

  s.hash_bits = memLevel + 7;
  s.hash_size = 1 << s.hash_bits;
  s.hash_mask = s.hash_size - 1;
  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);

  s.window = new common.Buf8(s.w_size * 2);
  s.head = new common.Buf16(s.hash_size);
  s.prev = new common.Buf16(s.w_size);

  // Don't need mem init magic for JS.
  //s.high_water = 0;  /* nothing written to s->window yet */

  s.lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */

  s.pending_buf_size = s.lit_bufsize * 4;

  //overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);
  //s->pending_buf = (uchf *) overlay;
  s.pending_buf = new common.Buf8(s.pending_buf_size);

  // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)
  //s->d_buf = overlay + s->lit_bufsize/sizeof(ush);
  s.d_buf = 1 * s.lit_bufsize;

  //s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;
  s.l_buf = (1 + 2) * s.lit_bufsize;

  s.level = level;
  s.strategy = strategy;
  s.method = method;

  return deflateReset(strm);
}

function deflateInit(strm, level) {
  return deflateInit2(strm, level, Z_DEFLATED$2, MAX_WBITS$1, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY$1);
}


function deflate$2(strm, flush) {
  var old_flush, s;
  var beg, val; // for gzip header write only

  if (!strm || !strm.state ||
    flush > Z_BLOCK$1 || flush < 0) {
    return strm ? err(strm, Z_STREAM_ERROR$1) : Z_STREAM_ERROR$1;
  }

  s = strm.state;

  if (!strm.output ||
      (!strm.input && strm.avail_in !== 0) ||
      (s.status === FINISH_STATE && flush !== Z_FINISH$2)) {
    return err(strm, (strm.avail_out === 0) ? Z_BUF_ERROR$1 : Z_STREAM_ERROR$1);
  }

  s.strm = strm; /* just in case */
  old_flush = s.last_flush;
  s.last_flush = flush;

  /* Write the header */
  if (s.status === INIT_STATE) {

    if (s.wrap === 2) { // GZIP header
      strm.adler = 0;  //crc32(0L, Z_NULL, 0);
      put_byte(s, 31);
      put_byte(s, 139);
      put_byte(s, 8);
      if (!s.gzhead) { // s->gzhead == Z_NULL
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, s.level === 9 ? 2 :
                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?
                     4 : 0));
        put_byte(s, OS_CODE);
        s.status = BUSY_STATE;
      }
      else {
        put_byte(s, (s.gzhead.text ? 1 : 0) +
                    (s.gzhead.hcrc ? 2 : 0) +
                    (!s.gzhead.extra ? 0 : 4) +
                    (!s.gzhead.name ? 0 : 8) +
                    (!s.gzhead.comment ? 0 : 16)
        );
        put_byte(s, s.gzhead.time & 0xff);
        put_byte(s, (s.gzhead.time >> 8) & 0xff);
        put_byte(s, (s.gzhead.time >> 16) & 0xff);
        put_byte(s, (s.gzhead.time >> 24) & 0xff);
        put_byte(s, s.level === 9 ? 2 :
                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?
                     4 : 0));
        put_byte(s, s.gzhead.os & 0xff);
        if (s.gzhead.extra && s.gzhead.extra.length) {
          put_byte(s, s.gzhead.extra.length & 0xff);
          put_byte(s, (s.gzhead.extra.length >> 8) & 0xff);
        }
        if (s.gzhead.hcrc) {
          strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending, 0);
        }
        s.gzindex = 0;
        s.status = EXTRA_STATE;
      }
    }
    else // DEFLATE header
    {
      var header = (Z_DEFLATED$2 + ((s.w_bits - 8) << 4)) << 8;
      var level_flags = -1;

      if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
        level_flags = 0;
      } else if (s.level < 6) {
        level_flags = 1;
      } else if (s.level === 6) {
        level_flags = 2;
      } else {
        level_flags = 3;
      }
      header |= (level_flags << 6);
      if (s.strstart !== 0) { header |= PRESET_DICT; }
      header += 31 - (header % 31);

      s.status = BUSY_STATE;
      putShortMSB(s, header);

      /* Save the adler32 of the preset dictionary: */
      if (s.strstart !== 0) {
        putShortMSB(s, strm.adler >>> 16);
        putShortMSB(s, strm.adler & 0xffff);
      }
      strm.adler = 1; // adler32(0L, Z_NULL, 0);
    }
  }

//#ifdef GZIP
  if (s.status === EXTRA_STATE) {
    if (s.gzhead.extra/* != Z_NULL*/) {
      beg = s.pending;  /* start of bytes to update crc */

      while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            break;
          }
        }
        put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);
        s.gzindex++;
      }
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (s.gzindex === s.gzhead.extra.length) {
        s.gzindex = 0;
        s.status = NAME_STATE;
      }
    }
    else {
      s.status = NAME_STATE;
    }
  }
  if (s.status === NAME_STATE) {
    if (s.gzhead.name/* != Z_NULL*/) {
      beg = s.pending;  /* start of bytes to update crc */
      //int val;

      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            val = 1;
            break;
          }
        }
        // JS specific: little magic to add zero terminator to end of string
        if (s.gzindex < s.gzhead.name.length) {
          val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);

      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (val === 0) {
        s.gzindex = 0;
        s.status = COMMENT_STATE;
      }
    }
    else {
      s.status = COMMENT_STATE;
    }
  }
  if (s.status === COMMENT_STATE) {
    if (s.gzhead.comment/* != Z_NULL*/) {
      beg = s.pending;  /* start of bytes to update crc */
      //int val;

      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            val = 1;
            break;
          }
        }
        // JS specific: little magic to add zero terminator to end of string
        if (s.gzindex < s.gzhead.comment.length) {
          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);

      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (val === 0) {
        s.status = HCRC_STATE;
      }
    }
    else {
      s.status = HCRC_STATE;
    }
  }
  if (s.status === HCRC_STATE) {
    if (s.gzhead.hcrc) {
      if (s.pending + 2 > s.pending_buf_size) {
        flush_pending(strm);
      }
      if (s.pending + 2 <= s.pending_buf_size) {
        put_byte(s, strm.adler & 0xff);
        put_byte(s, (strm.adler >> 8) & 0xff);
        strm.adler = 0; //crc32(0L, Z_NULL, 0);
        s.status = BUSY_STATE;
      }
    }
    else {
      s.status = BUSY_STATE;
    }
  }
//#endif

  /* Flush as much pending output as possible */
  if (s.pending !== 0) {
    flush_pending(strm);
    if (strm.avail_out === 0) {
      /* Since avail_out is 0, deflate will be called again with
       * more output space, but possibly with both pending and
       * avail_in equal to zero. There won't be anything to do,
       * but this is not an error situation so make sure we
       * return OK instead of BUF_ERROR at next call of deflate:
       */
      s.last_flush = -1;
      return Z_OK$2;
    }

    /* Make sure there is something to do and avoid duplicate consecutive
     * flushes. For repeated and useless calls with Z_FINISH, we keep
     * returning Z_STREAM_END instead of Z_BUF_ERROR.
     */
  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) &&
    flush !== Z_FINISH$2) {
    return err(strm, Z_BUF_ERROR$1);
  }

  /* User must not provide more input after the first FINISH: */
  if (s.status === FINISH_STATE && strm.avail_in !== 0) {
    return err(strm, Z_BUF_ERROR$1);
  }

  /* Start a new block or continue the current one.
   */
  if (strm.avail_in !== 0 || s.lookahead !== 0 ||
    (flush !== Z_NO_FLUSH$1 && s.status !== FINISH_STATE)) {
    var bstate = (s.strategy === Z_HUFFMAN_ONLY) ? deflate_huff(s, flush) :
      (s.strategy === Z_RLE ? deflate_rle(s, flush) :
        configuration_table[s.level].func(s, flush));

    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
      s.status = FINISH_STATE;
    }
    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
      if (strm.avail_out === 0) {
        s.last_flush = -1;
        /* avoid BUF_ERROR next call, see above */
      }
      return Z_OK$2;
      /* If flush != Z_NO_FLUSH && avail_out == 0, the next call
       * of deflate should use the same flush parameter to make sure
       * that the flush is complete. So we don't have to output an
       * empty block here, this will be done at next call. This also
       * ensures that for a very small output buffer, we emit at most
       * one empty block.
       */
    }
    if (bstate === BS_BLOCK_DONE) {
      if (flush === Z_PARTIAL_FLUSH) {
        trees._tr_align(s);
      }
      else if (flush !== Z_BLOCK$1) { /* FULL_FLUSH or SYNC_FLUSH */

        trees._tr_stored_block(s, 0, 0, false);
        /* For a full flush, this empty block will be recognized
         * as a special marker by inflate_sync().
         */
        if (flush === Z_FULL_FLUSH) {
          /*** CLEAR_HASH(s); ***/             /* forget history */
          zero(s.head); // Fill with NIL (= 0);

          if (s.lookahead === 0) {
            s.strstart = 0;
            s.block_start = 0;
            s.insert = 0;
          }
        }
      }
      flush_pending(strm);
      if (strm.avail_out === 0) {
        s.last_flush = -1; /* avoid BUF_ERROR at next call, see above */
        return Z_OK$2;
      }
    }
  }
  //Assert(strm->avail_out > 0, "bug2");
  //if (strm.avail_out <= 0) { throw new Error("bug2");}

  if (flush !== Z_FINISH$2) { return Z_OK$2; }
  if (s.wrap <= 0) { return Z_STREAM_END$2; }

  /* Write the trailer */
  if (s.wrap === 2) {
    put_byte(s, strm.adler & 0xff);
    put_byte(s, (strm.adler >> 8) & 0xff);
    put_byte(s, (strm.adler >> 16) & 0xff);
    put_byte(s, (strm.adler >> 24) & 0xff);
    put_byte(s, strm.total_in & 0xff);
    put_byte(s, (strm.total_in >> 8) & 0xff);
    put_byte(s, (strm.total_in >> 16) & 0xff);
    put_byte(s, (strm.total_in >> 24) & 0xff);
  }
  else
  {
    putShortMSB(s, strm.adler >>> 16);
    putShortMSB(s, strm.adler & 0xffff);
  }

  flush_pending(strm);
  /* If avail_out is zero, the application will call deflate again
   * to flush the rest.
   */
  if (s.wrap > 0) { s.wrap = -s.wrap; }
  /* write the trailer only once! */
  return s.pending !== 0 ? Z_OK$2 : Z_STREAM_END$2;
}

function deflateEnd(strm) {
  var status;

  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {
    return Z_STREAM_ERROR$1;
  }

  status = strm.state.status;
  if (status !== INIT_STATE &&
    status !== EXTRA_STATE &&
    status !== NAME_STATE &&
    status !== COMMENT_STATE &&
    status !== HCRC_STATE &&
    status !== BUSY_STATE &&
    status !== FINISH_STATE
  ) {
    return err(strm, Z_STREAM_ERROR$1);
  }

  strm.state = null;

  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR$1) : Z_OK$2;
}


/* =========================================================================
 * Initializes the compression dictionary from the given byte
 * sequence without producing any compressed output.
 */
function deflateSetDictionary(strm, dictionary) {
  var dictLength = dictionary.length;

  var s;
  var str, n;
  var wrap;
  var avail;
  var next;
  var input;
  var tmpDict;

  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {
    return Z_STREAM_ERROR$1;
  }

  s = strm.state;
  wrap = s.wrap;

  if (wrap === 2 || (wrap === 1 && s.status !== INIT_STATE) || s.lookahead) {
    return Z_STREAM_ERROR$1;
  }

  /* when using zlib wrappers, compute Adler-32 for provided dictionary */
  if (wrap === 1) {
    /* adler32(strm->adler, dictionary, dictLength); */
    strm.adler = adler32_1(strm.adler, dictionary, dictLength, 0);
  }

  s.wrap = 0;   /* avoid computing Adler-32 in read_buf */

  /* if dictionary would fill window, just replace the history */
  if (dictLength >= s.w_size) {
    if (wrap === 0) {            /* already empty otherwise */
      /*** CLEAR_HASH(s); ***/
      zero(s.head); // Fill with NIL (= 0);
      s.strstart = 0;
      s.block_start = 0;
      s.insert = 0;
    }
    /* use the tail */
    // dictionary = dictionary.slice(dictLength - s.w_size);
    tmpDict = new common.Buf8(s.w_size);
    common.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);
    dictionary = tmpDict;
    dictLength = s.w_size;
  }
  /* insert dictionary into window and hash */
  avail = strm.avail_in;
  next = strm.next_in;
  input = strm.input;
  strm.avail_in = dictLength;
  strm.next_in = 0;
  strm.input = dictionary;
  fill_window(s);
  while (s.lookahead >= MIN_MATCH) {
    str = s.strstart;
    n = s.lookahead - (MIN_MATCH - 1);
    do {
      /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;

      s.prev[str & s.w_mask] = s.head[s.ins_h];

      s.head[s.ins_h] = str;
      str++;
    } while (--n);
    s.strstart = str;
    s.lookahead = MIN_MATCH - 1;
    fill_window(s);
  }
  s.strstart += s.lookahead;
  s.block_start = s.strstart;
  s.insert = s.lookahead;
  s.lookahead = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  strm.next_in = next;
  strm.input = input;
  strm.avail_in = avail;
  s.wrap = wrap;
  return Z_OK$2;
}


var deflateInit_1 = deflateInit;
var deflateInit2_1 = deflateInit2;
var deflateReset_1 = deflateReset;
var deflateResetKeep_1 = deflateResetKeep;
var deflateSetHeader_1 = deflateSetHeader;
var deflate_2$1 = deflate$2;
var deflateEnd_1 = deflateEnd;
var deflateSetDictionary_1 = deflateSetDictionary;
var deflateInfo = 'pako deflate (from Nodeca project)';

/* Not implemented
exports.deflateBound = deflateBound;
exports.deflateCopy = deflateCopy;
exports.deflateParams = deflateParams;
exports.deflatePending = deflatePending;
exports.deflatePrime = deflatePrime;
exports.deflateTune = deflateTune;
*/

var deflate_1$1 = {
	deflateInit: deflateInit_1,
	deflateInit2: deflateInit2_1,
	deflateReset: deflateReset_1,
	deflateResetKeep: deflateResetKeep_1,
	deflateSetHeader: deflateSetHeader_1,
	deflate: deflate_2$1,
	deflateEnd: deflateEnd_1,
	deflateSetDictionary: deflateSetDictionary_1,
	deflateInfo: deflateInfo
};

// Quick check if we can use fast array to bin string conversion
//
// - apply(Array) can fail on Android 2.2
// - apply(Uint8Array) can fail on iOS 5.1 Safari
//
var STR_APPLY_OK = true;
var STR_APPLY_UIA_OK = true;

try { String.fromCharCode.apply(null, [ 0 ]); } catch (__) { STR_APPLY_OK = false; }
try { String.fromCharCode.apply(null, new Uint8Array(1)); } catch (__) { STR_APPLY_UIA_OK = false; }


// Table with utf8 lengths (calculated by first byte of sequence)
// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,
// because max possible codepoint is 0x10ffff
var _utf8len = new common.Buf8(256);
for (var q = 0; q < 256; q++) {
  _utf8len[q] = (q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1);
}
_utf8len[254] = _utf8len[254] = 1; // Invalid sequence start


// convert string to array (typed, when possible)
var string2buf = function (str) {
  var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;

  // count binary size
  for (m_pos = 0; m_pos < str_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 0xfc00) === 0xdc00) {
        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
        m_pos++;
      }
    }
    buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;
  }

  // allocate buffer
  buf = new common.Buf8(buf_len);

  // convert
  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 0xfc00) === 0xdc00) {
        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
        m_pos++;
      }
    }
    if (c < 0x80) {
      /* one byte */
      buf[i++] = c;
    } else if (c < 0x800) {
      /* two bytes */
      buf[i++] = 0xC0 | (c >>> 6);
      buf[i++] = 0x80 | (c & 0x3f);
    } else if (c < 0x10000) {
      /* three bytes */
      buf[i++] = 0xE0 | (c >>> 12);
      buf[i++] = 0x80 | (c >>> 6 & 0x3f);
      buf[i++] = 0x80 | (c & 0x3f);
    } else {
      /* four bytes */
      buf[i++] = 0xf0 | (c >>> 18);
      buf[i++] = 0x80 | (c >>> 12 & 0x3f);
      buf[i++] = 0x80 | (c >>> 6 & 0x3f);
      buf[i++] = 0x80 | (c & 0x3f);
    }
  }

  return buf;
};

// Helper (used in 2 places)
function buf2binstring(buf, len) {
  // On Chrome, the arguments in a function call that are allowed is `65534`.
  // If the length of the buffer is smaller than that, we can use this optimization,
  // otherwise we will take a slower path.
  if (len < 65534) {
    if ((buf.subarray && STR_APPLY_UIA_OK) || (!buf.subarray && STR_APPLY_OK)) {
      return String.fromCharCode.apply(null, common.shrinkBuf(buf, len));
    }
  }

  var result = '';
  for (var i = 0; i < len; i++) {
    result += String.fromCharCode(buf[i]);
  }
  return result;
}


// Convert byte array to binary string
var buf2binstring_1 = function (buf) {
  return buf2binstring(buf, buf.length);
};


// Convert binary string (typed, when possible)
var binstring2buf = function (str) {
  var buf = new common.Buf8(str.length);
  for (var i = 0, len = buf.length; i < len; i++) {
    buf[i] = str.charCodeAt(i);
  }
  return buf;
};


// convert array to string
var buf2string = function (buf, max) {
  var i, out, c, c_len;
  var len = max || buf.length;

  // Reserve max possible length (2 words per char)
  // NB: by unknown reasons, Array is significantly faster for
  //     String.fromCharCode.apply than Uint16Array.
  var utf16buf = new Array(len * 2);

  for (out = 0, i = 0; i < len;) {
    c = buf[i++];
    // quick process ascii
    if (c < 0x80) { utf16buf[out++] = c; continue; }

    c_len = _utf8len[c];
    // skip 5 & 6 byte codes
    if (c_len > 4) { utf16buf[out++] = 0xfffd; i += c_len - 1; continue; }

    // apply mask on first byte
    c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;
    // join the rest
    while (c_len > 1 && i < len) {
      c = (c << 6) | (buf[i++] & 0x3f);
      c_len--;
    }

    // terminated by end of string?
    if (c_len > 1) { utf16buf[out++] = 0xfffd; continue; }

    if (c < 0x10000) {
      utf16buf[out++] = c;
    } else {
      c -= 0x10000;
      utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff);
      utf16buf[out++] = 0xdc00 | (c & 0x3ff);
    }
  }

  return buf2binstring(utf16buf, out);
};


// Calculate max possible position in utf8 buffer,
// that will not break sequence. If that's not possible
// - (very small limits) return max size as is.
//
// buf[] - utf8 bytes array
// max   - length limit (mandatory);
var utf8border = function (buf, max) {
  var pos;

  max = max || buf.length;
  if (max > buf.length) { max = buf.length; }

  // go back from last position, until start of sequence found
  pos = max - 1;
  while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) { pos--; }

  // Very small and broken sequence,
  // return max, because we should return something anyway.
  if (pos < 0) { return max; }

  // If we came to start of buffer - that means buffer is too small,
  // return max too.
  if (pos === 0) { return max; }

  return (pos + _utf8len[buf[pos]] > max) ? pos : max;
};

var strings = {
	string2buf: string2buf,
	buf2binstring: buf2binstring_1,
	binstring2buf: binstring2buf,
	buf2string: buf2string,
	utf8border: utf8border
};

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

function ZStream() {
  /* next input byte */
  this.input = null; // JS specific, because we have no pointers
  this.next_in = 0;
  /* number of bytes available at input */
  this.avail_in = 0;
  /* total number of input bytes read so far */
  this.total_in = 0;
  /* next output byte should be put there */
  this.output = null; // JS specific, because we have no pointers
  this.next_out = 0;
  /* remaining free space at output */
  this.avail_out = 0;
  /* total number of bytes output so far */
  this.total_out = 0;
  /* last error message, NULL if no error */
  this.msg = ''/*Z_NULL*/;
  /* not visible by applications */
  this.state = null;
  /* best guess about the data type: binary or text */
  this.data_type = 2/*Z_UNKNOWN*/;
  /* adler32 value of the uncompressed data */
  this.adler = 0;
}

var zstream = ZStream;

var toString$1 = Object.prototype.toString;

/* Public constants ==========================================================*/
/* ===========================================================================*/

var Z_NO_FLUSH      = 0;
var Z_FINISH$1        = 4;

var Z_OK$1            = 0;
var Z_STREAM_END$1    = 1;
var Z_SYNC_FLUSH    = 2;

var Z_DEFAULT_COMPRESSION = -1;

var Z_DEFAULT_STRATEGY    = 0;

var Z_DEFLATED$1  = 8;

/* ===========================================================================*/


/**
 * class Deflate
 *
 * Generic JS-style wrapper for zlib calls. If you don't need
 * streaming behaviour - use more simple functions: [[deflate]],
 * [[deflateRaw]] and [[gzip]].
 **/

/* internal
 * Deflate.chunks -> Array
 *
 * Chunks of output data, if [[Deflate#onData]] not overridden.
 **/

/**
 * Deflate.result -> Uint8Array|Array
 *
 * Compressed result, generated by default [[Deflate#onData]]
 * and [[Deflate#onEnd]] handlers. Filled after you push last chunk
 * (call [[Deflate#push]] with `Z_FINISH` / `true` param)  or if you
 * push a chunk with explicit flush (call [[Deflate#push]] with
 * `Z_SYNC_FLUSH` param).
 **/

/**
 * Deflate.err -> Number
 *
 * Error code after deflate finished. 0 (Z_OK) on success.
 * You will not need it in real life, because deflate errors
 * are possible only on wrong options or bad `onData` / `onEnd`
 * custom handlers.
 **/

/**
 * Deflate.msg -> String
 *
 * Error message, if [[Deflate.err]] != 0
 **/


/**
 * new Deflate(options)
 * - options (Object): zlib deflate options.
 *
 * Creates new deflator instance with specified params. Throws exception
 * on bad params. Supported options:
 *
 * - `level`
 * - `windowBits`
 * - `memLevel`
 * - `strategy`
 * - `dictionary`
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Additional options, for internal needs:
 *
 * - `chunkSize` - size of generated data chunks (16K by default)
 * - `raw` (Boolean) - do raw deflate
 * - `gzip` (Boolean) - create gzip wrapper
 * - `to` (String) - if equal to 'string', then result will be "binary string"
 *    (each char code [0..255])
 * - `header` (Object) - custom header for gzip
 *   - `text` (Boolean) - true if compressed data believed to be text
 *   - `time` (Number) - modification time, unix timestamp
 *   - `os` (Number) - operation system code
 *   - `extra` (Array) - array of bytes with extra data (max 65536)
 *   - `name` (String) - file name (binary string)
 *   - `comment` (String) - comment (binary string)
 *   - `hcrc` (Boolean) - true if header crc should be added
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])
 *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);
 *
 * var deflate = new pako.Deflate({ level: 3});
 *
 * deflate.push(chunk1, false);
 * deflate.push(chunk2, true);  // true -> last chunk
 *
 * if (deflate.err) { throw new Error(deflate.err); }
 *
 * console.log(deflate.result);
 * ```
 **/
function Deflate(options) {
  if (!(this instanceof Deflate)) return new Deflate(options);

  this.options = common.assign({
    level: Z_DEFAULT_COMPRESSION,
    method: Z_DEFLATED$1,
    chunkSize: 16384,
    windowBits: 15,
    memLevel: 8,
    strategy: Z_DEFAULT_STRATEGY,
    to: ''
  }, options || {});

  var opt = this.options;

  if (opt.raw && (opt.windowBits > 0)) {
    opt.windowBits = -opt.windowBits;
  }

  else if (opt.gzip && (opt.windowBits > 0) && (opt.windowBits < 16)) {
    opt.windowBits += 16;
  }

  this.err    = 0;      // error code, if happens (0 = Z_OK)
  this.msg    = '';     // error message
  this.ended  = false;  // used to avoid multiple onEnd() calls
  this.chunks = [];     // chunks of compressed data

  this.strm = new zstream();
  this.strm.avail_out = 0;

  var status = deflate_1$1.deflateInit2(
    this.strm,
    opt.level,
    opt.method,
    opt.windowBits,
    opt.memLevel,
    opt.strategy
  );

  if (status !== Z_OK$1) {
    throw new Error(messages[status]);
  }

  if (opt.header) {
    deflate_1$1.deflateSetHeader(this.strm, opt.header);
  }

  if (opt.dictionary) {
    var dict;
    // Convert data if needed
    if (typeof opt.dictionary === 'string') {
      // If we need to compress text, change encoding to utf8.
      dict = strings.string2buf(opt.dictionary);
    } else if (toString$1.call(opt.dictionary) === '[object ArrayBuffer]') {
      dict = new Uint8Array(opt.dictionary);
    } else {
      dict = opt.dictionary;
    }

    status = deflate_1$1.deflateSetDictionary(this.strm, dict);

    if (status !== Z_OK$1) {
      throw new Error(messages[status]);
    }

    this._dict_set = true;
  }
}

/**
 * Deflate#push(data[, mode]) -> Boolean
 * - data (Uint8Array|Array|ArrayBuffer|String): input data. Strings will be
 *   converted to utf8 byte sequence.
 * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.
 *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.
 *
 * Sends input data to deflate pipe, generating [[Deflate#onData]] calls with
 * new compressed chunks. Returns `true` on success. The last data block must have
 * mode Z_FINISH (or `true`). That will flush internal pending buffers and call
 * [[Deflate#onEnd]]. For interim explicit flushes (without ending the stream) you
 * can use mode Z_SYNC_FLUSH, keeping the compression context.
 *
 * On fail call [[Deflate#onEnd]] with error code and return false.
 *
 * We strongly recommend to use `Uint8Array` on input for best speed (output
 * array format is detected automatically). Also, don't skip last param and always
 * use the same type in your code (boolean or number). That will improve JS speed.
 *
 * For regular `Array`-s make sure all elements are [0..255].
 *
 * ##### Example
 *
 * ```javascript
 * push(chunk, false); // push one of data chunks
 * ...
 * push(chunk, true);  // push last chunk
 * ```
 **/
Deflate.prototype.push = function (data, mode) {
  var strm = this.strm;
  var chunkSize = this.options.chunkSize;
  var status, _mode;

  if (this.ended) { return false; }

  _mode = (mode === ~~mode) ? mode : ((mode === true) ? Z_FINISH$1 : Z_NO_FLUSH);

  // Convert data if needed
  if (typeof data === 'string') {
    // If we need to compress text, change encoding to utf8.
    strm.input = strings.string2buf(data);
  } else if (toString$1.call(data) === '[object ArrayBuffer]') {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }

  strm.next_in = 0;
  strm.avail_in = strm.input.length;

  do {
    if (strm.avail_out === 0) {
      strm.output = new common.Buf8(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }
    status = deflate_1$1.deflate(strm, _mode);    /* no bad return value */

    if (status !== Z_STREAM_END$1 && status !== Z_OK$1) {
      this.onEnd(status);
      this.ended = true;
      return false;
    }
    if (strm.avail_out === 0 || (strm.avail_in === 0 && (_mode === Z_FINISH$1 || _mode === Z_SYNC_FLUSH))) {
      if (this.options.to === 'string') {
        this.onData(strings.buf2binstring(common.shrinkBuf(strm.output, strm.next_out)));
      } else {
        this.onData(common.shrinkBuf(strm.output, strm.next_out));
      }
    }
  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END$1);

  // Finalize on the last chunk.
  if (_mode === Z_FINISH$1) {
    status = deflate_1$1.deflateEnd(this.strm);
    this.onEnd(status);
    this.ended = true;
    return status === Z_OK$1;
  }

  // callback interim results if Z_SYNC_FLUSH.
  if (_mode === Z_SYNC_FLUSH) {
    this.onEnd(Z_OK$1);
    strm.avail_out = 0;
    return true;
  }

  return true;
};


/**
 * Deflate#onData(chunk) -> Void
 * - chunk (Uint8Array|Array|String): output data. Type of array depends
 *   on js engine support. When string output requested, each chunk
 *   will be string.
 *
 * By default, stores data blocks in `chunks[]` property and glue
 * those in `onEnd`. Override this handler, if you need another behaviour.
 **/
Deflate.prototype.onData = function (chunk) {
  this.chunks.push(chunk);
};


/**
 * Deflate#onEnd(status) -> Void
 * - status (Number): deflate status. 0 (Z_OK) on success,
 *   other if not.
 *
 * Called once after you tell deflate that the input stream is
 * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)
 * or if an error happened. By default - join collected chunks,
 * free memory and fill `results` / `err` properties.
 **/
Deflate.prototype.onEnd = function (status) {
  // On success - join
  if (status === Z_OK$1) {
    if (this.options.to === 'string') {
      this.result = this.chunks.join('');
    } else {
      this.result = common.flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};


/**
 * deflate(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * Compress `data` with deflate algorithm and `options`.
 *
 * Supported options are:
 *
 * - level
 * - windowBits
 * - memLevel
 * - strategy
 * - dictionary
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Sugar (options):
 *
 * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
 *   negative windowBits implicitly.
 * - `to` (String) - if equal to 'string', then result will be "binary string"
 *    (each char code [0..255])
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , data = Uint8Array([1,2,3,4,5,6,7,8,9]);
 *
 * console.log(pako.deflate(data));
 * ```
 **/
function deflate$1(input, options) {
  var deflator = new Deflate(options);

  deflator.push(input, true);

  // That will never happens, if you don't cheat with options :)
  if (deflator.err) { throw deflator.msg || messages[deflator.err]; }

  return deflator.result;
}


/**
 * deflateRaw(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * The same as [[deflate]], but creates raw data, without wrapper
 * (header and adler32 crc).
 **/
function deflateRaw(input, options) {
  options = options || {};
  options.raw = true;
  return deflate$1(input, options);
}


/**
 * gzip(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * The same as [[deflate]], but create gzip wrapper instead of
 * deflate one.
 **/
function gzip(input, options) {
  options = options || {};
  options.gzip = true;
  return deflate$1(input, options);
}


var Deflate_1 = Deflate;
var deflate_2 = deflate$1;
var deflateRaw_1 = deflateRaw;
var gzip_1 = gzip;

var deflate_1 = {
	Deflate: Deflate_1,
	deflate: deflate_2,
	deflateRaw: deflateRaw_1,
	gzip: gzip_1
};

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

// See state defs from inflate.js
var BAD$1 = 30;       /* got a data error -- remain here until reset */
var TYPE$1 = 12;      /* i: waiting for type bits, including last-flag bit */

/*
   Decode literal, length, and distance codes and write out the resulting
   literal and match bytes until either not enough input or output is
   available, an end-of-block is encountered, or a data error is encountered.
   When large enough input and output buffers are supplied to inflate(), for
   example, a 16K input buffer and a 64K output buffer, more than 95% of the
   inflate execution time is spent in this routine.

   Entry assumptions:

        state.mode === LEN
        strm.avail_in >= 6
        strm.avail_out >= 258
        start >= strm.avail_out
        state.bits < 8

   On return, state.mode is one of:

        LEN -- ran out of enough output space or enough available input
        TYPE -- reached end of block code, inflate() to interpret next block
        BAD -- error in block data

   Notes:

    - The maximum input bits used by a length/distance pair is 15 bits for the
      length code, 5 bits for the length extra, 15 bits for the distance code,
      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.
      Therefore if strm.avail_in >= 6, then there is enough input to avoid
      checking for available input while decoding.

    - The maximum bytes that a single length/distance pair can output is 258
      bytes, which is the maximum length that can be coded.  inflate_fast()
      requires strm.avail_out >= 258 for each loop to avoid checking for
      output space.
 */
var inffast = function inflate_fast(strm, start) {
  var state;
  var _in;                    /* local strm.input */
  var last;                   /* have enough input while in < last */
  var _out;                   /* local strm.output */
  var beg;                    /* inflate()'s initial strm.output */
  var end;                    /* while out < end, enough space available */
//#ifdef INFLATE_STRICT
  var dmax;                   /* maximum distance from zlib header */
//#endif
  var wsize;                  /* window size or zero if not using window */
  var whave;                  /* valid bytes in the window */
  var wnext;                  /* window write index */
  // Use `s_window` instead `window`, avoid conflict with instrumentation tools
  var s_window;               /* allocated sliding window, if wsize != 0 */
  var hold;                   /* local strm.hold */
  var bits;                   /* local strm.bits */
  var lcode;                  /* local strm.lencode */
  var dcode;                  /* local strm.distcode */
  var lmask;                  /* mask for first level of length codes */
  var dmask;                  /* mask for first level of distance codes */
  var here;                   /* retrieved table entry */
  var op;                     /* code bits, operation, extra bits, or */
                              /*  window position, window bytes to copy */
  var len;                    /* match length, unused bytes */
  var dist;                   /* match distance */
  var from;                   /* where to copy match from */
  var from_source;


  var input, output; // JS specific, because we have no pointers

  /* copy state to local variables */
  state = strm.state;
  //here = state.here;
  _in = strm.next_in;
  input = strm.input;
  last = _in + (strm.avail_in - 5);
  _out = strm.next_out;
  output = strm.output;
  beg = _out - (start - strm.avail_out);
  end = _out + (strm.avail_out - 257);
//#ifdef INFLATE_STRICT
  dmax = state.dmax;
//#endif
  wsize = state.wsize;
  whave = state.whave;
  wnext = state.wnext;
  s_window = state.window;
  hold = state.hold;
  bits = state.bits;
  lcode = state.lencode;
  dcode = state.distcode;
  lmask = (1 << state.lenbits) - 1;
  dmask = (1 << state.distbits) - 1;


  /* decode literals and length/distances until end-of-block or not enough
     input data or output space */

  top:
  do {
    if (bits < 15) {
      hold += input[_in++] << bits;
      bits += 8;
      hold += input[_in++] << bits;
      bits += 8;
    }

    here = lcode[hold & lmask];

    dolen:
    for (;;) { // Goto emulation
      op = here >>> 24/*here.bits*/;
      hold >>>= op;
      bits -= op;
      op = (here >>> 16) & 0xff/*here.op*/;
      if (op === 0) {                          /* literal */
        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
        //        "inflate:         literal '%c'\n" :
        //        "inflate:         literal 0x%02x\n", here.val));
        output[_out++] = here & 0xffff/*here.val*/;
      }
      else if (op & 16) {                     /* length base */
        len = here & 0xffff/*here.val*/;
        op &= 15;                           /* number of extra bits */
        if (op) {
          if (bits < op) {
            hold += input[_in++] << bits;
            bits += 8;
          }
          len += hold & ((1 << op) - 1);
          hold >>>= op;
          bits -= op;
        }
        //Tracevv((stderr, "inflate:         length %u\n", len));
        if (bits < 15) {
          hold += input[_in++] << bits;
          bits += 8;
          hold += input[_in++] << bits;
          bits += 8;
        }
        here = dcode[hold & dmask];

        dodist:
        for (;;) { // goto emulation
          op = here >>> 24/*here.bits*/;
          hold >>>= op;
          bits -= op;
          op = (here >>> 16) & 0xff/*here.op*/;

          if (op & 16) {                      /* distance base */
            dist = here & 0xffff/*here.val*/;
            op &= 15;                       /* number of extra bits */
            if (bits < op) {
              hold += input[_in++] << bits;
              bits += 8;
              if (bits < op) {
                hold += input[_in++] << bits;
                bits += 8;
              }
            }
            dist += hold & ((1 << op) - 1);
//#ifdef INFLATE_STRICT
            if (dist > dmax) {
              strm.msg = 'invalid distance too far back';
              state.mode = BAD$1;
              break top;
            }
//#endif
            hold >>>= op;
            bits -= op;
            //Tracevv((stderr, "inflate:         distance %u\n", dist));
            op = _out - beg;                /* max distance in output */
            if (dist > op) {                /* see if copy from window */
              op = dist - op;               /* distance back in window */
              if (op > whave) {
                if (state.sane) {
                  strm.msg = 'invalid distance too far back';
                  state.mode = BAD$1;
                  break top;
                }

// (!) This block is disabled in zlib defaults,
// don't enable it for binary compatibility
//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
//                if (len <= op - whave) {
//                  do {
//                    output[_out++] = 0;
//                  } while (--len);
//                  continue top;
//                }
//                len -= op - whave;
//                do {
//                  output[_out++] = 0;
//                } while (--op > whave);
//                if (op === 0) {
//                  from = _out - dist;
//                  do {
//                    output[_out++] = output[from++];
//                  } while (--len);
//                  continue top;
//                }
//#endif
              }
              from = 0; // window index
              from_source = s_window;
              if (wnext === 0) {           /* very common case */
                from += wsize - op;
                if (op < len) {         /* some from window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = _out - dist;  /* rest from output */
                  from_source = output;
                }
              }
              else if (wnext < op) {      /* wrap around window */
                from += wsize + wnext - op;
                op -= wnext;
                if (op < len) {         /* some from end of window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = 0;
                  if (wnext < len) {  /* some from start of window */
                    op = wnext;
                    len -= op;
                    do {
                      output[_out++] = s_window[from++];
                    } while (--op);
                    from = _out - dist;      /* rest from output */
                    from_source = output;
                  }
                }
              }
              else {                      /* contiguous in window */
                from += wnext - op;
                if (op < len) {         /* some from window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = _out - dist;  /* rest from output */
                  from_source = output;
                }
              }
              while (len > 2) {
                output[_out++] = from_source[from++];
                output[_out++] = from_source[from++];
                output[_out++] = from_source[from++];
                len -= 3;
              }
              if (len) {
                output[_out++] = from_source[from++];
                if (len > 1) {
                  output[_out++] = from_source[from++];
                }
              }
            }
            else {
              from = _out - dist;          /* copy direct from output */
              do {                        /* minimum length is three */
                output[_out++] = output[from++];
                output[_out++] = output[from++];
                output[_out++] = output[from++];
                len -= 3;
              } while (len > 2);
              if (len) {
                output[_out++] = output[from++];
                if (len > 1) {
                  output[_out++] = output[from++];
                }
              }
            }
          }
          else if ((op & 64) === 0) {          /* 2nd level distance code */
            here = dcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
            continue dodist;
          }
          else {
            strm.msg = 'invalid distance code';
            state.mode = BAD$1;
            break top;
          }

          break; // need to emulate goto via "continue"
        }
      }
      else if ((op & 64) === 0) {              /* 2nd level length code */
        here = lcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
        continue dolen;
      }
      else if (op & 32) {                     /* end-of-block */
        //Tracevv((stderr, "inflate:         end of block\n"));
        state.mode = TYPE$1;
        break top;
      }
      else {
        strm.msg = 'invalid literal/length code';
        state.mode = BAD$1;
        break top;
      }

      break; // need to emulate goto via "continue"
    }
  } while (_in < last && _out < end);

  /* return unused bytes (on entry, bits < 8, so in won't go too far back) */
  len = bits >> 3;
  _in -= len;
  bits -= len << 3;
  hold &= (1 << bits) - 1;

  /* update state and return */
  strm.next_in = _in;
  strm.next_out = _out;
  strm.avail_in = (_in < last ? 5 + (last - _in) : 5 - (_in - last));
  strm.avail_out = (_out < end ? 257 + (end - _out) : 257 - (_out - end));
  state.hold = hold;
  state.bits = bits;
  return;
};

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.



var MAXBITS = 15;
var ENOUGH_LENS$1 = 852;
var ENOUGH_DISTS$1 = 592;
//var ENOUGH = (ENOUGH_LENS+ENOUGH_DISTS);

var CODES$1 = 0;
var LENS$1 = 1;
var DISTS$1 = 2;

var lbase = [ /* Length codes 257..285 base */
  3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
  35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0
];

var lext = [ /* Length codes 257..285 extra */
  16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,
  19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78
];

var dbase = [ /* Distance codes 0..29 base */
  1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
  257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
  8193, 12289, 16385, 24577, 0, 0
];

var dext = [ /* Distance codes 0..29 extra */
  16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,
  23, 23, 24, 24, 25, 25, 26, 26, 27, 27,
  28, 28, 29, 29, 64, 64
];

var inftrees = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts)
{
  var bits = opts.bits;
      //here = opts.here; /* table entry for duplication */

  var len = 0;               /* a code's length in bits */
  var sym = 0;               /* index of code symbols */
  var min = 0, max = 0;          /* minimum and maximum code lengths */
  var root = 0;              /* number of index bits for root table */
  var curr = 0;              /* number of index bits for current table */
  var drop = 0;              /* code bits to drop for sub-table */
  var left = 0;                   /* number of prefix codes available */
  var used = 0;              /* code entries in table used */
  var huff = 0;              /* Huffman code */
  var incr;              /* for incrementing code, index */
  var fill;              /* index for replicating entries */
  var low;               /* low bits for current root entry */
  var mask;              /* mask for low root bits */
  var next;             /* next available space in table */
  var base = null;     /* base value table to use */
  var base_index = 0;
//  var shoextra;    /* extra bits table to use */
  var end;                    /* use base and extra for symbol > end */
  var count = new common.Buf16(MAXBITS + 1); //[MAXBITS+1];    /* number of codes of each length */
  var offs = new common.Buf16(MAXBITS + 1); //[MAXBITS+1];     /* offsets in table for each length */
  var extra = null;
  var extra_index = 0;

  var here_bits, here_op, here_val;

  /*
   Process a set of code lengths to create a canonical Huffman code.  The
   code lengths are lens[0..codes-1].  Each length corresponds to the
   symbols 0..codes-1.  The Huffman code is generated by first sorting the
   symbols by length from short to long, and retaining the symbol order
   for codes with equal lengths.  Then the code starts with all zero bits
   for the first code of the shortest length, and the codes are integer
   increments for the same length, and zeros are appended as the length
   increases.  For the deflate format, these bits are stored backwards
   from their more natural integer increment ordering, and so when the
   decoding tables are built in the large loop below, the integer codes
   are incremented backwards.

   This routine assumes, but does not check, that all of the entries in
   lens[] are in the range 0..MAXBITS.  The caller must assure this.
   1..MAXBITS is interpreted as that code length.  zero means that that
   symbol does not occur in this code.

   The codes are sorted by computing a count of codes for each length,
   creating from that a table of starting indices for each length in the
   sorted table, and then entering the symbols in order in the sorted
   table.  The sorted table is work[], with that space being provided by
   the caller.

   The length counts are used for other purposes as well, i.e. finding
   the minimum and maximum length codes, determining if there are any
   codes at all, checking for a valid set of lengths, and looking ahead
   at length counts to determine sub-table sizes when building the
   decoding tables.
   */

  /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
  for (len = 0; len <= MAXBITS; len++) {
    count[len] = 0;
  }
  for (sym = 0; sym < codes; sym++) {
    count[lens[lens_index + sym]]++;
  }

  /* bound code lengths, force root to be within code lengths */
  root = bits;
  for (max = MAXBITS; max >= 1; max--) {
    if (count[max] !== 0) { break; }
  }
  if (root > max) {
    root = max;
  }
  if (max === 0) {                     /* no symbols to code at all */
    //table.op[opts.table_index] = 64;  //here.op = (var char)64;    /* invalid code marker */
    //table.bits[opts.table_index] = 1;   //here.bits = (var char)1;
    //table.val[opts.table_index++] = 0;   //here.val = (var short)0;
    table[table_index++] = (1 << 24) | (64 << 16) | 0;


    //table.op[opts.table_index] = 64;
    //table.bits[opts.table_index] = 1;
    //table.val[opts.table_index++] = 0;
    table[table_index++] = (1 << 24) | (64 << 16) | 0;

    opts.bits = 1;
    return 0;     /* no symbols, but wait for decoding to report error */
  }
  for (min = 1; min < max; min++) {
    if (count[min] !== 0) { break; }
  }
  if (root < min) {
    root = min;
  }

  /* check for an over-subscribed or incomplete set of lengths */
  left = 1;
  for (len = 1; len <= MAXBITS; len++) {
    left <<= 1;
    left -= count[len];
    if (left < 0) {
      return -1;
    }        /* over-subscribed */
  }
  if (left > 0 && (type === CODES$1 || max !== 1)) {
    return -1;                      /* incomplete set */
  }

  /* generate offsets into symbol table for each length for sorting */
  offs[1] = 0;
  for (len = 1; len < MAXBITS; len++) {
    offs[len + 1] = offs[len] + count[len];
  }

  /* sort symbols by length, by symbol order within each length */
  for (sym = 0; sym < codes; sym++) {
    if (lens[lens_index + sym] !== 0) {
      work[offs[lens[lens_index + sym]]++] = sym;
    }
  }

  /*
   Create and fill in decoding tables.  In this loop, the table being
   filled is at next and has curr index bits.  The code being used is huff
   with length len.  That code is converted to an index by dropping drop
   bits off of the bottom.  For codes where len is less than drop + curr,
   those top drop + curr - len bits are incremented through all values to
   fill the table with replicated entries.

   root is the number of index bits for the root table.  When len exceeds
   root, sub-tables are created pointed to by the root entry with an index
   of the low root bits of huff.  This is saved in low to check for when a
   new sub-table should be started.  drop is zero when the root table is
   being filled, and drop is root when sub-tables are being filled.

   When a new sub-table is needed, it is necessary to look ahead in the
   code lengths to determine what size sub-table is needed.  The length
   counts are used for this, and so count[] is decremented as codes are
   entered in the tables.

   used keeps track of how many table entries have been allocated from the
   provided *table space.  It is checked for LENS and DIST tables against
   the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in
   the initial root table size constants.  See the comments in inftrees.h
   for more information.

   sym increments through all symbols, and the loop terminates when
   all codes of length max, i.e. all codes, have been processed.  This
   routine permits incomplete codes, so another loop after this one fills
   in the rest of the decoding tables with invalid code markers.
   */

  /* set up for code type */
  // poor man optimization - use if-else instead of switch,
  // to avoid deopts in old v8
  if (type === CODES$1) {
    base = extra = work;    /* dummy value--not used */
    end = 19;

  } else if (type === LENS$1) {
    base = lbase;
    base_index -= 257;
    extra = lext;
    extra_index -= 257;
    end = 256;

  } else {                    /* DISTS */
    base = dbase;
    extra = dext;
    end = -1;
  }

  /* initialize opts for loop */
  huff = 0;                   /* starting code */
  sym = 0;                    /* starting code symbol */
  len = min;                  /* starting code length */
  next = table_index;              /* current table to fill in */
  curr = root;                /* current table index bits */
  drop = 0;                   /* current bits to drop from code for index */
  low = -1;                   /* trigger new sub-table when len > root */
  used = 1 << root;          /* use root table entries */
  mask = used - 1;            /* mask for comparing low */

  /* check available table space */
  if ((type === LENS$1 && used > ENOUGH_LENS$1) ||
    (type === DISTS$1 && used > ENOUGH_DISTS$1)) {
    return 1;
  }

  /* process all codes and make table entries */
  for (;;) {
    /* create table entry */
    here_bits = len - drop;
    if (work[sym] < end) {
      here_op = 0;
      here_val = work[sym];
    }
    else if (work[sym] > end) {
      here_op = extra[extra_index + work[sym]];
      here_val = base[base_index + work[sym]];
    }
    else {
      here_op = 32 + 64;         /* end of block */
      here_val = 0;
    }

    /* replicate for those indices with low len bits equal to huff */
    incr = 1 << (len - drop);
    fill = 1 << curr;
    min = fill;                 /* save offset to next table */
    do {
      fill -= incr;
      table[next + (huff >> drop) + fill] = (here_bits << 24) | (here_op << 16) | here_val |0;
    } while (fill !== 0);

    /* backwards increment the len-bit code huff */
    incr = 1 << (len - 1);
    while (huff & incr) {
      incr >>= 1;
    }
    if (incr !== 0) {
      huff &= incr - 1;
      huff += incr;
    } else {
      huff = 0;
    }

    /* go to next symbol, update count, len */
    sym++;
    if (--count[len] === 0) {
      if (len === max) { break; }
      len = lens[lens_index + work[sym]];
    }

    /* create new sub-table if needed */
    if (len > root && (huff & mask) !== low) {
      /* if first time, transition to sub-tables */
      if (drop === 0) {
        drop = root;
      }

      /* increment past last table */
      next += min;            /* here min is 1 << curr */

      /* determine length of next table */
      curr = len - drop;
      left = 1 << curr;
      while (curr + drop < max) {
        left -= count[curr + drop];
        if (left <= 0) { break; }
        curr++;
        left <<= 1;
      }

      /* check for enough space */
      used += 1 << curr;
      if ((type === LENS$1 && used > ENOUGH_LENS$1) ||
        (type === DISTS$1 && used > ENOUGH_DISTS$1)) {
        return 1;
      }

      /* point entry in root table to sub-table */
      low = huff & mask;
      /*table.op[low] = curr;
      table.bits[low] = root;
      table.val[low] = next - opts.table_index;*/
      table[low] = (root << 24) | (curr << 16) | (next - table_index) |0;
    }
  }

  /* fill in remaining table entry if code is incomplete (guaranteed to have
   at most one remaining entry, since if the code is incomplete, the
   maximum code length that was allowed to get this far is one bit) */
  if (huff !== 0) {
    //table.op[next + huff] = 64;            /* invalid code marker */
    //table.bits[next + huff] = len - drop;
    //table.val[next + huff] = 0;
    table[next + huff] = ((len - drop) << 24) | (64 << 16) |0;
  }

  /* set return parameters */
  //opts.table_index += used;
  opts.bits = root;
  return 0;
};

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.







var CODES = 0;
var LENS = 1;
var DISTS = 2;

/* Public constants ==========================================================*/
/* ===========================================================================*/


/* Allowed flush values; see deflate() and inflate() below for details */
//var Z_NO_FLUSH      = 0;
//var Z_PARTIAL_FLUSH = 1;
//var Z_SYNC_FLUSH    = 2;
//var Z_FULL_FLUSH    = 3;
var Z_FINISH        = 4;
var Z_BLOCK         = 5;
var Z_TREES         = 6;


/* Return codes for the compression/decompression functions. Negative values
 * are errors, positive values are used for special but normal events.
 */
var Z_OK            = 0;
var Z_STREAM_END    = 1;
var Z_NEED_DICT     = 2;
//var Z_ERRNO         = -1;
var Z_STREAM_ERROR  = -2;
var Z_DATA_ERROR    = -3;
var Z_MEM_ERROR     = -4;
var Z_BUF_ERROR     = -5;
//var Z_VERSION_ERROR = -6;

/* The deflate compression method */
var Z_DEFLATED  = 8;


/* STATES ====================================================================*/
/* ===========================================================================*/


var    HEAD = 1;       /* i: waiting for magic header */
var    FLAGS = 2;      /* i: waiting for method and flags (gzip) */
var    TIME = 3;       /* i: waiting for modification time (gzip) */
var    OS = 4;         /* i: waiting for extra flags and operating system (gzip) */
var    EXLEN = 5;      /* i: waiting for extra length (gzip) */
var    EXTRA = 6;      /* i: waiting for extra bytes (gzip) */
var    NAME = 7;       /* i: waiting for end of file name (gzip) */
var    COMMENT = 8;    /* i: waiting for end of comment (gzip) */
var    HCRC = 9;       /* i: waiting for header crc (gzip) */
var    DICTID = 10;    /* i: waiting for dictionary check value */
var    DICT = 11;      /* waiting for inflateSetDictionary() call */
var        TYPE = 12;      /* i: waiting for type bits, including last-flag bit */
var        TYPEDO = 13;    /* i: same, but skip check to exit inflate on new block */
var        STORED = 14;    /* i: waiting for stored size (length and complement) */
var        COPY_ = 15;     /* i/o: same as COPY below, but only first time in */
var        COPY = 16;      /* i/o: waiting for input or output to copy stored block */
var        TABLE = 17;     /* i: waiting for dynamic block table lengths */
var        LENLENS = 18;   /* i: waiting for code length code lengths */
var        CODELENS = 19;  /* i: waiting for length/lit and distance code lengths */
var            LEN_ = 20;      /* i: same as LEN below, but only first time in */
var            LEN = 21;       /* i: waiting for length/lit/eob code */
var            LENEXT = 22;    /* i: waiting for length extra bits */
var            DIST = 23;      /* i: waiting for distance code */
var            DISTEXT = 24;   /* i: waiting for distance extra bits */
var            MATCH = 25;     /* o: waiting for output space to copy string */
var            LIT = 26;       /* o: waiting for output space to write literal */
var    CHECK = 27;     /* i: waiting for 32-bit check value */
var    LENGTH = 28;    /* i: waiting for 32-bit length (gzip) */
var    DONE = 29;      /* finished check, done -- remain here until reset */
var    BAD = 30;       /* got a data error -- remain here until reset */
var    MEM = 31;       /* got an inflate() memory error -- remain here until reset */
var    SYNC = 32;      /* looking for synchronization bytes to restart inflate() */

/* ===========================================================================*/



var ENOUGH_LENS = 852;
var ENOUGH_DISTS = 592;
//var ENOUGH =  (ENOUGH_LENS+ENOUGH_DISTS);

var MAX_WBITS = 15;
/* 32K LZ77 window */
var DEF_WBITS = MAX_WBITS;


function zswap32(q) {
  return  (((q >>> 24) & 0xff) +
          ((q >>> 8) & 0xff00) +
          ((q & 0xff00) << 8) +
          ((q & 0xff) << 24));
}


function InflateState() {
  this.mode = 0;             /* current inflate mode */
  this.last = false;          /* true if processing last block */
  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */
  this.havedict = false;      /* true if dictionary provided */
  this.flags = 0;             /* gzip header method and flags (0 if zlib) */
  this.dmax = 0;              /* zlib header max distance (INFLATE_STRICT) */
  this.check = 0;             /* protected copy of check value */
  this.total = 0;             /* protected copy of output count */
  // TODO: may be {}
  this.head = null;           /* where to save gzip header information */

  /* sliding window */
  this.wbits = 0;             /* log base 2 of requested window size */
  this.wsize = 0;             /* window size or zero if not using window */
  this.whave = 0;             /* valid bytes in the window */
  this.wnext = 0;             /* window write index */
  this.window = null;         /* allocated sliding window, if needed */

  /* bit accumulator */
  this.hold = 0;              /* input bit accumulator */
  this.bits = 0;              /* number of bits in "in" */

  /* for string and stored block copying */
  this.length = 0;            /* literal or length of data to copy */
  this.offset = 0;            /* distance back to copy string from */

  /* for table and code decoding */
  this.extra = 0;             /* extra bits needed */

  /* fixed and dynamic code tables */
  this.lencode = null;          /* starting table for length/literal codes */
  this.distcode = null;         /* starting table for distance codes */
  this.lenbits = 0;           /* index bits for lencode */
  this.distbits = 0;          /* index bits for distcode */

  /* dynamic table building */
  this.ncode = 0;             /* number of code length code lengths */
  this.nlen = 0;              /* number of length code lengths */
  this.ndist = 0;             /* number of distance code lengths */
  this.have = 0;              /* number of code lengths in lens[] */
  this.next = null;              /* next available space in codes[] */

  this.lens = new common.Buf16(320); /* temporary storage for code lengths */
  this.work = new common.Buf16(288); /* work area for code table building */

  /*
   because we don't have pointers in js, we use lencode and distcode directly
   as buffers so we don't need codes
  */
  //this.codes = new utils.Buf32(ENOUGH);       /* space for code tables */
  this.lendyn = null;              /* dynamic table for length/literal codes (JS specific) */
  this.distdyn = null;             /* dynamic table for distance codes (JS specific) */
  this.sane = 0;                   /* if false, allow invalid distance too far */
  this.back = 0;                   /* bits back of last unprocessed length/lit */
  this.was = 0;                    /* initial length of match */
}

function inflateResetKeep(strm) {
  var state;

  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  state = strm.state;
  strm.total_in = strm.total_out = state.total = 0;
  strm.msg = ''; /*Z_NULL*/
  if (state.wrap) {       /* to support ill-conceived Java test suite */
    strm.adler = state.wrap & 1;
  }
  state.mode = HEAD;
  state.last = 0;
  state.havedict = 0;
  state.dmax = 32768;
  state.head = null/*Z_NULL*/;
  state.hold = 0;
  state.bits = 0;
  //state.lencode = state.distcode = state.next = state.codes;
  state.lencode = state.lendyn = new common.Buf32(ENOUGH_LENS);
  state.distcode = state.distdyn = new common.Buf32(ENOUGH_DISTS);

  state.sane = 1;
  state.back = -1;
  //Tracev((stderr, "inflate: reset\n"));
  return Z_OK;
}

function inflateReset(strm) {
  var state;

  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  state = strm.state;
  state.wsize = 0;
  state.whave = 0;
  state.wnext = 0;
  return inflateResetKeep(strm);

}

function inflateReset2(strm, windowBits) {
  var wrap;
  var state;

  /* get the state */
  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  state = strm.state;

  /* extract wrap request from windowBits parameter */
  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  }
  else {
    wrap = (windowBits >> 4) + 1;
    if (windowBits < 48) {
      windowBits &= 15;
    }
  }

  /* set number of window bits, free window if different */
  if (windowBits && (windowBits < 8 || windowBits > 15)) {
    return Z_STREAM_ERROR;
  }
  if (state.window !== null && state.wbits !== windowBits) {
    state.window = null;
  }

  /* update state and reset the rest of it */
  state.wrap = wrap;
  state.wbits = windowBits;
  return inflateReset(strm);
}

function inflateInit2(strm, windowBits) {
  var ret;
  var state;

  if (!strm) { return Z_STREAM_ERROR; }
  //strm.msg = Z_NULL;                 /* in case we return an error */

  state = new InflateState();

  //if (state === Z_NULL) return Z_MEM_ERROR;
  //Tracev((stderr, "inflate: allocated\n"));
  strm.state = state;
  state.window = null/*Z_NULL*/;
  ret = inflateReset2(strm, windowBits);
  if (ret !== Z_OK) {
    strm.state = null/*Z_NULL*/;
  }
  return ret;
}

function inflateInit(strm) {
  return inflateInit2(strm, DEF_WBITS);
}


/*
 Return state with length and distance decoding tables and index sizes set to
 fixed code decoding.  Normally this returns fixed tables from inffixed.h.
 If BUILDFIXED is defined, then instead this routine builds the tables the
 first time it's called, and returns those tables the first time and
 thereafter.  This reduces the size of the code by about 2K bytes, in
 exchange for a little execution time.  However, BUILDFIXED should not be
 used for threaded applications, since the rewriting of the tables and virgin
 may not be thread-safe.
 */
var virgin = true;

var lenfix, distfix; // We have no pointers in JS, so keep tables separate

function fixedtables(state) {
  /* build fixed huffman tables if first call (may not be thread safe) */
  if (virgin) {
    var sym;

    lenfix = new common.Buf32(512);
    distfix = new common.Buf32(32);

    /* literal/length table */
    sym = 0;
    while (sym < 144) { state.lens[sym++] = 8; }
    while (sym < 256) { state.lens[sym++] = 9; }
    while (sym < 280) { state.lens[sym++] = 7; }
    while (sym < 288) { state.lens[sym++] = 8; }

    inftrees(LENS,  state.lens, 0, 288, lenfix,   0, state.work, { bits: 9 });

    /* distance table */
    sym = 0;
    while (sym < 32) { state.lens[sym++] = 5; }

    inftrees(DISTS, state.lens, 0, 32,   distfix, 0, state.work, { bits: 5 });

    /* do this just once */
    virgin = false;
  }

  state.lencode = lenfix;
  state.lenbits = 9;
  state.distcode = distfix;
  state.distbits = 5;
}


/*
 Update the window with the last wsize (normally 32K) bytes written before
 returning.  If window does not exist yet, create it.  This is only called
 when a window is already in use, or when output has been written during this
 inflate call, but the end of the deflate stream has not been reached yet.
 It is also called to create a window for dictionary data when a dictionary
 is loaded.

 Providing output buffers larger than 32K to inflate() should provide a speed
 advantage, since only the last 32K of output is copied to the sliding window
 upon return from inflate(), and since all distances after the first 32K of
 output will fall in the output data, making match copies simpler and faster.
 The advantage may be dependent on the size of the processor's data caches.
 */
function updatewindow(strm, src, end, copy) {
  var dist;
  var state = strm.state;

  /* if it hasn't been done already, allocate space for the window */
  if (state.window === null) {
    state.wsize = 1 << state.wbits;
    state.wnext = 0;
    state.whave = 0;

    state.window = new common.Buf8(state.wsize);
  }

  /* copy state->wsize or less output bytes into the circular window */
  if (copy >= state.wsize) {
    common.arraySet(state.window, src, end - state.wsize, state.wsize, 0);
    state.wnext = 0;
    state.whave = state.wsize;
  }
  else {
    dist = state.wsize - state.wnext;
    if (dist > copy) {
      dist = copy;
    }
    //zmemcpy(state->window + state->wnext, end - copy, dist);
    common.arraySet(state.window, src, end - copy, dist, state.wnext);
    copy -= dist;
    if (copy) {
      //zmemcpy(state->window, end - copy, copy);
      common.arraySet(state.window, src, end - copy, copy, 0);
      state.wnext = copy;
      state.whave = state.wsize;
    }
    else {
      state.wnext += dist;
      if (state.wnext === state.wsize) { state.wnext = 0; }
      if (state.whave < state.wsize) { state.whave += dist; }
    }
  }
  return 0;
}

function inflate$2(strm, flush) {
  var state;
  var input, output;          // input/output buffers
  var next;                   /* next input INDEX */
  var put;                    /* next output INDEX */
  var have, left;             /* available input and output */
  var hold;                   /* bit buffer */
  var bits;                   /* bits in bit buffer */
  var _in, _out;              /* save starting available input and output */
  var copy;                   /* number of stored or match bytes to copy */
  var from;                   /* where to copy match bytes from */
  var from_source;
  var here = 0;               /* current decoding table entry */
  var here_bits, here_op, here_val; // paked "here" denormalized (JS specific)
  //var last;                   /* parent table entry */
  var last_bits, last_op, last_val; // paked "last" denormalized (JS specific)
  var len;                    /* length to copy for repeats, bits to drop */
  var ret;                    /* return code */
  var hbuf = new common.Buf8(4);    /* buffer for gzip header crc calculation */
  var opts;

  var n; // temporary var for NEED_BITS

  var order = /* permutation of code lengths */
    [ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ];


  if (!strm || !strm.state || !strm.output ||
      (!strm.input && strm.avail_in !== 0)) {
    return Z_STREAM_ERROR;
  }

  state = strm.state;
  if (state.mode === TYPE) { state.mode = TYPEDO; }    /* skip check */


  //--- LOAD() ---
  put = strm.next_out;
  output = strm.output;
  left = strm.avail_out;
  next = strm.next_in;
  input = strm.input;
  have = strm.avail_in;
  hold = state.hold;
  bits = state.bits;
  //---

  _in = have;
  _out = left;
  ret = Z_OK;

  inf_leave: // goto emulation
  for (;;) {
    switch (state.mode) {
      case HEAD:
        if (state.wrap === 0) {
          state.mode = TYPEDO;
          break;
        }
        //=== NEEDBITS(16);
        while (bits < 16) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if ((state.wrap & 2) && hold === 0x8b1f) {  /* gzip header */
          state.check = 0/*crc32(0L, Z_NULL, 0)*/;
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          state.check = crc32_1(state.check, hbuf, 2, 0);
          //===//

          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
          state.mode = FLAGS;
          break;
        }
        state.flags = 0;           /* expect zlib header */
        if (state.head) {
          state.head.done = false;
        }
        if (!(state.wrap & 1) ||   /* check if zlib header allowed */
          (((hold & 0xff)/*BITS(8)*/ << 8) + (hold >> 8)) % 31) {
          strm.msg = 'incorrect header check';
          state.mode = BAD;
          break;
        }
        if ((hold & 0x0f)/*BITS(4)*/ !== Z_DEFLATED) {
          strm.msg = 'unknown compression method';
          state.mode = BAD;
          break;
        }
        //--- DROPBITS(4) ---//
        hold >>>= 4;
        bits -= 4;
        //---//
        len = (hold & 0x0f)/*BITS(4)*/ + 8;
        if (state.wbits === 0) {
          state.wbits = len;
        }
        else if (len > state.wbits) {
          strm.msg = 'invalid window size';
          state.mode = BAD;
          break;
        }
        state.dmax = 1 << len;
        //Tracev((stderr, "inflate:   zlib header ok\n"));
        strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
        state.mode = hold & 0x200 ? DICTID : TYPE;
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        break;
      case FLAGS:
        //=== NEEDBITS(16); */
        while (bits < 16) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.flags = hold;
        if ((state.flags & 0xff) !== Z_DEFLATED) {
          strm.msg = 'unknown compression method';
          state.mode = BAD;
          break;
        }
        if (state.flags & 0xe000) {
          strm.msg = 'unknown header flags set';
          state.mode = BAD;
          break;
        }
        if (state.head) {
          state.head.text = ((hold >> 8) & 1);
        }
        if (state.flags & 0x0200) {
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          state.check = crc32_1(state.check, hbuf, 2, 0);
          //===//
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = TIME;
        /* falls through */
      case TIME:
        //=== NEEDBITS(32); */
        while (bits < 32) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if (state.head) {
          state.head.time = hold;
        }
        if (state.flags & 0x0200) {
          //=== CRC4(state.check, hold)
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          hbuf[2] = (hold >>> 16) & 0xff;
          hbuf[3] = (hold >>> 24) & 0xff;
          state.check = crc32_1(state.check, hbuf, 4, 0);
          //===
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = OS;
        /* falls through */
      case OS:
        //=== NEEDBITS(16); */
        while (bits < 16) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if (state.head) {
          state.head.xflags = (hold & 0xff);
          state.head.os = (hold >> 8);
        }
        if (state.flags & 0x0200) {
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          state.check = crc32_1(state.check, hbuf, 2, 0);
          //===//
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = EXLEN;
        /* falls through */
      case EXLEN:
        if (state.flags & 0x0400) {
          //=== NEEDBITS(16); */
          while (bits < 16) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.length = hold;
          if (state.head) {
            state.head.extra_len = hold;
          }
          if (state.flags & 0x0200) {
            //=== CRC2(state.check, hold);
            hbuf[0] = hold & 0xff;
            hbuf[1] = (hold >>> 8) & 0xff;
            state.check = crc32_1(state.check, hbuf, 2, 0);
            //===//
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
        }
        else if (state.head) {
          state.head.extra = null/*Z_NULL*/;
        }
        state.mode = EXTRA;
        /* falls through */
      case EXTRA:
        if (state.flags & 0x0400) {
          copy = state.length;
          if (copy > have) { copy = have; }
          if (copy) {
            if (state.head) {
              len = state.head.extra_len - state.length;
              if (!state.head.extra) {
                // Use untyped array for more convenient processing later
                state.head.extra = new Array(state.head.extra_len);
              }
              common.arraySet(
                state.head.extra,
                input,
                next,
                // extra field is limited to 65536 bytes
                // - no need for additional size check
                copy,
                /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                len
              );
              //zmemcpy(state.head.extra + len, next,
              //        len + copy > state.head.extra_max ?
              //        state.head.extra_max - len : copy);
            }
            if (state.flags & 0x0200) {
              state.check = crc32_1(state.check, input, copy, next);
            }
            have -= copy;
            next += copy;
            state.length -= copy;
          }
          if (state.length) { break inf_leave; }
        }
        state.length = 0;
        state.mode = NAME;
        /* falls through */
      case NAME:
        if (state.flags & 0x0800) {
          if (have === 0) { break inf_leave; }
          copy = 0;
          do {
            // TODO: 2 or 1 bytes?
            len = input[next + copy++];
            /* use constant limit because in js we should not preallocate memory */
            if (state.head && len &&
                (state.length < 65536 /*state.head.name_max*/)) {
              state.head.name += String.fromCharCode(len);
            }
          } while (len && copy < have);

          if (state.flags & 0x0200) {
            state.check = crc32_1(state.check, input, copy, next);
          }
          have -= copy;
          next += copy;
          if (len) { break inf_leave; }
        }
        else if (state.head) {
          state.head.name = null;
        }
        state.length = 0;
        state.mode = COMMENT;
        /* falls through */
      case COMMENT:
        if (state.flags & 0x1000) {
          if (have === 0) { break inf_leave; }
          copy = 0;
          do {
            len = input[next + copy++];
            /* use constant limit because in js we should not preallocate memory */
            if (state.head && len &&
                (state.length < 65536 /*state.head.comm_max*/)) {
              state.head.comment += String.fromCharCode(len);
            }
          } while (len && copy < have);
          if (state.flags & 0x0200) {
            state.check = crc32_1(state.check, input, copy, next);
          }
          have -= copy;
          next += copy;
          if (len) { break inf_leave; }
        }
        else if (state.head) {
          state.head.comment = null;
        }
        state.mode = HCRC;
        /* falls through */
      case HCRC:
        if (state.flags & 0x0200) {
          //=== NEEDBITS(16); */
          while (bits < 16) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          if (hold !== (state.check & 0xffff)) {
            strm.msg = 'header crc mismatch';
            state.mode = BAD;
            break;
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
        }
        if (state.head) {
          state.head.hcrc = ((state.flags >> 9) & 1);
          state.head.done = true;
        }
        strm.adler = state.check = 0;
        state.mode = TYPE;
        break;
      case DICTID:
        //=== NEEDBITS(32); */
        while (bits < 32) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        strm.adler = state.check = zswap32(hold);
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = DICT;
        /* falls through */
      case DICT:
        if (state.havedict === 0) {
          //--- RESTORE() ---
          strm.next_out = put;
          strm.avail_out = left;
          strm.next_in = next;
          strm.avail_in = have;
          state.hold = hold;
          state.bits = bits;
          //---
          return Z_NEED_DICT;
        }
        strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
        state.mode = TYPE;
        /* falls through */
      case TYPE:
        if (flush === Z_BLOCK || flush === Z_TREES) { break inf_leave; }
        /* falls through */
      case TYPEDO:
        if (state.last) {
          //--- BYTEBITS() ---//
          hold >>>= bits & 7;
          bits -= bits & 7;
          //---//
          state.mode = CHECK;
          break;
        }
        //=== NEEDBITS(3); */
        while (bits < 3) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.last = (hold & 0x01)/*BITS(1)*/;
        //--- DROPBITS(1) ---//
        hold >>>= 1;
        bits -= 1;
        //---//

        switch ((hold & 0x03)/*BITS(2)*/) {
          case 0:                             /* stored block */
            //Tracev((stderr, "inflate:     stored block%s\n",
            //        state.last ? " (last)" : ""));
            state.mode = STORED;
            break;
          case 1:                             /* fixed block */
            fixedtables(state);
            //Tracev((stderr, "inflate:     fixed codes block%s\n",
            //        state.last ? " (last)" : ""));
            state.mode = LEN_;             /* decode codes */
            if (flush === Z_TREES) {
              //--- DROPBITS(2) ---//
              hold >>>= 2;
              bits -= 2;
              //---//
              break inf_leave;
            }
            break;
          case 2:                             /* dynamic block */
            //Tracev((stderr, "inflate:     dynamic codes block%s\n",
            //        state.last ? " (last)" : ""));
            state.mode = TABLE;
            break;
          case 3:
            strm.msg = 'invalid block type';
            state.mode = BAD;
        }
        //--- DROPBITS(2) ---//
        hold >>>= 2;
        bits -= 2;
        //---//
        break;
      case STORED:
        //--- BYTEBITS() ---// /* go to byte boundary */
        hold >>>= bits & 7;
        bits -= bits & 7;
        //---//
        //=== NEEDBITS(32); */
        while (bits < 32) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if ((hold & 0xffff) !== ((hold >>> 16) ^ 0xffff)) {
          strm.msg = 'invalid stored block lengths';
          state.mode = BAD;
          break;
        }
        state.length = hold & 0xffff;
        //Tracev((stderr, "inflate:       stored length %u\n",
        //        state.length));
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = COPY_;
        if (flush === Z_TREES) { break inf_leave; }
        /* falls through */
      case COPY_:
        state.mode = COPY;
        /* falls through */
      case COPY:
        copy = state.length;
        if (copy) {
          if (copy > have) { copy = have; }
          if (copy > left) { copy = left; }
          if (copy === 0) { break inf_leave; }
          //--- zmemcpy(put, next, copy); ---
          common.arraySet(output, input, next, copy, put);
          //---//
          have -= copy;
          next += copy;
          left -= copy;
          put += copy;
          state.length -= copy;
          break;
        }
        //Tracev((stderr, "inflate:       stored end\n"));
        state.mode = TYPE;
        break;
      case TABLE:
        //=== NEEDBITS(14); */
        while (bits < 14) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.nlen = (hold & 0x1f)/*BITS(5)*/ + 257;
        //--- DROPBITS(5) ---//
        hold >>>= 5;
        bits -= 5;
        //---//
        state.ndist = (hold & 0x1f)/*BITS(5)*/ + 1;
        //--- DROPBITS(5) ---//
        hold >>>= 5;
        bits -= 5;
        //---//
        state.ncode = (hold & 0x0f)/*BITS(4)*/ + 4;
        //--- DROPBITS(4) ---//
        hold >>>= 4;
        bits -= 4;
        //---//
//#ifndef PKZIP_BUG_WORKAROUND
        if (state.nlen > 286 || state.ndist > 30) {
          strm.msg = 'too many length or distance symbols';
          state.mode = BAD;
          break;
        }
//#endif
        //Tracev((stderr, "inflate:       table sizes ok\n"));
        state.have = 0;
        state.mode = LENLENS;
        /* falls through */
      case LENLENS:
        while (state.have < state.ncode) {
          //=== NEEDBITS(3);
          while (bits < 3) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.lens[order[state.have++]] = (hold & 0x07);//BITS(3);
          //--- DROPBITS(3) ---//
          hold >>>= 3;
          bits -= 3;
          //---//
        }
        while (state.have < 19) {
          state.lens[order[state.have++]] = 0;
        }
        // We have separate tables & no pointers. 2 commented lines below not needed.
        //state.next = state.codes;
        //state.lencode = state.next;
        // Switch to use dynamic table
        state.lencode = state.lendyn;
        state.lenbits = 7;

        opts = { bits: state.lenbits };
        ret = inftrees(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
        state.lenbits = opts.bits;

        if (ret) {
          strm.msg = 'invalid code lengths set';
          state.mode = BAD;
          break;
        }
        //Tracev((stderr, "inflate:       code lengths ok\n"));
        state.have = 0;
        state.mode = CODELENS;
        /* falls through */
      case CODELENS:
        while (state.have < state.nlen + state.ndist) {
          for (;;) {
            here = state.lencode[hold & ((1 << state.lenbits) - 1)];/*BITS(state.lenbits)*/
            here_bits = here >>> 24;
            here_op = (here >>> 16) & 0xff;
            here_val = here & 0xffff;

            if ((here_bits) <= bits) { break; }
            //--- PULLBYTE() ---//
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
            //---//
          }
          if (here_val < 16) {
            //--- DROPBITS(here.bits) ---//
            hold >>>= here_bits;
            bits -= here_bits;
            //---//
            state.lens[state.have++] = here_val;
          }
          else {
            if (here_val === 16) {
              //=== NEEDBITS(here.bits + 2);
              n = here_bits + 2;
              while (bits < n) {
                if (have === 0) { break inf_leave; }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              //--- DROPBITS(here.bits) ---//
              hold >>>= here_bits;
              bits -= here_bits;
              //---//
              if (state.have === 0) {
                strm.msg = 'invalid bit length repeat';
                state.mode = BAD;
                break;
              }
              len = state.lens[state.have - 1];
              copy = 3 + (hold & 0x03);//BITS(2);
              //--- DROPBITS(2) ---//
              hold >>>= 2;
              bits -= 2;
              //---//
            }
            else if (here_val === 17) {
              //=== NEEDBITS(here.bits + 3);
              n = here_bits + 3;
              while (bits < n) {
                if (have === 0) { break inf_leave; }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              //--- DROPBITS(here.bits) ---//
              hold >>>= here_bits;
              bits -= here_bits;
              //---//
              len = 0;
              copy = 3 + (hold & 0x07);//BITS(3);
              //--- DROPBITS(3) ---//
              hold >>>= 3;
              bits -= 3;
              //---//
            }
            else {
              //=== NEEDBITS(here.bits + 7);
              n = here_bits + 7;
              while (bits < n) {
                if (have === 0) { break inf_leave; }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              //--- DROPBITS(here.bits) ---//
              hold >>>= here_bits;
              bits -= here_bits;
              //---//
              len = 0;
              copy = 11 + (hold & 0x7f);//BITS(7);
              //--- DROPBITS(7) ---//
              hold >>>= 7;
              bits -= 7;
              //---//
            }
            if (state.have + copy > state.nlen + state.ndist) {
              strm.msg = 'invalid bit length repeat';
              state.mode = BAD;
              break;
            }
            while (copy--) {
              state.lens[state.have++] = len;
            }
          }
        }

        /* handle error breaks in while */
        if (state.mode === BAD) { break; }

        /* check for end-of-block code (better have one) */
        if (state.lens[256] === 0) {
          strm.msg = 'invalid code -- missing end-of-block';
          state.mode = BAD;
          break;
        }

        /* build code tables -- note: do not change the lenbits or distbits
           values here (9 and 6) without reading the comments in inftrees.h
           concerning the ENOUGH constants, which depend on those values */
        state.lenbits = 9;

        opts = { bits: state.lenbits };
        ret = inftrees(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
        // We have separate tables & no pointers. 2 commented lines below not needed.
        // state.next_index = opts.table_index;
        state.lenbits = opts.bits;
        // state.lencode = state.next;

        if (ret) {
          strm.msg = 'invalid literal/lengths set';
          state.mode = BAD;
          break;
        }

        state.distbits = 6;
        //state.distcode.copy(state.codes);
        // Switch to use dynamic table
        state.distcode = state.distdyn;
        opts = { bits: state.distbits };
        ret = inftrees(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
        // We have separate tables & no pointers. 2 commented lines below not needed.
        // state.next_index = opts.table_index;
        state.distbits = opts.bits;
        // state.distcode = state.next;

        if (ret) {
          strm.msg = 'invalid distances set';
          state.mode = BAD;
          break;
        }
        //Tracev((stderr, 'inflate:       codes ok\n'));
        state.mode = LEN_;
        if (flush === Z_TREES) { break inf_leave; }
        /* falls through */
      case LEN_:
        state.mode = LEN;
        /* falls through */
      case LEN:
        if (have >= 6 && left >= 258) {
          //--- RESTORE() ---
          strm.next_out = put;
          strm.avail_out = left;
          strm.next_in = next;
          strm.avail_in = have;
          state.hold = hold;
          state.bits = bits;
          //---
          inffast(strm, _out);
          //--- LOAD() ---
          put = strm.next_out;
          output = strm.output;
          left = strm.avail_out;
          next = strm.next_in;
          input = strm.input;
          have = strm.avail_in;
          hold = state.hold;
          bits = state.bits;
          //---

          if (state.mode === TYPE) {
            state.back = -1;
          }
          break;
        }
        state.back = 0;
        for (;;) {
          here = state.lencode[hold & ((1 << state.lenbits) - 1)];  /*BITS(state.lenbits)*/
          here_bits = here >>> 24;
          here_op = (here >>> 16) & 0xff;
          here_val = here & 0xffff;

          if (here_bits <= bits) { break; }
          //--- PULLBYTE() ---//
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
          //---//
        }
        if (here_op && (here_op & 0xf0) === 0) {
          last_bits = here_bits;
          last_op = here_op;
          last_val = here_val;
          for (;;) {
            here = state.lencode[last_val +
                    ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];
            here_bits = here >>> 24;
            here_op = (here >>> 16) & 0xff;
            here_val = here & 0xffff;

            if ((last_bits + here_bits) <= bits) { break; }
            //--- PULLBYTE() ---//
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
            //---//
          }
          //--- DROPBITS(last.bits) ---//
          hold >>>= last_bits;
          bits -= last_bits;
          //---//
          state.back += last_bits;
        }
        //--- DROPBITS(here.bits) ---//
        hold >>>= here_bits;
        bits -= here_bits;
        //---//
        state.back += here_bits;
        state.length = here_val;
        if (here_op === 0) {
          //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
          //        "inflate:         literal '%c'\n" :
          //        "inflate:         literal 0x%02x\n", here.val));
          state.mode = LIT;
          break;
        }
        if (here_op & 32) {
          //Tracevv((stderr, "inflate:         end of block\n"));
          state.back = -1;
          state.mode = TYPE;
          break;
        }
        if (here_op & 64) {
          strm.msg = 'invalid literal/length code';
          state.mode = BAD;
          break;
        }
        state.extra = here_op & 15;
        state.mode = LENEXT;
        /* falls through */
      case LENEXT:
        if (state.extra) {
          //=== NEEDBITS(state.extra);
          n = state.extra;
          while (bits < n) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.length += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;
          //--- DROPBITS(state.extra) ---//
          hold >>>= state.extra;
          bits -= state.extra;
          //---//
          state.back += state.extra;
        }
        //Tracevv((stderr, "inflate:         length %u\n", state.length));
        state.was = state.length;
        state.mode = DIST;
        /* falls through */
      case DIST:
        for (;;) {
          here = state.distcode[hold & ((1 << state.distbits) - 1)];/*BITS(state.distbits)*/
          here_bits = here >>> 24;
          here_op = (here >>> 16) & 0xff;
          here_val = here & 0xffff;

          if ((here_bits) <= bits) { break; }
          //--- PULLBYTE() ---//
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
          //---//
        }
        if ((here_op & 0xf0) === 0) {
          last_bits = here_bits;
          last_op = here_op;
          last_val = here_val;
          for (;;) {
            here = state.distcode[last_val +
                    ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];
            here_bits = here >>> 24;
            here_op = (here >>> 16) & 0xff;
            here_val = here & 0xffff;

            if ((last_bits + here_bits) <= bits) { break; }
            //--- PULLBYTE() ---//
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
            //---//
          }
          //--- DROPBITS(last.bits) ---//
          hold >>>= last_bits;
          bits -= last_bits;
          //---//
          state.back += last_bits;
        }
        //--- DROPBITS(here.bits) ---//
        hold >>>= here_bits;
        bits -= here_bits;
        //---//
        state.back += here_bits;
        if (here_op & 64) {
          strm.msg = 'invalid distance code';
          state.mode = BAD;
          break;
        }
        state.offset = here_val;
        state.extra = (here_op) & 15;
        state.mode = DISTEXT;
        /* falls through */
      case DISTEXT:
        if (state.extra) {
          //=== NEEDBITS(state.extra);
          n = state.extra;
          while (bits < n) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.offset += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;
          //--- DROPBITS(state.extra) ---//
          hold >>>= state.extra;
          bits -= state.extra;
          //---//
          state.back += state.extra;
        }
//#ifdef INFLATE_STRICT
        if (state.offset > state.dmax) {
          strm.msg = 'invalid distance too far back';
          state.mode = BAD;
          break;
        }
//#endif
        //Tracevv((stderr, "inflate:         distance %u\n", state.offset));
        state.mode = MATCH;
        /* falls through */
      case MATCH:
        if (left === 0) { break inf_leave; }
        copy = _out - left;
        if (state.offset > copy) {         /* copy from window */
          copy = state.offset - copy;
          if (copy > state.whave) {
            if (state.sane) {
              strm.msg = 'invalid distance too far back';
              state.mode = BAD;
              break;
            }
// (!) This block is disabled in zlib defaults,
// don't enable it for binary compatibility
//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
//          Trace((stderr, "inflate.c too far\n"));
//          copy -= state.whave;
//          if (copy > state.length) { copy = state.length; }
//          if (copy > left) { copy = left; }
//          left -= copy;
//          state.length -= copy;
//          do {
//            output[put++] = 0;
//          } while (--copy);
//          if (state.length === 0) { state.mode = LEN; }
//          break;
//#endif
          }
          if (copy > state.wnext) {
            copy -= state.wnext;
            from = state.wsize - copy;
          }
          else {
            from = state.wnext - copy;
          }
          if (copy > state.length) { copy = state.length; }
          from_source = state.window;
        }
        else {                              /* copy from output */
          from_source = output;
          from = put - state.offset;
          copy = state.length;
        }
        if (copy > left) { copy = left; }
        left -= copy;
        state.length -= copy;
        do {
          output[put++] = from_source[from++];
        } while (--copy);
        if (state.length === 0) { state.mode = LEN; }
        break;
      case LIT:
        if (left === 0) { break inf_leave; }
        output[put++] = state.length;
        left--;
        state.mode = LEN;
        break;
      case CHECK:
        if (state.wrap) {
          //=== NEEDBITS(32);
          while (bits < 32) {
            if (have === 0) { break inf_leave; }
            have--;
            // Use '|' instead of '+' to make sure that result is signed
            hold |= input[next++] << bits;
            bits += 8;
          }
          //===//
          _out -= left;
          strm.total_out += _out;
          state.total += _out;
          if (_out) {
            strm.adler = state.check =
                /*UPDATE(state.check, put - _out, _out);*/
                (state.flags ? crc32_1(state.check, output, _out, put - _out) : adler32_1(state.check, output, _out, put - _out));

          }
          _out = left;
          // NB: crc32 stored as signed 32-bit int, zswap32 returns signed too
          if ((state.flags ? hold : zswap32(hold)) !== state.check) {
            strm.msg = 'incorrect data check';
            state.mode = BAD;
            break;
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
          //Tracev((stderr, "inflate:   check matches trailer\n"));
        }
        state.mode = LENGTH;
        /* falls through */
      case LENGTH:
        if (state.wrap && state.flags) {
          //=== NEEDBITS(32);
          while (bits < 32) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          if (hold !== (state.total & 0xffffffff)) {
            strm.msg = 'incorrect length check';
            state.mode = BAD;
            break;
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
          //Tracev((stderr, "inflate:   length matches trailer\n"));
        }
        state.mode = DONE;
        /* falls through */
      case DONE:
        ret = Z_STREAM_END;
        break inf_leave;
      case BAD:
        ret = Z_DATA_ERROR;
        break inf_leave;
      case MEM:
        return Z_MEM_ERROR;
      case SYNC:
        /* falls through */
      default:
        return Z_STREAM_ERROR;
    }
  }

  // inf_leave <- here is real place for "goto inf_leave", emulated via "break inf_leave"

  /*
     Return from inflate(), updating the total counts and the check value.
     If there was no progress during the inflate() call, return a buffer
     error.  Call updatewindow() to create and/or update the window state.
     Note: a memory error from inflate() is non-recoverable.
   */

  //--- RESTORE() ---
  strm.next_out = put;
  strm.avail_out = left;
  strm.next_in = next;
  strm.avail_in = have;
  state.hold = hold;
  state.bits = bits;
  //---

  if (state.wsize || (_out !== strm.avail_out && state.mode < BAD &&
                      (state.mode < CHECK || flush !== Z_FINISH))) {
    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) ;
  }
  _in -= strm.avail_in;
  _out -= strm.avail_out;
  strm.total_in += _in;
  strm.total_out += _out;
  state.total += _out;
  if (state.wrap && _out) {
    strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
      (state.flags ? crc32_1(state.check, output, _out, strm.next_out - _out) : adler32_1(state.check, output, _out, strm.next_out - _out));
  }
  strm.data_type = state.bits + (state.last ? 64 : 0) +
                    (state.mode === TYPE ? 128 : 0) +
                    (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
  if (((_in === 0 && _out === 0) || flush === Z_FINISH) && ret === Z_OK) {
    ret = Z_BUF_ERROR;
  }
  return ret;
}

function inflateEnd(strm) {

  if (!strm || !strm.state /*|| strm->zfree == (free_func)0*/) {
    return Z_STREAM_ERROR;
  }

  var state = strm.state;
  if (state.window) {
    state.window = null;
  }
  strm.state = null;
  return Z_OK;
}

function inflateGetHeader(strm, head) {
  var state;

  /* check state */
  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  state = strm.state;
  if ((state.wrap & 2) === 0) { return Z_STREAM_ERROR; }

  /* save header structure */
  state.head = head;
  head.done = false;
  return Z_OK;
}

function inflateSetDictionary(strm, dictionary) {
  var dictLength = dictionary.length;

  var state;
  var dictid;
  var ret;

  /* check state */
  if (!strm /* == Z_NULL */ || !strm.state /* == Z_NULL */) { return Z_STREAM_ERROR; }
  state = strm.state;

  if (state.wrap !== 0 && state.mode !== DICT) {
    return Z_STREAM_ERROR;
  }

  /* check for correct dictionary identifier */
  if (state.mode === DICT) {
    dictid = 1; /* adler32(0, null, 0)*/
    /* dictid = adler32(dictid, dictionary, dictLength); */
    dictid = adler32_1(dictid, dictionary, dictLength, 0);
    if (dictid !== state.check) {
      return Z_DATA_ERROR;
    }
  }
  /* copy dictionary to window using updatewindow(), which will amend the
   existing dictionary if appropriate */
  ret = updatewindow(strm, dictionary, dictLength, dictLength);
  if (ret) {
    state.mode = MEM;
    return Z_MEM_ERROR;
  }
  state.havedict = 1;
  // Tracev((stderr, "inflate:   dictionary set\n"));
  return Z_OK;
}

var inflateReset_1 = inflateReset;
var inflateReset2_1 = inflateReset2;
var inflateResetKeep_1 = inflateResetKeep;
var inflateInit_1 = inflateInit;
var inflateInit2_1 = inflateInit2;
var inflate_2$1 = inflate$2;
var inflateEnd_1 = inflateEnd;
var inflateGetHeader_1 = inflateGetHeader;
var inflateSetDictionary_1 = inflateSetDictionary;
var inflateInfo = 'pako inflate (from Nodeca project)';

/* Not implemented
exports.inflateCopy = inflateCopy;
exports.inflateGetDictionary = inflateGetDictionary;
exports.inflateMark = inflateMark;
exports.inflatePrime = inflatePrime;
exports.inflateSync = inflateSync;
exports.inflateSyncPoint = inflateSyncPoint;
exports.inflateUndermine = inflateUndermine;
*/

var inflate_1$1 = {
	inflateReset: inflateReset_1,
	inflateReset2: inflateReset2_1,
	inflateResetKeep: inflateResetKeep_1,
	inflateInit: inflateInit_1,
	inflateInit2: inflateInit2_1,
	inflate: inflate_2$1,
	inflateEnd: inflateEnd_1,
	inflateGetHeader: inflateGetHeader_1,
	inflateSetDictionary: inflateSetDictionary_1,
	inflateInfo: inflateInfo
};

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

var constants = {

  /* Allowed flush values; see deflate() and inflate() below for details */
  Z_NO_FLUSH:         0,
  Z_PARTIAL_FLUSH:    1,
  Z_SYNC_FLUSH:       2,
  Z_FULL_FLUSH:       3,
  Z_FINISH:           4,
  Z_BLOCK:            5,
  Z_TREES:            6,

  /* Return codes for the compression/decompression functions. Negative values
  * are errors, positive values are used for special but normal events.
  */
  Z_OK:               0,
  Z_STREAM_END:       1,
  Z_NEED_DICT:        2,
  Z_ERRNO:           -1,
  Z_STREAM_ERROR:    -2,
  Z_DATA_ERROR:      -3,
  //Z_MEM_ERROR:     -4,
  Z_BUF_ERROR:       -5,
  //Z_VERSION_ERROR: -6,

  /* compression levels */
  Z_NO_COMPRESSION:         0,
  Z_BEST_SPEED:             1,
  Z_BEST_COMPRESSION:       9,
  Z_DEFAULT_COMPRESSION:   -1,


  Z_FILTERED:               1,
  Z_HUFFMAN_ONLY:           2,
  Z_RLE:                    3,
  Z_FIXED:                  4,
  Z_DEFAULT_STRATEGY:       0,

  /* Possible values of the data_type field (though see inflate()) */
  Z_BINARY:                 0,
  Z_TEXT:                   1,
  //Z_ASCII:                1, // = Z_TEXT (deprecated)
  Z_UNKNOWN:                2,

  /* The deflate compression method */
  Z_DEFLATED:               8
  //Z_NULL:                 null // Use -1 or null inline, depending on var type
};

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

function GZheader() {
  /* true if compressed data believed to be text */
  this.text       = 0;
  /* modification time */
  this.time       = 0;
  /* extra flags (not used when writing a gzip file) */
  this.xflags     = 0;
  /* operating system */
  this.os         = 0;
  /* pointer to extra field or Z_NULL if none */
  this.extra      = null;
  /* extra field length (valid if extra != Z_NULL) */
  this.extra_len  = 0; // Actually, we don't need it in JS,
                       // but leave for few code modifications

  //
  // Setup limits is not necessary because in js we should not preallocate memory
  // for inflate use constant limit in 65536 bytes
  //

  /* space at extra (only when reading header) */
  // this.extra_max  = 0;
  /* pointer to zero-terminated file name or Z_NULL */
  this.name       = '';
  /* space at name (only when reading header) */
  // this.name_max   = 0;
  /* pointer to zero-terminated comment or Z_NULL */
  this.comment    = '';
  /* space at comment (only when reading header) */
  // this.comm_max   = 0;
  /* true if there was or will be a header crc */
  this.hcrc       = 0;
  /* true when done reading gzip header (not used when writing a gzip file) */
  this.done       = false;
}

var gzheader = GZheader;

var toString = Object.prototype.toString;

/**
 * class Inflate
 *
 * Generic JS-style wrapper for zlib calls. If you don't need
 * streaming behaviour - use more simple functions: [[inflate]]
 * and [[inflateRaw]].
 **/

/* internal
 * inflate.chunks -> Array
 *
 * Chunks of output data, if [[Inflate#onData]] not overridden.
 **/

/**
 * Inflate.result -> Uint8Array|Array|String
 *
 * Uncompressed result, generated by default [[Inflate#onData]]
 * and [[Inflate#onEnd]] handlers. Filled after you push last chunk
 * (call [[Inflate#push]] with `Z_FINISH` / `true` param) or if you
 * push a chunk with explicit flush (call [[Inflate#push]] with
 * `Z_SYNC_FLUSH` param).
 **/

/**
 * Inflate.err -> Number
 *
 * Error code after inflate finished. 0 (Z_OK) on success.
 * Should be checked if broken data possible.
 **/

/**
 * Inflate.msg -> String
 *
 * Error message, if [[Inflate.err]] != 0
 **/


/**
 * new Inflate(options)
 * - options (Object): zlib inflate options.
 *
 * Creates new inflator instance with specified params. Throws exception
 * on bad params. Supported options:
 *
 * - `windowBits`
 * - `dictionary`
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Additional options, for internal needs:
 *
 * - `chunkSize` - size of generated data chunks (16K by default)
 * - `raw` (Boolean) - do raw inflate
 * - `to` (String) - if equal to 'string', then result will be converted
 *   from utf8 to utf16 (javascript) string. When string output requested,
 *   chunk length can differ from `chunkSize`, depending on content.
 *
 * By default, when no options set, autodetect deflate/gzip data format via
 * wrapper header.
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])
 *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);
 *
 * var inflate = new pako.Inflate({ level: 3});
 *
 * inflate.push(chunk1, false);
 * inflate.push(chunk2, true);  // true -> last chunk
 *
 * if (inflate.err) { throw new Error(inflate.err); }
 *
 * console.log(inflate.result);
 * ```
 **/
function Inflate(options) {
  if (!(this instanceof Inflate)) return new Inflate(options);

  this.options = common.assign({
    chunkSize: 16384,
    windowBits: 0,
    to: ''
  }, options || {});

  var opt = this.options;

  // Force window size for `raw` data, if not set directly,
  // because we have no header for autodetect.
  if (opt.raw && (opt.windowBits >= 0) && (opt.windowBits < 16)) {
    opt.windowBits = -opt.windowBits;
    if (opt.windowBits === 0) { opt.windowBits = -15; }
  }

  // If `windowBits` not defined (and mode not raw) - set autodetect flag for gzip/deflate
  if ((opt.windowBits >= 0) && (opt.windowBits < 16) &&
      !(options && options.windowBits)) {
    opt.windowBits += 32;
  }

  // Gzip header has no info about windows size, we can do autodetect only
  // for deflate. So, if window size not set, force it to max when gzip possible
  if ((opt.windowBits > 15) && (opt.windowBits < 48)) {
    // bit 3 (16) -> gzipped data
    // bit 4 (32) -> autodetect gzip/deflate
    if ((opt.windowBits & 15) === 0) {
      opt.windowBits |= 15;
    }
  }

  this.err    = 0;      // error code, if happens (0 = Z_OK)
  this.msg    = '';     // error message
  this.ended  = false;  // used to avoid multiple onEnd() calls
  this.chunks = [];     // chunks of compressed data

  this.strm   = new zstream();
  this.strm.avail_out = 0;

  var status  = inflate_1$1.inflateInit2(
    this.strm,
    opt.windowBits
  );

  if (status !== constants.Z_OK) {
    throw new Error(messages[status]);
  }

  this.header = new gzheader();

  inflate_1$1.inflateGetHeader(this.strm, this.header);

  // Setup dictionary
  if (opt.dictionary) {
    // Convert data if needed
    if (typeof opt.dictionary === 'string') {
      opt.dictionary = strings.string2buf(opt.dictionary);
    } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {
      opt.dictionary = new Uint8Array(opt.dictionary);
    }
    if (opt.raw) { //In raw mode we need to set the dictionary early
      status = inflate_1$1.inflateSetDictionary(this.strm, opt.dictionary);
      if (status !== constants.Z_OK) {
        throw new Error(messages[status]);
      }
    }
  }
}

/**
 * Inflate#push(data[, mode]) -> Boolean
 * - data (Uint8Array|Array|ArrayBuffer|String): input data
 * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.
 *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.
 *
 * Sends input data to inflate pipe, generating [[Inflate#onData]] calls with
 * new output chunks. Returns `true` on success. The last data block must have
 * mode Z_FINISH (or `true`). That will flush internal pending buffers and call
 * [[Inflate#onEnd]]. For interim explicit flushes (without ending the stream) you
 * can use mode Z_SYNC_FLUSH, keeping the decompression context.
 *
 * On fail call [[Inflate#onEnd]] with error code and return false.
 *
 * We strongly recommend to use `Uint8Array` on input for best speed (output
 * format is detected automatically). Also, don't skip last param and always
 * use the same type in your code (boolean or number). That will improve JS speed.
 *
 * For regular `Array`-s make sure all elements are [0..255].
 *
 * ##### Example
 *
 * ```javascript
 * push(chunk, false); // push one of data chunks
 * ...
 * push(chunk, true);  // push last chunk
 * ```
 **/
Inflate.prototype.push = function (data, mode) {
  var strm = this.strm;
  var chunkSize = this.options.chunkSize;
  var dictionary = this.options.dictionary;
  var status, _mode;
  var next_out_utf8, tail, utf8str;

  // Flag to properly process Z_BUF_ERROR on testing inflate call
  // when we check that all output data was flushed.
  var allowBufError = false;

  if (this.ended) { return false; }
  _mode = (mode === ~~mode) ? mode : ((mode === true) ? constants.Z_FINISH : constants.Z_NO_FLUSH);

  // Convert data if needed
  if (typeof data === 'string') {
    // Only binary strings can be decompressed on practice
    strm.input = strings.binstring2buf(data);
  } else if (toString.call(data) === '[object ArrayBuffer]') {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }

  strm.next_in = 0;
  strm.avail_in = strm.input.length;

  do {
    if (strm.avail_out === 0) {
      strm.output = new common.Buf8(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }

    status = inflate_1$1.inflate(strm, constants.Z_NO_FLUSH);    /* no bad return value */

    if (status === constants.Z_NEED_DICT && dictionary) {
      status = inflate_1$1.inflateSetDictionary(this.strm, dictionary);
    }

    if (status === constants.Z_BUF_ERROR && allowBufError === true) {
      status = constants.Z_OK;
      allowBufError = false;
    }

    if (status !== constants.Z_STREAM_END && status !== constants.Z_OK) {
      this.onEnd(status);
      this.ended = true;
      return false;
    }

    if (strm.next_out) {
      if (strm.avail_out === 0 || status === constants.Z_STREAM_END || (strm.avail_in === 0 && (_mode === constants.Z_FINISH || _mode === constants.Z_SYNC_FLUSH))) {

        if (this.options.to === 'string') {

          next_out_utf8 = strings.utf8border(strm.output, strm.next_out);

          tail = strm.next_out - next_out_utf8;
          utf8str = strings.buf2string(strm.output, next_out_utf8);

          // move tail
          strm.next_out = tail;
          strm.avail_out = chunkSize - tail;
          if (tail) { common.arraySet(strm.output, strm.output, next_out_utf8, tail, 0); }

          this.onData(utf8str);

        } else {
          this.onData(common.shrinkBuf(strm.output, strm.next_out));
        }
      }
    }

    // When no more input data, we should check that internal inflate buffers
    // are flushed. The only way to do it when avail_out = 0 - run one more
    // inflate pass. But if output data not exists, inflate return Z_BUF_ERROR.
    // Here we set flag to process this error properly.
    //
    // NOTE. Deflate does not return error in this case and does not needs such
    // logic.
    if (strm.avail_in === 0 && strm.avail_out === 0) {
      allowBufError = true;
    }

  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== constants.Z_STREAM_END);

  if (status === constants.Z_STREAM_END) {
    _mode = constants.Z_FINISH;
  }

  // Finalize on the last chunk.
  if (_mode === constants.Z_FINISH) {
    status = inflate_1$1.inflateEnd(this.strm);
    this.onEnd(status);
    this.ended = true;
    return status === constants.Z_OK;
  }

  // callback interim results if Z_SYNC_FLUSH.
  if (_mode === constants.Z_SYNC_FLUSH) {
    this.onEnd(constants.Z_OK);
    strm.avail_out = 0;
    return true;
  }

  return true;
};


/**
 * Inflate#onData(chunk) -> Void
 * - chunk (Uint8Array|Array|String): output data. Type of array depends
 *   on js engine support. When string output requested, each chunk
 *   will be string.
 *
 * By default, stores data blocks in `chunks[]` property and glue
 * those in `onEnd`. Override this handler, if you need another behaviour.
 **/
Inflate.prototype.onData = function (chunk) {
  this.chunks.push(chunk);
};


/**
 * Inflate#onEnd(status) -> Void
 * - status (Number): inflate status. 0 (Z_OK) on success,
 *   other if not.
 *
 * Called either after you tell inflate that the input stream is
 * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)
 * or if an error happened. By default - join collected chunks,
 * free memory and fill `results` / `err` properties.
 **/
Inflate.prototype.onEnd = function (status) {
  // On success - join
  if (status === constants.Z_OK) {
    if (this.options.to === 'string') {
      // Glue & convert here, until we teach pako to send
      // utf8 aligned strings to onData
      this.result = this.chunks.join('');
    } else {
      this.result = common.flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};


/**
 * inflate(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * Decompress `data` with inflate/ungzip and `options`. Autodetect
 * format via wrapper header by default. That's why we don't provide
 * separate `ungzip` method.
 *
 * Supported options are:
 *
 * - windowBits
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information.
 *
 * Sugar (options):
 *
 * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
 *   negative windowBits implicitly.
 * - `to` (String) - if equal to 'string', then result will be converted
 *   from utf8 to utf16 (javascript) string. When string output requested,
 *   chunk length can differ from `chunkSize`, depending on content.
 *
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , input = pako.deflate([1,2,3,4,5,6,7,8,9])
 *   , output;
 *
 * try {
 *   output = pako.inflate(input);
 * } catch (err)
 *   console.log(err);
 * }
 * ```
 **/
function inflate$1(input, options) {
  var inflator = new Inflate(options);

  inflator.push(input, true);

  // That will never happens, if you don't cheat with options :)
  if (inflator.err) { throw inflator.msg || messages[inflator.err]; }

  return inflator.result;
}


/**
 * inflateRaw(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * The same as [[inflate]], but creates raw data, without wrapper
 * (header and adler32 crc).
 **/
function inflateRaw(input, options) {
  options = options || {};
  options.raw = true;
  return inflate$1(input, options);
}


/**
 * ungzip(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * Just shortcut to [[inflate]], because it autodetects format
 * by header.content. Done for convenience.
 **/


var Inflate_1 = Inflate;
var inflate_2 = inflate$1;
var inflateRaw_1 = inflateRaw;
var ungzip  = inflate$1;

var inflate_1 = {
	Inflate: Inflate_1,
	inflate: inflate_2,
	inflateRaw: inflateRaw_1,
	ungzip: ungzip
};

var assign    = common.assign;





var pako = {};

assign(pako, deflate_1, inflate_1, constants);

var pako_1 = pako;

// A simple implementation of make-array
function makeArray (subject) {
  return Array.isArray(subject)
    ? subject
    : [subject]
}

const EMPTY = '';
const SPACE = ' ';
const ESCAPE = '\\';
const REGEX_TEST_BLANK_LINE = /^\s+$/;
const REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION = /^\\!/;
const REGEX_REPLACE_LEADING_EXCAPED_HASH = /^\\#/;
const REGEX_SPLITALL_CRLF = /\r?\n/g;
// /foo,
// ./foo,
// ../foo,
// .
// ..
const REGEX_TEST_INVALID_PATH = /^\.*\/|^\.+$/;

const SLASH = '/';
const KEY_IGNORE = typeof Symbol !== 'undefined'
  ? Symbol.for('node-ignore')
  /* istanbul ignore next */
  : 'node-ignore';

const define = (object, key, value) =>
  Object.defineProperty(object, key, {value});

const REGEX_REGEXP_RANGE = /([0-z])-([0-z])/g;

// Sanitize the range of a regular expression
// The cases are complicated, see test cases for details
const sanitizeRange = range => range.replace(
  REGEX_REGEXP_RANGE,
  (match, from, to) => from.charCodeAt(0) <= to.charCodeAt(0)
    ? match
    // Invalid range (out of order) which is ok for gitignore rules but
    //   fatal for JavaScript regular expression, so eliminate it.
    : EMPTY
);

// See fixtures #59
const cleanRangeBackSlash = slashes => {
  const {length} = slashes;
  return slashes.slice(0, length - length % 2)
};

// > If the pattern ends with a slash,
// > it is removed for the purpose of the following description,
// > but it would only find a match with a directory.
// > In other words, foo/ will match a directory foo and paths underneath it,
// > but will not match a regular file or a symbolic link foo
// >  (this is consistent with the way how pathspec works in general in Git).
// '`foo/`' will not match regular file '`foo`' or symbolic link '`foo`'
// -> ignore-rules will not deal with it, because it costs extra `fs.stat` call
//      you could use option `mark: true` with `glob`

// '`foo/`' should not continue with the '`..`'
const REPLACERS = [

  // > Trailing spaces are ignored unless they are quoted with backslash ("\")
  [
    // (a\ ) -> (a )
    // (a  ) -> (a)
    // (a \ ) -> (a  )
    /\\?\s+$/,
    match => match.indexOf('\\') === 0
      ? SPACE
      : EMPTY
  ],

  // replace (\ ) with ' '
  [
    /\\\s/g,
    () => SPACE
  ],

  // Escape metacharacters
  // which is written down by users but means special for regular expressions.

  // > There are 12 characters with special meanings:
  // > - the backslash \,
  // > - the caret ^,
  // > - the dollar sign $,
  // > - the period or dot .,
  // > - the vertical bar or pipe symbol |,
  // > - the question mark ?,
  // > - the asterisk or star *,
  // > - the plus sign +,
  // > - the opening parenthesis (,
  // > - the closing parenthesis ),
  // > - and the opening square bracket [,
  // > - the opening curly brace {,
  // > These special characters are often called "metacharacters".
  [
    /[\\$.|*+(){^]/g,
    match => `\\${match}`
  ],

  [
    // > a question mark (?) matches a single character
    /(?!\\)\?/g,
    () => '[^/]'
  ],

  // leading slash
  [

    // > A leading slash matches the beginning of the pathname.
    // > For example, "/*.c" matches "cat-file.c" but not "mozilla-sha1/sha1.c".
    // A leading slash matches the beginning of the pathname
    /^\//,
    () => '^'
  ],

  // replace special metacharacter slash after the leading slash
  [
    /\//g,
    () => '\\/'
  ],

  [
    // > A leading "**" followed by a slash means match in all directories.
    // > For example, "**/foo" matches file or directory "foo" anywhere,
    // > the same as pattern "foo".
    // > "**/foo/bar" matches file or directory "bar" anywhere that is directly
    // >   under directory "foo".
    // Notice that the '*'s have been replaced as '\\*'
    /^\^*\\\*\\\*\\\//,

    // '**/foo' <-> 'foo'
    () => '^(?:.*\\/)?'
  ],

  // starting
  [
    // there will be no leading '/'
    //   (which has been replaced by section "leading slash")
    // If starts with '**', adding a '^' to the regular expression also works
    /^(?=[^^])/,
    function startingReplacer () {
      // If has a slash `/` at the beginning or middle
      return !/\/(?!$)/.test(this)
        // > Prior to 2.22.1
        // > If the pattern does not contain a slash /,
        // >   Git treats it as a shell glob pattern
        // Actually, if there is only a trailing slash,
        //   git also treats it as a shell glob pattern

        // After 2.22.1 (compatible but clearer)
        // > If there is a separator at the beginning or middle (or both)
        // > of the pattern, then the pattern is relative to the directory
        // > level of the particular .gitignore file itself.
        // > Otherwise the pattern may also match at any level below
        // > the .gitignore level.
        ? '(?:^|\\/)'

        // > Otherwise, Git treats the pattern as a shell glob suitable for
        // >   consumption by fnmatch(3)
        : '^'
    }
  ],

  // two globstars
  [
    // Use lookahead assertions so that we could match more than one `'/**'`
    /\\\/\\\*\\\*(?=\\\/|$)/g,

    // Zero, one or several directories
    // should not use '*', or it will be replaced by the next replacer

    // Check if it is not the last `'/**'`
    (_, index, str) => index + 6 < str.length

      // case: /**/
      // > A slash followed by two consecutive asterisks then a slash matches
      // >   zero or more directories.
      // > For example, "a/**/b" matches "a/b", "a/x/b", "a/x/y/b" and so on.
      // '/**/'
      ? '(?:\\/[^\\/]+)*'

      // case: /**
      // > A trailing `"/**"` matches everything inside.

      // #21: everything inside but it should not include the current folder
      : '\\/.+'
  ],

  // intermediate wildcards
  [
    // Never replace escaped '*'
    // ignore rule '\*' will match the path '*'

    // 'abc.*/' -> go
    // 'abc.*'  -> skip this rule
    /(^|[^\\]+)\\\*(?=.+)/g,

    // '*.js' matches '.js'
    // '*.js' doesn't match 'abc'
    (_, p1) => `${p1}[^\\/]*`
  ],

  [
    // unescape, revert step 3 except for back slash
    // For example, if a user escape a '\\*',
    // after step 3, the result will be '\\\\\\*'
    /\\\\\\(?=[$.|*+(){^])/g,
    () => ESCAPE
  ],

  [
    // '\\\\' -> '\\'
    /\\\\/g,
    () => ESCAPE
  ],

  [
    // > The range notation, e.g. [a-zA-Z],
    // > can be used to match one of the characters in a range.

    // `\` is escaped by step 3
    /(\\)?\[([^\]/]*?)(\\*)($|\])/g,
    (match, leadEscape, range, endEscape, close) => leadEscape === ESCAPE
      // '\\[bar]' -> '\\\\[bar\\]'
      ? `\\[${range}${cleanRangeBackSlash(endEscape)}${close}`
      : close === ']'
        ? endEscape.length % 2 === 0
          // A normal case, and it is a range notation
          // '[bar]'
          // '[bar\\\\]'
          ? `[${sanitizeRange(range)}${endEscape}]`
          // Invalid range notaton
          // '[bar\\]' -> '[bar\\\\]'
          : '[]'
        : '[]'
  ],

  // ending
  [
    // 'js' will not match 'js.'
    // 'ab' will not match 'abc'
    /(?:[^*])$/,

    // WTF!
    // https://git-scm.com/docs/gitignore
    // changes in [2.22.1](https://git-scm.com/docs/gitignore/2.22.1)
    // which re-fixes #24, #38

    // > If there is a separator at the end of the pattern then the pattern
    // > will only match directories, otherwise the pattern can match both
    // > files and directories.

    // 'js*' will not match 'a.js'
    // 'js/' will not match 'a.js'
    // 'js' will match 'a.js' and 'a.js/'
    match => /\/$/.test(match)
      // foo/ will not match 'foo'
      ? `${match}$`
      // foo matches 'foo' and 'foo/'
      : `${match}(?=$|\\/$)`
  ],

  // trailing wildcard
  [
    /(\^|\\\/)?\\\*$/,
    (_, p1) => {
      const prefix = p1
        // '\^':
        // '/*' does not match EMPTY
        // '/*' does not match everything

        // '\\\/':
        // 'abc/*' does not match 'abc/'
        ? `${p1}[^/]+`

        // 'a*' matches 'a'
        // 'a*' matches 'aa'
        : '[^/]*';

      return `${prefix}(?=$|\\/$)`
    }
  ],
];

// A simple cache, because an ignore rule only has only one certain meaning
const regexCache = Object.create(null);

// @param {pattern}
const makeRegex = (pattern, negative, ignorecase) => {
  const r = regexCache[pattern];
  if (r) {
    return r
  }

  // const replacers = negative
  //   ? NEGATIVE_REPLACERS
  //   : POSITIVE_REPLACERS

  const source = REPLACERS.reduce(
    (prev, current) => prev.replace(current[0], current[1].bind(pattern)),
    pattern
  );

  return regexCache[pattern] = ignorecase
    ? new RegExp(source, 'i')
    : new RegExp(source)
};

const isString = subject => typeof subject === 'string';

// > A blank line matches no files, so it can serve as a separator for readability.
const checkPattern = pattern => pattern
  && isString(pattern)
  && !REGEX_TEST_BLANK_LINE.test(pattern)

  // > A line starting with # serves as a comment.
  && pattern.indexOf('#') !== 0;

const splitPattern = pattern => pattern.split(REGEX_SPLITALL_CRLF);

class IgnoreRule {
  constructor (
    origin,
    pattern,
    negative,
    regex
  ) {
    this.origin = origin;
    this.pattern = pattern;
    this.negative = negative;
    this.regex = regex;
  }
}

const createRule = (pattern, ignorecase) => {
  const origin = pattern;
  let negative = false;

  // > An optional prefix "!" which negates the pattern;
  if (pattern.indexOf('!') === 0) {
    negative = true;
    pattern = pattern.substr(1);
  }

  pattern = pattern
  // > Put a backslash ("\") in front of the first "!" for patterns that
  // >   begin with a literal "!", for example, `"\!important!.txt"`.
  .replace(REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION, '!')
  // > Put a backslash ("\") in front of the first hash for patterns that
  // >   begin with a hash.
  .replace(REGEX_REPLACE_LEADING_EXCAPED_HASH, '#');

  const regex = makeRegex(pattern, negative, ignorecase);

  return new IgnoreRule(
    origin,
    pattern,
    negative,
    regex
  )
};

const throwError = (message, Ctor) => {
  throw new Ctor(message)
};

const checkPath = (path, originalPath, doThrow) => {
  if (!isString(path)) {
    return doThrow(
      `path must be a string, but got \`${originalPath}\``,
      TypeError
    )
  }

  // We don't know if we should ignore EMPTY, so throw
  if (!path) {
    return doThrow(`path must not be empty`, TypeError)
  }

  // Check if it is a relative path
  if (checkPath.isNotRelative(path)) {
    const r = '`path.relative()`d';
    return doThrow(
      `path should be a ${r} string, but got "${originalPath}"`,
      RangeError
    )
  }

  return true
};

const isNotRelative = path => REGEX_TEST_INVALID_PATH.test(path);

checkPath.isNotRelative = isNotRelative;
checkPath.convert = p => p;

class Ignore {
  constructor ({
    ignorecase = true
  } = {}) {
    this._rules = [];
    this._ignorecase = ignorecase;
    define(this, KEY_IGNORE, true);
    this._initCache();
  }

  _initCache () {
    this._ignoreCache = Object.create(null);
    this._testCache = Object.create(null);
  }

  _addPattern (pattern) {
    // #32
    if (pattern && pattern[KEY_IGNORE]) {
      this._rules = this._rules.concat(pattern._rules);
      this._added = true;
      return
    }

    if (checkPattern(pattern)) {
      const rule = createRule(pattern, this._ignorecase);
      this._added = true;
      this._rules.push(rule);
    }
  }

  // @param {Array<string> | string | Ignore} pattern
  add (pattern) {
    this._added = false;

    makeArray(
      isString(pattern)
        ? splitPattern(pattern)
        : pattern
    ).forEach(this._addPattern, this);

    // Some rules have just added to the ignore,
    // making the behavior changed.
    if (this._added) {
      this._initCache();
    }

    return this
  }

  // legacy
  addPattern (pattern) {
    return this.add(pattern)
  }

  //          |           ignored : unignored
  // negative |   0:0   |   0:1   |   1:0   |   1:1
  // -------- | ------- | ------- | ------- | --------
  //     0    |  TEST   |  TEST   |  SKIP   |    X
  //     1    |  TESTIF |  SKIP   |  TEST   |    X

  // - SKIP: always skip
  // - TEST: always test
  // - TESTIF: only test if checkUnignored
  // - X: that never happen

  // @param {boolean} whether should check if the path is unignored,
  //   setting `checkUnignored` to `false` could reduce additional
  //   path matching.

  // @returns {TestResult} true if a file is ignored
  _testOne (path, checkUnignored) {
    let ignored = false;
    let unignored = false;

    this._rules.forEach(rule => {
      const {negative} = rule;
      if (
        unignored === negative && ignored !== unignored
        || negative && !ignored && !unignored && !checkUnignored
      ) {
        return
      }

      const matched = rule.regex.test(path);

      if (matched) {
        ignored = !negative;
        unignored = negative;
      }
    });

    return {
      ignored,
      unignored
    }
  }

  // @returns {TestResult}
  _test (originalPath, cache, checkUnignored, slices) {
    const path = originalPath
      // Supports nullable path
      && checkPath.convert(originalPath);

    checkPath(path, originalPath, throwError);

    return this._t(path, cache, checkUnignored, slices)
  }

  _t (path, cache, checkUnignored, slices) {
    if (path in cache) {
      return cache[path]
    }

    if (!slices) {
      // path/to/a.js
      // ['path', 'to', 'a.js']
      slices = path.split(SLASH);
    }

    slices.pop();

    // If the path has no parent directory, just test it
    if (!slices.length) {
      return cache[path] = this._testOne(path, checkUnignored)
    }

    const parent = this._t(
      slices.join(SLASH) + SLASH,
      cache,
      checkUnignored,
      slices
    );

    // If the path contains a parent directory, check the parent first
    return cache[path] = parent.ignored
      // > It is not possible to re-include a file if a parent directory of
      // >   that file is excluded.
      ? parent
      : this._testOne(path, checkUnignored)
  }

  ignores (path) {
    return this._test(path, this._ignoreCache, false).ignored
  }

  createFilter () {
    return path => !this.ignores(path)
  }

  filter (paths) {
    return makeArray(paths).filter(this.createFilter())
  }

  // @returns {TestResult}
  test (path) {
    return this._test(path, this._testCache, true)
  }
}

const factory = options => new Ignore(options);

const returnFalse = () => false;

const isPathValid = path =>
  checkPath(path && checkPath.convert(path), path, returnFalse);

factory.isPathValid = isPathValid;

// Fixes typescript
factory.default = factory;

var ignore = factory;

// Windows
// --------------------------------------------------------------
/* istanbul ignore if  */
if (
  // Detect `process` so that it can run in browsers.
  typeof process !== 'undefined'
  && (
    process.env && process.env.IGNORE_TEST_WIN32
    || process.platform === 'win32'
  )
) {
  /* eslint no-control-regex: "off" */
  const makePosix = str => /^\\\\\?\\/.test(str)
  || /["<>|\u0000-\u001F]+/u.test(str)
    ? str
    : str.replace(/\\/g, '/');

  checkPath.convert = makePosix;

  // 'C:\\foo'     <- 'C:\\foo' has been converted to 'C:/'
  // 'd:\\foo'
  const REGIX_IS_WINDOWS_PATH_ABSOLUTE = /^[a-z]:\//i;
  checkPath.isNotRelative = path =>
    REGIX_IS_WINDOWS_PATH_ABSOLUTE.test(path)
    || isNotRelative(path);
}

const processFn = (fn, options) => function (...args) {
	const P = options.promiseModule;

	return new P((resolve, reject) => {
		if (options.multiArgs) {
			args.push((...result) => {
				if (options.errorFirst) {
					if (result[0]) {
						reject(result);
					} else {
						result.shift();
						resolve(result);
					}
				} else {
					resolve(result);
				}
			});
		} else if (options.errorFirst) {
			args.push((error, result) => {
				if (error) {
					reject(error);
				} else {
					resolve(result);
				}
			});
		} else {
			args.push(resolve);
		}

		fn.apply(this, args);
	});
};

var pify = (input, options) => {
	options = Object.assign({
		exclude: [/.+(Sync|Stream)$/],
		errorFirst: true,
		promiseModule: Promise
	}, options);

	const objType = typeof input;
	if (!(input !== null && (objType === 'object' || objType === 'function'))) {
		throw new TypeError(`Expected \`input\` to be a \`Function\` or \`Object\`, got \`${input === null ? 'null' : objType}\``);
	}

	const filter = key => {
		const match = pattern => typeof pattern === 'string' ? key === pattern : pattern.test(key);
		return options.include ? options.include.some(match) : !options.exclude.some(match);
	};

	let ret;
	if (objType === 'function') {
		ret = function (...args) {
			return options.excludeMain ? input(...args) : processFn(input, options).apply(this, args);
		};
	} else {
		ret = Object.create(Object.getPrototypeOf(input));
	}

	for (const key in input) { // eslint-disable-line guard-for-in
		const property = input[key];
		ret[key] = typeof property === 'function' && filter(key) ? processFn(property, options) : property;
	}

	return ret;
};

function escapeRegExp(string) {
  return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'); // $& means the whole matched string
}

function replaceAll(str, search, replacement) {
  search = search instanceof RegExp ? search : new RegExp(escapeRegExp(search), 'g');

  return str.replace(search, replacement);
}

var CleanGitRef = {
  clean: function clean(value) {
    if (typeof value !== 'string') {
      throw new Error('Expected a string, received: ' + value);
    }

    value = replaceAll(value, './', '/');
    value = replaceAll(value, '..', '.');
    value = replaceAll(value, ' ', '-');
    value = replaceAll(value, /^[~^:?*\\\-]/g, '');
    value = replaceAll(value, /[~^:?*\\]/g, '-');
    value = replaceAll(value, /[~^:?*\\\-]$/g, '');
    value = replaceAll(value, '@{', '-');
    value = replaceAll(value, /\.$/g, '');
    value = replaceAll(value, /\/$/g, '');
    value = replaceAll(value, /\.lock$/g, '');
    return value;
  }
};

var lib = CleanGitRef;

/*
 * URL: https://github.com/cubicdaiya/onp
 *
 * Copyright (c) 2013 Tatsuhiko Kubo <cubicdaiya@gmail.com>
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the "Software"), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
/**
 * The algorithm implemented here is based on "An O(NP) Sequence Comparison Algorithm"
 * by described by Sun Wu, Udi Manber and Gene Myers
*/
var onp = function (a_, b_) {
    var a          = a_,
        b          = b_,
        m          = a.length,
        n          = b.length,
        reverse    = false,
        ed         = null,
        offset     = m + 1,
        path       = [],
        pathposi   = [],
        ses        = [],
        lcs        = "",
        SES_DELETE = -1,
        SES_COMMON = 0,
        SES_ADD    = 1;

    var tmp1,
        tmp2;

    var init = function () {
        if (m >= n) {
            tmp1    = a;
            tmp2    = m;
            a       = b;
            b       = tmp1;
            m       = n;
            n       = tmp2;
            reverse = true;
            offset = m + 1;
        }
    };

    var P = function (x, y, k) {
        return {
            'x' : x,
            'y' : y,
            'k' : k,
        };
    };

    var seselem = function (elem, t) {
        return {
            'elem' : elem,
            't'    : t,
        };
    };

    var snake = function (k, p, pp) {
        var r, x, y;
        if (p > pp) {
            r = path[k-1+offset];
        } else {
            r = path[k+1+offset];
        }

        y = Math.max(p, pp);
        x = y - k;
        while (x < m && y < n && a[x] === b[y]) {
            ++x;
            ++y;
        }

        path[k+offset] = pathposi.length;
        pathposi[pathposi.length] = new P(x, y, r);
        return y;
    };

    var recordseq = function (epc) {
        var px_idx, py_idx, i;
        px_idx = py_idx = 0;
        for (i=epc.length-1;i>=0;--i) {
            while(px_idx < epc[i].x || py_idx < epc[i].y) {
                if (epc[i].y - epc[i].x > py_idx - px_idx) {
                    if (reverse) {
                        ses[ses.length] = new seselem(b[py_idx], SES_DELETE);
                    } else {
                        ses[ses.length] = new seselem(b[py_idx], SES_ADD);
                    }
                    ++py_idx;
                } else if (epc[i].y - epc[i].x < py_idx - px_idx) {
                    if (reverse) {
                        ses[ses.length] = new seselem(a[px_idx], SES_ADD);
                    } else {
                        ses[ses.length] = new seselem(a[px_idx], SES_DELETE);
                    }
                    ++px_idx;
                } else {
                    ses[ses.length] = new seselem(a[px_idx], SES_COMMON);
                    lcs += a[px_idx];
                    ++px_idx;
                    ++py_idx;
                }
            }
        }
    };

    init();

    return {
        SES_DELETE : -1,
        SES_COMMON :  0,
        SES_ADD    :  1,
        editdistance : function () {
            return ed;
        },
        getlcs : function () {
            return lcs;
        },
        getses : function () {
            return ses;
        },
        compose : function () {
            var delta, size, fp, p, r, epc, i, k;
            delta  = n - m;
            size   = m + n + 3;
            fp     = {};
            for (i=0;i<size;++i) {
                fp[i] = -1;
                path[i] = -1;
            }
            p = -1;
            do {
                ++p;
                for (k=-p;k<=delta-1;++k) {
                    fp[k+offset] = snake(k, fp[k-1+offset]+1, fp[k+1+offset]);
                }
                for (k=delta+p;k>=delta+1;--k) {
                    fp[k+offset] = snake(k, fp[k-1+offset]+1, fp[k+1+offset]);
                }
                fp[delta+offset] = snake(delta, fp[delta-1+offset]+1, fp[delta+1+offset]);
            } while (fp[delta+offset] !== n);

            ed = delta + 2 * p;

            r = path[delta+offset];

            epc  = [];
            while (r !== -1) {
                epc[epc.length] = new P(pathposi[r].x, pathposi[r].y, null);
                r = pathposi[r].k;
            }
            recordseq(epc);
        }
    };
};

// Copyright (c) 2006, 2008 Tony Garnock-Jones <tonyg@lshift.net>
// Copyright (c) 2006, 2008 LShift Ltd. <query@lshift.net>
//
// Permission is hereby granted, free of charge, to any person
// obtaining a copy of this software and associated documentation files
// (the "Software"), to deal in the Software without restriction,
// including without limitation the rights to use, copy, modify, merge,
// publish, distribute, sublicense, and/or sell copies of the Software,
// and to permit persons to whom the Software is furnished to do so,
// subject to the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
// BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
// CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.



function longestCommonSubsequence(file1, file2) {
  var diff = new onp(file1, file2);
  diff.compose();
  var ses = diff.getses();

  var root;
  var prev;
  var file1RevIdx = file1.length - 1,
      file2RevIdx = file2.length - 1;
  for (var i = ses.length - 1; i >= 0; --i) {
      if (ses[i].t === diff.SES_COMMON) {
        if (prev) {
          prev.chain = {
            file1index: file1RevIdx,
            file2index: file2RevIdx,
            chain: null
          };
          prev = prev.chain;
        } else {
          root = {
            file1index: file1RevIdx,
            file2index: file2RevIdx,
            chain: null
          };
          prev = root;
        }
        file1RevIdx--;
        file2RevIdx--;
      } else if (ses[i].t === diff.SES_DELETE) {
        file1RevIdx--;
      } else if (ses[i].t === diff.SES_ADD) {
        file2RevIdx--;
      }
  }

  var tail = {
    file1index: -1,
    file2index: -1,
    chain: null
  };

  if (!prev) {
    return tail;
  }

  prev.chain = tail;

  return root;
}

function diffIndices(file1, file2) {
  // We apply the LCS to give a simple representation of the
  // offsets and lengths of mismatched chunks in the input
  // files. This is used by diff3_merge_indices below.

  var result = [];
  var tail1 = file1.length;
  var tail2 = file2.length;

  for (var candidate = longestCommonSubsequence(file1, file2); candidate !== null; candidate = candidate.chain) {
    var mismatchLength1 = tail1 - candidate.file1index - 1;
    var mismatchLength2 = tail2 - candidate.file2index - 1;
    tail1 = candidate.file1index;
    tail2 = candidate.file2index;

    if (mismatchLength1 || mismatchLength2) {
      result.push({
        file1: [tail1 + 1, mismatchLength1],
        file2: [tail2 + 1, mismatchLength2]
      });
    }
  }

  result.reverse();
  return result;
}

function diff3MergeIndices(a, o, b) {
  // Given three files, A, O, and B, where both A and B are
  // independently derived from O, returns a fairly complicated
  // internal representation of merge decisions it's taken. The
  // interested reader may wish to consult
  //
  // Sanjeev Khanna, Keshav Kunal, and Benjamin C. Pierce. "A
  // Formal Investigation of Diff3." In Arvind and Prasad,
  // editors, Foundations of Software Technology and Theoretical
  // Computer Science (FSTTCS), December 2007.
  //
  // (http://www.cis.upenn.edu/~bcpierce/papers/diff3-short.pdf)
  var i;

  var m1 = diffIndices(o, a);
  var m2 = diffIndices(o, b);

  var hunks = [];

  function addHunk(h, side) {
    hunks.push([h.file1[0], side, h.file1[1], h.file2[0], h.file2[1]]);
  }
  for (i = 0; i < m1.length; i++) {
    addHunk(m1[i], 0);
  }
  for (i = 0; i < m2.length; i++) {
    addHunk(m2[i], 2);
  }
  hunks.sort(function(x, y) {
    return x[0] - y[0]
  });

  var result = [];
  var commonOffset = 0;

  function copyCommon(targetOffset) {
    if (targetOffset > commonOffset) {
      result.push([1, commonOffset, targetOffset - commonOffset]);
      commonOffset = targetOffset;
    }
  }

  for (var hunkIndex = 0; hunkIndex < hunks.length; hunkIndex++) {
    var firstHunkIndex = hunkIndex;
    var hunk = hunks[hunkIndex];
    var regionLhs = hunk[0];
    var regionRhs = regionLhs + hunk[2];
    while (hunkIndex < hunks.length - 1) {
      var maybeOverlapping = hunks[hunkIndex + 1];
      var maybeLhs = maybeOverlapping[0];
      if (maybeLhs > regionRhs) break;
      regionRhs = Math.max(regionRhs, maybeLhs + maybeOverlapping[2]);
      hunkIndex++;
    }

    copyCommon(regionLhs);
    if (firstHunkIndex == hunkIndex) {
      // The "overlap" was only one hunk long, meaning that
      // there's no conflict here. Either a and o were the
      // same, or b and o were the same.
      if (hunk[4] > 0) {
        result.push([hunk[1], hunk[3], hunk[4]]);
      }
    } else {
      // A proper conflict. Determine the extents of the
      // regions involved from a, o and b. Effectively merge
      // all the hunks on the left into one giant hunk, and
      // do the same for the right; then, correct for skew
      // in the regions of o that each side changed, and
      // report appropriate spans for the three sides.
      var regions = {
        0: [a.length, -1, o.length, -1],
        2: [b.length, -1, o.length, -1]
      };
      for (i = firstHunkIndex; i <= hunkIndex; i++) {
        hunk = hunks[i];
        var side = hunk[1];
        var r = regions[side];
        var oLhs = hunk[0];
        var oRhs = oLhs + hunk[2];
        var abLhs = hunk[3];
        var abRhs = abLhs + hunk[4];
        r[0] = Math.min(abLhs, r[0]);
        r[1] = Math.max(abRhs, r[1]);
        r[2] = Math.min(oLhs, r[2]);
        r[3] = Math.max(oRhs, r[3]);
      }
      var aLhs = regions[0][0] + (regionLhs - regions[0][2]);
      var aRhs = regions[0][1] + (regionRhs - regions[0][3]);
      var bLhs = regions[2][0] + (regionLhs - regions[2][2]);
      var bRhs = regions[2][1] + (regionRhs - regions[2][3]);
      result.push([-1,
        aLhs, aRhs - aLhs,
        regionLhs, regionRhs - regionLhs,
        bLhs, bRhs - bLhs
      ]);
    }
    commonOffset = regionRhs;
  }

  copyCommon(o.length);
  return result;
}

function diff3Merge(a, o, b) {
  // Applies the output of Diff.diff3_merge_indices to actually
  // construct the merged file; the returned result alternates
  // between "ok" and "conflict" blocks.

  var result = [];
  var files = [a, o, b];
  var indices = diff3MergeIndices(a, o, b);

  var okLines = [];

  function flushOk() {
    if (okLines.length) {
      result.push({
        ok: okLines
      });
    }
    okLines = [];
  }

  function pushOk(xs) {
    for (var j = 0; j < xs.length; j++) {
      okLines.push(xs[j]);
    }
  }

  function isTrueConflict(rec) {
    if (rec[2] != rec[6]) return true;
    var aoff = rec[1];
    var boff = rec[5];
    for (var j = 0; j < rec[2]; j++) {
      if (a[j + aoff] != b[j + boff]) return true;
    }
    return false;
  }

  for (var i = 0; i < indices.length; i++) {
    var x = indices[i];
    var side = x[0];
    if (side == -1) {
      if (!isTrueConflict(x)) {
        pushOk(files[0].slice(x[1], x[1] + x[2]));
      } else {
        flushOk();
        result.push({
          conflict: {
            a: a.slice(x[1], x[1] + x[2]),
            aIndex: x[1],
            o: o.slice(x[3], x[3] + x[4]),
            oIndex: x[3],
            b: b.slice(x[5], x[5] + x[6]),
            bIndex: x[5]
          }
        });
      }
    } else {
      pushOk(files[side].slice(x[1], x[1] + x[2]));
    }
  }

  flushOk();
  return result;
}

var diff3 = diff3Merge;

/**
 * @typedef {Object} GitProgressEvent
 * @property {string} phase
 * @property {number} loaded
 * @property {number} total
 */

/**
 * @callback ProgressCallback
 * @param {GitProgressEvent} progress
 * @returns {void | Promise<void>}
 */

/**
 * @typedef {Object} GitHttpRequest
 * @property {string} url - The URL to request
 * @property {string} [method='GET'] - The HTTP method to use
 * @property {Object<string, string>} [headers={}] - Headers to include in the HTTP request
 * @property {AsyncIterableIterator<Uint8Array>} [body] - An async iterator of Uint8Arrays that make up the body of POST requests
 * @property {ProgressCallback} [onProgress] - Reserved for future use (emitting `GitProgressEvent`s)
 * @property {object} [signal] - Reserved for future use (canceling a request)
 */

/**
 * @typedef {Object} GitHttpResponse
 * @property {string} url - The final URL that was fetched after any redirects
 * @property {string} [method] - The HTTP method that was used
 * @property {Object<string, string>} [headers] - HTTP response headers
 * @property {AsyncIterableIterator<Uint8Array>} [body] - An async iterator of Uint8Arrays that make up the body of the response
 * @property {number} statusCode - The HTTP status code
 * @property {string} statusMessage - The HTTP status message
 */

/**
 * @callback HttpFetch
 * @param {GitHttpRequest} request
 * @returns {Promise<GitHttpResponse>}
 */

/**
 * @typedef {Object} HttpClient
 * @property {HttpFetch} request
 */

/**
 * A git commit object.
 *
 * @typedef {Object} CommitObject
 * @property {string} message Commit message
 * @property {string} tree SHA-1 object id of corresponding file tree
 * @property {string[]} parent an array of zero or more SHA-1 object ids
 * @property {Object} author
 * @property {string} author.name The author's name
 * @property {string} author.email The author's email
 * @property {number} author.timestamp UTC Unix timestamp in seconds
 * @property {number} author.timezoneOffset Timezone difference from UTC in minutes
 * @property {Object} committer
 * @property {string} committer.name The committer's name
 * @property {string} committer.email The committer's email
 * @property {number} committer.timestamp UTC Unix timestamp in seconds
 * @property {number} committer.timezoneOffset Timezone difference from UTC in minutes
 * @property {string} [gpgsig] PGP signature (if present)
 */

/**
 * An entry from a git tree object. Files are called 'blobs' and directories are called 'trees'.
 *
 * @typedef {Object} TreeEntry
 * @property {string} mode the 6 digit hexadecimal mode
 * @property {string} path the name of the file or directory
 * @property {string} oid the SHA-1 object id of the blob or tree
 * @property {'commit'|'blob'|'tree'} type the type of object
 */

/**
 * A git tree object. Trees represent a directory snapshot.
 *
 * @typedef {TreeEntry[]} TreeObject
 */

/**
 * A git annotated tag object.
 *
 * @typedef {Object} TagObject
 * @property {string} object SHA-1 object id of object being tagged
 * @property {'blob' | 'tree' | 'commit' | 'tag'} type the type of the object being tagged
 * @property {string} tag the tag name
 * @property {Object} tagger
 * @property {string} tagger.name the tagger's name
 * @property {string} tagger.email the tagger's email
 * @property {number} tagger.timestamp UTC Unix timestamp in seconds
 * @property {number} tagger.timezoneOffset timezone difference from UTC in minutes
 * @property {string} message tag message
 * @property {string} [gpgsig] PGP signature (if present)
 */

/**
 * @typedef {Object} ReadCommitResult
 * @property {string} oid - SHA-1 object id of this commit
 * @property {CommitObject} commit - the parsed commit object
 * @property {string} payload - PGP signing payload
 */

/**
 * @typedef {Object} ServerRef - This object has the following schema:
 * @property {string} ref - The name of the ref
 * @property {string} oid - The SHA-1 object id the ref points to
 * @property {string} [target] - The target ref pointed to by a symbolic ref
 * @property {string} [peeled] - If the oid is the SHA-1 object id of an annotated tag, this is the SHA-1 object id that the annotated tag points to
 */

/**
 * @typedef Walker
 * @property {Symbol} Symbol('GitWalkerSymbol')
 */

/**
 * Normalized subset of filesystem `stat` data:
 *
 * @typedef {Object} Stat
 * @property {number} ctimeSeconds
 * @property {number} ctimeNanoseconds
 * @property {number} mtimeSeconds
 * @property {number} mtimeNanoseconds
 * @property {number} dev
 * @property {number} ino
 * @property {number} mode
 * @property {number} uid
 * @property {number} gid
 * @property {number} size
 */

/**
 * The `WalkerEntry` is an interface that abstracts computing many common tree / blob stats.
 *
 * @typedef {Object} WalkerEntry
 * @property {function(): Promise<'tree'|'blob'|'special'|'commit'>} type
 * @property {function(): Promise<number>} mode
 * @property {function(): Promise<string>} oid
 * @property {function(): Promise<Uint8Array|void>} content
 * @property {function(): Promise<Stat>} stat
 */

/**
 * @typedef {Object} CallbackFsClient
 * @property {function} readFile - https://nodejs.org/api/fs.html#fs_fs_readfile_path_options_callback
 * @property {function} writeFile - https://nodejs.org/api/fs.html#fs_fs_writefile_file_data_options_callback
 * @property {function} unlink - https://nodejs.org/api/fs.html#fs_fs_unlink_path_callback
 * @property {function} readdir - https://nodejs.org/api/fs.html#fs_fs_readdir_path_options_callback
 * @property {function} mkdir - https://nodejs.org/api/fs.html#fs_fs_mkdir_path_mode_callback
 * @property {function} rmdir - https://nodejs.org/api/fs.html#fs_fs_rmdir_path_callback
 * @property {function} stat - https://nodejs.org/api/fs.html#fs_fs_stat_path_options_callback
 * @property {function} lstat - https://nodejs.org/api/fs.html#fs_fs_lstat_path_options_callback
 * @property {function} [readlink] - https://nodejs.org/api/fs.html#fs_fs_readlink_path_options_callback
 * @property {function} [symlink] - https://nodejs.org/api/fs.html#fs_fs_symlink_target_path_type_callback
 * @property {function} [chmod] - https://nodejs.org/api/fs.html#fs_fs_chmod_path_mode_callback
 */

/**
 * @typedef {Object} PromiseFsClient
 * @property {Object} promises
 * @property {function} promises.readFile - https://nodejs.org/api/fs.html#fs_fspromises_readfile_path_options
 * @property {function} promises.writeFile - https://nodejs.org/api/fs.html#fs_fspromises_writefile_file_data_options
 * @property {function} promises.unlink - https://nodejs.org/api/fs.html#fs_fspromises_unlink_path
 * @property {function} promises.readdir - https://nodejs.org/api/fs.html#fs_fspromises_readdir_path_options
 * @property {function} promises.mkdir - https://nodejs.org/api/fs.html#fs_fspromises_mkdir_path_options
 * @property {function} promises.rmdir - https://nodejs.org/api/fs.html#fs_fspromises_rmdir_path
 * @property {function} promises.stat - https://nodejs.org/api/fs.html#fs_fspromises_stat_path_options
 * @property {function} promises.lstat - https://nodejs.org/api/fs.html#fs_fspromises_lstat_path_options
 * @property {function} [promises.readlink] - https://nodejs.org/api/fs.html#fs_fspromises_readlink_path_options
 * @property {function} [promises.symlink] - https://nodejs.org/api/fs.html#fs_fspromises_symlink_target_path_type
 * @property {function} [promises.chmod] - https://nodejs.org/api/fs.html#fs_fspromises_chmod_path_mode
 */

/**
 * @typedef {CallbackFsClient | PromiseFsClient} FsClient
 */

/**
 * @callback MessageCallback
 * @param {string} message
 * @returns {void | Promise<void>}
 */

/**
 * @typedef {Object} GitAuth
 * @property {string} [username]
 * @property {string} [password]
 * @property {Object<string, string>} [headers]
 * @property {boolean} [cancel] Tells git to throw a `UserCanceledError` (instead of an `HttpError`).
 */

/**
 * @callback AuthCallback
 * @param {string} url
 * @param {GitAuth} auth Might have some values if the URL itself originally contained a username or password.
 * @returns {GitAuth | void | Promise<GitAuth | void>}
 */

/**
 * @callback AuthFailureCallback
 * @param {string} url
 * @param {GitAuth} auth The credentials that failed
 * @returns {GitAuth | void | Promise<GitAuth | void>}
 */

/**
 * @callback AuthSuccessCallback
 * @param {string} url
 * @param {GitAuth} auth
 * @returns {void | Promise<void>}
 */

/**
 * @typedef {Object} SignParams
 * @property {string} payload - a plaintext message
 * @property {string} secretKey - an 'ASCII armor' encoded PGP key (technically can actually contain _multiple_ keys)
 */

/**
 * @callback SignCallback
 * @param {SignParams} args
 * @return {{signature: string} | Promise<{signature: string}>} - an 'ASCII armor' encoded "detached" signature
 */

/**
 * @callback WalkerMap
 * @param {string} filename
 * @param {WalkerEntry[]} entries
 * @returns {Promise<any>}
 */

/**
 * @callback WalkerReduce
 * @param {any} parent
 * @param {any[]} children
 * @returns {Promise<any>}
 */

/**
 * @callback WalkerIterateCallback
 * @param {WalkerEntry[]} entries
 * @returns {Promise<any[]>}
 */

/**
 * @callback WalkerIterate
 * @param {WalkerIterateCallback} walk
 * @param {IterableIterator<WalkerEntry[]>} children
 * @returns {Promise<any[]>}
 */

/**
 * @typedef {Object} RefUpdateStatus
 * @property {boolean} ok
 * @property {string} error
 */

/**
 * @typedef {Object} PushResult
 * @property {boolean} ok
 * @property {?string} error
 * @property {Object<string, RefUpdateStatus>} refs
 * @property {Object<string, string>} [headers]
 */

/**
 * @typedef {0|1} HeadStatus
 */

/**
 * @typedef {0|1|2} WorkdirStatus
 */

/**
 * @typedef {0|1|2|3} StageStatus
 */

/**
 * @typedef {[string, HeadStatus, WorkdirStatus, StageStatus]} StatusRow
 */

class BaseError extends Error {
  constructor(message) {
    super(message);
    // Setting this here allows TS to infer that all git errors have a `caller` property and
    // that its type is string.
    this.caller = '';
  }

  toJSON() {
    // Error objects aren't normally serializable. So we do something about that.
    return {
      code: this.code,
      data: this.data,
      caller: this.caller,
      message: this.message,
      stack: this.stack,
    }
  }

  fromJSON(json) {
    const e = new BaseError(json.message);
    e.code = json.code;
    e.data = json.data;
    e.caller = json.caller;
    e.stack = json.stack;
    return e
  }

  get isIsomorphicGitError() {
    return true
  }
}

class InternalError extends BaseError {
  /**
   * @param {string} message
   */
  constructor(message) {
    super(
      `An internal error caused this command to fail. Please file a bug report at https://github.com/isomorphic-git/isomorphic-git/issues with this error message: ${message}`
    );
    this.code = this.name = InternalError.code;
    this.data = { message };
  }
}
/** @type {'InternalError'} */
InternalError.code = 'InternalError';

// Modeled after https://github.com/tjfontaine/node-buffercursor
// but with the goal of being much lighter weight.
class BufferCursor {
  constructor(buffer) {
    this.buffer = buffer;
    this._start = 0;
  }

  eof() {
    return this._start >= this.buffer.length
  }

  tell() {
    return this._start
  }

  seek(n) {
    this._start = n;
  }

  slice(n) {
    const r = this.buffer.slice(this._start, this._start + n);
    this._start += n;
    return r
  }

  toString(enc, length) {
    const r = this.buffer.toString(enc, this._start, this._start + length);
    this._start += length;
    return r
  }

  write(value, length, enc) {
    const r = this.buffer.write(value, this._start, length, enc);
    this._start += length;
    return r
  }

  copy(source, start, end) {
    const r = source.copy(this.buffer, this._start, start, end);
    this._start += r;
    return r
  }

  readUInt8() {
    const r = this.buffer.readUInt8(this._start);
    this._start += 1;
    return r
  }

  writeUInt8(value) {
    const r = this.buffer.writeUInt8(value, this._start);
    this._start += 1;
    return r
  }

  readUInt16BE() {
    const r = this.buffer.readUInt16BE(this._start);
    this._start += 2;
    return r
  }

  writeUInt16BE(value) {
    const r = this.buffer.writeUInt16BE(value, this._start);
    this._start += 2;
    return r
  }

  readUInt32BE() {
    const r = this.buffer.readUInt32BE(this._start);
    this._start += 4;
    return r
  }

  writeUInt32BE(value) {
    const r = this.buffer.writeUInt32BE(value, this._start);
    this._start += 4;
    return r
  }
}

function compareStrings(a, b) {
  // https://stackoverflow.com/a/40355107/2168416
  return -(a < b) || +(a > b)
}

function comparePath(a, b) {
  // https://stackoverflow.com/a/40355107/2168416
  return compareStrings(a.path, b.path)
}

/**
 * From https://github.com/git/git/blob/master/Documentation/technical/index-format.txt
 *
 * 32-bit mode, split into (high to low bits)
 *
 *  4-bit object type
 *    valid values in binary are 1000 (regular file), 1010 (symbolic link)
 *    and 1110 (gitlink)
 *
 *  3-bit unused
 *
 *  9-bit unix permission. Only 0755 and 0644 are valid for regular files.
 *  Symbolic links and gitlinks have value 0 in this field.
 */
function normalizeMode(mode) {
  // Note: BrowserFS will use -1 for "unknown"
  // I need to make it non-negative for these bitshifts to work.
  let type = mode > 0 ? mode >> 12 : 0;
  // If it isn't valid, assume it as a "regular file"
  // 0100 = directory
  // 1000 = regular file
  // 1010 = symlink
  // 1110 = gitlink
  if (
    type !== 0b0100 &&
    type !== 0b1000 &&
    type !== 0b1010 &&
    type !== 0b1110
  ) {
    type = 0b1000;
  }
  let permissions = mode & 0o777;
  // Is the file executable? then 755. Else 644.
  if (permissions & 0b001001001) {
    permissions = 0o755;
  } else {
    permissions = 0o644;
  }
  // If it's not a regular file, scrub all permissions
  if (type !== 0b1000) permissions = 0;
  return (type << 12) + permissions
}

const MAX_UINT32 = 2 ** 32;

function SecondsNanoseconds(
  givenSeconds,
  givenNanoseconds,
  milliseconds,
  date
) {
  if (givenSeconds !== undefined && givenNanoseconds !== undefined) {
    return [givenSeconds, givenNanoseconds]
  }
  if (milliseconds === undefined) {
    milliseconds = date.valueOf();
  }
  const seconds = Math.floor(milliseconds / 1000);
  const nanoseconds = (milliseconds - seconds * 1000) * 1000000;
  return [seconds, nanoseconds]
}

function normalizeStats(e) {
  const [ctimeSeconds, ctimeNanoseconds] = SecondsNanoseconds(
    e.ctimeSeconds,
    e.ctimeNanoseconds,
    e.ctimeMs,
    e.ctime
  );
  const [mtimeSeconds, mtimeNanoseconds] = SecondsNanoseconds(
    e.mtimeSeconds,
    e.mtimeNanoseconds,
    e.mtimeMs,
    e.mtime
  );

  return {
    ctimeSeconds: ctimeSeconds % MAX_UINT32,
    ctimeNanoseconds: ctimeNanoseconds % MAX_UINT32,
    mtimeSeconds: mtimeSeconds % MAX_UINT32,
    mtimeNanoseconds: mtimeNanoseconds % MAX_UINT32,
    dev: e.dev % MAX_UINT32,
    ino: e.ino % MAX_UINT32,
    mode: normalizeMode(e.mode % MAX_UINT32),
    uid: e.uid % MAX_UINT32,
    gid: e.gid % MAX_UINT32,
    // size of -1 happens over a BrowserFS HTTP Backend that doesn't serve Content-Length headers
    // (like the Karma webserver) because BrowserFS HTTP Backend uses HTTP HEAD requests to do fs.stat
    size: e.size > -1 ? e.size % MAX_UINT32 : 0,
  }
}

function toHex(buffer) {
  let hex = '';
  for (const byte of new Uint8Array(buffer)) {
    if (byte < 16) hex += '0';
    hex += byte.toString(16);
  }
  return hex
}

/* eslint-env node, browser */

let supportsSubtleSHA1 = null;

async function shasum(buffer) {
  if (supportsSubtleSHA1 === null) {
    supportsSubtleSHA1 = await testSubtleSHA1();
  }
  return supportsSubtleSHA1 ? subtleSHA1(buffer) : shasumSync(buffer)
}

// This is modeled after @dominictarr's "shasum" module,
// but without the 'json-stable-stringify' dependency and
// extra type-casting features.
function shasumSync(buffer) {
  return new sha1().update(buffer).digest('hex')
}

async function subtleSHA1(buffer) {
  const hash = await crypto.subtle.digest('SHA-1', buffer);
  return toHex(hash)
}

async function testSubtleSHA1() {
  // I'm using a rather crude method of progressive enhancement, because
  // some browsers that have crypto.subtle.digest don't actually implement SHA-1.
  try {
    const hash = await subtleSHA1(new Uint8Array([]));
    if (hash === 'da39a3ee5e6b4b0d3255bfef95601890afd80709') return true
  } catch (_) {
    // no bother
  }
  return false
}

// Extract 1-bit assume-valid, 1-bit extended flag, 2-bit merge state flag, 12-bit path length flag
function parseCacheEntryFlags(bits) {
  return {
    assumeValid: Boolean(bits & 0b1000000000000000),
    extended: Boolean(bits & 0b0100000000000000),
    stage: (bits & 0b0011000000000000) >> 12,
    nameLength: bits & 0b0000111111111111,
  }
}

function renderCacheEntryFlags(entry) {
  const flags = entry.flags;
  // 1-bit extended flag (must be zero in version 2)
  flags.extended = false;
  // 12-bit name length if the length is less than 0xFFF; otherwise 0xFFF
  // is stored in this field.
  flags.nameLength = Math.min(Buffer.from(entry.path).length, 0xfff);
  return (
    (flags.assumeValid ? 0b1000000000000000 : 0) +
    (flags.extended ? 0b0100000000000000 : 0) +
    ((flags.stage & 0b11) << 12) +
    (flags.nameLength & 0b111111111111)
  )
}

class GitIndex {
  /*::
   _entries: Map<string, CacheEntry>
   _dirty: boolean // Used to determine if index needs to be saved to filesystem
   */
  constructor(entries) {
    this._dirty = false;
    this._entries = entries || new Map();
  }

  static async from(buffer) {
    if (Buffer.isBuffer(buffer)) {
      return GitIndex.fromBuffer(buffer)
    } else if (buffer === null) {
      return new GitIndex(null)
    } else {
      throw new InternalError('invalid type passed to GitIndex.from')
    }
  }

  static async fromBuffer(buffer) {
    // Verify shasum
    const shaComputed = await shasum(buffer.slice(0, -20));
    const shaClaimed = buffer.slice(-20).toString('hex');
    if (shaClaimed !== shaComputed) {
      throw new InternalError(
        `Invalid checksum in GitIndex buffer: expected ${shaClaimed} but saw ${shaComputed}`
      )
    }
    const reader = new BufferCursor(buffer);
    const _entries = new Map();
    const magic = reader.toString('utf8', 4);
    if (magic !== 'DIRC') {
      throw new InternalError(`Inavlid dircache magic file number: ${magic}`)
    }
    const version = reader.readUInt32BE();
    if (version !== 2) {
      throw new InternalError(`Unsupported dircache version: ${version}`)
    }
    const numEntries = reader.readUInt32BE();
    let i = 0;
    while (!reader.eof() && i < numEntries) {
      const entry = {};
      entry.ctimeSeconds = reader.readUInt32BE();
      entry.ctimeNanoseconds = reader.readUInt32BE();
      entry.mtimeSeconds = reader.readUInt32BE();
      entry.mtimeNanoseconds = reader.readUInt32BE();
      entry.dev = reader.readUInt32BE();
      entry.ino = reader.readUInt32BE();
      entry.mode = reader.readUInt32BE();
      entry.uid = reader.readUInt32BE();
      entry.gid = reader.readUInt32BE();
      entry.size = reader.readUInt32BE();
      entry.oid = reader.slice(20).toString('hex');
      const flags = reader.readUInt16BE();
      entry.flags = parseCacheEntryFlags(flags);
      // TODO: handle if (version === 3 && entry.flags.extended)
      const pathlength = buffer.indexOf(0, reader.tell() + 1) - reader.tell();
      if (pathlength < 1) {
        throw new InternalError(`Got a path length of: ${pathlength}`)
      }
      // TODO: handle pathnames larger than 12 bits
      entry.path = reader.toString('utf8', pathlength);
      // The next bit is awkward. We expect 1 to 8 null characters
      // such that the total size of the entry is a multiple of 8 bits.
      // (Hence subtract 12 bytes for the header.)
      let padding = 8 - ((reader.tell() - 12) % 8);
      if (padding === 0) padding = 8;
      while (padding--) {
        const tmp = reader.readUInt8();
        if (tmp !== 0) {
          throw new InternalError(
            `Expected 1-8 null characters but got '${tmp}' after ${entry.path}`
          )
        } else if (reader.eof()) {
          throw new InternalError('Unexpected end of file')
        }
      }
      // end of awkward part
      _entries.set(entry.path, entry);
      i++;
    }
    return new GitIndex(_entries)
  }

  get entries() {
    return [...this._entries.values()].sort(comparePath)
  }

  get entriesMap() {
    return this._entries
  }

  *[Symbol.iterator]() {
    for (const entry of this.entries) {
      yield entry;
    }
  }

  insert({ filepath, stats, oid }) {
    stats = normalizeStats(stats);
    const bfilepath = Buffer.from(filepath);
    const entry = {
      ctimeSeconds: stats.ctimeSeconds,
      ctimeNanoseconds: stats.ctimeNanoseconds,
      mtimeSeconds: stats.mtimeSeconds,
      mtimeNanoseconds: stats.mtimeNanoseconds,
      dev: stats.dev,
      ino: stats.ino,
      // We provide a fallback value for `mode` here because not all fs
      // implementations assign it, but we use it in GitTree.
      // '100644' is for a "regular non-executable file"
      mode: stats.mode || 0o100644,
      uid: stats.uid,
      gid: stats.gid,
      size: stats.size,
      path: filepath,
      oid: oid,
      flags: {
        assumeValid: false,
        extended: false,
        stage: 0,
        nameLength: bfilepath.length < 0xfff ? bfilepath.length : 0xfff,
      },
    };
    this._entries.set(entry.path, entry);
    this._dirty = true;
  }

  delete({ filepath }) {
    if (this._entries.has(filepath)) {
      this._entries.delete(filepath);
    } else {
      for (const key of this._entries.keys()) {
        if (key.startsWith(filepath + '/')) {
          this._entries.delete(key);
        }
      }
    }
    this._dirty = true;
  }

  clear() {
    this._entries.clear();
    this._dirty = true;
  }

  render() {
    return this.entries
      .map(entry => `${entry.mode.toString(8)} ${entry.oid}    ${entry.path}`)
      .join('\n')
  }

  async toObject() {
    const header = Buffer.alloc(12);
    const writer = new BufferCursor(header);
    writer.write('DIRC', 4, 'utf8');
    writer.writeUInt32BE(2);
    writer.writeUInt32BE(this.entries.length);
    const body = Buffer.concat(
      this.entries.map(entry => {
        const bpath = Buffer.from(entry.path);
        // the fixed length + the filename + at least one null char => align by 8
        const length = Math.ceil((62 + bpath.length + 1) / 8) * 8;
        const written = Buffer.alloc(length);
        const writer = new BufferCursor(written);
        const stat = normalizeStats(entry);
        writer.writeUInt32BE(stat.ctimeSeconds);
        writer.writeUInt32BE(stat.ctimeNanoseconds);
        writer.writeUInt32BE(stat.mtimeSeconds);
        writer.writeUInt32BE(stat.mtimeNanoseconds);
        writer.writeUInt32BE(stat.dev);
        writer.writeUInt32BE(stat.ino);
        writer.writeUInt32BE(stat.mode);
        writer.writeUInt32BE(stat.uid);
        writer.writeUInt32BE(stat.gid);
        writer.writeUInt32BE(stat.size);
        writer.write(entry.oid, 20, 'hex');
        writer.writeUInt16BE(renderCacheEntryFlags(entry));
        writer.write(entry.path, bpath.length, 'utf8');
        return written
      })
    );
    const main = Buffer.concat([header, body]);
    const sum = await shasum(main);
    return Buffer.concat([main, Buffer.from(sum, 'hex')])
  }
}

function compareStats(entry, stats) {
  // Comparison based on the description in Paragraph 4 of
  // https://www.kernel.org/pub/software/scm/git/docs/technical/racy-git.txt
  const e = normalizeStats(entry);
  const s = normalizeStats(stats);
  const staleness =
    e.mode !== s.mode ||
    e.mtimeSeconds !== s.mtimeSeconds ||
    e.ctimeSeconds !== s.ctimeSeconds ||
    e.uid !== s.uid ||
    e.gid !== s.gid ||
    e.ino !== s.ino ||
    e.size !== s.size;
  return staleness
}

// import LockManager from 'travix-lock-manager'

// import Lock from '../utils.js'

// const lm = new LockManager()
let lock = null;

const IndexCache = Symbol('IndexCache');

function createCache() {
  return {
    map: new Map(),
    stats: new Map(),
  }
}

async function updateCachedIndexFile(fs, filepath, cache) {
  const stat = await fs.lstat(filepath);
  const rawIndexFile = await fs.read(filepath);
  const index = await GitIndex.from(rawIndexFile);
  // cache the GitIndex object so we don't need to re-read it every time.
  cache.map.set(filepath, index);
  // Save the stat data for the index so we know whether the cached file is stale (modified by an outside process).
  cache.stats.set(filepath, stat);
}

// Determine whether our copy of the index file is stale
async function isIndexStale(fs, filepath, cache) {
  const savedStats = cache.stats.get(filepath);
  if (savedStats === undefined) return true
  const currStats = await fs.lstat(filepath);
  if (savedStats === null) return false
  if (currStats === null) return false
  return compareStats(savedStats, currStats)
}

class GitIndexManager {
  /**
   *
   * @param {object} opts
   * @param {import('../models/FileSystem.js').FileSystem} opts.fs
   * @param {string} opts.gitdir
   * @param {object} opts.cache
   * @param {function(GitIndex): any} closure
   */
  static async acquire({ fs, gitdir, cache }, closure) {
    if (!cache[IndexCache]) cache[IndexCache] = createCache();

    const filepath = `${gitdir}/index`;
    if (lock === null) lock = new asyncLock({ maxPending: Infinity });
    let result;
    await lock.acquire(filepath, async function() {
      // Acquire a file lock while we're reading the index
      // to make sure other processes aren't writing to it
      // simultaneously, which could result in a corrupted index.
      // const fileLock = await Lock(filepath)
      if (await isIndexStale(fs, filepath, cache[IndexCache])) {
        await updateCachedIndexFile(fs, filepath, cache[IndexCache]);
      }
      const index = cache[IndexCache].map.get(filepath);
      result = await closure(index);
      if (index._dirty) {
        // Acquire a file lock while we're writing the index file
        // let fileLock = await Lock(filepath)
        const buffer = await index.toObject();
        await fs.write(filepath, buffer);
        // Update cached stat value
        cache[IndexCache].stats.set(filepath, await fs.lstat(filepath));
        index._dirty = false;
      }
    });
    return result
  }
}

function basename(path) {
  const last = Math.max(path.lastIndexOf('/'), path.lastIndexOf('\\'));
  if (last > -1) {
    path = path.slice(last + 1);
  }
  return path
}

function dirname(path) {
  const last = Math.max(path.lastIndexOf('/'), path.lastIndexOf('\\'));
  if (last === -1) return '.'
  if (last === 0) return '/'
  return path.slice(0, last)
}

/*::
type Node = {
  type: string,
  fullpath: string,
  basename: string,
  metadata: Object, // mode, oid
  parent?: Node,
  children: Array<Node>
}
*/

function flatFileListToDirectoryStructure(files) {
  const inodes = new Map();
  const mkdir = function(name) {
    if (!inodes.has(name)) {
      const dir = {
        type: 'tree',
        fullpath: name,
        basename: basename(name),
        metadata: {},
        children: [],
      };
      inodes.set(name, dir);
      // This recursively generates any missing parent folders.
      // We do it after we've added the inode to the set so that
      // we don't recurse infinitely trying to create the root '.' dirname.
      dir.parent = mkdir(dirname(name));
      if (dir.parent && dir.parent !== dir) dir.parent.children.push(dir);
    }
    return inodes.get(name)
  };

  const mkfile = function(name, metadata) {
    if (!inodes.has(name)) {
      const file = {
        type: 'blob',
        fullpath: name,
        basename: basename(name),
        metadata: metadata,
        // This recursively generates any missing parent folders.
        parent: mkdir(dirname(name)),
        children: [],
      };
      if (file.parent) file.parent.children.push(file);
      inodes.set(name, file);
    }
    return inodes.get(name)
  };

  mkdir('.');
  for (const file of files) {
    mkfile(file.path, file);
  }
  return inodes
}

/**
 *
 * @param {number} mode
 */
function mode2type(mode) {
  // prettier-ignore
  switch (mode) {
    case 0o040000: return 'tree'
    case 0o100644: return 'blob'
    case 0o100755: return 'blob'
    case 0o120000: return 'blob'
    case 0o160000: return 'commit'
  }
  throw new InternalError(`Unexpected GitTree entry mode: ${mode.toString(8)}`)
}

class GitWalkerIndex {
  constructor({ fs, gitdir, cache }) {
    this.treePromise = GitIndexManager.acquire(
      { fs, gitdir, cache },
      async function(index) {
        return flatFileListToDirectoryStructure(index.entries)
      }
    );
    const walker = this;
    this.ConstructEntry = class StageEntry {
      constructor(fullpath) {
        this._fullpath = fullpath;
        this._type = false;
        this._mode = false;
        this._stat = false;
        this._oid = false;
      }

      async type() {
        return walker.type(this)
      }

      async mode() {
        return walker.mode(this)
      }

      async stat() {
        return walker.stat(this)
      }

      async content() {
        return walker.content(this)
      }

      async oid() {
        return walker.oid(this)
      }
    };
  }

  async readdir(entry) {
    const filepath = entry._fullpath;
    const tree = await this.treePromise;
    const inode = tree.get(filepath);
    if (!inode) return null
    if (inode.type === 'blob') return null
    if (inode.type !== 'tree') {
      throw new Error(`ENOTDIR: not a directory, scandir '${filepath}'`)
    }
    const names = inode.children.map(inode => inode.fullpath);
    names.sort(compareStrings);
    return names
  }

  async type(entry) {
    if (entry._type === false) {
      await entry.stat();
    }
    return entry._type
  }

  async mode(entry) {
    if (entry._mode === false) {
      await entry.stat();
    }
    return entry._mode
  }

  async stat(entry) {
    if (entry._stat === false) {
      const tree = await this.treePromise;
      const inode = tree.get(entry._fullpath);
      if (!inode) {
        throw new Error(
          `ENOENT: no such file or directory, lstat '${entry._fullpath}'`
        )
      }
      const stats = inode.type === 'tree' ? {} : normalizeStats(inode.metadata);
      entry._type = inode.type === 'tree' ? 'tree' : mode2type(stats.mode);
      entry._mode = stats.mode;
      if (inode.type === 'tree') {
        entry._stat = undefined;
      } else {
        entry._stat = stats;
      }
    }
    return entry._stat
  }

  async content(_entry) {
    // Cannot get content for an index entry
  }

  async oid(entry) {
    if (entry._oid === false) {
      const tree = await this.treePromise;
      const inode = tree.get(entry._fullpath);
      entry._oid = inode.metadata.oid;
    }
    return entry._oid
  }
}

// This is part of an elaborate system to facilitate code-splitting / tree-shaking.
// commands/walk.js can depend on only this, and the actual Walker classes exported
// can be opaque - only having a single property (this symbol) that is not enumerable,
// and thus the constructor can be passed as an argument to walk while being "unusable"
// outside of it.
const GitWalkSymbol = Symbol('GitWalkSymbol');

// @ts-check

/**
 * @returns {Walker}
 */
function STAGE() {
  const o = Object.create(null);
  Object.defineProperty(o, GitWalkSymbol, {
    value: function({ fs, gitdir, cache }) {
      return new GitWalkerIndex({ fs, gitdir, cache })
    },
  });
  Object.freeze(o);
  return o
}

// @ts-check

class NotFoundError extends BaseError {
  /**
   * @param {string} what
   */
  constructor(what) {
    super(`Could not find ${what}.`);
    this.code = this.name = NotFoundError.code;
    this.data = { what };
  }
}
/** @type {'NotFoundError'} */
NotFoundError.code = 'NotFoundError';

class ObjectTypeError extends BaseError {
  /**
   * @param {string} oid
   * @param {'blob'|'commit'|'tag'|'tree'} actual
   * @param {'blob'|'commit'|'tag'|'tree'} expected
   * @param {string} [filepath]
   */
  constructor(oid, actual, expected, filepath) {
    super(
      `Object ${oid} ${
        filepath ? `at ${filepath}` : ''
      }was anticipated to be a ${expected} but it is a ${actual}.`
    );
    this.code = this.name = ObjectTypeError.code;
    this.data = { oid, actual, expected, filepath };
  }
}
/** @type {'ObjectTypeError'} */
ObjectTypeError.code = 'ObjectTypeError';

class InvalidOidError extends BaseError {
  /**
   * @param {string} value
   */
  constructor(value) {
    super(`Expected a 40-char hex object id but saw "${value}".`);
    this.code = this.name = InvalidOidError.code;
    this.data = { value };
  }
}
/** @type {'InvalidOidError'} */
InvalidOidError.code = 'InvalidOidError';

class NoRefspecError extends BaseError {
  /**
   * @param {string} remote
   */
  constructor(remote) {
    super(`Could not find a fetch refspec for remote "${remote}". Make sure the config file has an entry like the following:
[remote "${remote}"]
\tfetch = +refs/heads/*:refs/remotes/origin/*
`);
    this.code = this.name = NoRefspecError.code;
    this.data = { remote };
  }
}
/** @type {'NoRefspecError'} */
NoRefspecError.code = 'NoRefspecError';

class GitPackedRefs {
  constructor(text) {
    this.refs = new Map();
    this.parsedConfig = [];
    if (text) {
      let key = null;
      this.parsedConfig = text
        .trim()
        .split('\n')
        .map(line => {
          if (/^\s*#/.test(line)) {
            return { line, comment: true }
          }
          const i = line.indexOf(' ');
          if (line.startsWith('^')) {
            // This is a oid for the commit associated with the annotated tag immediately preceding this line.
            // Trim off the '^'
            const value = line.slice(1);
            // The tagname^{} syntax is based on the output of `git show-ref --tags -d`
            this.refs.set(key + '^{}', value);
            return { line, ref: key, peeled: value }
          } else {
            // This is an oid followed by the ref name
            const value = line.slice(0, i);
            key = line.slice(i + 1);
            this.refs.set(key, value);
            return { line, ref: key, oid: value }
          }
        });
    }
    return this
  }

  static from(text) {
    return new GitPackedRefs(text)
  }

  delete(ref) {
    this.parsedConfig = this.parsedConfig.filter(entry => entry.ref !== ref);
    this.refs.delete(ref);
  }

  toString() {
    return this.parsedConfig.map(({ line }) => line).join('\n') + '\n'
  }
}

class GitRefSpec {
  constructor({ remotePath, localPath, force, matchPrefix }) {
    Object.assign(this, {
      remotePath,
      localPath,
      force,
      matchPrefix,
    });
  }

  static from(refspec) {
    const [
      forceMatch,
      remotePath,
      remoteGlobMatch,
      localPath,
      localGlobMatch,
    ] = refspec.match(/^(\+?)(.*?)(\*?):(.*?)(\*?)$/).slice(1);
    const force = forceMatch === '+';
    const remoteIsGlob = remoteGlobMatch === '*';
    const localIsGlob = localGlobMatch === '*';
    // validate
    // TODO: Make this check more nuanced, and depend on whether this is a fetch refspec or a push refspec
    if (remoteIsGlob !== localIsGlob) {
      throw new InternalError('Invalid refspec')
    }
    return new GitRefSpec({
      remotePath,
      localPath,
      force,
      matchPrefix: remoteIsGlob,
    })
    // TODO: We need to run resolveRef on both paths to expand them to their full name.
  }

  translate(remoteBranch) {
    if (this.matchPrefix) {
      if (remoteBranch.startsWith(this.remotePath)) {
        return this.localPath + remoteBranch.replace(this.remotePath, '')
      }
    } else {
      if (remoteBranch === this.remotePath) return this.localPath
    }
    return null
  }

  reverseTranslate(localBranch) {
    if (this.matchPrefix) {
      if (localBranch.startsWith(this.localPath)) {
        return this.remotePath + localBranch.replace(this.localPath, '')
      }
    } else {
      if (localBranch === this.localPath) return this.remotePath
    }
    return null
  }
}

class GitRefSpecSet {
  constructor(rules = []) {
    this.rules = rules;
  }

  static from(refspecs) {
    const rules = [];
    for (const refspec of refspecs) {
      rules.push(GitRefSpec.from(refspec)); // might throw
    }
    return new GitRefSpecSet(rules)
  }

  add(refspec) {
    const rule = GitRefSpec.from(refspec); // might throw
    this.rules.push(rule);
  }

  translate(remoteRefs) {
    const result = [];
    for (const rule of this.rules) {
      for (const remoteRef of remoteRefs) {
        const localRef = rule.translate(remoteRef);
        if (localRef) {
          result.push([remoteRef, localRef]);
        }
      }
    }
    return result
  }

  translateOne(remoteRef) {
    let result = null;
    for (const rule of this.rules) {
      const localRef = rule.translate(remoteRef);
      if (localRef) {
        result = localRef;
      }
    }
    return result
  }

  localNamespaces() {
    return this.rules
      .filter(rule => rule.matchPrefix)
      .map(rule => rule.localPath.replace(/\/$/, ''))
  }
}

function compareRefNames(a, b) {
  // https://stackoverflow.com/a/40355107/2168416
  const _a = a.replace(/\^\{\}$/, '');
  const _b = b.replace(/\^\{\}$/, '');
  const tmp = -(_a < _b) || +(_a > _b);
  if (tmp === 0) {
    return a.endsWith('^{}') ? 1 : -1
  }
  return tmp
}

function normalizePath(path) {
  return path
    .replace(/\/\.\//g, '/') // Replace '/./' with '/'
    .replace(/\/{2,}/g, '/') // Replace consecutive '/'
    .replace(/^\/\.$/, '/') // if path === '/.' return '/'
    .replace(/^\.\/$/, '.') // if path === './' return '.'
    .replace(/^\.\//, '') // Remove leading './'
    .replace(/\/\.$/, '') // Remove trailing '/.'
    .replace(/(.+)\/$/, '$1') // Remove trailing '/'
    .replace(/^$/, '.') // if path === '' return '.'
}

// For some reason path.posix.join is undefined in webpack

function join(...parts) {
  return normalizePath(parts.map(normalizePath).join('/'))
}

// This is straight from parse_unit_factor in config.c of canonical git
const num = val => {
  val = val.toLowerCase();
  let n = parseInt(val);
  if (val.endsWith('k')) n *= 1024;
  if (val.endsWith('m')) n *= 1024 * 1024;
  if (val.endsWith('g')) n *= 1024 * 1024 * 1024;
  return n
};

// This is straight from git_parse_maybe_bool_text in config.c of canonical git
const bool = val => {
  val = val.trim().toLowerCase();
  if (val === 'true' || val === 'yes' || val === 'on') return true
  if (val === 'false' || val === 'no' || val === 'off') return false
  throw Error(
    `Expected 'true', 'false', 'yes', 'no', 'on', or 'off', but got ${val}`
  )
};

const schema = {
  core: {
    filemode: bool,
    bare: bool,
    logallrefupdates: bool,
    symlinks: bool,
    ignorecase: bool,
    bigFileThreshold: num,
  },
};

// https://git-scm.com/docs/git-config#_syntax

// section starts with [ and ends with ]
// section is alphanumeric (ASCII) with - and .
// section is case insensitive
// subsection is optionnal
// subsection is specified after section and one or more spaces
// subsection is specified between double quotes
const SECTION_LINE_REGEX = /^\[([A-Za-z0-9-.]+)(?: "(.*)")?\]$/;
const SECTION_REGEX = /^[A-Za-z0-9-.]+$/;

// variable lines contain a name, and equal sign and then a value
// variable lines can also only contain a name (the implicit value is a boolean true)
// variable name is alphanumeric (ASCII) with -
// variable name starts with an alphabetic character
// variable name is case insensitive
const VARIABLE_LINE_REGEX = /^([A-Za-z][A-Za-z-]*)(?: *= *(.*))?$/;
const VARIABLE_NAME_REGEX = /^[A-Za-z][A-Za-z-]*$/;

const VARIABLE_VALUE_COMMENT_REGEX = /^(.*?)( *[#;].*)$/;

const extractSectionLine = line => {
  const matches = SECTION_LINE_REGEX.exec(line);
  if (matches != null) {
    const [section, subsection] = matches.slice(1);
    return [section, subsection]
  }
  return null
};

const extractVariableLine = line => {
  const matches = VARIABLE_LINE_REGEX.exec(line);
  if (matches != null) {
    const [name, rawValue = 'true'] = matches.slice(1);
    const valueWithoutComments = removeComments(rawValue);
    const valueWithoutQuotes = removeQuotes(valueWithoutComments);
    return [name, valueWithoutQuotes]
  }
  return null
};

const removeComments = rawValue => {
  const commentMatches = VARIABLE_VALUE_COMMENT_REGEX.exec(rawValue);
  if (commentMatches == null) {
    return rawValue
  }
  const [valueWithoutComment, comment] = commentMatches.slice(1);
  // if odd number of quotes before and after comment => comment is escaped
  if (
    hasOddNumberOfQuotes(valueWithoutComment) &&
    hasOddNumberOfQuotes(comment)
  ) {
    return `${valueWithoutComment}${comment}`
  }
  return valueWithoutComment
};

const hasOddNumberOfQuotes = text => {
  const numberOfQuotes = (text.match(/(?:^|[^\\])"/g) || []).length;
  return numberOfQuotes % 2 !== 0
};

const removeQuotes = text => {
  return text.split('').reduce((newText, c, idx, text) => {
    const isQuote = c === '"' && text[idx - 1] !== '\\';
    const isEscapeForQuote = c === '\\' && text[idx + 1] === '"';
    if (isQuote || isEscapeForQuote) {
      return newText
    }
    return newText + c
  }, '')
};

const lower = text => {
  return text != null ? text.toLowerCase() : null
};

const getPath = (section, subsection, name) => {
  return [lower(section), subsection, lower(name)]
    .filter(a => a != null)
    .join('.')
};

const findLastIndex = (array, callback) => {
  return array.reduce((lastIndex, item, index) => {
    return callback(item) ? index : lastIndex
  }, -1)
};

// Note: there are a LOT of edge cases that aren't covered (e.g. keys in sections that also
// have subsections, [include] directives, etc.
class GitConfig {
  constructor(text) {
    let section = null;
    let subsection = null;
    this.parsedConfig = text.split('\n').map(line => {
      let name = null;
      let value = null;

      const trimmedLine = line.trim();
      const extractedSection = extractSectionLine(trimmedLine);
      const isSection = extractedSection != null;
      if (isSection) {
[section, subsection] = extractedSection;
      } else {
        const extractedVariable = extractVariableLine(trimmedLine);
        const isVariable = extractedVariable != null;
        if (isVariable) {
[name, value] = extractedVariable;
        }
      }

      const path = getPath(section, subsection, name);
      return { line, isSection, section, subsection, name, value, path }
    });
  }

  static from(text) {
    return new GitConfig(text)
  }

  async get(path, getall = false) {
    const allValues = this.parsedConfig
      .filter(config => config.path === path.toLowerCase())
      .map(({ section, name, value }) => {
        const fn = schema[section] && schema[section][name];
        return fn ? fn(value) : value
      });
    return getall ? allValues : allValues.pop()
  }

  async getall(path) {
    return this.get(path, true)
  }

  async getSubsections(section) {
    return this.parsedConfig
      .filter(config => config.section === section && config.isSection)
      .map(config => config.subsection)
  }

  async deleteSection(section, subsection) {
    this.parsedConfig = this.parsedConfig.filter(
      config =>
        !(config.section === section && config.subsection === subsection)
    );
  }

  async append(path, value) {
    return this.set(path, value, true)
  }

  async set(path, value, append = false) {
    const configIndex = findLastIndex(
      this.parsedConfig,
      config => config.path === path.toLowerCase()
    );
    if (value == null) {
      if (configIndex !== -1) {
        this.parsedConfig.splice(configIndex, 1);
      }
    } else {
      if (configIndex !== -1) {
        const config = this.parsedConfig[configIndex];
        const modifiedConfig = Object.assign({}, config, {
          value,
          modified: true,
        });
        if (append) {
          this.parsedConfig.splice(configIndex + 1, 0, modifiedConfig);
        } else {
          this.parsedConfig[configIndex] = modifiedConfig;
        }
      } else {
        const sectionPath = path
          .split('.')
          .slice(0, -1)
          .join('.')
          .toLowerCase();
        const sectionIndex = this.parsedConfig.findIndex(
          config => config.path === sectionPath
        );
        const [section, subsection] = sectionPath.split('.');
        const name = path.split('.').pop();
        const newConfig = {
          section,
          subsection,
          name,
          value,
          modified: true,
          path: getPath(section, subsection, name),
        };
        if (SECTION_REGEX.test(section) && VARIABLE_NAME_REGEX.test(name)) {
          if (sectionIndex >= 0) {
            // Reuse existing section
            this.parsedConfig.splice(sectionIndex + 1, 0, newConfig);
          } else {
            // Add a new section
            const newSection = {
              section,
              subsection,
              modified: true,
              path: getPath(section, subsection, null),
            };
            this.parsedConfig.push(newSection, newConfig);
          }
        }
      }
    }
  }

  toString() {
    return this.parsedConfig
      .map(({ line, section, subsection, name, value, modified = false }) => {
        if (!modified) {
          return line
        }
        if (name != null && value != null) {
          return `\t${name} = ${value}`
        }
        if (subsection != null) {
          return `[${section} "${subsection}"]`
        }
        return `[${section}]`
      })
      .join('\n')
  }
}

class GitConfigManager {
  static async get({ fs, gitdir }) {
    // We can improve efficiency later if needed.
    // TODO: read from full list of git config files
    const text = await fs.read(`${gitdir}/config`, { encoding: 'utf8' });
    return GitConfig.from(text)
  }

  static async save({ fs, gitdir, config }) {
    // We can improve efficiency later if needed.
    // TODO: handle saving to the correct global/user/repo location
    await fs.write(`${gitdir}/config`, config.toString(), {
      encoding: 'utf8',
    });
  }
}

// This is a convenience wrapper for reading and writing files in the 'refs' directory.

// @see https://git-scm.com/docs/git-rev-parse.html#_specifying_revisions
const refpaths = ref => [
  `${ref}`,
  `refs/${ref}`,
  `refs/tags/${ref}`,
  `refs/heads/${ref}`,
  `refs/remotes/${ref}`,
  `refs/remotes/${ref}/HEAD`,
];

// @see https://git-scm.com/docs/gitrepository-layout
const GIT_FILES = ['config', 'description', 'index', 'shallow', 'commondir'];

class GitRefManager {
  static async updateRemoteRefs({
    fs,
    gitdir,
    remote,
    refs,
    symrefs,
    tags,
    refspecs = undefined,
    prune = false,
    pruneTags = false,
  }) {
    // Validate input
    for (const value of refs.values()) {
      if (!value.match(/[0-9a-f]{40}/)) {
        throw new InvalidOidError(value)
      }
    }
    const config = await GitConfigManager.get({ fs, gitdir });
    if (!refspecs) {
      refspecs = await config.getall(`remote.${remote}.fetch`);
      if (refspecs.length === 0) {
        throw new NoRefspecError(remote)
      }
      // There's some interesting behavior with HEAD that doesn't follow the refspec.
      refspecs.unshift(`+HEAD:refs/remotes/${remote}/HEAD`);
    }
    const refspec = GitRefSpecSet.from(refspecs);
    const actualRefsToWrite = new Map();
    // Delete all current tags if the pruneTags argument is true.
    if (pruneTags) {
      const tags = await GitRefManager.listRefs({
        fs,
        gitdir,
        filepath: 'refs/tags',
      });
      await GitRefManager.deleteRefs({
        fs,
        gitdir,
        refs: tags.map(tag => `refs/tags/${tag}`),
      });
    }
    // Add all tags if the fetch tags argument is true.
    if (tags) {
      for (const serverRef of refs.keys()) {
        if (serverRef.startsWith('refs/tags') && !serverRef.endsWith('^{}')) {
          // Git's behavior is to only fetch tags that do not conflict with tags already present.
          if (!(await GitRefManager.exists({ fs, gitdir, ref: serverRef }))) {
            // If there is a dereferenced an annotated tag value available, prefer that.
            const oid = refs.get(serverRef + '^{}') || refs.get(serverRef);
            actualRefsToWrite.set(serverRef, oid);
          }
        }
      }
    }
    // Combine refs and symrefs giving symrefs priority
    const refTranslations = refspec.translate([...refs.keys()]);
    for (const [serverRef, translatedRef] of refTranslations) {
      const value = refs.get(serverRef);
      actualRefsToWrite.set(translatedRef, value);
    }
    const symrefTranslations = refspec.translate([...symrefs.keys()]);
    for (const [serverRef, translatedRef] of symrefTranslations) {
      const value = symrefs.get(serverRef);
      const symtarget = refspec.translateOne(value);
      if (symtarget) {
        actualRefsToWrite.set(translatedRef, `ref: ${symtarget}`);
      }
    }
    // If `prune` argument is true, clear out the existing local refspec roots
    const pruned = [];
    if (prune) {
      for (const filepath of refspec.localNamespaces()) {
        const refs = (
          await GitRefManager.listRefs({
            fs,
            gitdir,
            filepath,
          })
        ).map(file => `${filepath}/${file}`);
        for (const ref of refs) {
          if (!actualRefsToWrite.has(ref)) {
            pruned.push(ref);
          }
        }
      }
      if (pruned.length > 0) {
        await GitRefManager.deleteRefs({ fs, gitdir, refs: pruned });
      }
    }
    // Update files
    // TODO: For large repos with a history of thousands of pull requests
    // (i.e. gitlab-ce) it would be vastly more efficient to write them
    // to .git/packed-refs.
    // The trick is to make sure we a) don't write a packed ref that is
    // already shadowed by a loose ref and b) don't loose any refs already
    // in packed-refs. Doing this efficiently may be difficult. A
    // solution that might work is
    // a) load the current packed-refs file
    // b) add actualRefsToWrite, overriding the existing values if present
    // c) enumerate all the loose refs currently in .git/refs/remotes/${remote}
    // d) overwrite their value with the new value.
    // Examples of refs we need to avoid writing in loose format for efficieny's sake
    // are .git/refs/remotes/origin/refs/remotes/remote_mirror_3059
    // and .git/refs/remotes/origin/refs/merge-requests
    for (const [key, value] of actualRefsToWrite) {
      await fs.write(join(gitdir, key), `${value.trim()}\n`, 'utf8');
    }
    return { pruned }
  }

  // TODO: make this less crude?
  static async writeRef({ fs, gitdir, ref, value }) {
    // Validate input
    if (!value.match(/[0-9a-f]{40}/)) {
      throw new InvalidOidError(value)
    }
    await fs.write(join(gitdir, ref), `${value.trim()}\n`, 'utf8');
  }

  static async writeSymbolicRef({ fs, gitdir, ref, value }) {
    await fs.write(join(gitdir, ref), 'ref: ' + `${value.trim()}\n`, 'utf8');
  }

  static async deleteRef({ fs, gitdir, ref }) {
    return GitRefManager.deleteRefs({ fs, gitdir, refs: [ref] })
  }

  static async deleteRefs({ fs, gitdir, refs }) {
    // Delete regular ref
    await Promise.all(refs.map(ref => fs.rm(join(gitdir, ref))));
    // Delete any packed ref
    let text = await fs.read(`${gitdir}/packed-refs`, { encoding: 'utf8' });
    const packed = GitPackedRefs.from(text);
    const beforeSize = packed.refs.size;
    for (const ref of refs) {
      if (packed.refs.has(ref)) {
        packed.delete(ref);
      }
    }
    if (packed.refs.size < beforeSize) {
      text = packed.toString();
      await fs.write(`${gitdir}/packed-refs`, text, { encoding: 'utf8' });
    }
  }

  /**
   * @param {object} args
   * @param {import('../models/FileSystem.js').FileSystem} args.fs
   * @param {string} args.gitdir
   * @param {string} args.ref
   * @param {number} [args.depth]
   * @returns {Promise<string>}
   */
  static async resolve({ fs, gitdir, ref, depth = undefined }) {
    if (depth !== undefined) {
      depth--;
      if (depth === -1) {
        return ref
      }
    }
    let sha;
    // Is it a ref pointer?
    if (ref.startsWith('ref: ')) {
      ref = ref.slice('ref: '.length);
      return GitRefManager.resolve({ fs, gitdir, ref, depth })
    }
    // Is it a complete and valid SHA?
    if (ref.length === 40 && /[0-9a-f]{40}/.test(ref)) {
      return ref
    }
    // We need to alternate between the file system and the packed-refs
    const packedMap = await GitRefManager.packedRefs({ fs, gitdir });
    // Look in all the proper paths, in this order
    const allpaths = refpaths(ref).filter(p => !GIT_FILES.includes(p)); // exclude git system files (#709)

    for (const ref of allpaths) {
      sha =
        (await fs.read(`${gitdir}/${ref}`, { encoding: 'utf8' })) ||
        packedMap.get(ref);
      if (sha) {
        return GitRefManager.resolve({ fs, gitdir, ref: sha.trim(), depth })
      }
    }
    // Do we give up?
    throw new NotFoundError(ref)
  }

  static async exists({ fs, gitdir, ref }) {
    try {
      await GitRefManager.expand({ fs, gitdir, ref });
      return true
    } catch (err) {
      return false
    }
  }

  static async expand({ fs, gitdir, ref }) {
    // Is it a complete and valid SHA?
    if (ref.length === 40 && /[0-9a-f]{40}/.test(ref)) {
      return ref
    }
    // We need to alternate between the file system and the packed-refs
    const packedMap = await GitRefManager.packedRefs({ fs, gitdir });
    // Look in all the proper paths, in this order
    const allpaths = refpaths(ref);
    for (const ref of allpaths) {
      if (await fs.exists(`${gitdir}/${ref}`)) return ref
      if (packedMap.has(ref)) return ref
    }
    // Do we give up?
    throw new NotFoundError(ref)
  }

  static async expandAgainstMap({ ref, map }) {
    // Look in all the proper paths, in this order
    const allpaths = refpaths(ref);
    for (const ref of allpaths) {
      if (await map.has(ref)) return ref
    }
    // Do we give up?
    throw new NotFoundError(ref)
  }

  static resolveAgainstMap({ ref, fullref = ref, depth = undefined, map }) {
    if (depth !== undefined) {
      depth--;
      if (depth === -1) {
        return { fullref, oid: ref }
      }
    }
    // Is it a ref pointer?
    if (ref.startsWith('ref: ')) {
      ref = ref.slice('ref: '.length);
      return GitRefManager.resolveAgainstMap({ ref, fullref, depth, map })
    }
    // Is it a complete and valid SHA?
    if (ref.length === 40 && /[0-9a-f]{40}/.test(ref)) {
      return { fullref, oid: ref }
    }
    // Look in all the proper paths, in this order
    const allpaths = refpaths(ref);
    for (const ref of allpaths) {
      const sha = map.get(ref);
      if (sha) {
        return GitRefManager.resolveAgainstMap({
          ref: sha.trim(),
          fullref: ref,
          depth,
          map,
        })
      }
    }
    // Do we give up?
    throw new NotFoundError(ref)
  }

  static async packedRefs({ fs, gitdir }) {
    const text = await fs.read(`${gitdir}/packed-refs`, { encoding: 'utf8' });
    const packed = GitPackedRefs.from(text);
    return packed.refs
  }

  // List all the refs that match the `filepath` prefix
  static async listRefs({ fs, gitdir, filepath }) {
    const packedMap = GitRefManager.packedRefs({ fs, gitdir });
    let files = null;
    try {
      files = await fs.readdirDeep(`${gitdir}/${filepath}`);
      files = files.map(x => x.replace(`${gitdir}/${filepath}/`, ''));
    } catch (err) {
      files = [];
    }

    for (let key of (await packedMap).keys()) {
      // filter by prefix
      if (key.startsWith(filepath)) {
        // remove prefix
        key = key.replace(filepath + '/', '');
        // Don't include duplicates; the loose files have precedence anyway
        if (!files.includes(key)) {
          files.push(key);
        }
      }
    }
    // since we just appended things onto an array, we need to sort them now
    files.sort(compareRefNames);
    return files
  }

  static async listBranches({ fs, gitdir, remote }) {
    if (remote) {
      return GitRefManager.listRefs({
        fs,
        gitdir,
        filepath: `refs/remotes/${remote}`,
      })
    } else {
      return GitRefManager.listRefs({ fs, gitdir, filepath: `refs/heads` })
    }
  }

  static async listTags({ fs, gitdir }) {
    const tags = await GitRefManager.listRefs({
      fs,
      gitdir,
      filepath: `refs/tags`,
    });
    return tags.filter(x => !x.endsWith('^{}'))
  }
}

function compareTreeEntryPath(a, b) {
  // Git sorts tree entries as if there is a trailing slash on directory names.
  return compareStrings(appendSlashIfDir(a), appendSlashIfDir(b))
}

function appendSlashIfDir(entry) {
  return entry.mode === '040000' ? entry.path + '/' : entry.path
}

/**
 *
 * @typedef {Object} TreeEntry
 * @property {string} mode - the 6 digit hexadecimal mode
 * @property {string} path - the name of the file or directory
 * @property {string} oid - the SHA-1 object id of the blob or tree
 * @property {'commit'|'blob'|'tree'} type - the type of object
 */

function mode2type$1(mode) {
  // prettier-ignore
  switch (mode) {
    case '040000': return 'tree'
    case '100644': return 'blob'
    case '100755': return 'blob'
    case '120000': return 'blob'
    case '160000': return 'commit'
  }
  throw new InternalError(`Unexpected GitTree entry mode: ${mode}`)
}

function parseBuffer(buffer) {
  const _entries = [];
  let cursor = 0;
  while (cursor < buffer.length) {
    const space = buffer.indexOf(32, cursor);
    if (space === -1) {
      throw new InternalError(
        `GitTree: Error parsing buffer at byte location ${cursor}: Could not find the next space character.`
      )
    }
    const nullchar = buffer.indexOf(0, cursor);
    if (nullchar === -1) {
      throw new InternalError(
        `GitTree: Error parsing buffer at byte location ${cursor}: Could not find the next null character.`
      )
    }
    let mode = buffer.slice(cursor, space).toString('utf8');
    if (mode === '40000') mode = '040000'; // makes it line up neater in printed output
    const type = mode2type$1(mode);
    const path = buffer.slice(space + 1, nullchar).toString('utf8');
    const oid = buffer.slice(nullchar + 1, nullchar + 21).toString('hex');
    cursor = nullchar + 21;
    _entries.push({ mode, path, oid, type });
  }
  return _entries
}

function limitModeToAllowed(mode) {
  if (typeof mode === 'number') {
    mode = mode.toString(8);
  }
  // tree
  if (mode.match(/^0?4.*/)) return '040000' // Directory
  if (mode.match(/^1006.*/)) return '100644' // Regular non-executable file
  if (mode.match(/^1007.*/)) return '100755' // Regular executable file
  if (mode.match(/^120.*/)) return '120000' // Symbolic link
  if (mode.match(/^160.*/)) return '160000' // Commit (git submodule reference)
  throw new InternalError(`Could not understand file mode: ${mode}`)
}

function nudgeIntoShape(entry) {
  if (!entry.oid && entry.sha) {
    entry.oid = entry.sha; // Github
  }
  entry.mode = limitModeToAllowed(entry.mode); // index
  if (!entry.type) {
    entry.type = mode2type$1(entry.mode); // index
  }
  return entry
}

class GitTree {
  constructor(entries) {
    if (Buffer.isBuffer(entries)) {
      this._entries = parseBuffer(entries);
    } else if (Array.isArray(entries)) {
      this._entries = entries.map(nudgeIntoShape);
    } else {
      throw new InternalError('invalid type passed to GitTree constructor')
    }
    // Tree entries are not sorted alphabetically in the usual sense (see `compareTreeEntryPath`)
    // but it is important later on that these be sorted in the same order as they would be returned from readdir.
    this._entries.sort(comparePath);
  }

  static from(tree) {
    return new GitTree(tree)
  }

  render() {
    return this._entries
      .map(entry => `${entry.mode} ${entry.type} ${entry.oid}    ${entry.path}`)
      .join('\n')
  }

  toObject() {
    // Adjust the sort order to match git's
    const entries = [...this._entries];
    entries.sort(compareTreeEntryPath);
    return Buffer.concat(
      entries.map(entry => {
        const mode = Buffer.from(entry.mode.replace(/^0/, ''));
        const space = Buffer.from(' ');
        const path = Buffer.from(entry.path, 'utf8');
        const nullchar = Buffer.from([0]);
        const oid = Buffer.from(entry.oid, 'hex');
        return Buffer.concat([mode, space, path, nullchar, oid])
      })
    )
  }

  /**
   * @returns {TreeEntry[]}
   */
  entries() {
    return this._entries
  }

  *[Symbol.iterator]() {
    for (const entry of this._entries) {
      yield entry;
    }
  }
}

class GitObject {
  static wrap({ type, object }) {
    return Buffer.concat([
      Buffer.from(`${type} ${object.byteLength.toString()}\x00`),
      Buffer.from(object),
    ])
  }

  static unwrap(buffer) {
    const s = buffer.indexOf(32); // first space
    const i = buffer.indexOf(0); // first null value
    const type = buffer.slice(0, s).toString('utf8'); // get type of object
    const length = buffer.slice(s + 1, i).toString('utf8'); // get type of object
    const actualLength = buffer.length - (i + 1);
    // verify length
    if (parseInt(length) !== actualLength) {
      throw new InternalError(
        `Length mismatch: expected ${length} bytes but got ${actualLength} instead.`
      )
    }
    return {
      type,
      object: Buffer.from(buffer.slice(i + 1)),
    }
  }
}

async function readObjectLoose({ fs, gitdir, oid }) {
  const source = `objects/${oid.slice(0, 2)}/${oid.slice(2)}`;
  const file = await fs.read(`${gitdir}/${source}`);
  if (!file) {
    return null
  }
  return { object: file, format: 'deflated', source }
}

/**
 * @param {Buffer} delta
 * @param {Buffer} source
 * @returns {Buffer}
 */
function applyDelta(delta, source) {
  const reader = new BufferCursor(delta);
  const sourceSize = readVarIntLE(reader);

  if (sourceSize !== source.byteLength) {
    throw new InternalError(
      `applyDelta expected source buffer to be ${sourceSize} bytes but the provided buffer was ${source.length} bytes`
    )
  }
  const targetSize = readVarIntLE(reader);
  let target;

  const firstOp = readOp(reader, source);
  // Speed optimization - return raw buffer if it's just single simple copy
  if (firstOp.byteLength === targetSize) {
    target = firstOp;
  } else {
    // Otherwise, allocate a fresh buffer and slices
    target = Buffer.alloc(targetSize);
    const writer = new BufferCursor(target);
    writer.copy(firstOp);

    while (!reader.eof()) {
      writer.copy(readOp(reader, source));
    }

    const tell = writer.tell();
    if (targetSize !== tell) {
      throw new InternalError(
        `applyDelta expected target buffer to be ${targetSize} bytes but the resulting buffer was ${tell} bytes`
      )
    }
  }
  return target
}

function readVarIntLE(reader) {
  let result = 0;
  let shift = 0;
  let byte = null;
  do {
    byte = reader.readUInt8();
    result |= (byte & 0b01111111) << shift;
    shift += 7;
  } while (byte & 0b10000000)
  return result
}

function readCompactLE(reader, flags, size) {
  let result = 0;
  let shift = 0;
  while (size--) {
    if (flags & 0b00000001) {
      result |= reader.readUInt8() << shift;
    }
    flags >>= 1;
    shift += 8;
  }
  return result
}

function readOp(reader, source) {
  /** @type {number} */
  const byte = reader.readUInt8();
  const COPY = 0b10000000;
  const OFFS = 0b00001111;
  const SIZE = 0b01110000;
  if (byte & COPY) {
    // copy consists of 4 byte offset, 3 byte size (in LE order)
    const offset = readCompactLE(reader, byte & OFFS, 4);
    let size = readCompactLE(reader, (byte & SIZE) >> 4, 3);
    // Yup. They really did this optimization.
    if (size === 0) size = 0x10000;
    return source.slice(offset, offset + size)
  } else {
    // insert
    return reader.slice(byte)
  }
}

// Convert a value to an Async Iterator
// This will be easier with async generator functions.
function fromValue(value) {
  let queue = [value];
  return {
    next() {
      return Promise.resolve({ done: queue.length === 0, value: queue.pop() })
    },
    return() {
      queue = [];
      return {}
    },
    [Symbol.asyncIterator]() {
      return this
    },
  }
}

function getIterator(iterable) {
  if (iterable[Symbol.asyncIterator]) {
    return iterable[Symbol.asyncIterator]()
  }
  if (iterable[Symbol.iterator]) {
    return iterable[Symbol.iterator]()
  }
  if (iterable.next) {
    return iterable
  }
  return fromValue(iterable)
}

// inspired by 'gartal' but lighter-weight and more battle-tested.
class StreamReader {
  constructor(stream) {
    this.stream = getIterator(stream);
    this.buffer = null;
    this.cursor = 0;
    this.undoCursor = 0;
    this.started = false;
    this._ended = false;
    this._discardedBytes = 0;
  }

  eof() {
    return this._ended && this.cursor === this.buffer.length
  }

  tell() {
    return this._discardedBytes + this.cursor
  }

  async byte() {
    if (this.eof()) return
    if (!this.started) await this._init();
    if (this.cursor === this.buffer.length) {
      await this._loadnext();
      if (this._ended) return
    }
    this._moveCursor(1);
    return this.buffer[this.undoCursor]
  }

  async chunk() {
    if (this.eof()) return
    if (!this.started) await this._init();
    if (this.cursor === this.buffer.length) {
      await this._loadnext();
      if (this._ended) return
    }
    this._moveCursor(this.buffer.length);
    return this.buffer.slice(this.undoCursor, this.cursor)
  }

  async read(n) {
    if (this.eof()) return
    if (!this.started) await this._init();
    if (this.cursor + n > this.buffer.length) {
      this._trim();
      await this._accumulate(n);
    }
    this._moveCursor(n);
    return this.buffer.slice(this.undoCursor, this.cursor)
  }

  async skip(n) {
    if (this.eof()) return
    if (!this.started) await this._init();
    if (this.cursor + n > this.buffer.length) {
      this._trim();
      await this._accumulate(n);
    }
    this._moveCursor(n);
  }

  async undo() {
    this.cursor = this.undoCursor;
  }

  async _next() {
    this.started = true;
    let { done, value } = await this.stream.next();
    if (done) {
      this._ended = true;
    }
    if (value) {
      value = Buffer.from(value);
    }
    return value
  }

  _trim() {
    // Throw away parts of the buffer we don't need anymore
    // assert(this.cursor <= this.buffer.length)
    this.buffer = this.buffer.slice(this.undoCursor);
    this.cursor -= this.undoCursor;
    this._discardedBytes += this.undoCursor;
    this.undoCursor = 0;
  }

  _moveCursor(n) {
    this.undoCursor = this.cursor;
    this.cursor += n;
    if (this.cursor > this.buffer.length) {
      this.cursor = this.buffer.length;
    }
  }

  async _accumulate(n) {
    if (this._ended) return
    // Expand the buffer until we have N bytes of data
    // or we've reached the end of the stream
    const buffers = [this.buffer];
    while (this.cursor + n > lengthBuffers(buffers)) {
      const nextbuffer = await this._next();
      if (this._ended) break
      buffers.push(nextbuffer);
    }
    this.buffer = Buffer.concat(buffers);
  }

  async _loadnext() {
    this._discardedBytes += this.buffer.length;
    this.undoCursor = 0;
    this.cursor = 0;
    this.buffer = await this._next();
  }

  async _init() {
    this.buffer = await this._next();
  }
}

// This helper function helps us postpone concatenating buffers, which
// would create intermediate buffer objects,
function lengthBuffers(buffers) {
  return buffers.reduce((acc, buffer) => acc + buffer.length, 0)
}

// My version of git-list-pack - roughly 15x faster than the original

async function listpack(stream, onData) {
  const reader = new StreamReader(stream);
  let PACK = await reader.read(4);
  PACK = PACK.toString('utf8');
  if (PACK !== 'PACK') {
    throw new InternalError(`Invalid PACK header '${PACK}'`)
  }

  let version = await reader.read(4);
  version = version.readUInt32BE(0);
  if (version !== 2) {
    throw new InternalError(`Invalid packfile version: ${version}`)
  }

  let numObjects = await reader.read(4);
  numObjects = numObjects.readUInt32BE(0);
  // If (for some godforsaken reason) this is an empty packfile, abort now.
  if (numObjects < 1) return

  while (!reader.eof() && numObjects--) {
    const offset = reader.tell();
    const { type, length, ofs, reference } = await parseHeader(reader);
    const inflator = new pako_1.Inflate();
    while (!inflator.result) {
      const chunk = await reader.chunk();
      if (reader.ended) break
      inflator.push(chunk, false);
      if (inflator.err) {
        throw new InternalError(`Pako error: ${inflator.msg}`)
      }
      if (inflator.result) {
        if (inflator.result.length !== length) {
          throw new InternalError(
            `Inflated object size is different from that stated in packfile.`
          )
        }

        // Backtrack parser to where deflated data ends
        await reader.undo();
        await reader.read(chunk.length - inflator.strm.avail_in);
        const end = reader.tell();
        await onData({
          data: inflator.result,
          type,
          num: numObjects,
          offset,
          end,
          reference,
          ofs,
        });
      }
    }
  }
}

async function parseHeader(reader) {
  // Object type is encoded in bits 654
  let byte = await reader.byte();
  const type = (byte >> 4) & 0b111;
  // The length encoding get complicated.
  // Last four bits of length is encoded in bits 3210
  let length = byte & 0b1111;
  // Whether the next byte is part of the variable-length encoded number
  // is encoded in bit 7
  if (byte & 0b10000000) {
    let shift = 4;
    do {
      byte = await reader.byte();
      length |= (byte & 0b01111111) << shift;
      shift += 7;
    } while (byte & 0b10000000)
  }
  // Handle deltified objects
  let ofs;
  let reference;
  if (type === 6) {
    let shift = 0;
    ofs = 0;
    const bytes = [];
    do {
      byte = await reader.byte();
      ofs |= (byte & 0b01111111) << shift;
      shift += 7;
      bytes.push(byte);
    } while (byte & 0b10000000)
    reference = Buffer.from(bytes);
  }
  if (type === 7) {
    const buf = await reader.read(20);
    reference = buf;
  }
  return { type, length, ofs, reference }
}

async function inflate(buffer) {
  return pako_1.inflate(buffer)
}

function decodeVarInt(reader) {
  const bytes = [];
  let byte = 0;
  let multibyte = 0;
  do {
    byte = reader.readUInt8();
    // We keep bits 6543210
    const lastSeven = byte & 0b01111111;
    bytes.push(lastSeven);
    // Whether the next byte is part of the variable-length encoded number
    // is encoded in bit 7
    multibyte = byte & 0b10000000;
  } while (multibyte)
  // Now that all the bytes are in big-endian order,
  // alternate shifting the bits left by 7 and OR-ing the next byte.
  // And... do a weird increment-by-one thing that I don't quite understand.
  return bytes.reduce((a, b) => ((a + 1) << 7) | b, -1)
}

// I'm pretty much copying this one from the git C source code,
// because it makes no sense.
function otherVarIntDecode(reader, startWith) {
  let result = startWith;
  let shift = 4;
  let byte = null;
  do {
    byte = reader.readUInt8();
    result |= (byte & 0b01111111) << shift;
    shift += 7;
  } while (byte & 0b10000000)
  return result
}

class GitPackIndex {
  constructor(stuff) {
    Object.assign(this, stuff);
    this.offsetCache = {};
  }

  static async fromIdx({ idx, getExternalRefDelta }) {
    const reader = new BufferCursor(idx);
    const magic = reader.slice(4).toString('hex');
    // Check for IDX v2 magic number
    if (magic !== 'ff744f63') {
      return // undefined
    }
    const version = reader.readUInt32BE();
    if (version !== 2) {
      throw new InternalError(
        `Unable to read version ${version} packfile IDX. (Only version 2 supported)`
      )
    }
    if (idx.byteLength > 2048 * 1024 * 1024) {
      throw new InternalError(
        `To keep implementation simple, I haven't implemented the layer 5 feature needed to support packfiles > 2GB in size.`
      )
    }
    // Skip over fanout table
    reader.seek(reader.tell() + 4 * 255);
    // Get hashes
    const size = reader.readUInt32BE();
    const hashes = [];
    for (let i = 0; i < size; i++) {
      const hash = reader.slice(20).toString('hex');
      hashes[i] = hash;
    }
    reader.seek(reader.tell() + 4 * size);
    // Skip over CRCs
    // Get offsets
    const offsets = new Map();
    for (let i = 0; i < size; i++) {
      offsets.set(hashes[i], reader.readUInt32BE());
    }
    const packfileSha = reader.slice(20).toString('hex');
    return new GitPackIndex({
      hashes,
      crcs: {},
      offsets,
      packfileSha,
      getExternalRefDelta,
    })
  }

  static async fromPack({ pack, getExternalRefDelta, onProgress }) {
    const listpackTypes = {
      1: 'commit',
      2: 'tree',
      3: 'blob',
      4: 'tag',
      6: 'ofs-delta',
      7: 'ref-delta',
    };
    const offsetToObject = {};

    // Older packfiles do NOT use the shasum of the pack itself,
    // so it is recommended to just use whatever bytes are in the trailer.
    // Source: https://github.com/git/git/commit/1190a1acf800acdcfd7569f87ac1560e2d077414
    const packfileSha = pack.slice(-20).toString('hex');

    const hashes = [];
    const crcs = {};
    const offsets = new Map();
    let totalObjectCount = null;
    let lastPercent = null;

    await listpack([pack], async ({ data, type, reference, offset, num }) => {
      if (totalObjectCount === null) totalObjectCount = num;
      const percent = Math.floor(
        ((totalObjectCount - num) * 100) / totalObjectCount
      );
      if (percent !== lastPercent) {
        if (onProgress) {
          await onProgress({
            phase: 'Receiving objects',
            loaded: totalObjectCount - num,
            total: totalObjectCount,
          });
        }
      }
      lastPercent = percent;
      // Change type from a number to a meaningful string
      type = listpackTypes[type];

      if (['commit', 'tree', 'blob', 'tag'].includes(type)) {
        offsetToObject[offset] = {
          type,
          offset,
        };
      } else if (type === 'ofs-delta') {
        offsetToObject[offset] = {
          type,
          offset,
        };
      } else if (type === 'ref-delta') {
        offsetToObject[offset] = {
          type,
          offset,
        };
      }
    });

    // We need to know the lengths of the slices to compute the CRCs.
    const offsetArray = Object.keys(offsetToObject).map(Number);
    for (const [i, start] of offsetArray.entries()) {
      const end =
        i + 1 === offsetArray.length ? pack.byteLength - 20 : offsetArray[i + 1];
      const o = offsetToObject[start];
      const crc = crc32$1.buf(pack.slice(start, end)) >>> 0;
      o.end = end;
      o.crc = crc;
    }

    // We don't have the hashes yet. But we can generate them using the .readSlice function!
    const p = new GitPackIndex({
      pack: Promise.resolve(pack),
      packfileSha,
      crcs,
      hashes,
      offsets,
      getExternalRefDelta,
    });

    // Resolve deltas and compute the oids
    lastPercent = null;
    let count = 0;
    const objectsByDepth = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    for (let offset in offsetToObject) {
      offset = Number(offset);
      const percent = Math.floor((count++ * 100) / totalObjectCount);
      if (percent !== lastPercent) {
        if (onProgress) {
          await onProgress({
            phase: 'Resolving deltas',
            loaded: count,
            total: totalObjectCount,
          });
        }
      }
      lastPercent = percent;

      const o = offsetToObject[offset];
      if (o.oid) continue
      try {
        p.readDepth = 0;
        p.externalReadDepth = 0;
        const { type, object } = await p.readSlice({ start: offset });
        objectsByDepth[p.readDepth] += 1;
        const oid = await shasum(GitObject.wrap({ type, object }));
        o.oid = oid;
        hashes.push(oid);
        offsets.set(oid, offset);
        crcs[oid] = o.crc;
      } catch (err) {
        continue
      }
    }

    hashes.sort();
    return p
  }

  async toBuffer() {
    const buffers = [];
    const write = (str, encoding) => {
      buffers.push(Buffer.from(str, encoding));
    };
    // Write out IDX v2 magic number
    write('ff744f63', 'hex');
    // Write out version number 2
    write('00000002', 'hex');
    // Write fanout table
    const fanoutBuffer = new BufferCursor(Buffer.alloc(256 * 4));
    for (let i = 0; i < 256; i++) {
      let count = 0;
      for (const hash of this.hashes) {
        if (parseInt(hash.slice(0, 2), 16) <= i) count++;
      }
      fanoutBuffer.writeUInt32BE(count);
    }
    buffers.push(fanoutBuffer.buffer);
    // Write out hashes
    for (const hash of this.hashes) {
      write(hash, 'hex');
    }
    // Write out crcs
    const crcsBuffer = new BufferCursor(Buffer.alloc(this.hashes.length * 4));
    for (const hash of this.hashes) {
      crcsBuffer.writeUInt32BE(this.crcs[hash]);
    }
    buffers.push(crcsBuffer.buffer);
    // Write out offsets
    const offsetsBuffer = new BufferCursor(Buffer.alloc(this.hashes.length * 4));
    for (const hash of this.hashes) {
      offsetsBuffer.writeUInt32BE(this.offsets.get(hash));
    }
    buffers.push(offsetsBuffer.buffer);
    // Write out packfile checksum
    write(this.packfileSha, 'hex');
    // Write out shasum
    const totalBuffer = Buffer.concat(buffers);
    const sha = await shasum(totalBuffer);
    const shaBuffer = Buffer.alloc(20);
    shaBuffer.write(sha, 'hex');
    return Buffer.concat([totalBuffer, shaBuffer])
  }

  async load({ pack }) {
    this.pack = pack;
  }

  async unload() {
    this.pack = null;
  }

  async read({ oid }) {
    if (!this.offsets.get(oid)) {
      if (this.getExternalRefDelta) {
        this.externalReadDepth++;
        return this.getExternalRefDelta(oid)
      } else {
        throw new InternalError(`Could not read object ${oid} from packfile`)
      }
    }
    const start = this.offsets.get(oid);
    return this.readSlice({ start })
  }

  async readSlice({ start }) {
    if (this.offsetCache[start]) {
      return Object.assign({}, this.offsetCache[start])
    }
    this.readDepth++;
    const types = {
      0b0010000: 'commit',
      0b0100000: 'tree',
      0b0110000: 'blob',
      0b1000000: 'tag',
      0b1100000: 'ofs_delta',
      0b1110000: 'ref_delta',
    };
    if (!this.pack) {
      throw new InternalError(
        'Tried to read from a GitPackIndex with no packfile loaded into memory'
      )
    }
    const raw = (await this.pack).slice(start);
    const reader = new BufferCursor(raw);
    const byte = reader.readUInt8();
    // Object type is encoded in bits 654
    const btype = byte & 0b1110000;
    let type = types[btype];
    if (type === undefined) {
      throw new InternalError('Unrecognized type: 0b' + btype.toString(2))
    }
    // The length encoding get complicated.
    // Last four bits of length is encoded in bits 3210
    const lastFour = byte & 0b1111;
    let length = lastFour;
    // Whether the next byte is part of the variable-length encoded number
    // is encoded in bit 7
    const multibyte = byte & 0b10000000;
    if (multibyte) {
      length = otherVarIntDecode(reader, lastFour);
    }
    let base = null;
    let object = null;
    // Handle deltified objects
    if (type === 'ofs_delta') {
      const offset = decodeVarInt(reader);
      const baseOffset = start - offset
      ;({ object: base, type } = await this.readSlice({ start: baseOffset }));
    }
    if (type === 'ref_delta') {
      const oid = reader.slice(20).toString('hex')
      ;({ object: base, type } = await this.read({ oid }));
    }
    // Handle undeltified objects
    const buffer = raw.slice(reader.tell());
    object = Buffer.from(await inflate(buffer));
    // Assert that the object length is as expected.
    if (object.byteLength !== length) {
      throw new InternalError(
        `Packfile told us object would have length ${length} but it had length ${object.byteLength}`
      )
    }
    if (base) {
      object = Buffer.from(applyDelta(object, base));
    }
    // Cache the result based on depth.
    if (this.readDepth > 3) {
      // hand tuned for speed / memory usage tradeoff
      this.offsetCache[start] = { type, object };
    }
    return { type, format: 'content', object }
  }
}

const PackfileCache = Symbol('PackfileCache');

async function loadPackIndex({
  fs,
  filename,
  getExternalRefDelta,
  emitter,
  emitterPrefix,
}) {
  const idx = await fs.read(filename);
  return GitPackIndex.fromIdx({ idx, getExternalRefDelta })
}

function readPackIndex({
  fs,
  cache,
  filename,
  getExternalRefDelta,
  emitter,
  emitterPrefix,
}) {
  // Try to get the packfile index from the in-memory cache
  if (!cache[PackfileCache]) cache[PackfileCache] = new Map();
  let p = cache[PackfileCache].get(filename);
  if (!p) {
    p = loadPackIndex({
      fs,
      filename,
      getExternalRefDelta,
      emitter,
      emitterPrefix,
    });
    cache[PackfileCache].set(filename, p);
  }
  return p
}

async function readObjectPacked({
  fs,
  cache,
  gitdir,
  oid,
  format = 'content',
  getExternalRefDelta,
}) {
  // Check to see if it's in a packfile.
  // Iterate through all the .idx files
  let list = await fs.readdir(join(gitdir, 'objects/pack'));
  list = list.filter(x => x.endsWith('.idx'));
  for (const filename of list) {
    const indexFile = `${gitdir}/objects/pack/${filename}`;
    const p = await readPackIndex({
      fs,
      cache,
      filename: indexFile,
      getExternalRefDelta,
    });
    if (p.error) throw new InternalError(p.error)
    // If the packfile DOES have the oid we're looking for...
    if (p.offsets.has(oid)) {
      // Get the resolved git object from the packfile
      if (!p.pack) {
        const packFile = indexFile.replace(/idx$/, 'pack');
        p.pack = fs.read(packFile);
      }
      const result = await p.read({ oid, getExternalRefDelta });
      result.format = 'content';
      result.source = `objects/pack/${filename.replace(/idx$/, 'pack')}`;
      return result
    }
  }
  // Failed to find it
  return null
}

/**
 * @param {object} args
 * @param {import('../models/FileSystem.js').FileSystem} args.fs
 * @param {any} args.cache
 * @param {string} args.gitdir
 * @param {string} args.oid
 * @param {string} [args.format]
 */
async function _readObject({
  fs,
  cache,
  gitdir,
  oid,
  format = 'content',
}) {
  // Curry the current read method so that the packfile un-deltification
  // process can acquire external ref-deltas.
  const getExternalRefDelta = oid => _readObject({ fs, cache, gitdir, oid });

  let result;
  // Empty tree - hard-coded so we can use it as a shorthand.
  // Note: I think the canonical git implementation must do this too because
  // `git cat-file -t 4b825dc642cb6eb9a060e54bf8d69288fbee4904` prints "tree" even in empty repos.
  if (oid === '4b825dc642cb6eb9a060e54bf8d69288fbee4904') {
    result = { format: 'wrapped', object: Buffer.from(`tree 0\x00`) };
  }
  // Look for it in the loose object directory.
  if (!result) {
    result = await readObjectLoose({ fs, gitdir, oid });
  }
  // Check to see if it's in a packfile.
  if (!result) {
    result = await readObjectPacked({
      fs,
      cache,
      gitdir,
      oid,
      getExternalRefDelta,
    });
  }
  // Finally
  if (!result) {
    throw new NotFoundError(oid)
  }

  if (format === 'deflated') {
    return result
  }

  // BEHOLD! THE ONLY TIME I'VE EVER WANTED TO USE A CASE STATEMENT WITH FOLLOWTHROUGH!
  // eslint-ignore
  /* eslint-disable no-fallthrough */
  switch (result.format) {
    case 'deflated': {
      result.object = Buffer.from(await inflate(result.object));
      result.format = 'wrapped';
    }
    case 'wrapped': {
      if (format === 'wrapped' && result.format === 'wrapped') {
        return result
      }
      const sha = await shasum(result.object);
      if (sha !== oid) {
        throw new InternalError(
          `SHA check failed! Expected ${oid}, computed ${sha}`
        )
      }
      const { object, type } = GitObject.unwrap(result.object);
      result.type = type;
      result.object = object;
      result.format = 'content';
    }
    case 'content': {
      if (format === 'content') return result
      break
    }
    default: {
      throw new InternalError(`invalid format "${result.format}"`)
    }
  }
  /* eslint-enable no-fallthrough */
}

class AlreadyExistsError extends BaseError {
  /**
   * @param {'note'|'remote'|'tag'|'branch'} noun
   * @param {string} where
   * @param {boolean} canForce
   */
  constructor(noun, where, canForce = true) {
    super(
      `Failed to create ${noun} at ${where} because it already exists.${
        canForce
          ? ` (Hint: use 'force: true' parameter to overwrite existing ${noun}.)`
          : ''
      }`
    );
    this.code = this.name = AlreadyExistsError.code;
    this.data = { noun, where, canForce };
  }
}
/** @type {'AlreadyExistsError'} */
AlreadyExistsError.code = 'AlreadyExistsError';

class AmbiguousError extends BaseError {
  /**
   * @param {'oids'|'refs'} nouns
   * @param {string} short
   * @param {string[]} matches
   */
  constructor(nouns, short, matches) {
    super(
      `Found multiple ${nouns} matching "${short}" (${matches.join(
        ', '
      )}). Use a longer abbreviation length to disambiguate them.`
    );
    this.code = this.name = AmbiguousError.code;
    this.data = { nouns, short, matches };
  }
}
/** @type {'AmbiguousError'} */
AmbiguousError.code = 'AmbiguousError';

class CheckoutConflictError extends BaseError {
  /**
   * @param {string[]} filepaths
   */
  constructor(filepaths) {
    super(
      `Your local changes to the following files would be overwritten by checkout: ${filepaths.join(
        ', '
      )}`
    );
    this.code = this.name = CheckoutConflictError.code;
    this.data = { filepaths };
  }
}
/** @type {'CheckoutConflictError'} */
CheckoutConflictError.code = 'CheckoutConflictError';

class CommitNotFetchedError extends BaseError {
  /**
   * @param {string} ref
   * @param {string} oid
   */
  constructor(ref, oid) {
    super(
      `Failed to checkout "${ref}" because commit ${oid} is not available locally. Do a git fetch to make the branch available locally.`
    );
    this.code = this.name = CommitNotFetchedError.code;
    this.data = { ref, oid };
  }
}
/** @type {'CommitNotFetchedError'} */
CommitNotFetchedError.code = 'CommitNotFetchedError';

class EmptyServerResponseError extends BaseError {
  constructor() {
    super(`Empty response from git server.`);
    this.code = this.name = EmptyServerResponseError.code;
    this.data = {};
  }
}
/** @type {'EmptyServerResponseError'} */
EmptyServerResponseError.code = 'EmptyServerResponseError';

class FastForwardError extends BaseError {
  constructor() {
    super(`A simple fast-forward merge was not possible.`);
    this.code = this.name = FastForwardError.code;
    this.data = {};
  }
}
/** @type {'FastForwardError'} */
FastForwardError.code = 'FastForwardError';

class GitPushError extends BaseError {
  /**
   * @param {string} prettyDetails
   * @param {PushResult} result
   */
  constructor(prettyDetails, result) {
    super(`One or more branches were not updated: ${prettyDetails}`);
    this.code = this.name = GitPushError.code;
    this.data = { prettyDetails, result };
  }
}
/** @type {'GitPushError'} */
GitPushError.code = 'GitPushError';

class HttpError extends BaseError {
  /**
   * @param {number} statusCode
   * @param {string} statusMessage
   * @param {string} response
   */
  constructor(statusCode, statusMessage, response) {
    super(`HTTP Error: ${statusCode} ${statusMessage}`);
    this.code = this.name = HttpError.code;
    this.data = { statusCode, statusMessage, response };
  }
}
/** @type {'HttpError'} */
HttpError.code = 'HttpError';

class InvalidFilepathError extends BaseError {
  /**
   * @param {'leading-slash'|'trailing-slash'} [reason]
   */
  constructor(reason) {
    let message = 'invalid filepath';
    if (reason === 'leading-slash' || reason === 'trailing-slash') {
      message = `"filepath" parameter should not include leading or trailing directory separators because these can cause problems on some platforms.`;
    }
    super(message);
    this.code = this.name = InvalidFilepathError.code;
    this.data = { reason };
  }
}
/** @type {'InvalidFilepathError'} */
InvalidFilepathError.code = 'InvalidFilepathError';

class InvalidRefNameError extends BaseError {
  /**
   * @param {string} ref
   * @param {string} suggestion
   * @param {boolean} canForce
   */
  constructor(ref, suggestion) {
    super(
      `"${ref}" would be an invalid git reference. (Hint: a valid alternative would be "${suggestion}".)`
    );
    this.code = this.name = InvalidRefNameError.code;
    this.data = { ref, suggestion };
  }
}
/** @type {'InvalidRefNameError'} */
InvalidRefNameError.code = 'InvalidRefNameError';

class MaxDepthError extends BaseError {
  /**
   * @param {number} depth
   */
  constructor(depth) {
    super(`Maximum search depth of ${depth} exceeded.`);
    this.code = this.name = MaxDepthError.code;
    this.data = { depth };
  }
}
/** @type {'MaxDepthError'} */
MaxDepthError.code = 'MaxDepthError';

class MergeNotSupportedError extends BaseError {
  constructor() {
    super(`Merges with conflicts are not supported yet.`);
    this.code = this.name = MergeNotSupportedError.code;
    this.data = {};
  }
}
/** @type {'MergeNotSupportedError'} */
MergeNotSupportedError.code = 'MergeNotSupportedError';

class MissingNameError extends BaseError {
  /**
   * @param {'author'|'committer'|'tagger'} role
   */
  constructor(role) {
    super(
      `No name was provided for ${role} in the argument or in the .git/config file.`
    );
    this.code = this.name = MissingNameError.code;
    this.data = { role };
  }
}
/** @type {'MissingNameError'} */
MissingNameError.code = 'MissingNameError';

class MissingParameterError extends BaseError {
  /**
   * @param {string} parameter
   */
  constructor(parameter) {
    super(
      `The function requires a "${parameter}" parameter but none was provided.`
    );
    this.code = this.name = MissingParameterError.code;
    this.data = { parameter };
  }
}
/** @type {'MissingParameterError'} */
MissingParameterError.code = 'MissingParameterError';

class ParseError extends BaseError {
  /**
   * @param {string} expected
   * @param {string} actual
   */
  constructor(expected, actual) {
    super(`Expected "${expected}" but received "${actual}".`);
    this.code = this.name = ParseError.code;
    this.data = { expected, actual };
  }
}
/** @type {'ParseError'} */
ParseError.code = 'ParseError';

class PushRejectedError extends BaseError {
  /**
   * @param {'not-fast-forward'|'tag-exists'} reason
   */
  constructor(reason) {
    let message = '';
    if (reason === 'not-fast-forward') {
      message = ' because it was not a simple fast-forward';
    } else if (reason === 'tag-exists') {
      message = ' because tag already exists';
    }
    super(`Push rejected${message}. Use "force: true" to override.`);
    this.code = this.name = PushRejectedError.code;
    this.data = { reason };
  }
}
/** @type {'PushRejectedError'} */
PushRejectedError.code = 'PushRejectedError';

class RemoteCapabilityError extends BaseError {
  /**
   * @param {'shallow'|'deepen-since'|'deepen-not'|'deepen-relative'} capability
   * @param {'depth'|'since'|'exclude'|'relative'} parameter
   */
  constructor(capability, parameter) {
    super(
      `Remote does not support the "${capability}" so the "${parameter}" parameter cannot be used.`
    );
    this.code = this.name = RemoteCapabilityError.code;
    this.data = { capability, parameter };
  }
}
/** @type {'RemoteCapabilityError'} */
RemoteCapabilityError.code = 'RemoteCapabilityError';

class SmartHttpError extends BaseError {
  /**
   * @param {string} preview
   * @param {string} response
   */
  constructor(preview, response) {
    super(
      `Remote did not reply using the "smart" HTTP protocol. Expected "001e# service=git-upload-pack" but received: ${preview}`
    );
    this.code = this.name = SmartHttpError.code;
    this.data = { preview, response };
  }
}
/** @type {'SmartHttpError'} */
SmartHttpError.code = 'SmartHttpError';

class UnknownTransportError extends BaseError {
  /**
   * @param {string} url
   * @param {string} transport
   * @param {string} suggestion
   */
  constructor(url, transport, suggestion) {
    super(
      `Git remote "${url}" uses an unrecognized transport protocol: "${transport}"`
    );
    this.code = this.name = UnknownTransportError.code;
    this.data = { url, transport, suggestion };
  }
}
/** @type {'UnknownTransportError'} */
UnknownTransportError.code = 'UnknownTransportError';

class UrlParseError extends BaseError {
  /**
   * @param {string} url
   */
  constructor(url) {
    super(`Cannot parse remote URL: "${url}"`);
    this.code = this.name = UrlParseError.code;
    this.data = { url };
  }
}
/** @type {'UrlParseError'} */
UrlParseError.code = 'UrlParseError';

class UserCanceledError extends BaseError {
  constructor() {
    super(`The operation was canceled.`);
    this.code = this.name = UserCanceledError.code;
    this.data = {};
  }
}
/** @type {'UserCanceledError'} */
UserCanceledError.code = 'UserCanceledError';



var Errors = /*#__PURE__*/Object.freeze({
  __proto__: null,
  AlreadyExistsError: AlreadyExistsError,
  AmbiguousError: AmbiguousError,
  CheckoutConflictError: CheckoutConflictError,
  CommitNotFetchedError: CommitNotFetchedError,
  EmptyServerResponseError: EmptyServerResponseError,
  FastForwardError: FastForwardError,
  GitPushError: GitPushError,
  HttpError: HttpError,
  InternalError: InternalError,
  InvalidFilepathError: InvalidFilepathError,
  InvalidOidError: InvalidOidError,
  InvalidRefNameError: InvalidRefNameError,
  MaxDepthError: MaxDepthError,
  MergeNotSupportedError: MergeNotSupportedError,
  MissingNameError: MissingNameError,
  MissingParameterError: MissingParameterError,
  NoRefspecError: NoRefspecError,
  NotFoundError: NotFoundError,
  ObjectTypeError: ObjectTypeError,
  ParseError: ParseError,
  PushRejectedError: PushRejectedError,
  RemoteCapabilityError: RemoteCapabilityError,
  SmartHttpError: SmartHttpError,
  UnknownTransportError: UnknownTransportError,
  UrlParseError: UrlParseError,
  UserCanceledError: UserCanceledError
});

function formatAuthor({ name, email, timestamp, timezoneOffset }) {
  timezoneOffset = formatTimezoneOffset(timezoneOffset);
  return `${name} <${email}> ${timestamp} ${timezoneOffset}`
}

// The amount of effort that went into crafting these cases to handle
// -0 (just so we don't lose that information when parsing and reconstructing)
// but can also default to +0 was extraordinary.

function formatTimezoneOffset(minutes) {
  const sign = simpleSign(negateExceptForZero(minutes));
  minutes = Math.abs(minutes);
  const hours = Math.floor(minutes / 60);
  minutes -= hours * 60;
  let strHours = String(hours);
  let strMinutes = String(minutes);
  if (strHours.length < 2) strHours = '0' + strHours;
  if (strMinutes.length < 2) strMinutes = '0' + strMinutes;
  return (sign === -1 ? '-' : '+') + strHours + strMinutes
}

function simpleSign(n) {
  return Math.sign(n) || (Object.is(n, -0) ? -1 : 1)
}

function negateExceptForZero(n) {
  return n === 0 ? n : -n
}

function normalizeNewlines(str) {
  // remove all <CR>
  str = str.replace(/\r/g, '');
  // no extra newlines up front
  str = str.replace(/^\n+/, '');
  // and a single newline at the end
  str = str.replace(/\n+$/, '') + '\n';
  return str
}

function parseAuthor(author) {
  const [, name, email, timestamp, offset] = author.match(
    /^(.*) <(.*)> (.*) (.*)$/
  );
  return {
    name: name,
    email: email,
    timestamp: Number(timestamp),
    timezoneOffset: parseTimezoneOffset(offset),
  }
}

// The amount of effort that went into crafting these cases to handle
// -0 (just so we don't lose that information when parsing and reconstructing)
// but can also default to +0 was extraordinary.

function parseTimezoneOffset(offset) {
  let [, sign, hours, minutes] = offset.match(/(\+|-)(\d\d)(\d\d)/);
  minutes = (sign === '+' ? 1 : -1) * (Number(hours) * 60 + Number(minutes));
  return negateExceptForZero$1(minutes)
}

function negateExceptForZero$1(n) {
  return n === 0 ? n : -n
}

class GitAnnotatedTag {
  constructor(tag) {
    if (typeof tag === 'string') {
      this._tag = tag;
    } else if (Buffer.isBuffer(tag)) {
      this._tag = tag.toString('utf8');
    } else if (typeof tag === 'object') {
      this._tag = GitAnnotatedTag.render(tag);
    } else {
      throw new InternalError(
        'invalid type passed to GitAnnotatedTag constructor'
      )
    }
  }

  static from(tag) {
    return new GitAnnotatedTag(tag)
  }

  static render(obj) {
    return `object ${obj.object}
type ${obj.type}
tag ${obj.tag}
tagger ${formatAuthor(obj.tagger)}

${obj.message}
${obj.gpgsig ? obj.gpgsig : ''}`
  }

  justHeaders() {
    return this._tag.slice(0, this._tag.indexOf('\n\n'))
  }

  message() {
    const tag = this.withoutSignature();
    return tag.slice(tag.indexOf('\n\n') + 2)
  }

  parse() {
    return Object.assign(this.headers(), {
      message: this.message(),
      gpgsig: this.gpgsig(),
    })
  }

  render() {
    return this._tag
  }

  headers() {
    const headers = this.justHeaders().split('\n');
    const hs = [];
    for (const h of headers) {
      if (h[0] === ' ') {
        // combine with previous header (without space indent)
        hs[hs.length - 1] += '\n' + h.slice(1);
      } else {
        hs.push(h);
      }
    }
    const obj = {};
    for (const h of hs) {
      const key = h.slice(0, h.indexOf(' '));
      const value = h.slice(h.indexOf(' ') + 1);
      if (Array.isArray(obj[key])) {
        obj[key].push(value);
      } else {
        obj[key] = value;
      }
    }
    if (obj.tagger) {
      obj.tagger = parseAuthor(obj.tagger);
    }
    if (obj.committer) {
      obj.committer = parseAuthor(obj.committer);
    }
    return obj
  }

  withoutSignature() {
    const tag = normalizeNewlines(this._tag);
    if (tag.indexOf('\n-----BEGIN PGP SIGNATURE-----') === -1) return tag
    return tag.slice(0, tag.lastIndexOf('\n-----BEGIN PGP SIGNATURE-----'))
  }

  gpgsig() {
    if (this._tag.indexOf('\n-----BEGIN PGP SIGNATURE-----') === -1) return
    const signature = this._tag.slice(
      this._tag.indexOf('-----BEGIN PGP SIGNATURE-----'),
      this._tag.indexOf('-----END PGP SIGNATURE-----') +
        '-----END PGP SIGNATURE-----'.length
    );
    return normalizeNewlines(signature)
  }

  payload() {
    return this.withoutSignature() + '\n'
  }

  toObject() {
    return Buffer.from(this._tag, 'utf8')
  }

  static async sign(tag, sign, secretKey) {
    const payload = tag.payload();
    let { signature } = await sign({ payload, secretKey });
    // renormalize the line endings to the one true line-ending
    signature = normalizeNewlines(signature);
    const signedTag = payload + signature;
    // return a new tag object
    return GitAnnotatedTag.from(signedTag)
  }
}

function indent(str) {
  return (
    str
      .trim()
      .split('\n')
      .map(x => ' ' + x)
      .join('\n') + '\n'
  )
}

function outdent(str) {
  return str
    .split('\n')
    .map(x => x.replace(/^ /, ''))
    .join('\n')
}

class GitCommit {
  constructor(commit) {
    if (typeof commit === 'string') {
      this._commit = commit;
    } else if (Buffer.isBuffer(commit)) {
      this._commit = commit.toString('utf8');
    } else if (typeof commit === 'object') {
      this._commit = GitCommit.render(commit);
    } else {
      throw new InternalError('invalid type passed to GitCommit constructor')
    }
  }

  static fromPayloadSignature({ payload, signature }) {
    const headers = GitCommit.justHeaders(payload);
    const message = GitCommit.justMessage(payload);
    const commit = normalizeNewlines(
      headers + '\ngpgsig' + indent(signature) + '\n' + message
    );
    return new GitCommit(commit)
  }

  static from(commit) {
    return new GitCommit(commit)
  }

  toObject() {
    return Buffer.from(this._commit, 'utf8')
  }

  // Todo: allow setting the headers and message
  headers() {
    return this.parseHeaders()
  }

  // Todo: allow setting the headers and message
  message() {
    return GitCommit.justMessage(this._commit)
  }

  parse() {
    return Object.assign({ message: this.message() }, this.headers())
  }

  static justMessage(commit) {
    return normalizeNewlines(commit.slice(commit.indexOf('\n\n') + 2))
  }

  static justHeaders(commit) {
    return commit.slice(0, commit.indexOf('\n\n'))
  }

  parseHeaders() {
    const headers = GitCommit.justHeaders(this._commit).split('\n');
    const hs = [];
    for (const h of headers) {
      if (h[0] === ' ') {
        // combine with previous header (without space indent)
        hs[hs.length - 1] += '\n' + h.slice(1);
      } else {
        hs.push(h);
      }
    }
    const obj = {
      parent: [],
    };
    for (const h of hs) {
      const key = h.slice(0, h.indexOf(' '));
      const value = h.slice(h.indexOf(' ') + 1);
      if (Array.isArray(obj[key])) {
        obj[key].push(value);
      } else {
        obj[key] = value;
      }
    }
    if (obj.author) {
      obj.author = parseAuthor(obj.author);
    }
    if (obj.committer) {
      obj.committer = parseAuthor(obj.committer);
    }
    return obj
  }

  static renderHeaders(obj) {
    let headers = '';
    if (obj.tree) {
      headers += `tree ${obj.tree}\n`;
    } else {
      headers += `tree 4b825dc642cb6eb9a060e54bf8d69288fbee4904\n`; // the null tree
    }
    if (obj.parent) {
      if (obj.parent.length === undefined) {
        throw new InternalError(`commit 'parent' property should be an array`)
      }
      for (const p of obj.parent) {
        headers += `parent ${p}\n`;
      }
    }
    const author = obj.author;
    headers += `author ${formatAuthor(author)}\n`;
    const committer = obj.committer || obj.author;
    headers += `committer ${formatAuthor(committer)}\n`;
    if (obj.gpgsig) {
      headers += 'gpgsig' + indent(obj.gpgsig);
    }
    return headers
  }

  static render(obj) {
    return GitCommit.renderHeaders(obj) + '\n' + normalizeNewlines(obj.message)
  }

  render() {
    return this._commit
  }

  withoutSignature() {
    const commit = normalizeNewlines(this._commit);
    if (commit.indexOf('\ngpgsig') === -1) return commit
    const headers = commit.slice(0, commit.indexOf('\ngpgsig'));
    const message = commit.slice(
      commit.indexOf('-----END PGP SIGNATURE-----\n') +
        '-----END PGP SIGNATURE-----\n'.length
    );
    return normalizeNewlines(headers + '\n' + message)
  }

  isolateSignature() {
    const signature = this._commit.slice(
      this._commit.indexOf('-----BEGIN PGP SIGNATURE-----'),
      this._commit.indexOf('-----END PGP SIGNATURE-----') +
        '-----END PGP SIGNATURE-----'.length
    );
    return outdent(signature)
  }

  static async sign(commit, sign, secretKey) {
    const payload = commit.withoutSignature();
    const message = GitCommit.justMessage(commit._commit);
    let { signature } = await sign({ payload, secretKey });
    // renormalize the line endings to the one true line-ending
    signature = normalizeNewlines(signature);
    const headers = GitCommit.justHeaders(commit._commit);
    const signedCommit =
      headers + '\n' + 'gpgsig' + indent(signature) + '\n' + message;
    // return a new commit object
    return GitCommit.from(signedCommit)
  }
}

async function resolveTree({ fs, cache, gitdir, oid }) {
  // Empty tree - bypass `readObject`
  if (oid === '4b825dc642cb6eb9a060e54bf8d69288fbee4904') {
    return { tree: GitTree.from([]), oid }
  }
  const { type, object } = await _readObject({ fs, cache, gitdir, oid });
  // Resolve annotated tag objects to whatever
  if (type === 'tag') {
    oid = GitAnnotatedTag.from(object).parse().object;
    return resolveTree({ fs, cache, gitdir, oid })
  }
  // Resolve commits to trees
  if (type === 'commit') {
    oid = GitCommit.from(object).parse().tree;
    return resolveTree({ fs, cache, gitdir, oid })
  }
  if (type !== 'tree') {
    throw new ObjectTypeError(oid, type, 'tree')
  }
  return { tree: GitTree.from(object), oid }
}

class GitWalkerRepo {
  constructor({ fs, gitdir, ref, cache }) {
    this.fs = fs;
    this.cache = cache;
    this.gitdir = gitdir;
    this.mapPromise = (async () => {
      const map = new Map();
      let oid;
      try {
        oid = await GitRefManager.resolve({ fs, gitdir, ref });
      } catch (e) {
        if (e instanceof NotFoundError) {
          // Handle fresh branches with no commits
          oid = '4b825dc642cb6eb9a060e54bf8d69288fbee4904';
        }
      }
      const tree = await resolveTree({ fs, cache: this.cache, gitdir, oid });
      tree.type = 'tree';
      tree.mode = '40000';
      map.set('.', tree);
      return map
    })();
    const walker = this;
    this.ConstructEntry = class TreeEntry {
      constructor(fullpath) {
        this._fullpath = fullpath;
        this._type = false;
        this._mode = false;
        this._stat = false;
        this._content = false;
        this._oid = false;
      }

      async type() {
        return walker.type(this)
      }

      async mode() {
        return walker.mode(this)
      }

      async stat() {
        return walker.stat(this)
      }

      async content() {
        return walker.content(this)
      }

      async oid() {
        return walker.oid(this)
      }
    };
  }

  async readdir(entry) {
    const filepath = entry._fullpath;
    const { fs, cache, gitdir } = this;
    const map = await this.mapPromise;
    const obj = map.get(filepath);
    if (!obj) throw new Error(`No obj for ${filepath}`)
    const oid = obj.oid;
    if (!oid) throw new Error(`No oid for obj ${JSON.stringify(obj)}`)
    if (obj.type !== 'tree') {
      // TODO: support submodules (type === 'commit')
      return null
    }
    const { type, object } = await _readObject({ fs, cache, gitdir, oid });
    if (type !== obj.type) {
      throw new ObjectTypeError(oid, type, obj.type)
    }
    const tree = GitTree.from(object);
    // cache all entries
    for (const entry of tree) {
      map.set(join(filepath, entry.path), entry);
    }
    return tree.entries().map(entry => join(filepath, entry.path))
  }

  async type(entry) {
    if (entry._type === false) {
      const map = await this.mapPromise;
      const { type } = map.get(entry._fullpath);
      entry._type = type;
    }
    return entry._type
  }

  async mode(entry) {
    if (entry._mode === false) {
      const map = await this.mapPromise;
      const { mode } = map.get(entry._fullpath);
      entry._mode = normalizeMode(parseInt(mode, 8));
    }
    return entry._mode
  }

  async stat(_entry) {}

  async content(entry) {
    if (entry._content === false) {
      const map = await this.mapPromise;
      const { fs, cache, gitdir } = this;
      const obj = map.get(entry._fullpath);
      const oid = obj.oid;
      const { type, object } = await _readObject({ fs, cache, gitdir, oid });
      if (type !== 'blob') {
        entry._content = undefined;
      } else {
        entry._content = new Uint8Array(object);
      }
    }
    return entry._content
  }

  async oid(entry) {
    if (entry._oid === false) {
      const map = await this.mapPromise;
      const obj = map.get(entry._fullpath);
      entry._oid = obj.oid;
    }
    return entry._oid
  }
}

// @ts-check

/**
 * @param {object} args
 * @param {string} [args.ref='HEAD']
 * @returns {Walker}
 */
function TREE({ ref = 'HEAD' }) {
  const o = Object.create(null);
  Object.defineProperty(o, GitWalkSymbol, {
    value: function({ fs, gitdir, cache }) {
      return new GitWalkerRepo({ fs, gitdir, ref, cache })
    },
  });
  Object.freeze(o);
  return o
}

// @ts-check

class GitWalkerFs {
  constructor({ fs, dir, gitdir, cache }) {
    this.fs = fs;
    this.cache = cache;
    this.dir = dir;
    this.gitdir = gitdir;
    const walker = this;
    this.ConstructEntry = class WorkdirEntry {
      constructor(fullpath) {
        this._fullpath = fullpath;
        this._type = false;
        this._mode = false;
        this._stat = false;
        this._content = false;
        this._oid = false;
      }

      async type() {
        return walker.type(this)
      }

      async mode() {
        return walker.mode(this)
      }

      async stat() {
        return walker.stat(this)
      }

      async content() {
        return walker.content(this)
      }

      async oid() {
        return walker.oid(this)
      }
    };
  }

  async readdir(entry) {
    const filepath = entry._fullpath;
    const { fs, dir } = this;
    const names = await fs.readdir(join(dir, filepath));
    if (names === null) return null
    return names.map(name => join(filepath, name))
  }

  async type(entry) {
    if (entry._type === false) {
      await entry.stat();
    }
    return entry._type
  }

  async mode(entry) {
    if (entry._mode === false) {
      await entry.stat();
    }
    return entry._mode
  }

  async stat(entry) {
    if (entry._stat === false) {
      const { fs, dir } = this;
      let stat = await fs.lstat(`${dir}/${entry._fullpath}`);
      if (!stat) {
        throw new Error(
          `ENOENT: no such file or directory, lstat '${entry._fullpath}'`
        )
      }
      let type = stat.isDirectory() ? 'tree' : 'blob';
      if (type === 'blob' && !stat.isFile() && !stat.isSymbolicLink()) {
        type = 'special';
      }
      entry._type = type;
      stat = normalizeStats(stat);
      entry._mode = stat.mode;
      // workaround for a BrowserFS edge case
      if (stat.size === -1 && entry._actualSize) {
        stat.size = entry._actualSize;
      }
      entry._stat = stat;
    }
    return entry._stat
  }

  async content(entry) {
    if (entry._content === false) {
      const { fs, dir } = this;
      if ((await entry.type()) === 'tree') {
        entry._content = undefined;
      } else {
        const content = await fs.read(`${dir}/${entry._fullpath}`);
        // workaround for a BrowserFS edge case
        entry._actualSize = content.length;
        if (entry._stat && entry._stat.size === -1) {
          entry._stat.size = entry._actualSize;
        }
        entry._content = new Uint8Array(content);
      }
    }
    return entry._content
  }

  async oid(entry) {
    if (entry._oid === false) {
      const { fs, gitdir, cache } = this;
      let oid;
      // See if we can use the SHA1 hash in the index.
      await GitIndexManager.acquire({ fs, gitdir, cache }, async function(
        index
      ) {
        const stage = index.entriesMap.get(entry._fullpath);
        const stats = await entry.stat();
        if (!stage || compareStats(stats, stage)) {
          const content = await entry.content();
          if (content === undefined) {
            oid = undefined;
          } else {
            oid = await shasum(
              GitObject.wrap({ type: 'blob', object: await entry.content() })
            );
            if (stage && oid === stage.oid) {
              index.insert({
                filepath: entry._fullpath,
                stats,
                oid: oid,
              });
            }
          }
        } else {
          // Use the index SHA1 rather than compute it
          oid = stage.oid;
        }
      });
      entry._oid = oid;
    }
    return entry._oid
  }
}

// @ts-check

/**
 * @returns {Walker}
 */
function WORKDIR() {
  const o = Object.create(null);
  Object.defineProperty(o, GitWalkSymbol, {
    value: function({ fs, dir, gitdir, cache }) {
      return new GitWalkerFs({ fs, dir, gitdir, cache })
    },
  });
  Object.freeze(o);
  return o
}

// @ts-check

// I'm putting this in a Manager because I reckon it could benefit
// from a LOT of cacheing.

// TODO: Implement .git/info/exclude

class GitIgnoreManager {
  static async isIgnored({ fs, dir, gitdir = join(dir, '.git'), filepath }) {
    // ALWAYS ignore ".git" folders.
    if (basename(filepath) === '.git') return true
    // '.' is not a valid gitignore entry, so '.' is never ignored
    if (filepath === '.') return false
    // Find all the .gitignore files that could affect this file
    const pairs = [
      {
        gitignore: join(dir, '.gitignore'),
        filepath,
      },
    ];
    const pieces = filepath.split('/');
    for (let i = 1; i < pieces.length; i++) {
      const folder = pieces.slice(0, i).join('/');
      const file = pieces.slice(i).join('/');
      pairs.push({
        gitignore: join(dir, folder, '.gitignore'),
        filepath: file,
      });
    }
    let ignoredStatus = false;
    for (const p of pairs) {
      let file;
      try {
        file = await fs.read(p.gitignore, 'utf8');
      } catch (err) {
        if (err.code === 'NOENT') continue
      }
      const ign = ignore().add(file);
      // If the parent directory is excluded, we are done.
      // "It is not possible to re-include a file if a parent directory of that file is excluded. Git doesnt list excluded directories for performance reasons, so any patterns on contained files have no effect, no matter where they are defined."
      // source: https://git-scm.com/docs/gitignore
      const parentdir = dirname(p.filepath);
      if (parentdir !== '.' && ign.ignores(parentdir)) return true
      // If the file is currently ignored, test for UNignoring.
      if (ignoredStatus) {
        ignoredStatus = !ign.test(p.filepath).unignored;
      } else {
        ignoredStatus = ign.test(p.filepath).ignored;
      }
    }
    return ignoredStatus
  }
}

/**
 * This is just a collection of helper functions really. At least that's how it started.
 */
class FileSystem {
  constructor(fs) {
    if (typeof fs._original_unwrapped_fs !== 'undefined') return fs

    const promises = Object.getOwnPropertyDescriptor(fs, 'promises');
    if (promises && promises.enumerable) {
      this._readFile = fs.promises.readFile.bind(fs.promises);
      this._writeFile = fs.promises.writeFile.bind(fs.promises);
      this._mkdir = fs.promises.mkdir.bind(fs.promises);
      this._rmdir = fs.promises.rmdir.bind(fs.promises);
      this._unlink = fs.promises.unlink.bind(fs.promises);
      this._stat = fs.promises.stat.bind(fs.promises);
      this._lstat = fs.promises.lstat.bind(fs.promises);
      this._readdir = fs.promises.readdir.bind(fs.promises);
      this._readlink = fs.promises.readlink.bind(fs.promises);
      this._symlink = fs.promises.symlink.bind(fs.promises);
    } else {
      this._readFile = pify(fs.readFile.bind(fs));
      this._writeFile = pify(fs.writeFile.bind(fs));
      this._mkdir = pify(fs.mkdir.bind(fs));
      this._rmdir = pify(fs.rmdir.bind(fs));
      this._unlink = pify(fs.unlink.bind(fs));
      this._stat = pify(fs.stat.bind(fs));
      this._lstat = pify(fs.lstat.bind(fs));
      this._readdir = pify(fs.readdir.bind(fs));
      this._readlink = pify(fs.readlink.bind(fs));
      this._symlink = pify(fs.symlink.bind(fs));
    }
    this._original_unwrapped_fs = fs;
  }

  /**
   * Return true if a file exists, false if it doesn't exist.
   * Rethrows errors that aren't related to file existance.
   */
  async exists(filepath, options = {}) {
    try {
      await this._stat(filepath);
      return true
    } catch (err) {
      if (err.code === 'ENOENT' || err.code === 'ENOTDIR') {
        return false
      } else {
        console.log('Unhandled error in "FileSystem.exists()" function', err);
        throw err
      }
    }
  }

  /**
   * Return the contents of a file if it exists, otherwise returns null.
   *
   * @param {string} filepath
   * @param {object} [options]
   *
   * @returns {Promise<Buffer|string|null>}
   */
  async read(filepath, options = {}) {
    try {
      let buffer = await this._readFile(filepath, options);
      // Convert plain ArrayBuffers to Buffers
      if (typeof buffer !== 'string') {
        buffer = Buffer.from(buffer);
      }
      return buffer
    } catch (err) {
      return null
    }
  }

  /**
   * Write a file (creating missing directories if need be) without throwing errors.
   *
   * @param {string} filepath
   * @param {Buffer|Uint8Array|string} contents
   * @param {object|string} [options]
   */
  async write(filepath, contents, options = {}) {
    try {
      await this._writeFile(filepath, contents, options);
      return
    } catch (err) {
      // Hmm. Let's try mkdirp and try again.
      await this.mkdir(dirname(filepath));
      await this._writeFile(filepath, contents, options);
    }
  }

  /**
   * Make a directory (or series of nested directories) without throwing an error if it already exists.
   */
  async mkdir(filepath, _selfCall = false) {
    try {
      await this._mkdir(filepath);
      return
    } catch (err) {
      // If err is null then operation succeeded!
      if (err === null) return
      // If the directory already exists, that's OK!
      if (err.code === 'EEXIST') return
      // Avoid infinite loops of failure
      if (_selfCall) throw err
      // If we got a "no such file or directory error" backup and try again.
      if (err.code === 'ENOENT') {
        const parent = dirname(filepath);
        // Check to see if we've gone too far
        if (parent === '.' || parent === '/' || parent === filepath) throw err
        // Infinite recursion, what could go wrong?
        await this.mkdir(parent);
        await this.mkdir(filepath, true);
      }
    }
  }

  /**
   * Delete a file without throwing an error if it is already deleted.
   */
  async rm(filepath) {
    try {
      await this._unlink(filepath);
    } catch (err) {
      if (err.code !== 'ENOENT') throw err
    }
  }

  /**
   * Delete a directory without throwing an error if it is already deleted.
   */
  async rmdir(filepath) {
    try {
      await this._rmdir(filepath);
    } catch (err) {
      if (err.code !== 'ENOENT') throw err
    }
  }

  /**
   * Read a directory without throwing an error is the directory doesn't exist
   */
  async readdir(filepath) {
    try {
      const names = await this._readdir(filepath);
      // Ordering is not guaranteed, and system specific (Windows vs Unix)
      // so we must sort them ourselves.
      names.sort(compareStrings);
      return names
    } catch (err) {
      if (err.code === 'ENOTDIR') return null
      return []
    }
  }

  /**
   * Return a flast list of all the files nested inside a directory
   *
   * Based on an elegant concurrent recursive solution from SO
   * https://stackoverflow.com/a/45130990/2168416
   */
  async readdirDeep(dir) {
    const subdirs = await this._readdir(dir);
    const files = await Promise.all(
      subdirs.map(async subdir => {
        const res = dir + '/' + subdir;
        return (await this._stat(res)).isDirectory()
          ? this.readdirDeep(res)
          : res
      })
    );
    return files.reduce((a, f) => a.concat(f), [])
  }

  /**
   * Return the Stats of a file/symlink if it exists, otherwise returns null.
   * Rethrows errors that aren't related to file existance.
   */
  async lstat(filename) {
    try {
      const stats = await this._lstat(filename);
      return stats
    } catch (err) {
      if (err.code === 'ENOENT') {
        return null
      }
      throw err
    }
  }

  /**
   * Reads the contents of a symlink if it exists, otherwise returns null.
   * Rethrows errors that aren't related to file existance.
   */
  async readlink(filename, opts = { encoding: 'buffer' }) {
    // Note: FileSystem.readlink returns a buffer by default
    // so we can dump it into GitObject.write just like any other file.
    try {
      return this._readlink(filename, opts)
    } catch (err) {
      if (err.code === 'ENOENT') {
        return null
      }
      throw err
    }
  }

  /**
   * Write the contents of buffer to a symlink.
   */
  async writelink(filename, buffer) {
    return this._symlink(buffer.toString('utf8'), filename)
  }
}

async function writeObjectLoose({ fs, gitdir, object, format, oid }) {
  if (format !== 'deflated') {
    throw new InternalError(
      'GitObjectStoreLoose expects objects to write to be in deflated format'
    )
  }
  const source = `objects/${oid.slice(0, 2)}/${oid.slice(2)}`;
  const filepath = `${gitdir}/${source}`;
  // Don't overwrite existing git objects - this helps avoid EPERM errors.
  // Although I don't know how we'd fix corrupted objects then. Perhaps delete them
  // on read?
  if (!(await fs.exists(filepath))) await fs.write(filepath, object);
}

/* eslint-env node, browser */

let supportsCompressionStream = null;

async function deflate(buffer) {
  if (supportsCompressionStream === null) {
    supportsCompressionStream = testCompressionStream();
  }
  return supportsCompressionStream
    ? browserDeflate(buffer)
    : pako_1.deflate(buffer)
}

async function browserDeflate(buffer) {
  const cs = new CompressionStream('deflate');
  const c = new Blob([buffer]).stream().pipeThrough(cs);
  return new Uint8Array(await new Response(c).arrayBuffer())
}

function testCompressionStream() {
  try {
    const cs = new CompressionStream('deflate');
    // Test if `Blob.stream` is present. React Native does not have the `stream` method
    new Blob([]).stream();
    if (cs) return true
  } catch (_) {
    // no bother
  }
  return false
}

async function _writeObject({
  fs,
  gitdir,
  type,
  object,
  format = 'content',
  oid = undefined,
  dryRun = false,
}) {
  if (format !== 'deflated') {
    if (format !== 'wrapped') {
      object = GitObject.wrap({ type, object });
    }
    oid = await shasum(object);
    object = Buffer.from(await deflate(object));
  }
  if (!dryRun) {
    await writeObjectLoose({ fs, gitdir, object, format: 'deflated', oid });
  }
  return oid
}

function assertParameter(name, value) {
  if (value === undefined) {
    throw new MissingParameterError(name)
  }
}

// @ts-check

/**
 * Add a file to the git index (aka staging area)
 *
 * @param {object} args
 * @param {FsClient} args.fs - a file system implementation
 * @param {string} args.dir - The [working tree](dir-vs-gitdir.md) directory path
 * @param {string} [args.gitdir=join(dir, '.git')] - [required] The [git directory](dir-vs-gitdir.md) path
 * @param {string} args.filepath - The path to the file to add to the index
 * @param {object} [args.cache] - a [cache](cache.md) object
 *
 * @returns {Promise<void>} Resolves successfully once the git index has been updated
 *
 * @example
 * await fs.promises.writeFile('/tutorial/README.md', `# TEST`)
 * await git.add({ fs, dir: '/tutorial', filepath: 'README.md' })
 * console.log('done')
 *
 */
async function add({
  fs: _fs,
  dir,
  gitdir = join(dir, '.git'),
  filepath,
  cache = {},
}) {
  try {
    assertParameter('fs', _fs);
    assertParameter('dir', dir);
    assertParameter('gitdir', gitdir);
    assertParameter('filepath', filepath);

    const fs = new FileSystem(_fs);
    await GitIndexManager.acquire({ fs, gitdir, cache }, async function(index) {
      await addToIndex({ dir, gitdir, fs, filepath, index });
    });
  } catch (err) {
    err.caller = 'git.add';
    throw err
  }
}

async function addToIndex({ dir, gitdir, fs, filepath, index }) {
  // TODO: Should ignore UNLESS it's already in the index.
  const ignored = await GitIgnoreManager.isIgnored({
    fs,
    dir,
    gitdir,
    filepath,
  });
  if (ignored) return
  const stats = await fs.lstat(join(dir, filepath));
  if (!stats) throw new NotFoundError(filepath)
  if (stats.isDirectory()) {
    const children = await fs.readdir(join(dir, filepath));
    const promises = children.map(child =>
      addToIndex({ dir, gitdir, fs, filepath: join(filepath, child), index })
    );
    await Promise.all(promises);
  } else {
    const object = stats.isSymbolicLink()
      ? await fs.readlink(join(dir, filepath))
      : await fs.read(join(dir, filepath));
    if (object === null) throw new NotFoundError(filepath)
    const oid = await _writeObject({ fs, gitdir, type: 'blob', object });
    index.insert({ filepath, stats, oid });
  }
}

// @ts-check

/**
 *
 * @param {Object} args
 * @param {import('../models/FileSystem.js').FileSystem} args.fs
 * @param {object} args.cache
 * @param {SignCallback} [args.onSign]
 * @param {string} args.gitdir
 * @param {string} args.message
 * @param {Object} args.author
 * @param {string} args.author.name
 * @param {string} args.author.email
 * @param {number} args.author.timestamp
 * @param {number} args.author.timezoneOffset
 * @param {Object} args.committer
 * @param {string} args.committer.name
 * @param {string} args.committer.email
 * @param {number} args.committer.timestamp
 * @param {number} args.committer.timezoneOffset
 * @param {string} [args.signingKey]
 * @param {boolean} [args.dryRun = false]
 * @param {boolean} [args.noUpdateBranch = false]
 * @param {string} [args.ref]
 * @param {string[]} [args.parent]
 * @param {string} [args.tree]
 *
 * @returns {Promise<string>} Resolves successfully with the SHA-1 object id of the newly created commit.
 */
async function _commit({
  fs,
  cache,
  onSign,
  gitdir,
  message,
  author,
  committer,
  signingKey,
  dryRun = false,
  noUpdateBranch = false,
  ref,
  parent,
  tree,
}) {
  if (!ref) {
    ref = await GitRefManager.resolve({
      fs,
      gitdir,
      ref: 'HEAD',
      depth: 2,
    });
  }

  return GitIndexManager.acquire({ fs, gitdir, cache }, async function(index) {
    const inodes = flatFileListToDirectoryStructure(index.entries);
    const inode = inodes.get('.');
    if (!tree) {
      tree = await constructTree({ fs, gitdir, inode, dryRun });
    }
    if (!parent) {
      try {
        parent = [
          await GitRefManager.resolve({
            fs,
            gitdir,
            ref,
          }),
        ];
      } catch (err) {
        // Probably an initial commit
        parent = [];
      }
    }
    let comm = GitCommit.from({
      tree,
      parent,
      author,
      committer,
      message,
    });
    if (signingKey) {
      comm = await GitCommit.sign(comm, onSign, signingKey);
    }
    const oid = await _writeObject({
      fs,
      gitdir,
      type: 'commit',
      object: comm.toObject(),
      dryRun,
    });
    if (!noUpdateBranch && !dryRun) {
      // Update branch pointer
      await GitRefManager.writeRef({
        fs,
        gitdir,
        ref,
        value: oid,
      });
    }
    return oid
  })
}

async function constructTree({ fs, gitdir, inode, dryRun }) {
  // use depth first traversal
  const children = inode.children;
  for (const inode of children) {
    if (inode.type === 'tree') {
      inode.metadata.mode = '040000';
      inode.metadata.oid = await constructTree({ fs, gitdir, inode, dryRun });
    }
  }
  const entries = children.map(inode => ({
    mode: inode.metadata.mode,
    path: inode.basename,
    oid: inode.metadata.oid,
    type: inode.type,
  }));
  const tree = GitTree.from(entries);
  const oid = await _writeObject({
    fs,
    gitdir,
    type: 'tree',
    object: tree.toObject(),
    dryRun,
  });
  return oid
}

// @ts-check

async function resolveFilepath({ fs, cache, gitdir, oid, filepath }) {
  // Ensure there are no leading or trailing directory separators.
  // I was going to do this automatically, but then found that the Git Terminal for Windows
  // auto-expands --filepath=/src/utils to --filepath=C:/Users/Will/AppData/Local/Programs/Git/src/utils
  // so I figured it would be wise to promote the behavior in the application layer not just the library layer.
  if (filepath.startsWith('/')) {
    throw new InvalidFilepathError('leading-slash')
  } else if (filepath.endsWith('/')) {
    throw new InvalidFilepathError('trailing-slash')
  }
  const _oid = oid;
  const result = await resolveTree({ fs, cache, gitdir, oid });
  const tree = result.tree;
  if (filepath === '') {
    oid = result.oid;
  } else {
    const pathArray = filepath.split('/');
    oid = await _resolveFilepath({
      fs,
      cache,
      gitdir,
      tree,
      pathArray,
      oid: _oid,
      filepath,
    });
  }
  return oid
}

async function _resolveFilepath({
  fs,
  cache,
  gitdir,
  tree,
  pathArray,
  oid,
  filepath,
}) {
  const name = pathArray.shift();
  for (const entry of tree) {
    if (entry.path === name) {
      if (pathArray.length === 0) {
        return entry.oid
      } else {
        const { type, object } = await _readObject({
          fs,
          cache,
          gitdir,
          oid: entry.oid,
        });
        if (type !== 'tree') {
          throw new ObjectTypeError(oid, type, 'blob', filepath)
        }
        tree = GitTree.from(object);
        return _resolveFilepath({
          fs,
          cache,
          gitdir,
          tree,
          pathArray,
          oid,
          filepath,
        })
      }
    }
  }
  throw new NotFoundError(`file or directory found at "${oid}:${filepath}"`)
}

// @ts-check

/**
 *
 * @typedef {Object} ReadTreeResult - The object returned has the following schema:
 * @property {string} oid - SHA-1 object id of this tree
 * @property {TreeObject} tree - the parsed tree object
 */

/**
 * @param {object} args
 * @param {import('../models/FileSystem.js').FileSystem} args.fs
 * @param {any} args.cache
 * @param {string} args.gitdir
 * @param {string} args.oid
 * @param {string} [args.filepath]
 *
 * @returns {Promise<ReadTreeResult>}
 */
async function _readTree({
  fs,
  cache,
  gitdir,
  oid,
  filepath = undefined,
}) {
  if (filepath !== undefined) {
    oid = await resolveFilepath({ fs, cache, gitdir, oid, filepath });
  }
  const { tree, oid: treeOid } = await resolveTree({ fs, cache, gitdir, oid });
  const result = {
    oid: treeOid,
    tree: tree.entries(),
  };
  return result
}

// @ts-check

/**
 * @param {object} args
 * @param {import('../models/FileSystem.js').FileSystem} args.fs
 * @param {string} args.gitdir
 * @param {TreeObject} args.tree
 *
 * @returns {Promise<string>}
 */
async function _writeTree({ fs, gitdir, tree }) {
  // Convert object to buffer
  const object = GitTree.from(tree).toObject();
  const oid = await _writeObject({
    fs,
    gitdir,
    type: 'tree',
    object,
    format: 'content',
  });
  return oid
}

// @ts-check

/**
 * @param {object} args
 * @param {import('../models/FileSystem.js').FileSystem} args.fs
 * @param {object} args.cache
 * @param {SignCallback} [args.onSign]
 * @param {string} args.gitdir
 * @param {string} args.ref
 * @param {string} args.oid
 * @param {string|Uint8Array} args.note
 * @param {boolean} [args.force]
 * @param {Object} args.author
 * @param {string} args.author.name
 * @param {string} args.author.email
 * @param {number} args.author.timestamp
 * @param {number} args.author.timezoneOffset
 * @param {Object} args.committer
 * @param {string} args.committer.name
 * @param {string} args.committer.email
 * @param {number} args.committer.timestamp
 * @param {number} args.committer.timezoneOffset
 * @param {string} [args.signingKey]
 *
 * @returns {Promise<string>}
 */

async function _addNote({
  fs,
  cache,
  onSign,
  gitdir,
  ref,
  oid,
  note,
  force,
  author,
  committer,
  signingKey,
}) {
  // Get the current note commit
  let parent;
  try {
    parent = await GitRefManager.resolve({ gitdir, fs, ref });
  } catch (err) {
    if (!(err instanceof NotFoundError)) {
      throw err
    }
  }

  // I'm using the "empty tree" magic number here for brevity
  const result = await _readTree({
    fs,
    cache,
    gitdir,
    oid: parent || '4b825dc642cb6eb9a060e54bf8d69288fbee4904',
  });
  let tree = result.tree;

  // Handle the case where a note already exists
  if (force) {
    tree = tree.filter(entry => entry.path !== oid);
  } else {
    for (const entry of tree) {
      if (entry.path === oid) {
        throw new AlreadyExistsError('note', oid)
      }
    }
  }

  // Create the note blob
  if (typeof note === 'string') {
    note = Buffer.from(note, 'utf8');
  }
  const noteOid = await _writeObject({
    fs,
    gitdir,
    type: 'blob',
    object: note,
    format: 'content',
  });

  // Create the new note tree
  tree.push({ mode: '100644', path: oid, oid: noteOid, type: 'blob' });
  const treeOid = await _writeTree({
    fs,
    gitdir,
    tree,
  });

  // Create the new note commit
  const commitOid = await _commit({
    fs,
    cache,
    onSign,
    gitdir,
    ref,
    tree: treeOid,
    parent: parent && [parent],
    message: `Note added by 'isomorphic-git addNote'\n`,
    author,
    committer,
    signingKey,
  });

  return commitOid
}

// @ts-check

/**
 * @param {Object} args
 * @param {import('../models/FileSystem.js').FileSystem} args.fs
 * @param {string} args.gitdir
 * @param {string} args.path
 *
 * @returns {Promise<any>} Resolves with the config value
 *
 * @example
 * // Read config value
 * let value = await git.getConfig({
 *   dir: '$input((/))',
 *   path: '$input((user.name))'
 * })
 * console.log(value)
 *
 */
async function _getConfig({ fs, gitdir, path }) {
  const config = await GitConfigManager.get({ fs, gitdir });
  return config.get(path)
}

/**
 *
 * @returns {Promise<void | {name: string, email: string, date: Date, timestamp: number, timezoneOffset: number }>}
 */
async function normalizeAuthorObject({ fs, gitdir, author = {} }) {
  let { name, email, timestamp, timezoneOffset } = author;
  name = name || (await _getConfig({ fs, gitdir, path: 'user.name' }));
  email = email || (await _getConfig({ fs, gitdir, path: 'user.email' })) || '';

  if (name === undefined) {
    return undefined
  }

  timestamp = timestamp != null ? timestamp : Math.floor(Date.now() / 1000);
  timezoneOffset =
    timezoneOffset != null
      ? timezoneOffset
      : new Date(timestamp * 1000).getTimezoneOffset();

  return { name, email, timestamp, timezoneOffset }
}

/**
 *
 * @returns {Promise<void | {name: string, email: string, timestamp: number, timezoneOffset: number }>}
 */
async function normalizeCommitterObject({
  fs,
  gitdir,
  author,
  committer,
}) {
  committer = Object.assign({}, committer || author);
  // Match committer's date to author's one, if omitted
  if (author) {
    committer.timestamp = committer.timestamp || author.timestamp;
    committer.timezoneOffset = committer.timezoneOffset || author.timezoneOffset;
  }
  committer = await normalizeAuthorObject({ fs, gitdir, author: committer });
  return committer
}

// @ts-check

/**
 * Add or update an object note
 *
 * @param {object} args
 * @param {FsClient} args.fs - a file system implementation
 * @param {SignCallback} [args.onSign] - a PGP signing implementation
 * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path
 * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path
 * @param {string} [args.ref] - The notes ref to look under
 * @param {string} args.oid - The SHA-1 object id of the object to add the note to.
 * @param {string|Uint8Array} args.note - The note to add
 * @param {boolean} [args.force] - Over-write note if it already exists.
 * @param {Object} [args.author] - The details about the author.
 * @param {string} [args.author.name] - Default is `user.name` config.
 * @param {string} [args.author.email] - Default is `user.email` config.
 * @param {number} [args.author.timestamp=Math.floor(Date.now()/1000)] - Set the author timestamp field. This is the integer number of seconds since the Unix epoch (1970-01-01 00:00:00).
 * @param {number} [args.author.timezoneOffset] - Set the author timezone offset field. This is the difference, in minutes, from the current timezone to UTC. Default is `(new Date()).getTimezoneOffset()`.
 * @param {Object} [args.committer = author] - The details about the note committer, in the same format as the author parameter. If not specified, the author details are used.
 * @param {string} [args.committer.name] - Default is `user.name` config.
 * @param {string} [args.committer.email] - Default is `user.email` config.
 * @param {number} [args.committer.timestamp=Math.floor(Date.now()/1000)] - Set the committer timestamp field. This is the integer number of seconds since the Unix epoch (1970-01-01 00:00:00).
 * @param {number} [args.committer.timezoneOffset] - Set the committer timezone offset field. This is the difference, in minutes, from the current timezone to UTC. Default is `(new Date()).getTimezoneOffset()`.
 * @param {string} [args.signingKey] - Sign the note commit using this private PGP key.
 * @param {object} [args.cache] - a [cache](cache.md) object
 *
 * @returns {Promise<string>} Resolves successfully with the SHA-1 object id of the commit object for the added note.
 */

async function addNote({
  fs: _fs,
  onSign,
  dir,
  gitdir = join(dir, '.git'),
  ref = 'refs/notes/commits',
  oid,
  note,
  force,
  author: _author,
  committer: _committer,
  signingKey,
  cache = {},
}) {
  try {
    assertParameter('fs', _fs);
    assertParameter('gitdir', gitdir);
    assertParameter('oid', oid);
    assertParameter('note', note);
    if (signingKey) {
      assertParameter('onSign', onSign);
    }
    const fs = new FileSystem(_fs);

    const author = await normalizeAuthorObject({ fs, gitdir, author: _author });
    if (!author) throw new MissingNameError('author')

    const committer = await normalizeCommitterObject({
      fs,
      gitdir,
      author,
      committer: _committer,
    });
    if (!committer) throw new MissingNameError('committer')

    return await _addNote({
      fs: new FileSystem(fs),
      cache,
      onSign,
      gitdir,
      ref,
      oid,
      note,
      force,
      author,
      committer,
      signingKey,
    })
  } catch (err) {
    err.caller = 'git.addNote';
    throw err
  }
}

// @ts-check

/**
 * @param {object} args
 * @param {import('../models/FileSystem.js').FileSystem} args.fs
 * @param {string} args.gitdir
 * @param {string} args.remote
 * @param {string} args.url
 * @param {boolean} args.force
 *
 * @returns {Promise<void>}
 *
 */
async function _addRemote({ fs, gitdir, remote, url, force }) {
  if (remote !== lib.clean(remote)) {
    throw new InvalidRefNameError(remote, lib.clean(remote))
  }
  const config = await GitConfigManager.get({ fs, gitdir });
  if (!force) {
    // Check that setting it wouldn't overwrite.
    const remoteNames = await config.getSubsections('remote');
    if (remoteNames.includes(remote)) {
      // Throw an error if it would overwrite an existing remote,
      // but not if it's simply setting the same value again.
      if (url !== (await config.get(`remote.${remote}.url`))) {
        throw new AlreadyExistsError('remote', remote)
      }
    }
  }
  await config.set(`remote.${remote}.url`, url);
  await config.set(
    `remote.${remote}.fetch`,
    `+refs/heads/*:refs/remotes/${remote}/*`
  );
  await GitConfigManager.save({ fs, gitdir, config });
}

// @ts-check

/**
 * Add or update a remote
 *
 * @param {object} args
 * @param {FsClient} args.fs - a file system implementation
 * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path
 * @param {string} [args.gitdir] - [required] The [git directory](dir-vs-gitdir.md) path
 * @param {string} args.remote - The name of the remote
 * @param {string} args.url - The URL of the remote
 * @param {boolean} [args.force = false] - Instead of throwing an error if a remote named `remote` already exists, overwrite the existing remote.
 *
 * @returns {Promise<void>} Resolves successfully when filesystem operations are complete
 *
 * @example
 * await git.addRemote({
 *   fs,
 *   dir: '/tutorial',
 *   remote: 'upstream',
 *   url: 'https://github.com/isomorphic-git/isomorphic-git'
 * })
 * console.log('done')
 *
 */
async function addRemote({
  fs,
  dir,
  gitdir = join(dir, '.git'),
  remote,
  url,
  force = false,
}) {
  try {
    assertParameter('fs', fs);
    assertParameter('gitdir', gitdir);
    assertParameter('remote', remote);
    assertParameter('url', url);
    return await _addRemote({
      fs: new FileSystem(fs),
      gitdir,
      remote,
      url,
      force,
    })
  } catch (err) {
    err.caller = 'git.addRemote';
    throw err
  }
}

// @ts-check

/**
 * Create an annotated tag.
 *
 * @param {object} args
 * @param {import('../models/FileSystem.js').FileSystem} args.fs
 * @param {any} args.cache
 * @param {SignCallback} [args.onSign]
 * @param {string} args.gitdir
 * @param {string} args.ref
 * @param {string} [args.message = ref]
 * @param {string} [args.object = 'HEAD']
 * @param {object} [args.tagger]
 * @param {string} args.tagger.name
 * @param {string} args.tagger.email
 * @param {number} args.tagger.timestamp
 * @param {number} args.tagger.timezoneOffset
 * @param {string} [args.gpgsig]
 * @param {string} [args.signingKey]
 * @param {boolean} [args.force = false]
 *
 * @returns {Promise<void>} Resolves successfully when filesystem operations are complete
 *
 * @example
 * await git.annotatedTag({
 *   dir: '$input((/))',
 *   ref: '$input((test-tag))',
 *   message: '$input((This commit is awesome))',
 *   tagger: {
 *     name: '$input((Mr. Test))',
 *     email: '$input((mrtest@example.com))'
 *   }
 * })
 * console.log('done')
 *
 */
async function _annotatedTag({
  fs,
  cache,
  onSign,
  gitdir,
  ref,
  tagger,
  message = ref,
  gpgsig,
  object,
  signingKey,
  force = false,
}) {
  ref = ref.startsWith('refs/tags/') ? ref : `refs/tags/${ref}`;

  if (!force && (await GitRefManager.exists({ fs, gitdir, ref }))) {
    throw new AlreadyExistsError('tag', ref)
  }

  // Resolve passed value
  const oid = await GitRefManager.resolve({
    fs,
    gitdir,
    ref: object || 'HEAD',
  });

  const { type } = await _readObject({ fs, cache, gitdir, oid });
  let tagObject = GitAnnotatedTag.from({
    object: oid,
    type,
    tag: ref.replace('refs/tags/', ''),
    tagger,
    message,
    gpgsig,
  });
  if (signingKey) {
    tagObject = await GitAnnotatedTag.sign(tagObject, onSign, signingKey);
  }
  const value = await _writeObject({
    fs,
    gitdir,
    type: 'tag',
    object: tagObject.toObject(),
  });

  await GitRefManager.writeRef({ fs, gitdir, ref, value });
}

// @ts-check

/**
 * Create an annotated tag.
 *
 * @param {object} args
 * @param {FsClient} args.fs - a file system implementation
 * @param {SignCallback} [args.onSign] - a PGP signing implementation
 * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path
 * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path
 * @param {string} args.ref - What to name the tag
 * @param {string} [args.message = ref] - The tag message to use.
 * @param {string} [args.object = 'HEAD'] - The SHA-1 object id the tag points to. (Will resolve to a SHA-1 object id if value is a ref.) By default, the commit object which is referred by the current `HEAD` is used.
 * @param {object} [args.tagger] - The details about the tagger.
 * @param {string} [args.tagger.name] - Default is `user.name` config.
 * @param {string} [args.tagger.email] - Default is `user.email` config.
 * @param {number} [args.tagger.timestamp=Math.floor(Date.now()/1000)] - Set the tagger timestamp field. This is the integer number of seconds since the Unix epoch (1970-01-01 00:00:00).
 * @param {number} [args.tagger.timezoneOffset] - Set the tagger timezone offset field. This is the difference, in minutes, from the current timezone to UTC. Default is `(new Date()).getTimezoneOffset()`.
 * @param {string} [args.gpgsig] - The gpgsig attatched to the tag object. (Mutually exclusive with the `signingKey` option.)
 * @param {string} [args.signingKey] - Sign the tag object using this private PGP key. (Mutually exclusive with the `gpgsig` option.)
 * @param {boolean} [args.force = false] - Instead of throwing an error if a tag named `ref` already exists, overwrite the existing tag. Note that this option does not modify the original tag object itself.
 * @param {object} [args.cache] - a [cache](cache.md) object
 *
 * @returns {Promise<void>} Resolves successfully when filesystem operations are complete
 *
 * @example
 * await git.annotatedTag({
 *   fs,
 *   dir: '/tutorial',
 *   ref: 'test-tag',
 *   message: 'This commit is awesome',
 *   tagger: {
 *     name: 'Mr. Test',
 *     email: 'mrtest@example.com'
 *   }
 * })
 * console.log('done')
 *
 */
async function annotatedTag({
  fs: _fs,
  onSign,
  dir,
  gitdir = join(dir, '.git'),
  ref,
  tagger: _tagger,
  message = ref,
  gpgsig,
  object,
  signingKey,
  force = false,
  cache = {},
}) {
  try {
    assertParameter('fs', _fs);
    assertParameter('gitdir', gitdir);
    assertParameter('ref', ref);
    if (signingKey) {
      assertParameter('onSign', onSign);
    }
    const fs = new FileSystem(_fs);

    // Fill in missing arguments with default values
    const tagger = await normalizeAuthorObject({ fs, gitdir, author: _tagger });
    if (!tagger) throw new MissingNameError('tagger')

    return await _annotatedTag({
      fs,
      cache,
      onSign,
      gitdir,
      ref,
      tagger,
      message,
      gpgsig,
      object,
      signingKey,
      force,
    })
  } catch (err) {
    err.caller = 'git.annotatedTag';
    throw err
  }
}

// @ts-check

/**
 * Create a branch
 *
 * @param {object} args
 * @param {import('../models/FileSystem.js').FileSystem} args.fs
 * @param {string} args.gitdir
 * @param {string} args.ref
 * @param {boolean} [args.checkout = false]
 *
 * @returns {Promise<void>} Resolves successfully when filesystem operations are complete
 *
 * @example
 * await git.branch({ dir: '$input((/))', ref: '$input((develop))' })
 * console.log('done')
 *
 */
async function _branch({ fs, gitdir, ref, checkout = false }) {
  if (ref !== lib.clean(ref)) {
    throw new InvalidRefNameError(ref, lib.clean(ref))
  }

  const fullref = `refs/heads/${ref}`;

  const exist = await GitRefManager.exists({ fs, gitdir, ref: fullref });
  if (exist) {
    throw new AlreadyExistsError('branch', ref, false)
  }

  // Get current HEAD tree oid
  let oid;
  try {
    oid = await GitRefManager.resolve({ fs, gitdir, ref: 'HEAD' });
  } catch (e) {
    // Probably an empty repo
  }

  // Create a new ref that points at the current commit
  if (oid) {
    await GitRefManager.writeRef({ fs, gitdir, ref: fullref, value: oid });
  }

  if (checkout) {
    // Update HEAD
    await GitRefManager.writeSymbolicRef({
      fs,
      gitdir,
      ref: 'HEAD',
      value: fullref,
    });
  }
}

// @ts-check

/**
 * Create a branch
 *
 * @param {object} args
 * @param {FsClient} args.fs - a file system implementation
 * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path
 * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path
 * @param {string} args.ref - What to name the branch
 * @param {boolean} [args.checkout = false] - Update `HEAD` to point at the newly created branch
 *
 * @returns {Promise<void>} Resolves successfully when filesystem operations are complete
 *
 * @example
 * await git.branch({ fs, dir: '/tutorial', ref: 'develop' })
 * console.log('done')
 *
 */
async function branch({
  fs,
  dir,
  gitdir = join(dir, '.git'),
  ref,
  checkout = false,
}) {
  try {
    assertParameter('fs', fs);
    assertParameter('gitdir', gitdir);
    assertParameter('ref', ref);
    return await _branch({
      fs: new FileSystem(fs),
      gitdir,
      ref,
      checkout,
    })
  } catch (err) {
    err.caller = 'git.branch';
    throw err
  }
}

// https://dev.to/namirsab/comment/2050
function arrayRange(start, end) {
  const length = end - start;
  return Array.from({ length }, (_, i) => start + i)
}

// TODO: Should I just polyfill Array.flat?
const flat =
  typeof Array.prototype.flat === 'undefined'
    ? entries => entries.reduce((acc, x) => acc.concat(x), [])
    : entries => entries.flat();

// This is convenient for computing unions/joins of sorted lists.
class RunningMinimum {
  constructor() {
    // Using a getter for 'value' would just bloat the code.
    // You know better than to set it directly right?
    this.value = null;
  }

  consider(value) {
    if (value === null || value === undefined) return
    if (this.value === null) {
      this.value = value;
    } else if (value < this.value) {
      this.value = value;
    }
  }

  reset() {
    this.value = null;
  }
}

// Take an array of length N of
//   iterators of length Q_n
//     of strings
// and return an iterator of length max(Q_n) for all n
//   of arrays of length N
//     of string|null who all have the same string value
function* unionOfIterators(sets) {
  /* NOTE: We can assume all arrays are sorted.
   * Indexes are sorted because they are defined that way:
   *
   * > Index entries are sorted in ascending order on the name field,
   * > interpreted as a string of unsigned bytes (i.e. memcmp() order, no
   * > localization, no special casing of directory separator '/'). Entries
   * > with the same name are sorted by their stage field.
   *
   * Trees should be sorted because they are created directly from indexes.
   * They definitely should be sorted, or else they wouldn't have a unique SHA1.
   * So that would be very naughty on the part of the tree-creator.
   *
   * Lastly, the working dir entries are sorted because I choose to sort them
   * in my FileSystem.readdir() implementation.
   */

  // Init
  const min = new RunningMinimum();
  let minimum;
  const heads = [];
  const numsets = sets.length;
  for (let i = 0; i < numsets; i++) {
    // Abuse the fact that iterators continue to return 'undefined' for value
    // once they are done
    heads[i] = sets[i].next().value;
    if (heads[i] !== undefined) {
      min.consider(heads[i]);
    }
  }
  if (min.value === null) return
  // Iterate
  while (true) {
    const result = [];
    minimum = min.value;
    min.reset();
    for (let i = 0; i < numsets; i++) {
      if (heads[i] !== undefined && heads[i] === minimum) {
        result[i] = heads[i];
        heads[i] = sets[i].next().value;
      } else {
        // A little hacky, but eh
        result[i] = null;
      }
      if (heads[i] !== undefined) {
        min.consider(heads[i]);
      }
    }
    yield result;
    if (min.value === null) return
  }
}

// @ts-check

/**
 * @param {object} args
 * @param {import('../models/FileSystem.js').FileSystem} args.fs
 * @param {object} args.cache
 * @param {string} [args.dir]
 * @param {string} [args.gitdir=join(dir,'.git')]
 * @param {Walker[]} args.trees
 * @param {WalkerMap} [args.map]
 * @param {WalkerReduce} [args.reduce]
 * @param {WalkerIterate} [args.iterate]
 *
 * @returns {Promise<any>} The finished tree-walking result
 *
 * @see {WalkerMap}
 *
 */
async function _walk({
  fs,
  cache,
  dir,
  gitdir,
  trees,
  // @ts-ignore
  map = async (_, entry) => entry,
  // The default reducer is a flatmap that filters out undefineds.
  reduce = async (parent, children) => {
    const flatten = flat(children);
    if (parent !== undefined) flatten.unshift(parent);
    return flatten
  },
  // The default iterate function walks all children concurrently
  iterate = (walk, children) => Promise.all([...children].map(walk)),
}) {
  const walkers = trees.map(proxy =>
    proxy[GitWalkSymbol]({ fs, dir, gitdir, cache })
  );

  const root = new Array(walkers.length).fill('.');
  const range = arrayRange(0, walkers.length);
  const unionWalkerFromReaddir = async entries => {
    range.map(i => {
      entries[i] = entries[i] && new walkers[i].ConstructEntry(entries[i]);
    });
    const subdirs = await Promise.all(
      range.map(i => (entries[i] ? walkers[i].readdir(entries[i]) : []))
    );
    // Now process child directories
    const iterators = subdirs
      .map(array => (array === null ? [] : array))
      .map(array => array[Symbol.iterator]());
    return {
      entries,
      children: unionOfIterators(iterators),
    }
  };

  const walk = async root => {
    const { entries, children } = await unionWalkerFromReaddir(root);
    const fullpath = entries.find(entry => entry && entry._fullpath)._fullpath;
    const parent = await map(fullpath, entries);
    if (parent !== null) {
      let walkedChildren = await iterate(walk, children);
      walkedChildren = walkedChildren.filter(x => x !== undefined);
      return reduce(parent, walkedChildren)
    }
  };
  return walk(root)
}

const worthWalking = (filepath, root) => {
  if (filepath === '.' || root == null || root.length === 0 || root === '.') {
    return true
  }
  if (root.length >= filepath.length) {
    return root.startsWith(filepath)
  } else {
    return filepath.startsWith(root)
  }
};

// @ts-check

/**
 * @param {object} args
 * @param {import('../models/FileSystem.js').FileSystem} args.fs
 * @param {any} args.cache
 * @param {ProgressCallback} [args.onProgress]
 * @param {string} args.dir
 * @param {string} args.gitdir
 * @param {string} args.ref
 * @param {string[]} [args.filepaths]
 * @param {string} args.remote
 * @param {boolean} args.noCheckout
 * @param {boolean} [args.noUpdateHead]
 * @param {boolean} [args.dryRun]
 * @param {boolean} [args.force]
 *
 * @returns {Promise<void>} Resolves successfully when filesystem operations are complete
 *
 */
async function _checkout({
  fs,
  cache,
  onProgress,
  dir,
  gitdir,
  remote,
  ref,
  filepaths,
  noCheckout,
  noUpdateHead,
  dryRun,
  force,
}) {
  // Get tree oid
  let oid;
  try {
    oid = await GitRefManager.resolve({ fs, gitdir, ref });
    // TODO: Figure out what to do if both 'ref' and 'remote' are specified, ref already exists,
    // and is configured to track a different remote.
  } catch (err) {
    if (ref === 'HEAD') throw err
    // If `ref` doesn't exist, create a new remote tracking branch
    // Figure out the commit to checkout
    const remoteRef = `${remote}/${ref}`;
    oid = await GitRefManager.resolve({
      fs,
      gitdir,
      ref: remoteRef,
    });
    // Set up remote tracking branch
    const config = await GitConfigManager.get({ fs, gitdir });
    await config.set(`branch.${ref}.remote`, remote);
    await config.set(`branch.${ref}.merge`, `refs/heads/${ref}`);
    await GitConfigManager.save({ fs, gitdir, config });
    // Create a new branch that points at that same commit
    await GitRefManager.writeRef({
      fs,
      gitdir,
      ref: `refs/heads/${ref}`,
      value: oid,
    });
  }

  // Update working dir
  if (!noCheckout) {
    let ops;
    // First pass - just analyze files (not directories) and figure out what needs to be done
    try {
      ops = await analyze({
        fs,
        cache,
        onProgress,
        dir,
        gitdir,
        ref,
        force,
        filepaths,
      });
    } catch (err) {
      // Throw a more helpful error message for this common mistake.
      if (err instanceof NotFoundError && err.data.what === oid) {
        throw new CommitNotFetchedError(ref, oid)
      } else {
        throw err
      }
    }

    // Report conflicts
    const conflicts = ops
      .filter(([method]) => method === 'conflict')
      .map(([method, fullpath]) => fullpath);
    if (conflicts.length > 0) {
      throw new CheckoutConflictError(conflicts)
    }

    // Collect errors
    const errors = ops
      .filter(([method]) => method === 'error')
      .map(([method, fullpath]) => fullpath);
    if (errors.length > 0) {
      throw new InternalError(errors.join(', '))
    }

    if (dryRun) {
      // Since the format of 'ops' is in flux, I really would rather folk besides myself not start relying on it
      // return ops
      return
    }

    // Second pass - execute planned changes
    // The cheapest semi-parallel solution without computing a full dependency graph will be
    // to just do ops in 4 dumb phases: delete files, delete dirs, create dirs, write files

    let count = 0;
    const total = ops.length;
    await GitIndexManager.acquire({ fs, gitdir, cache }, async function(index) {
      await Promise.all(
        ops
          .filter(
            ([method]) => method === 'delete' || method === 'delete-index'
          )
          .map(async function([method, fullpath]) {
            const filepath = `${dir}/${fullpath}`;
            if (method === 'delete') {
              await fs.rm(filepath);
            }
            index.delete({ filepath: fullpath });
            if (onProgress) {
              await onProgress({
                phase: 'Updating workdir',
                loaded: ++count,
                total,
              });
            }
          })
      );
    });

    // Note: this is cannot be done naively in parallel
    await GitIndexManager.acquire({ fs, gitdir, cache }, async function(index) {
      for (const [method, fullpath] of ops) {
        if (method === 'rmdir' || method === 'rmdir-index') {
          const filepath = `${dir}/${fullpath}`;
          try {
            if (method === 'rmdir-index') {
              index.delete({ filepath: fullpath });
            }
            await fs.rmdir(filepath);
            if (onProgress) {
              await onProgress({
                phase: 'Updating workdir',
                loaded: ++count,
                total,
              });
            }
          } catch (e) {
            if (e.code === 'ENOTEMPTY') {
              console.log(
                `Did not delete ${fullpath} because directory is not empty`
              );
            } else {
              throw e
            }
          }
        }
      }
    });

    await Promise.all(
      ops
        .filter(([method]) => method === 'mkdir' || method === 'mkdir-index')
        .map(async function([_, fullpath]) {
          const filepath = `${dir}/${fullpath}`;
          await fs.mkdir(filepath);
          if (onProgress) {
            await onProgress({
              phase: 'Updating workdir',
              loaded: ++count,
              total,
            });
          }
        })
    );

    await GitIndexManager.acquire({ fs, gitdir, cache }, async function(index) {
      await Promise.all(
        ops
          .filter(
            ([method]) =>
              method === 'create' ||
              method === 'create-index' ||
              method === 'update' ||
              method === 'mkdir-index'
          )
          .map(async function([method, fullpath, oid, mode, chmod]) {
            const filepath = `${dir}/${fullpath}`;
            try {
              if (method !== 'create-index' && method !== 'mkdir-index') {
                const { object } = await _readObject({ fs, cache, gitdir, oid });
                if (chmod) {
                  // Note: the mode option of fs.write only works when creating files,
                  // not updating them. Since the `fs` plugin doesn't expose `chmod` this
                  // is our only option.
                  await fs.rm(filepath);
                }
                if (mode === 0o100644) {
                  // regular file
                  await fs.write(filepath, object);
                } else if (mode === 0o100755) {
                  // executable file
                  await fs.write(filepath, object, { mode: 0o777 });
                } else if (mode === 0o120000) {
                  // symlink
                  await fs.writelink(filepath, object);
                } else {
                  throw new InternalError(
                    `Invalid mode 0o${mode.toString(8)} detected in blob ${oid}`
                  )
                }
              }

              const stats = await fs.lstat(filepath);
              // We can't trust the executable bit returned by lstat on Windows,
              // so we need to preserve this value from the TREE.
              // TODO: Figure out how git handles this internally.
              if (mode === 0o100755) {
                stats.mode = 0o755;
              }
              // Submodules are present in the git index but use a unique mode different from trees
              if (method === 'mkdir-index') {
                stats.mode = 0o160000;
              }
              index.insert({
                filepath: fullpath,
                stats,
                oid,
              });
              if (onProgress) {
                await onProgress({
                  phase: 'Updating workdir',
                  loaded: ++count,
                  total,
                });
              }
            } catch (e) {
              console.log(e);
            }
          })
      );
    });
  }

  // Update HEAD
  if (!noUpdateHead) {
    const fullRef = await GitRefManager.expand({ fs, gitdir, ref });
    if (fullRef.startsWith('refs/heads')) {
      await GitRefManager.writeSymbolicRef({
        fs,
        gitdir,
        ref: 'HEAD',
        value: fullRef,
      });
    } else {
      // detached head
      await GitRefManager.writeRef({ fs, gitdir, ref: 'HEAD', value: oid });
    }
  }
}

async function analyze({
  fs,
  cache,
  onProgress,
  dir,
  gitdir,
  ref,
  force,
  filepaths,
}) {
  let count = 0;
  return _walk({
    fs,
    cache,
    dir,
    gitdir,
    trees: [TREE({ ref }), WORKDIR(), STAGE()],
    map: async function(fullpath, [commit, workdir, stage]) {
      if (fullpath === '.') return
      // match against base paths
      if (filepaths && !filepaths.some(base => worthWalking(fullpath, base))) {
        return null
      }
      // Emit progress event
      if (onProgress) {
        await onProgress({ phase: 'Analyzing workdir', loaded: ++count });
      }

      // This is a kind of silly pattern but it worked so well for me in the past
      // and it makes intuitively demonstrating exhaustiveness so *easy*.
      // This checks for the presense and/or absense of each of the 3 entries,
      // converts that to a 3-bit binary representation, and then handles
      // every possible combination (2^3 or 8 cases) with a lookup table.
      const key = [!!stage, !!commit, !!workdir].map(Number).join('');
      switch (key) {
        // Impossible case.
        case '000':
          return
        // Ignore workdir files that are not tracked and not part of the new commit.
        case '001':
          // OK, make an exception for explicitly named files.
          if (force && filepaths && filepaths.includes(fullpath)) {
            return ['delete', fullpath]
          }
          return
        // New entries
        case '010': {
          switch (await commit.type()) {
            case 'tree': {
              return ['mkdir', fullpath]
            }
            case 'blob': {
              return [
                'create',
                fullpath,
                await commit.oid(),
                await commit.mode(),
              ]
            }
            case 'commit': {
              return [
                'mkdir-index',
                fullpath,
                await commit.oid(),
                await commit.mode(),
              ]
            }
            default: {
              return [
                'error',
                `new entry Unhandled type ${await commit.type()}`,
              ]
            }
          }
        }
        // New entries but there is already something in the workdir there.
        case '011': {
          switch (`${await commit.type()}-${await workdir.type()}`) {
            case 'tree-tree': {
              return // noop
            }
            case 'tree-blob':
            case 'blob-tree': {
              return ['conflict', fullpath]
            }
            case 'blob-blob': {
              // Is the incoming file different?
              if ((await commit.oid()) !== (await workdir.oid())) {
                if (force) {
                  return [
                    'update',
                    fullpath,
                    await commit.oid(),
                    await commit.mode(),
                    (await commit.mode()) !== (await workdir.mode()),
                  ]
                } else {
                  return ['conflict', fullpath]
                }
              } else {
                // Is the incoming file a different mode?
                if ((await commit.mode()) !== (await workdir.mode())) {
                  if (force) {
                    return [
                      'update',
                      fullpath,
                      await commit.oid(),
                      await commit.mode(),
                      true,
                    ]
                  } else {
                    return ['conflict', fullpath]
                  }
                } else {
                  return [
                    'create-index',
                    fullpath,
                    await commit.oid(),
                    await commit.mode(),
                  ]
                }
              }
            }
            case 'commit-tree': {
              // TODO: submodule
              // We'll ignore submodule directories for now.
              // Users prefer we not throw an error for lack of submodule support.
              // gitlinks
              return
            }
            case 'commit-blob': {
              // TODO: submodule
              // But... we'll complain if there is a *file* where we would
              // put a submodule if we had submodule support.
              return ['conflict', fullpath]
            }
            default: {
              return ['error', `new entry Unhandled type ${commit.type}`]
            }
          }
        }
        // Something in stage but not in the commit OR the workdir.
        // Note: I verified this behavior against canonical git.
        case '100': {
          return ['delete-index', fullpath]
        }
        // Deleted entries
        // TODO: How to handle if stage type and workdir type mismatch?
        case '101': {
          switch (await stage.type()) {
            case 'tree': {
              return ['rmdir', fullpath]
            }
            case 'blob': {
              // Git checks that the workdir.oid === stage.oid before deleting file
              if ((await stage.oid()) !== (await workdir.oid())) {
                if (force) {
                  return ['delete', fullpath]
                } else {
                  return ['conflict', fullpath]
                }
              } else {
                return ['delete', fullpath]
              }
            }
            case 'commit': {
              return ['rmdir-index', fullpath]
            }
            default: {
              return [
                'error',
                `delete entry Unhandled type ${await stage.type()}`,
              ]
            }
          }
        }
        /* eslint-disable no-fallthrough */
        // File missing from workdir
        case '110':
        // Possibly modified entries
        case '111': {
          /* eslint-enable no-fallthrough */
          switch (`${await stage.type()}-${await commit.type()}`) {
            case 'tree-tree': {
              return
            }
            case 'blob-blob': {
              // If the file hasn't changed, there is no need to do anything.
              // Existing file modifications in the workdir can be be left as is.
              if (
                (await stage.oid()) === (await commit.oid()) &&
                (await stage.mode()) === (await commit.mode()) &&
                !force
              ) {
                return
              }

              // Check for local changes that would be lost
              if (workdir) {
                // Note: canonical git only compares with the stage. But we're smart enough
                // to compare to the stage AND the incoming commit.
                if (
                  (await workdir.oid()) !== (await stage.oid()) &&
                  (await workdir.oid()) !== (await commit.oid())
                ) {
                  if (force) {
                    return [
                      'update',
                      fullpath,
                      await commit.oid(),
                      await commit.mode(),
                      (await commit.mode()) !== (await workdir.mode()),
                    ]
                  } else {
                    return ['conflict', fullpath]
                  }
                }
              } else if (force) {
                return [
                  'update',
                  fullpath,
                  await commit.oid(),
                  await commit.mode(),
                  (await commit.mode()) !== (await stage.mode()),
                ]
              }
              // Has file mode changed?
              if ((await commit.mode()) !== (await stage.mode())) {
                return [
                  'update',
                  fullpath,
                  await commit.oid(),
                  await commit.mode(),
                  true,
                ]
              }
              // TODO: HANDLE SYMLINKS
              // Has the file content changed?
              if ((await commit.oid()) !== (await stage.oid())) {
                return [
                  'update',
                  fullpath,
                  await commit.oid(),
                  await commit.mode(),
                  false,
                ]
              } else {
                return
              }
            }
            case 'tree-blob': {
              return ['update-dir-to-blob', fullpath, await commit.oid()]
            }
            case 'blob-tree': {
              return ['update-blob-to-tree', fullpath]
            }
            case 'commit-commit': {
              return [
                'mkdir-index',
                fullpath,
                await commit.oid(),
                await commit.mode(),
              ]
            }
            default: {
              return [
                'error',
                `update entry Unhandled type ${await stage.type()}-${await commit.type()}`,
              ]
            }
          }
        }
      }
    },
    // Modify the default flat mapping
    reduce: async function(parent, children) {
      children = flat(children);
      if (!parent) {
        return children
      } else if (parent && parent[0] === 'rmdir') {
        children.push(parent);
        return children
      } else {
        children.unshift(parent);
        return children
      }
    },
  })
}

// @ts-check

/**
 * Checkout a branch
 *
 * If the branch already exists it will check out that branch. Otherwise, it will create a new remote tracking branch set to track the remote branch of that name.
 *
 * @param {object} args
 * @param {FsClient} args.fs - a file system implementation
 * @param {ProgressCallback} [args.onProgress] - optional progress event callback
 * @param {string} args.dir - The [working tree](dir-vs-gitdir.md) directory path
 * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path
 * @param {string} [args.ref = 'HEAD'] - Source to checkout files from
 * @param {string[]} [args.filepaths] - Limit the checkout to the given files and directories
 * @param {string} [args.remote = 'origin'] - Which remote repository to use
 * @param {boolean} [args.noCheckout = false] - If true, will update HEAD but won't update the working directory
 * @param {boolean} [args.noUpdateHead] - If true, will update the working directory but won't update HEAD. Defaults to `false` when `ref` is provided, and `true` if `ref` is not provided.
 * @param {boolean} [args.dryRun = false] - If true, simulates a checkout so you can test whether it would succeed.
 * @param {boolean} [args.force = false] - If true, conflicts will be ignored and files will be overwritten regardless of local changes.
 * @param {object} [args.cache] - a [cache](cache.md) object
 *
 * @returns {Promise<void>} Resolves successfully when filesystem operations are complete
 *
 * @example
 * // switch to the main branch
 * await git.checkout({
 *   fs,
 *   dir: '/tutorial',
 *   ref: 'main'
 * })
 * console.log('done')
 *
 * @example
 * // restore the 'docs' and 'src/docs' folders to the way they were, overwriting any changes
 * await git.checkout({
 *   fs,
 *   dir: '/tutorial',
 *   force: true,
 *   filepaths: ['docs', 'src/docs']
 * })
 * console.log('done')
 *
 * @example
 * // restore the 'docs' and 'src/docs' folders to the way they are in the 'develop' branch, overwriting any changes
 * await git.checkout({
 *   fs,
 *   dir: '/tutorial',
 *   ref: 'develop',
 *   noUpdateHead: true,
 *   force: true,
 *   filepaths: ['docs', 'src/docs']
 * })
 * console.log('done')
 */
async function checkout({
  fs,
  onProgress,
  dir,
  gitdir = join(dir, '.git'),
  remote = 'origin',
  ref: _ref,
  filepaths,
  noCheckout = false,
  noUpdateHead = _ref === undefined,
  dryRun = false,
  force = false,
  cache = {},
}) {
  try {
    assertParameter('fs', fs);
    assertParameter('dir', dir);
    assertParameter('gitdir', gitdir);

    const ref = _ref || 'HEAD';
    return await _checkout({
      fs: new FileSystem(fs),
      cache,
      onProgress,
      dir,
      gitdir,
      remote,
      ref,
      filepaths,
      noCheckout,
      noUpdateHead,
      dryRun,
      force,
    })
  } catch (err) {
    err.caller = 'git.checkout';
    throw err
  }
}

// @see https://git-scm.com/docs/git-rev-parse.html#_specifying_revisions
const abbreviateRx = new RegExp('^refs/(heads/|tags/|remotes/)?(.*)');

function abbreviateRef(ref) {
  const match = abbreviateRx.exec(ref);
  if (match) {
    if (match[1] === 'remotes/' && ref.endsWith('/HEAD')) {
      return match[2].slice(0, -5)
    } else {
      return match[2]
    }
  }
  return ref
}

// @ts-check

/**
 * @param {Object} args
 * @param {import('../models/FileSystem.js').FileSystem} args.fs
 * @param {string} args.gitdir
 * @param {boolean} [args.fullname = false] - Return the full path (e.g. "refs/heads/main") instead of the abbreviated form.
 * @param {boolean} [args.test = false] - If the current branch doesn't actually exist (such as right after git init) then return `undefined`.
 *
 * @returns {Promise<string|void>} The name of the current branch or undefined if the HEAD is detached.
 *
 */
async function _currentBranch({
  fs,
  gitdir,
  fullname = false,
  test = false,
}) {
  const ref = await GitRefManager.resolve({
    fs,
    gitdir,
    ref: 'HEAD',
    depth: 2,
  });
  if (test) {
    try {
      await GitRefManager.resolve({ fs, gitdir, ref });
    } catch (_) {
      return
    }
  }
  // Return `undefined` for detached HEAD
  if (!ref.startsWith('refs/')) return
  return fullname ? ref : abbreviateRef(ref)
}

function translateSSHtoHTTP(url) {
  // handle "shorter scp-like syntax"
  url = url.replace(/^git@([^:]+):/, 'https://$1/');
  // handle proper SSH URLs
  url = url.replace(/^ssh:\/\//, 'https://');
  return url
}

function calculateBasicAuthHeader({ username = '', password = '' }) {
  return `Basic ${Buffer.from(`${username}:${password}`).toString('base64')}`
}

// Currently 'for await' upsets my linters.
async function forAwait(iterable, cb) {
  const iter = getIterator(iterable);
  while (true) {
    const { value, done } = await iter.next();
    if (value) await cb(value);
    if (done) break
  }
  if (iter.return) iter.return();
}

async function collect(iterable) {
  let size = 0;
  const buffers = [];
  // This will be easier once `for await ... of` loops are available.
  await forAwait(iterable, value => {
    buffers.push(value);
    size += value.byteLength;
  });
  const result = new Uint8Array(size);
  let nextIndex = 0;
  for (const buffer of buffers) {
    result.set(buffer, nextIndex);
    nextIndex += buffer.byteLength;
  }
  return result
}

function extractAuthFromUrl(url) {
  // For whatever reason, the `fetch` API does not convert credentials embedded in the URL
  // into Basic Authentication headers automatically. Instead it throws an error!
  // So we must manually parse the URL, rip out the user:password portion if it is present
  // and compute the Authorization header.
  // Note: I tried using new URL(url) but that throws a security exception in Edge. :rolleyes:
  let userpass = url.match(/^https?:\/\/([^/]+)@/);
  // No credentials, return the url unmodified and an empty auth object
  if (userpass == null) return { url, auth: {} }
  userpass = userpass[1];
  const [username, password] = userpass.split(':');
  // Remove credentials from URL
  url = url.replace(`${userpass}@`, '');
  // Has credentials, return the fetch-safe URL and the parsed credentials
  return { url, auth: { username, password } }
}

function padHex(b, n) {
  const s = n.toString(16);
  return '0'.repeat(b - s.length) + s
}

/**
pkt-line Format
---------------

Much (but not all) of the payload is described around pkt-lines.

A pkt-line is a variable length binary string.  The first four bytes
of the line, the pkt-len, indicates the total length of the line,
in hexadecimal.  The pkt-len includes the 4 bytes used to contain
the length's hexadecimal representation.

A pkt-line MAY contain binary data, so implementors MUST ensure
pkt-line parsing/formatting routines are 8-bit clean.

A non-binary line SHOULD BE terminated by an LF, which if present
MUST be included in the total length. Receivers MUST treat pkt-lines
with non-binary data the same whether or not they contain the trailing
LF (stripping the LF if present, and not complaining when it is
missing).

The maximum length of a pkt-line's data component is 65516 bytes.
Implementations MUST NOT send pkt-line whose length exceeds 65520
(65516 bytes of payload + 4 bytes of length data).

Implementations SHOULD NOT send an empty pkt-line ("0004").

A pkt-line with a length field of 0 ("0000"), called a flush-pkt,
is a special case and MUST be handled differently than an empty
pkt-line ("0004").

----
  pkt-line     =  data-pkt / flush-pkt

  data-pkt     =  pkt-len pkt-payload
  pkt-len      =  4*(HEXDIG)
  pkt-payload  =  (pkt-len - 4)*(OCTET)

  flush-pkt    = "0000"
----

Examples (as C-style strings):

----
  pkt-line          actual value
  ---------------------------------
  "0006a\n"         "a\n"
  "0005a"           "a"
  "000bfoobar\n"    "foobar\n"
  "0004"            ""
----
*/

// I'm really using this more as a namespace.
// There's not a lot of "state" in a pkt-line

class GitPktLine {
  static flush() {
    return Buffer.from('0000', 'utf8')
  }

  static delim() {
    return Buffer.from('0001', 'utf8')
  }

  static encode(line) {
    if (typeof line === 'string') {
      line = Buffer.from(line);
    }
    const length = line.length + 4;
    const hexlength = padHex(4, length);
    return Buffer.concat([Buffer.from(hexlength, 'utf8'), line])
  }

  static streamReader(stream) {
    const reader = new StreamReader(stream);
    return async function read() {
      try {
        let length = await reader.read(4);
        if (length == null) return true
        length = parseInt(length.toString('utf8'), 16);
        if (length === 0) return null
        if (length === 1) return null // delim packets
        const buffer = await reader.read(length - 4);
        if (buffer == null) return true
        return buffer
      } catch (err) {
        console.log('error', err);
        return true
      }
    }
  }
}

// @ts-check

/**
 * @param {function} read
 */
async function parseCapabilitiesV2(read) {
  /** @type {Object<string, string | true>} */
  const capabilities2 = {};

  let line;
  while (true) {
    line = await read();
    if (line === true) break
    if (line === null) continue
    line = line.toString('utf8').replace(/\n$/, '');
    const i = line.indexOf('=');
    if (i > -1) {
      const key = line.slice(0, i);
      const value = line.slice(i + 1);
      capabilities2[key] = value;
    } else {
      capabilities2[line] = true;
    }
  }
  return { protocolVersion: 2, capabilities2 }
}

async function parseRefsAdResponse(stream, { service }) {
  const capabilities = new Set();
  const refs = new Map();
  const symrefs = new Map();

  // There is probably a better way to do this, but for now
  // let's just throw the result parser inline here.
  const read = GitPktLine.streamReader(stream);
  let lineOne = await read();
  // skip past any flushes
  while (lineOne === null) lineOne = await read();
  if (lineOne === true) throw new EmptyServerResponseError()
  // Clients MUST ignore an LF at the end of the line.
  if (lineOne.toString('utf8').replace(/\n$/, '') !== `# service=${service}`) {
    throw new ParseError(`# service=${service}\\n`, lineOne.toString('utf8'))
  }
  let lineTwo = await read();
  // skip past any flushes
  while (lineTwo === null) lineTwo = await read();
  // In the edge case of a brand new repo, zero refs (and zero capabilities)
  // are returned.
  if (lineTwo === true) return { capabilities, refs, symrefs }
  lineTwo = lineTwo.toString('utf8');
  // Handle protocol v2 responses
  if (lineTwo.includes('version 2')) {
    return parseCapabilitiesV2(read)
  }
  const [firstRef, capabilitiesLine] = splitAndAssert(lineTwo, '\x00', '\\x00');
  capabilitiesLine.split(' ').map(x => capabilities.add(x));
  const [ref, name] = splitAndAssert(firstRef, ' ', ' ');
  refs.set(name, ref);
  while (true) {
    const line = await read();
    if (line === true) break
    if (line !== null) {
      const [ref, name] = splitAndAssert(line.toString('utf8'), ' ', ' ');
      refs.set(name, ref);
    }
  }
  // Symrefs are thrown into the "capabilities" unfortunately.
  for (const cap of capabilities) {
    if (cap.startsWith('symref=')) {
      const m = cap.match(/symref=([^:]+):(.*)/);
      if (m.length === 3) {
        symrefs.set(m[1], m[2]);
      }
    }
  }
  return { protocolVersion: 1, capabilities, refs, symrefs }
}

function splitAndAssert(line, sep, expected) {
  const split = line.trim().split(sep);
  if (split.length !== 2) {
    throw new ParseError(
      `Two strings separated by '${expected}'`,
      line.toString('utf8')
    )
  }
  return split
}

// Try to accomodate known CORS proxy implementations:
// - https://jcubic.pl/proxy.php?  <-- uses query string
// - https://cors.isomorphic-git.org  <-- uses path
const corsProxify = (corsProxy, url) =>
  corsProxy.endsWith('?')
    ? `${corsProxy}${url}`
    : `${corsProxy}/${url.replace(/^https?:\/\//, '')}`;

const updateHeaders = (headers, auth) => {
  // Update the basic auth header
  if (auth.username || auth.password) {
    headers.Authorization = calculateBasicAuthHeader(auth);
  }
  // but any manually provided headers take precedence
  if (auth.headers) {
    Object.assign(headers, auth.headers);
  }
};

/**
 * @param {GitHttpResponse} res
 *
 * @returns {{ preview: string, response: string, data: Buffer }}
 */
const stringifyBody = async res => {
  try {
    // Some services provide a meaningful error message in the body of 403s like "token lacks the scopes necessary to perform this action"
    const data = Buffer.from(await collect(res.body));
    const response = data.toString('utf8');
    const preview =
      response.length < 256 ? response : response.slice(0, 256) + '...';
    return { preview, response, data }
  } catch (e) {
    return {}
  }
};

class GitRemoteHTTP {
  static async capabilities() {
    return ['discover', 'connect']
  }

  /**
   * @param {Object} args
   * @param {HttpClient} args.http
   * @param {ProgressCallback} [args.onProgress]
   * @param {AuthCallback} [args.onAuth]
   * @param {AuthFailureCallback} [args.onAuthFailure]
   * @param {AuthSuccessCallback} [args.onAuthSuccess]
   * @param {string} [args.corsProxy]
   * @param {string} args.service
   * @param {string} args.url
   * @param {Object<string, string>} args.headers
   * @param {1 | 2} args.protocolVersion - Git Protocol Version
   */
  static async discover({
    http,
    onProgress,
    onAuth,
    onAuthSuccess,
    onAuthFailure,
    corsProxy,
    service,
    url: _origUrl,
    headers,
    protocolVersion,
  }) {
    let { url, auth } = extractAuthFromUrl(_origUrl);
    const proxifiedURL = corsProxy ? corsProxify(corsProxy, url) : url;
    if (auth.username || auth.password) {
      headers.Authorization = calculateBasicAuthHeader(auth);
    }
    if (protocolVersion === 2) {
      headers['Git-Protocol'] = 'version=2';
    }

    let res;
    let tryAgain;
    let providedAuthBefore = false;
    do {
      res = await http.request({
        onProgress,
        method: 'GET',
        url: `${proxifiedURL}/info/refs?service=${service}`,
        headers,
      });

      // the default loop behavior
      tryAgain = false;

      // 401 is the "correct" response for access denied. 203 is Non-Authoritative Information and comes from Azure DevOps, which
      // apparently doesn't realize this is a git request and is returning the HTML for the "Azure DevOps Services | Sign In" page.
      if (res.statusCode === 401 || res.statusCode === 203) {
        // On subsequent 401s, call `onAuthFailure` instead of `onAuth`.
        // This is so that naive `onAuth` callbacks that return a fixed value don't create an infinite loop of retrying.
        const getAuth = providedAuthBefore ? onAuthFailure : onAuth;
        if (getAuth) {
          // Acquire credentials and try again
          // TODO: read `useHttpPath` value from git config and pass along?
          auth = await getAuth(url, {
            ...auth,
            headers: { ...headers },
          });
          if (auth && auth.cancel) {
            throw new UserCanceledError()
          } else if (auth) {
            updateHeaders(headers, auth);
            providedAuthBefore = true;
            tryAgain = true;
          }
        }
      } else if (
        res.statusCode === 200 &&
        providedAuthBefore &&
        onAuthSuccess
      ) {
        await onAuthSuccess(url, auth);
      }
    } while (tryAgain)

    if (res.statusCode !== 200) {
      const { response } = await stringifyBody(res);
      throw new HttpError(res.statusCode, res.statusMessage, response)
    }
    // Git "smart" HTTP servers should respond with the correct Content-Type header.
    if (
      res.headers['content-type'] === `application/x-${service}-advertisement`
    ) {
      const remoteHTTP = await parseRefsAdResponse(res.body, { service });
      remoteHTTP.auth = auth;
      return remoteHTTP
    } else {
      // If they don't send the correct content-type header, that's a good indicator it is either a "dumb" HTTP
      // server, or the user specified an incorrect remote URL and the response is actually an HTML page.
      // In this case, we save the response as plain text so we can generate a better error message if needed.
      const { preview, response, data } = await stringifyBody(res);
      // For backwards compatibility, try to parse it anyway.
      // TODO: maybe just throw instead of trying?
      try {
        const remoteHTTP = await parseRefsAdResponse([data], { service });
        remoteHTTP.auth = auth;
        return remoteHTTP
      } catch (e) {
        throw new SmartHttpError(preview, response)
      }
    }
  }

  /**
   * @param {Object} args
   * @param {HttpClient} args.http
   * @param {ProgressCallback} [args.onProgress]
   * @param {string} [args.corsProxy]
   * @param {string} args.service
   * @param {string} args.url
   * @param {Object<string, string>} [args.headers]
   * @param {any} args.body
   * @param {any} args.auth
   */
  static async connect({
    http,
    onProgress,
    corsProxy,
    service,
    url,
    auth,
    body,
    headers,
  }) {
    // We already have the "correct" auth value at this point, but
    // we need to strip out the username/password from the URL yet again.
    const urlAuth = extractAuthFromUrl(url);
    if (urlAuth) url = urlAuth.url;

    if (corsProxy) url = corsProxify(corsProxy, url);

    headers['content-type'] = `application/x-${service}-request`;
    headers.accept = `application/x-${service}-result`;
    updateHeaders(headers, auth);

    const res = await http.request({
      onProgress,
      method: 'POST',
      url: `${url}/${service}`,
      body,
      headers,
    });
    if (res.statusCode !== 200) {
      const { response } = stringifyBody(res);
      throw new HttpError(res.statusCode, res.statusMessage, response)
    }
    return res
  }
}

function parseRemoteUrl({ url }) {
  // the stupid "shorter scp-like syntax"
  if (url.startsWith('git@')) {
    return {
      transport: 'ssh',
      address: url,
    }
  }
  const matches = url.match(/(\w+)(:\/\/|::)(.*)/);
  if (matches === null) return
  /*
   * When git encounters a URL of the form <transport>://<address>, where <transport> is
   * a protocol that it cannot handle natively, it automatically invokes git remote-<transport>
   * with the full URL as the second argument.
   *
   * @see https://git-scm.com/docs/git-remote-helpers
   */
  if (matches[2] === '://') {
    return {
      transport: matches[1],
      address: matches[0],
    }
  }
  /*
   * A URL of the form <transport>::<address> explicitly instructs git to invoke
   * git remote-<transport> with <address> as the second argument.
   *
   * @see https://git-scm.com/docs/git-remote-helpers
   */
  if (matches[2] === '::') {
    return {
      transport: matches[1],
      address: matches[3],
    }
  }
}

class GitRemoteManager {
  static getRemoteHelperFor({ url }) {
    // TODO: clean up the remoteHelper API and move into PluginCore
    const remoteHelpers = new Map();
    remoteHelpers.set('http', GitRemoteHTTP);
    remoteHelpers.set('https', GitRemoteHTTP);

    const parts = parseRemoteUrl({ url });
    if (!parts) {
      throw new UrlParseError(url)
    }
    if (remoteHelpers.has(parts.transport)) {
      return remoteHelpers.get(parts.transport)
    }
    throw new UnknownTransportError(
      url,
      parts.transport,
      parts.transport === 'ssh' ? translateSSHtoHTTP(url) : undefined
    )
  }
}

let lock$1 = null;

class GitShallowManager {
  static async read({ fs, gitdir }) {
    if (lock$1 === null) lock$1 = new asyncLock();
    const filepath = join(gitdir, 'shallow');
    const oids = new Set();
    await lock$1.acquire(filepath, async function() {
      const text = await fs.read(filepath, { encoding: 'utf8' });
      if (text === null) return oids // no file
      if (text.trim() === '') return oids // empty file
      text
        .trim()
        .split('\n')
        .map(oid => oids.add(oid));
    });
    return oids
  }

  static async write({ fs, gitdir, oids }) {
    if (lock$1 === null) lock$1 = new asyncLock();
    const filepath = join(gitdir, 'shallow');
    if (oids.size > 0) {
      const text = [...oids].join('\n') + '\n';
      await lock$1.acquire(filepath, async function() {
        await fs.write(filepath, text, {
          encoding: 'utf8',
        });
      });
    } else {
      // No shallows
      await lock$1.acquire(filepath, async function() {
        await fs.rm(filepath);
      });
    }
  }
}

async function hasObjectLoose({ fs, gitdir, oid }) {
  const source = `objects/${oid.slice(0, 2)}/${oid.slice(2)}`;
  return fs.exists(`${gitdir}/${source}`)
}

async function hasObjectPacked({
  fs,
  cache,
  gitdir,
  oid,
  getExternalRefDelta,
}) {
  // Check to see if it's in a packfile.
  // Iterate through all the .idx files
  let list = await fs.readdir(join(gitdir, 'objects/pack'));
  list = list.filter(x => x.endsWith('.idx'));
  for (const filename of list) {
    const indexFile = `${gitdir}/objects/pack/${filename}`;
    const p = await readPackIndex({
      fs,
      cache,
      filename: indexFile,
      getExternalRefDelta,
    });
    if (p.error) throw new InternalError(p.error)
    // If the packfile DOES have the oid we're looking for...
    if (p.offsets.has(oid)) {
      return true
    }
  }
  // Failed to find it
  return false
}

async function hasObject({
  fs,
  cache,
  gitdir,
  oid,
  format = 'content',
}) {
  // Curry the current read method so that the packfile un-deltification
  // process can acquire external ref-deltas.
  const getExternalRefDelta = oid => _readObject({ fs, cache, gitdir, oid });

  // Look for it in the loose object directory.
  let result = await hasObjectLoose({ fs, gitdir, oid });
  // Check to see if it's in a packfile.
  if (!result) {
    result = await hasObjectPacked({
      fs,
      cache,
      gitdir,
      oid,
      getExternalRefDelta,
    });
  }
  // Finally
  return result
}

// TODO: make a function that just returns obCount. then emptyPackfile = () => sizePack(pack) === 0
function emptyPackfile(pack) {
  const pheader = '5041434b';
  const version = '00000002';
  const obCount = '00000000';
  const header = pheader + version + obCount;
  return pack.slice(0, 12).toString('hex') === header
}

function filterCapabilities(server, client) {
  const serverNames = server.map(cap => cap.split('=', 1)[0]);
  return client.filter(cap => {
    const name = cap.split('=', 1)[0];
    return serverNames.includes(name)
  })
}

const pkg = {
  name: 'isomorphic-git',
  version: '1.8.1',
  agent: 'git/isomorphic-git@1.8.1',
};

class FIFO {
  constructor() {
    this._queue = [];
  }

  write(chunk) {
    if (this._ended) {
      throw Error('You cannot write to a FIFO that has already been ended!')
    }
    if (this._waiting) {
      const resolve = this._waiting;
      this._waiting = null;
      resolve({ value: chunk });
    } else {
      this._queue.push(chunk);
    }
  }

  end() {
    this._ended = true;
    if (this._waiting) {
      const resolve = this._waiting;
      this._waiting = null;
      resolve({ done: true });
    }
  }

  destroy(err) {
    this._ended = true;
    this.error = err;
  }

  async next() {
    if (this._queue.length > 0) {
      return { value: this._queue.shift() }
    }
    if (this._ended) {
      return { done: true }
    }
    if (this._waiting) {
      throw Error(
        'You cannot call read until the previous call to read has returned!'
      )
    }
    return new Promise(resolve => {
      this._waiting = resolve;
    })
  }
}

// Note: progress messages are designed to be written directly to the terminal,
// so they are often sent with just a carriage return to overwrite the last line of output.
// But there are also messages delimited with newlines.
// I also include CRLF just in case.
function findSplit(str) {
  const r = str.indexOf('\r');
  const n = str.indexOf('\n');
  if (r === -1 && n === -1) return -1
  if (r === -1) return n + 1 // \n
  if (n === -1) return r + 1 // \r
  if (n === r + 1) return n + 1 // \r\n
  return Math.min(r, n) + 1 // \r or \n
}

function splitLines(input) {
  const output = new FIFO();
  let tmp = ''
  ;(async () => {
    await forAwait(input, chunk => {
      chunk = chunk.toString('utf8');
      tmp += chunk;
      while (true) {
        const i = findSplit(tmp);
        if (i === -1) break
        output.write(tmp.slice(0, i));
        tmp = tmp.slice(i);
      }
    });
    if (tmp.length > 0) {
      output.write(tmp);
    }
    output.end();
  })();
  return output
}

/*
If 'side-band' or 'side-band-64k' capabilities have been specified by
the client, the server will send the packfile data multiplexed.

Each packet starting with the packet-line length of the amount of data
that follows, followed by a single byte specifying the sideband the
following data is coming in on.

In 'side-band' mode, it will send up to 999 data bytes plus 1 control
code, for a total of up to 1000 bytes in a pkt-line.  In 'side-band-64k'
mode it will send up to 65519 data bytes plus 1 control code, for a
total of up to 65520 bytes in a pkt-line.

The sideband byte will be a '1', '2' or a '3'. Sideband '1' will contain
packfile data, sideband '2' will be used for progress information that the
client will generally print to stderr and sideband '3' is used for error
information.

If no 'side-band' capability was specified, the server will stream the
entire packfile without multiplexing.
*/

class GitSideBand {
  static demux(input) {
    const read = GitPktLine.streamReader(input);
    // And now for the ridiculous side-band or side-band-64k protocol
    const packetlines = new FIFO();
    const packfile = new FIFO();
    const progress = new FIFO();
    // TODO: Use a proper through stream?
    const nextBit = async function() {
      const line = await read();
      // Skip over flush packets
      if (line === null) return nextBit()
      // A made up convention to signal there's no more to read.
      if (line === true) {
        packetlines.end();
        progress.end();
        packfile.end();
        return
      }
      // Examine first byte to determine which output "stream" to use
      switch (line[0]) {
        case 1: {
          // pack data
          packfile.write(line.slice(1));
          break
        }
        case 2: {
          // progress message
          progress.write(line.slice(1));
          break
        }
        case 3: {
          // fatal error message just before stream aborts
          const error = line.slice(1);
          progress.write(error);
          packfile.destroy(new Error(error.toString('utf8')));
          return
        }
        default: {
          // Not part of the side-band-64k protocol
          packetlines.write(line.slice(0));
        }
      }
      // Careful not to blow up the stack.
      // I think Promises in a tail-call position should be OK.
      nextBit();
    };
    nextBit();
    return {
      packetlines,
      packfile,
      progress,
    }
  }
  // static mux ({
  //   protocol, // 'side-band' or 'side-band-64k'
  //   packetlines,
  //   packfile,
  //   progress,
  //   error
  // }) {
  //   const MAX_PACKET_LENGTH = protocol === 'side-band-64k' ? 999 : 65519
  //   let output = new PassThrough()
  //   packetlines.on('data', data => {
  //     if (data === null) {
  //       output.write(GitPktLine.flush())
  //     } else {
  //       output.write(GitPktLine.encode(data))
  //     }
  //   })
  //   let packfileWasEmpty = true
  //   let packfileEnded = false
  //   let progressEnded = false
  //   let errorEnded = false
  //   let goodbye = Buffer.concat([
  //     GitPktLine.encode(Buffer.from('010A', 'hex')),
  //     GitPktLine.flush()
  //   ])
  //   packfile
  //     .on('data', data => {
  //       packfileWasEmpty = false
  //       const buffers = splitBuffer(data, MAX_PACKET_LENGTH)
  //       for (const buffer of buffers) {
  //         output.write(
  //           GitPktLine.encode(Buffer.concat([Buffer.from('01', 'hex'), buffer]))
  //         )
  //       }
  //     })
  //     .on('end', () => {
  //       packfileEnded = true
  //       if (!packfileWasEmpty) output.write(goodbye)
  //       if (progressEnded && errorEnded) output.end()
  //     })
  //   progress
  //     .on('data', data => {
  //       const buffers = splitBuffer(data, MAX_PACKET_LENGTH)
  //       for (const buffer of buffers) {
  //         output.write(
  //           GitPktLine.encode(Buffer.concat([Buffer.from('02', 'hex'), buffer]))
  //         )
  //       }
  //     })
  //     .on('end', () => {
  //       progressEnded = true
  //       if (packfileEnded && errorEnded) output.end()
  //     })
  //   error
  //     .on('data', data => {
  //       const buffers = splitBuffer(data, MAX_PACKET_LENGTH)
  //       for (const buffer of buffers) {
  //         output.write(
  //           GitPktLine.encode(Buffer.concat([Buffer.from('03', 'hex'), buffer]))
  //         )
  //       }
  //     })
  //     .on('end', () => {
  //       errorEnded = true
  //       if (progressEnded && packfileEnded) output.end()
  //     })
  //   return output
  // }
}

async function parseUploadPackResponse(stream) {
  const { packetlines, packfile, progress } = GitSideBand.demux(stream);
  const shallows = [];
  const unshallows = [];
  const acks = [];
  let nak = false;
  let done = false;
  return new Promise((resolve, reject) => {
    // Parse the response
    forAwait(packetlines, data => {
      const line = data.toString('utf8').trim();
      if (line.startsWith('shallow')) {
        const oid = line.slice(-41).trim();
        if (oid.length !== 40) {
          reject(new InvalidOidError(oid));
        }
        shallows.push(oid);
      } else if (line.startsWith('unshallow')) {
        const oid = line.slice(-41).trim();
        if (oid.length !== 40) {
          reject(new InvalidOidError(oid));
        }
        unshallows.push(oid);
      } else if (line.startsWith('ACK')) {
        const [, oid, status] = line.split(' ');
        acks.push({ oid, status });
        if (!status) done = true;
      } else if (line.startsWith('NAK')) {
        nak = true;
        done = true;
      }
      if (done) {
        resolve({ shallows, unshallows, acks, nak, packfile, progress });
      }
    });
  })
}

function writeUploadPackRequest({
  capabilities = [],
  wants = [],
  haves = [],
  shallows = [],
  depth = null,
  since = null,
  exclude = [],
}) {
  const packstream = [];
  wants = [...new Set(wants)]; // remove duplicates
  let firstLineCapabilities = ` ${capabilities.join(' ')}`;
  for (const oid of wants) {
    packstream.push(GitPktLine.encode(`want ${oid}${firstLineCapabilities}\n`));
    firstLineCapabilities = '';
  }
  for (const oid of shallows) {
    packstream.push(GitPktLine.encode(`shallow ${oid}\n`));
  }
  if (depth !== null) {
    packstream.push(GitPktLine.encode(`deepen ${depth}\n`));
  }
  if (since !== null) {
    packstream.push(
      GitPktLine.encode(`deepen-since ${Math.floor(since.valueOf() / 1000)}\n`)
    );
  }
  for (const oid of exclude) {
    packstream.push(GitPktLine.encode(`deepen-not ${oid}\n`));
  }
  packstream.push(GitPktLine.flush());
  for (const oid of haves) {
    packstream.push(GitPktLine.encode(`have ${oid}\n`));
  }
  packstream.push(GitPktLine.encode(`done\n`));
  return packstream
}

// @ts-check

/**
 *
 * @typedef {object} FetchResult - The object returned has the following schema:
 * @property {string | null} defaultBranch - The branch that is cloned if no branch is specified
 * @property {string | null} fetchHead - The SHA-1 object id of the fetched head commit
 * @property {string | null} fetchHeadDescription - a textual description of the branch that was fetched
 * @property {Object<string, string>} [headers] - The HTTP response headers returned by the git server
 * @property {string[]} [pruned] - A list of branches that were pruned, if you provided the `prune` parameter
 *
 */

/**
 * @param {object} args
 * @param {import('../models/FileSystem.js').FileSystem} args.fs
 * @param {any} args.cache
 * @param {HttpClient} args.http
 * @param {ProgressCallback} [args.onProgress]
 * @param {MessageCallback} [args.onMessage]
 * @param {AuthCallback} [args.onAuth]
 * @param {AuthFailureCallback} [args.onAuthFailure]
 * @param {AuthSuccessCallback} [args.onAuthSuccess]
 * @param {string} args.gitdir
 * @param {string|void} [args.url]
 * @param {string} [args.corsProxy]
 * @param {string} [args.ref]
 * @param {string} [args.remoteRef]
 * @param {string} [args.remote]
 * @param {boolean} [args.singleBranch = false]
 * @param {boolean} [args.tags = false]
 * @param {number} [args.depth]
 * @param {Date} [args.since]
 * @param {string[]} [args.exclude = []]
 * @param {boolean} [args.relative = false]
 * @param {Object<string, string>} [args.headers]
 * @param {boolean} [args.prune]
 * @param {boolean} [args.pruneTags]
 *
 * @returns {Promise<FetchResult>}
 * @see FetchResult
 */
async function _fetch({
  fs,
  cache,
  http,
  onProgress,
  onMessage,
  onAuth,
  onAuthSuccess,
  onAuthFailure,
  gitdir,
  ref: _ref,
  remoteRef: _remoteRef,
  remote: _remote,
  url: _url,
  corsProxy,
  depth = null,
  since = null,
  exclude = [],
  relative = false,
  tags = false,
  singleBranch = false,
  headers = {},
  prune = false,
  pruneTags = false,
}) {
  const ref = _ref || (await _currentBranch({ fs, gitdir, test: true }));
  const config = await GitConfigManager.get({ fs, gitdir });
  // Figure out what remote to use.
  const remote =
    _remote || (ref && (await config.get(`branch.${ref}.remote`))) || 'origin';
  // Lookup the URL for the given remote.
  const url = _url || (await config.get(`remote.${remote}.url`));
  if (typeof url === 'undefined') {
    throw new MissingParameterError('remote OR url')
  }
  // Figure out what remote ref to use.
  const remoteRef =
    _remoteRef ||
    (ref && (await config.get(`branch.${ref}.merge`))) ||
    _ref ||
    'HEAD';

  if (corsProxy === undefined) {
    corsProxy = await config.get('http.corsProxy');
  }

  const GitRemoteHTTP = GitRemoteManager.getRemoteHelperFor({ url });
  const remoteHTTP = await GitRemoteHTTP.discover({
    http,
    onAuth,
    onAuthSuccess,
    onAuthFailure,
    corsProxy,
    service: 'git-upload-pack',
    url,
    headers,
    protocolVersion: 1,
  });
  const auth = remoteHTTP.auth; // hack to get new credentials from CredentialManager API
  const remoteRefs = remoteHTTP.refs;
  // For the special case of an empty repository with no refs, return null.
  if (remoteRefs.size === 0) {
    return {
      defaultBranch: null,
      fetchHead: null,
      fetchHeadDescription: null,
    }
  }
  // Check that the remote supports the requested features
  if (depth !== null && !remoteHTTP.capabilities.has('shallow')) {
    throw new RemoteCapabilityError('shallow', 'depth')
  }
  if (since !== null && !remoteHTTP.capabilities.has('deepen-since')) {
    throw new RemoteCapabilityError('deepen-since', 'since')
  }
  if (exclude.length > 0 && !remoteHTTP.capabilities.has('deepen-not')) {
    throw new RemoteCapabilityError('deepen-not', 'exclude')
  }
  if (relative === true && !remoteHTTP.capabilities.has('deepen-relative')) {
    throw new RemoteCapabilityError('deepen-relative', 'relative')
  }
  // Figure out the SHA for the requested ref
  const { oid, fullref } = GitRefManager.resolveAgainstMap({
    ref: remoteRef,
    map: remoteRefs,
  });
  // Filter out refs we want to ignore: only keep ref we're cloning, HEAD, branches, and tags (if we're keeping them)
  for (const remoteRef of remoteRefs.keys()) {
    if (
      remoteRef === fullref ||
      remoteRef === 'HEAD' ||
      remoteRef.startsWith('refs/heads/') ||
      (tags && remoteRef.startsWith('refs/tags/'))
    ) {
      continue
    }
    remoteRefs.delete(remoteRef);
  }
  // Assemble the application/x-git-upload-pack-request
  const capabilities = filterCapabilities(
    [...remoteHTTP.capabilities],
    [
      'multi_ack_detailed',
      'no-done',
      'side-band-64k',
      // Note: I removed 'thin-pack' option since our code doesn't "fatten" packfiles,
      // which is necessary for compatibility with git. It was the cause of mysterious
      // 'fatal: pack has [x] unresolved deltas' errors that plagued us for some time.
      // isomorphic-git is perfectly happy with thin packfiles in .git/objects/pack but
      // canonical git it turns out is NOT.
      'ofs-delta',
      `agent=${pkg.agent}`,
    ]
  );
  if (relative) capabilities.push('deepen-relative');
  // Start figuring out which oids from the remote we want to request
  const wants = singleBranch ? [oid] : remoteRefs.values();
  // Come up with a reasonable list of oids to tell the remote we already have
  // (preferably oids that are close ancestors of the branch heads we're fetching)
  const haveRefs = singleBranch
    ? [ref]
    : await GitRefManager.listRefs({
        fs,
        gitdir,
        filepath: `refs`,
      });
  let haves = [];
  for (let ref of haveRefs) {
    try {
      ref = await GitRefManager.expand({ fs, gitdir, ref });
      const oid = await GitRefManager.resolve({ fs, gitdir, ref });
      if (await hasObject({ fs, cache, gitdir, oid })) {
        haves.push(oid);
      }
    } catch (err) {}
  }
  haves = [...new Set(haves)];
  const oids = await GitShallowManager.read({ fs, gitdir });
  const shallows = remoteHTTP.capabilities.has('shallow') ? [...oids] : [];
  const packstream = writeUploadPackRequest({
    capabilities,
    wants,
    haves,
    shallows,
    depth,
    since,
    exclude,
  });
  // CodeCommit will hang up if we don't send a Content-Length header
  // so we can't stream the body.
  const packbuffer = Buffer.from(await collect(packstream));
  const raw = await GitRemoteHTTP.connect({
    http,
    onProgress,
    corsProxy,
    service: 'git-upload-pack',
    url,
    auth,
    body: [packbuffer],
    headers,
  });
  const response = await parseUploadPackResponse(raw.body);
  if (raw.headers) {
    response.headers = raw.headers;
  }
  // Apply all the 'shallow' and 'unshallow' commands
  for (const oid of response.shallows) {
    if (!oids.has(oid)) {
      // this is in a try/catch mostly because my old test fixtures are missing objects
      try {
        // server says it's shallow, but do we have the parents?
        const { object } = await _readObject({ fs, cache, gitdir, oid });
        const commit = new GitCommit(object);
        const hasParents = await Promise.all(
          commit
            .headers()
            .parent.map(oid => hasObject({ fs, cache, gitdir, oid }))
        );
        const haveAllParents =
          hasParents.length === 0 || hasParents.every(has => has);
        if (!haveAllParents) {
          oids.add(oid);
        }
      } catch (err) {
        oids.add(oid);
      }
    }
  }
  for (const oid of response.unshallows) {
    oids.delete(oid);
  }
  await GitShallowManager.write({ fs, gitdir, oids });
  // Update local remote refs
  if (singleBranch) {
    const refs = new Map([[fullref, oid]]);
    // But wait, maybe it was a symref, like 'HEAD'!
    // We need to save all the refs in the symref chain (sigh).
    const symrefs = new Map();
    let bail = 10;
    let key = fullref;
    while (bail--) {
      const value = remoteHTTP.symrefs.get(key);
      if (value === undefined) break
      symrefs.set(key, value);
      key = value;
    }
    // final value must not be a symref but a real ref
    const realRef = remoteRefs.get(key);
    // There may be no ref at all if we've fetched a specific commit hash
    if (realRef) {
      refs.set(key, realRef);
    }
    const { pruned } = await GitRefManager.updateRemoteRefs({
      fs,
      gitdir,
      remote,
      refs,
      symrefs,
      tags,
      prune,
    });
    if (prune) {
      response.pruned = pruned;
    }
  } else {
    const { pruned } = await GitRefManager.updateRemoteRefs({
      fs,
      gitdir,
      remote,
      refs: remoteRefs,
      symrefs: remoteHTTP.symrefs,
      tags,
      prune,
      pruneTags,
    });
    if (prune) {
      response.pruned = pruned;
    }
  }
  // We need this value later for the `clone` command.
  response.HEAD = remoteHTTP.symrefs.get('HEAD');
  // AWS CodeCommit doesn't list HEAD as a symref, but we can reverse engineer it
  // Find the SHA of the branch called HEAD
  if (response.HEAD === undefined) {
    const { oid } = GitRefManager.resolveAgainstMap({
      ref: 'HEAD',
      map: remoteRefs,
    });
    // Use the name of the first branch that's not called HEAD that has
    // the same SHA as the branch called HEAD.
    for (const [key, value] of remoteRefs.entries()) {
      if (key !== 'HEAD' && value === oid) {
        response.HEAD = key;
        break
      }
    }
  }
  const noun = fullref.startsWith('refs/tags') ? 'tag' : 'branch';
  response.FETCH_HEAD = {
    oid,
    description: `${noun} '${abbreviateRef(fullref)}' of ${url}`,
  };

  if (onProgress || onMessage) {
    const lines = splitLines(response.progress);
    forAwait(lines, async line => {
      if (onMessage) await onMessage(line);
      if (onProgress) {
        const matches = line.match(/([^:]*).*\((\d+?)\/(\d+?)\)/);
        if (matches) {
          await onProgress({
            phase: matches[1].trim(),
            loaded: parseInt(matches[2], 10),
            total: parseInt(matches[3], 10),
          });
        }
      }
    });
  }
  const packfile = Buffer.from(await collect(response.packfile));
  const packfileSha = packfile.slice(-20).toString('hex');
  const res = {
    defaultBranch: response.HEAD,
    fetchHead: response.FETCH_HEAD.oid,
    fetchHeadDescription: response.FETCH_HEAD.description,
  };
  if (response.headers) {
    res.headers = response.headers;
  }
  if (prune) {
    res.pruned = response.pruned;
  }
  // This is a quick fix for the empty .git/objects/pack/pack-.pack file error,
  // which due to the way `git-list-pack` works causes the program to hang when it tries to read it.
  // TODO: Longer term, we should actually:
  // a) NOT concatenate the entire packfile into memory (line 78),
  // b) compute the SHA of the stream except for the last 20 bytes, using the same library used in push.js, and
  // c) compare the computed SHA with the last 20 bytes of the stream before saving to disk, and throwing a "packfile got corrupted during download" error if the SHA doesn't match.
  if (packfileSha !== '' && !emptyPackfile(packfile)) {
    res.packfile = `objects/pack/pack-${packfileSha}.pack`;
    const fullpath = join(gitdir, res.packfile);
    await fs.write(fullpath, packfile);
    const getExternalRefDelta = oid => _readObject({ fs, cache, gitdir, oid });
    const idx = await GitPackIndex.fromPack({
      pack: packfile,
      getExternalRefDelta,
      onProgress,
    });
    await fs.write(fullpath.replace(/\.pack$/, '.idx'), await idx.toBuffer());
  }
  return res
}

// @ts-check

/**
 * Initialize a new repository
 *
 * @param {object} args
 * @param {import('../models/FileSystem.js').FileSystem} args.fs
 * @param {string} [args.dir]
 * @param {string} [args.gitdir]
 * @param {boolean} [args.bare = false]
 * @param {string} [args.defaultBranch = 'master']
 * @returns {Promise<void>}
 */
async function _init({
  fs,
  bare = false,
  dir,
  gitdir = bare ? dir : join(dir, '.git'),
  defaultBranch = 'master',
}) {
  // Don't overwrite an existing config
  if (await fs.exists(gitdir + '/config')) return

  let folders = [
    'hooks',
    'info',
    'objects/info',
    'objects/pack',
    'refs/heads',
    'refs/tags',
  ];
  folders = folders.map(dir => gitdir + '/' + dir);
  for (const folder of folders) {
    await fs.mkdir(folder);
  }

  await fs.write(
    gitdir + '/config',
    '[core]\n' +
      '\trepositoryformatversion = 0\n' +
      '\tfilemode = false\n' +
      `\tbare = ${bare}\n` +
      (bare ? '' : '\tlogallrefupdates = true\n') +
      '\tsymlinks = false\n' +
      '\tignorecase = true\n'
  );
  await fs.write(gitdir + '/HEAD', `ref: refs/heads/${defaultBranch}\n`);
}

// @ts-check

/**
 * @param {object} args
 * @param {import('../models/FileSystem.js').FileSystem} args.fs
 * @param {object} args.cache
 * @param {HttpClient} args.http
 * @param {ProgressCallback} [args.onProgress]
 * @param {MessageCallback} [args.onMessage]
 * @param {AuthCallback} [args.onAuth]
 * @param {AuthFailureCallback} [args.onAuthFailure]
 * @param {AuthSuccessCallback} [args.onAuthSuccess]
 * @param {string} [args.dir]
 * @param {string} args.gitdir
 * @param {string} args.url
 * @param {string} args.corsProxy
 * @param {string} args.ref
 * @param {boolean} args.singleBranch
 * @param {boolean} args.noCheckout
 * @param {boolean} args.noTags
 * @param {string} args.remote
 * @param {number} args.depth
 * @param {Date} args.since
 * @param {string[]} args.exclude
 * @param {boolean} args.relative
 * @param {Object<string, string>} args.headers
 *
 * @returns {Promise<void>} Resolves successfully when clone completes
 *
 */
async function _clone({
  fs,
  cache,
  http,
  onProgress,
  onMessage,
  onAuth,
  onAuthSuccess,
  onAuthFailure,
  dir,
  gitdir,
  url,
  corsProxy,
  ref,
  remote,
  depth,
  since,
  exclude,
  relative,
  singleBranch,
  noCheckout,
  noTags,
  headers,
}) {
  await _init({ fs, gitdir });
  await _addRemote({ fs, gitdir, remote, url, force: false });
  if (corsProxy) {
    const config = await GitConfigManager.get({ fs, gitdir });
    await config.set(`http.corsProxy`, corsProxy);
    await GitConfigManager.save({ fs, gitdir, config });
  }
  const { defaultBranch, fetchHead } = await _fetch({
    fs,
    cache,
    http,
    onProgress,
    onMessage,
    onAuth,
    onAuthSuccess,
    onAuthFailure,
    gitdir,
    ref,
    remote,
    depth,
    since,
    exclude,
    relative,
    singleBranch,
    headers,
    tags: !noTags,
  });
  if (fetchHead === null) return
  ref = ref || defaultBranch;
  ref = ref.replace('refs/heads/', '');
  // Checkout that branch
  await _checkout({
    fs,
    cache,
    onProgress,
    dir,
    gitdir,
    ref,
    remote,
    noCheckout,
  });
}

// @ts-check

/**
 * Clone a repository
 *
 * @param {object} args
 * @param {FsClient} args.fs - a file system implementation
 * @param {HttpClient} args.http - an HTTP client
 * @param {ProgressCallback} [args.onProgress] - optional progress event callback
 * @param {MessageCallback} [args.onMessage] - optional message event callback
 * @param {AuthCallback} [args.onAuth] - optional auth fill callback
 * @param {AuthFailureCallback} [args.onAuthFailure] - optional auth rejected callback
 * @param {AuthSuccessCallback} [args.onAuthSuccess] - optional auth approved callback
 * @param {string} args.dir - The [working tree](dir-vs-gitdir.md) directory path
 * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path
 * @param {string} args.url - The URL of the remote repository
 * @param {string} [args.corsProxy] - Optional [CORS proxy](https://www.npmjs.com/%40isomorphic-git/cors-proxy). Value is stored in the git config file for that repo.
 * @param {string} [args.ref] - Which branch to checkout. By default this is the designated "main branch" of the repository.
 * @param {boolean} [args.singleBranch = false] - Instead of the default behavior of fetching all the branches, only fetch a single branch.
 * @param {boolean} [args.noCheckout = false] - If true, clone will only fetch the repo, not check out a branch. Skipping checkout can save a lot of time normally spent writing files to disk.
 * @param {boolean} [args.noTags = false] - By default clone will fetch all tags. `noTags` disables that behavior.
 * @param {string} [args.remote = 'origin'] - What to name the remote that is created.
 * @param {number} [args.depth] - Integer. Determines how much of the git repository's history to retrieve
 * @param {Date} [args.since] - Only fetch commits created after the given date. Mutually exclusive with `depth`.
 * @param {string[]} [args.exclude = []] - A list of branches or tags. Instructs the remote server not to send us any commits reachable from these refs.
 * @param {boolean} [args.relative = false] - Changes the meaning of `depth` to be measured from the current shallow depth rather than from the branch tip.
 * @param {Object<string, string>} [args.headers = {}] - Additional headers to include in HTTP requests, similar to git's `extraHeader` config
 * @param {object} [args.cache] - a [cache](cache.md) object
 *
 * @returns {Promise<void>} Resolves successfully when clone completes
 *
 * @example
 * await git.clone({
 *   fs,
 *   http,
 *   dir: '/tutorial',
 *   corsProxy: 'https://cors.isomorphic-git.org',
 *   url: 'https://github.com/isomorphic-git/isomorphic-git',
 *   singleBranch: true,
 *   depth: 1
 * })
 * console.log('done')
 *
 */
async function clone({
  fs,
  http,
  onProgress,
  onMessage,
  onAuth,
  onAuthSuccess,
  onAuthFailure,
  dir,
  gitdir = join(dir, '.git'),
  url,
  corsProxy = undefined,
  ref = undefined,
  remote = 'origin',
  depth = undefined,
  since = undefined,
  exclude = [],
  relative = false,
  singleBranch = false,
  noCheckout = false,
  noTags = false,
  headers = {},
  cache = {},
}) {
  try {
    assertParameter('fs', fs);
    assertParameter('http', http);
    assertParameter('gitdir', gitdir);
    if (!noCheckout) {
      assertParameter('dir', dir);
    }
    assertParameter('url', url);

    return await _clone({
      fs: new FileSystem(fs),
      cache,
      http,
      onProgress,
      onMessage,
      onAuth,
      onAuthSuccess,
      onAuthFailure,
      dir,
      gitdir,
      url,
      corsProxy,
      ref,
      remote,
      depth,
      since,
      exclude,
      relative,
      singleBranch,
      noCheckout,
      noTags,
      headers,
    })
  } catch (err) {
    err.caller = 'git.clone';
    throw err
  }
}

// @ts-check

/**
 * Create a new commit
 *
 * @param {Object} args
 * @param {FsClient} args.fs - a file system implementation
 * @param {SignCallback} [args.onSign] - a PGP signing implementation
 * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path
 * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path
 * @param {string} args.message - The commit message to use.
 * @param {Object} [args.author] - The details about the author.
 * @param {string} [args.author.name] - Default is `user.name` config.
 * @param {string} [args.author.email] - Default is `user.email` config.
 * @param {number} [args.author.timestamp=Math.floor(Date.now()/1000)] - Set the author timestamp field. This is the integer number of seconds since the Unix epoch (1970-01-01 00:00:00).
 * @param {number} [args.author.timezoneOffset] - Set the author timezone offset field. This is the difference, in minutes, from the current timezone to UTC. Default is `(new Date()).getTimezoneOffset()`.
 * @param {Object} [args.committer = author] - The details about the commit committer, in the same format as the author parameter. If not specified, the author details are used.
 * @param {string} [args.committer.name] - Default is `user.name` config.
 * @param {string} [args.committer.email] - Default is `user.email` config.
 * @param {number} [args.committer.timestamp=Math.floor(Date.now()/1000)] - Set the committer timestamp field. This is the integer number of seconds since the Unix epoch (1970-01-01 00:00:00).
 * @param {number} [args.committer.timezoneOffset] - Set the committer timezone offset field. This is the difference, in minutes, from the current timezone to UTC. Default is `(new Date()).getTimezoneOffset()`.
 * @param {string} [args.signingKey] - Sign the tag object using this private PGP key.
 * @param {boolean} [args.dryRun = false] - If true, simulates making a commit so you can test whether it would succeed. Implies `noUpdateBranch`.
 * @param {boolean} [args.noUpdateBranch = false] - If true, does not update the branch pointer after creating the commit.
 * @param {string} [args.ref] - The fully expanded name of the branch to commit to. Default is the current branch pointed to by HEAD. (TODO: fix it so it can expand branch names without throwing if the branch doesn't exist yet.)
 * @param {string[]} [args.parent] - The SHA-1 object ids of the commits to use as parents. If not specified, the commit pointed to by `ref` is used.
 * @param {string} [args.tree] - The SHA-1 object id of the tree to use. If not specified, a new tree object is created from the current git index.
 * @param {object} [args.cache] - a [cache](cache.md) object
 *
 * @returns {Promise<string>} Resolves successfully with the SHA-1 object id of the newly created commit.
 *
 * @example
 * let sha = await git.commit({
 *   fs,
 *   dir: '/tutorial',
 *   author: {
 *     name: 'Mr. Test',
 *     email: 'mrtest@example.com',
 *   },
 *   message: 'Added the a.txt file'
 * })
 * console.log(sha)
 *
 */
async function commit({
  fs: _fs,
  onSign,
  dir,
  gitdir = join(dir, '.git'),
  message,
  author: _author,
  committer: _committer,
  signingKey,
  dryRun = false,
  noUpdateBranch = false,
  ref,
  parent,
  tree,
  cache = {},
}) {
  try {
    assertParameter('fs', _fs);
    assertParameter('message', message);
    if (signingKey) {
      assertParameter('onSign', onSign);
    }
    const fs = new FileSystem(_fs);

    const author = await normalizeAuthorObject({ fs, gitdir, author: _author });
    if (!author) throw new MissingNameError('author')

    const committer = await normalizeCommitterObject({
      fs,
      gitdir,
      author,
      committer: _committer,
    });
    if (!committer) throw new MissingNameError('committer')

    return await _commit({
      fs,
      cache,
      onSign,
      gitdir,
      message,
      author,
      committer,
      signingKey,
      dryRun,
      noUpdateBranch,
      ref,
      parent,
      tree,
    })
  } catch (err) {
    err.caller = 'git.commit';
    throw err
  }
}

// @ts-check

/**
 * Get the name of the branch currently pointed to by .git/HEAD
 *
 * @param {Object} args
 * @param {FsClient} args.fs - a file system implementation
 * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path
 * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path
 * @param {boolean} [args.fullname = false] - Return the full path (e.g. "refs/heads/main") instead of the abbreviated form.
 * @param {boolean} [args.test = false] - If the current branch doesn't actually exist (such as right after git init) then return `undefined`.
 *
 * @returns {Promise<string|void>} The name of the current branch or undefined if the HEAD is detached.
 *
 * @example
 * // Get the current branch name
 * let branch = await git.currentBranch({
 *   fs,
 *   dir: '/tutorial',
 *   fullname: false
 * })
 * console.log(branch)
 *
 */
async function currentBranch({
  fs,
  dir,
  gitdir = join(dir, '.git'),
  fullname = false,
  test = false,
}) {
  try {
    assertParameter('fs', fs);
    assertParameter('gitdir', gitdir);
    return await _currentBranch({
      fs: new FileSystem(fs),
      gitdir,
      fullname,
      test,
    })
  } catch (err) {
    err.caller = 'git.currentBranch';
    throw err
  }
}

// @ts-check

/**
 * @param {Object} args
 * @param {import('../models/FileSystem.js').FileSystem} args.fs
 * @param {string} args.gitdir
 * @param {string} args.ref
 *
 * @returns {Promise<void>}
 */
async function _deleteBranch({ fs, gitdir, ref }) {
  const exist = await GitRefManager.exists({ fs, gitdir, ref });
  if (!exist) {
    throw new NotFoundError(ref)
  }

  const fullRef = await GitRefManager.expand({ fs, gitdir, ref });
  const currentRef = await _currentBranch({ fs, gitdir, fullname: true });
  if (fullRef === currentRef) {
    // detach HEAD
    const value = await GitRefManager.resolve({ fs, gitdir, ref: fullRef });
    await GitRefManager.writeRef({ fs, gitdir, ref: 'HEAD', value });
  }

  // Delete a specified branch
  await GitRefManager.deleteRef({ fs, gitdir, ref: fullRef });
}

// @ts-check

/**
 * Delete a local branch
 *
 * > Note: This only deletes loose branches - it should be fixed in the future to delete packed branches as well.
 *
 * @param {Object} args
 * @param {FsClient} args.fs - a file system implementation
 * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path
 * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path
 * @param {string} args.ref - The branch to delete
 *
 * @returns {Promise<void>} Resolves successfully when filesystem operations are complete
 *
 * @example
 * await git.deleteBranch({ fs, dir: '/tutorial', ref: 'local-branch' })
 * console.log('done')
 *
 */
async function deleteBranch({
  fs,
  dir,
  gitdir = join(dir, '.git'),
  ref,
}) {
  try {
    assertParameter('fs', fs);
    assertParameter('ref', ref);
    return await _deleteBranch({
      fs: new FileSystem(fs),
      gitdir,
      ref,
    })
  } catch (err) {
    err.caller = 'git.deleteBranch';
    throw err
  }
}

// @ts-check

/**
 * Delete a local ref
 *
 * @param {Object} args
 * @param {FsClient} args.fs - a file system implementation
 * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path
 * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path
 * @param {string} args.ref - The ref to delete
 *
 * @returns {Promise<void>} Resolves successfully when filesystem operations are complete
 *
 * @example
 * await git.deleteRef({ fs, dir: '/tutorial', ref: 'refs/tags/test-tag' })
 * console.log('done')
 *
 */
async function deleteRef({ fs, dir, gitdir = join(dir, '.git'), ref }) {
  try {
    assertParameter('fs', fs);
    assertParameter('ref', ref);
    await GitRefManager.deleteRef({ fs: new FileSystem(fs), gitdir, ref });
  } catch (err) {
    err.caller = 'git.deleteRef';
    throw err
  }
}

// @ts-check

/**
 * @param {Object} args
 * @param {import('../models/FileSystem.js').FileSystem} args.fs
 * @param {string} args.gitdir
 * @param {string} args.remote
 *
 * @returns {Promise<void>}
 */
async function _deleteRemote({ fs, gitdir, remote }) {
  const config = await GitConfigManager.get({ fs, gitdir });
  await config.deleteSection('remote', remote);
  await GitConfigManager.save({ fs, gitdir, config });
}

// @ts-check

/**
 * Removes the local config entry for a given remote
 *
 * @param {Object} args
 * @param {FsClient} args.fs - a file system implementation
 * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path
 * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path
 * @param {string} args.remote - The name of the remote to delete
 *
 * @returns {Promise<void>} Resolves successfully when filesystem operations are complete
 *
 * @example
 * await git.deleteRemote({ fs, dir: '/tutorial', remote: 'upstream' })
 * console.log('done')
 *
 */
async function deleteRemote({
  fs,
  dir,
  gitdir = join(dir, '.git'),
  remote,
}) {
  try {
    assertParameter('fs', fs);
    assertParameter('remote', remote);
    return await _deleteRemote({
      fs: new FileSystem(fs),
      gitdir,
      remote,
    })
  } catch (err) {
    err.caller = 'git.deleteRemote';
    throw err
  }
}

// @ts-check

/**
 * Delete a local tag ref
 *
 * @param {Object} args
 * @param {import('../models/FileSystem.js').FileSystem} args.fs
 * @param {string} args.gitdir
 * @param {string} args.ref - The tag to delete
 *
 * @returns {Promise<void>} Resolves successfully when filesystem operations are complete
 *
 * @example
 * await git.deleteTag({ dir: '$input((/))', ref: '$input((test-tag))' })
 * console.log('done')
 *
 */
async function _deleteTag({ fs, gitdir, ref }) {
  ref = ref.startsWith('refs/tags/') ? ref : `refs/tags/${ref}`;
  await GitRefManager.deleteRef({ fs, gitdir, ref });
}

// @ts-check

/**
 * Delete a local tag ref
 *
 * @param {Object} args
 * @param {FsClient} args.fs - a file system implementation
 * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path
 * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path
 * @param {string} args.ref - The tag to delete
 *
 * @returns {Promise<void>} Resolves successfully when filesystem operations are complete
 *
 * @example
 * await git.deleteTag({ fs, dir: '/tutorial', ref: 'test-tag' })
 * console.log('done')
 *
 */
async function deleteTag({ fs, dir, gitdir = join(dir, '.git'), ref }) {
  try {
    assertParameter('fs', fs);
    assertParameter('ref', ref);
    return await _deleteTag({
      fs: new FileSystem(fs),
      gitdir,
      ref,
    })
  } catch (err) {
    err.caller = 'git.deleteTag';
    throw err
  }
}

async function expandOidLoose({ fs, gitdir, oid: short }) {
  const prefix = short.slice(0, 2);
  const objectsSuffixes = await fs.readdir(`${gitdir}/objects/${prefix}`);
  return objectsSuffixes
    .map(suffix => `${prefix}${suffix}`)
    .filter(_oid => _oid.startsWith(short))
}

async function expandOidPacked({
  fs,
  cache,
  gitdir,
  oid: short,
  getExternalRefDelta,
}) {
  // Iterate through all the .pack files
  const results = [];
  let list = await fs.readdir(join(gitdir, 'objects/pack'));
  list = list.filter(x => x.endsWith('.idx'));
  for (const filename of list) {
    const indexFile = `${gitdir}/objects/pack/${filename}`;
    const p = await readPackIndex({
      fs,
      cache,
      filename: indexFile,
      getExternalRefDelta,
    });
    if (p.error) throw new InternalError(p.error)
    // Search through the list of oids in the packfile
    for (const oid of p.offsets.keys()) {
      if (oid.startsWith(short)) results.push(oid);
    }
  }
  return results
}

async function _expandOid({ fs, cache, gitdir, oid: short }) {
  // Curry the current read method so that the packfile un-deltification
  // process can acquire external ref-deltas.
  const getExternalRefDelta = oid => _readObject({ fs, cache, gitdir, oid });

  const results1 = await expandOidLoose({ fs, gitdir, oid: short });
  const results2 = await expandOidPacked({
    fs,
    cache,
    gitdir,
    oid: short,
    getExternalRefDelta,
  });
  const results = results1.concat(results2);

  if (results.length === 1) {
    return results[0]
  }
  if (results.length > 1) {
    throw new AmbiguousError('oids', short, results)
  }
  throw new NotFoundError(`an object matching "${short}"`)
}

// @ts-check

/**
 * Expand and resolve a short oid into a full oid
 *
 * @param {Object} args
 * @param {FsClient} args.fs - a file system implementation
 * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path
 * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path
 * @param {string} args.oid - The shortened oid prefix to expand (like "0414d2a")
 * @param {object} [args.cache] - a [cache](cache.md) object
 *
 * @returns {Promise<string>} Resolves successfully with the full oid (like "0414d2a286d7bbc7a4a326a61c1f9f888a8ab87f")
 *
 * @example
 * let oid = await git.expandOid({ fs, dir: '/tutorial', oid: '0414d2a'})
 * console.log(oid)
 *
 */
async function expandOid({
  fs,
  dir,
  gitdir = join(dir, '.git'),
  oid,
  cache = {},
}) {
  try {
    assertParameter('fs', fs);
    assertParameter('gitdir', gitdir);
    assertParameter('oid', oid);
    return await _expandOid({
      fs: new FileSystem(fs),
      cache,
      gitdir,
      oid,
    })
  } catch (err) {
    err.caller = 'git.expandOid';
    throw err
  }
}

// @ts-check

/**
 * Expand an abbreviated ref to its full name
 *
 * @param {Object} args
 * @param {FsClient} args.fs - a file system implementation
 * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path
 * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path
 * @param {string} args.ref - The ref to expand (like "v1.0.0")
 *
 * @returns {Promise<string>} Resolves successfully with a full ref name ("refs/tags/v1.0.0")
 *
 * @example
 * let fullRef = await git.expandRef({ fs, dir: '/tutorial', ref: 'main'})
 * console.log(fullRef)
 *
 */
async function expandRef({ fs, dir, gitdir = join(dir, '.git'), ref }) {
  try {
    assertParameter('fs', fs);
    assertParameter('gitdir', gitdir);
    assertParameter('ref', ref);
    return await GitRefManager.expand({
      fs: new FileSystem(fs),
      gitdir,
      ref,
    })
  } catch (err) {
    err.caller = 'git.expandRef';
    throw err
  }
}

// @ts-check

/**
 * @param {object} args
 * @param {import('../models/FileSystem.js').FileSystem} args.fs
 * @param {any} args.cache
 * @param {string} args.gitdir
 * @param {string[]} args.oids
 *
 */
async function _findMergeBase({ fs, cache, gitdir, oids }) {
  // Note: right now, the tests are geared so that the output should match that of
  // `git merge-base --all --octopus`
  // because without the --octopus flag, git's output seems to depend on the ORDER of the oids,
  // and computing virtual merge bases is just too much for me to fathom right now.

  // If we start N independent walkers, one at each of the given `oids`, and walk backwards
  // through ancestors, eventually we'll discover a commit where each one of these N walkers
  // has passed through. So we just need to keep track of which walkers have visited each commit
  // until we find a commit that N distinct walkers has visited.
  const visits = {};
  const passes = oids.length;
  let heads = oids.map((oid, index) => ({ index, oid }));
  while (heads.length) {
    // Count how many times we've passed each commit
    const result = new Set();
    for (const { oid, index } of heads) {
      if (!visits[oid]) visits[oid] = new Set();
      visits[oid].add(index);
      if (visits[oid].size === passes) {
        result.add(oid);
      }
    }
    if (result.size > 0) {
      return [...result]
    }
    // We haven't found a common ancestor yet
    const newheads = new Map();
    for (const { oid, index } of heads) {
      try {
        const { object } = await _readObject({ fs, cache, gitdir, oid });
        const commit = GitCommit.from(object);
        const { parent } = commit.parseHeaders();
        for (const oid of parent) {
          if (!visits[oid] || !visits[oid].has(index)) {
            newheads.set(oid + ':' + index, { oid, index });
          }
        }
      } catch (err) {
        // do nothing
      }
    }
    heads = Array.from(newheads.values());
  }
  return []
}

const LINEBREAKS = /^.*(\r?\n|$)/gm;

function mergeFile({
  ourContent,
  baseContent,
  theirContent,
  ourName = 'ours',
  baseName = 'base',
  theirName = 'theirs',
  format = 'diff',
  markerSize = 7,
}) {
  const ours = ourContent.match(LINEBREAKS);
  const base = baseContent.match(LINEBREAKS);
  const theirs = theirContent.match(LINEBREAKS);

  // Here we let the diff3 library do the heavy lifting.
  const result = diff3(ours, base, theirs);

  // Here we note whether there are conflicts and format the results
  let mergedText = '';
  let cleanMerge = true;
  for (const item of result) {
    if (item.ok) {
      mergedText += item.ok.join('');
    }
    if (item.conflict) {
      cleanMerge = false;
      mergedText += `${'<'.repeat(markerSize)} ${ourName}\n`;
      mergedText += item.conflict.a.join('');
      if (format === 'diff3') {
        mergedText += `${'|'.repeat(markerSize)} ${baseName}\n`;
        mergedText += item.conflict.o.join('');
      }
      mergedText += `${'='.repeat(markerSize)}\n`;
      mergedText += item.conflict.b.join('');
      mergedText += `${'>'.repeat(markerSize)} ${theirName}\n`;
    }
  }
  return { cleanMerge, mergedText }
}

// @ts-check

/**
 * Create a merged tree
 *
 * @param {Object} args
 * @param {import('../models/FileSystem.js').FileSystem} args.fs
 * @param {object} args.cache
 * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path
 * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path
 * @param {string} args.ourOid - The SHA-1 object id of our tree
 * @param {string} args.baseOid - The SHA-1 object id of the base tree
 * @param {string} args.theirOid - The SHA-1 object id of their tree
 * @param {string} [args.ourName='ours'] - The name to use in conflicted files for our hunks
 * @param {string} [args.baseName='base'] - The name to use in conflicted files (in diff3 format) for the base hunks
 * @param {string} [args.theirName='theirs'] - The name to use in conflicted files for their hunks
 * @param {boolean} [args.dryRun=false]
 *
 * @returns {Promise<string>} - The SHA-1 object id of the merged tree
 *
 */
async function mergeTree({
  fs,
  cache,
  dir,
  gitdir = join(dir, '.git'),
  ourOid,
  baseOid,
  theirOid,
  ourName = 'ours',
  baseName = 'base',
  theirName = 'theirs',
  dryRun = false,
}) {
  const ourTree = TREE({ ref: ourOid });
  const baseTree = TREE({ ref: baseOid });
  const theirTree = TREE({ ref: theirOid });

  const results = await _walk({
    fs,
    cache,
    dir,
    gitdir,
    trees: [ourTree, baseTree, theirTree],
    map: async function(filepath, [ours, base, theirs]) {
      const path = basename(filepath);
      // What we did, what they did
      const ourChange = await modified(ours, base);
      const theirChange = await modified(theirs, base);
      switch (`${ourChange}-${theirChange}`) {
        case 'false-false': {
          return {
            mode: await base.mode(),
            path,
            oid: await base.oid(),
            type: await base.type(),
          }
        }
        case 'false-true': {
          return theirs
            ? {
                mode: await theirs.mode(),
                path,
                oid: await theirs.oid(),
                type: await theirs.type(),
              }
            : undefined
        }
        case 'true-false': {
          return ours
            ? {
                mode: await ours.mode(),
                path,
                oid: await ours.oid(),
                type: await ours.type(),
              }
            : undefined
        }
        case 'true-true': {
          // Modifications
          if (
            ours &&
            base &&
            theirs &&
            (await ours.type()) === 'blob' &&
            (await base.type()) === 'blob' &&
            (await theirs.type()) === 'blob'
          ) {
            return mergeBlobs({
              fs,
              gitdir,
              path,
              ours,
              base,
              theirs,
              ourName,
              baseName,
              theirName,
            })
          }
          // all other types of conflicts fail
          throw new MergeNotSupportedError()
        }
      }
    },
    /**
     * @param {TreeEntry} [parent]
     * @param {Array<TreeEntry>} children
     */
    reduce: async (parent, children) => {
      const entries = children.filter(Boolean); // remove undefineds

      // if the parent was deleted, the children have to go
      if (!parent) return

      // automatically delete directories if they have been emptied
      if (parent && parent.type === 'tree' && entries.length === 0) return

      if (entries.length > 0) {
        const tree = new GitTree(entries);
        const object = tree.toObject();
        const oid = await _writeObject({
          fs,
          gitdir,
          type: 'tree',
          object,
          dryRun,
        });
        parent.oid = oid;
      }
      return parent
    },
  });
  return results.oid
}

/**
 *
 * @param {WalkerEntry} entry
 * @param {WalkerEntry} base
 *
 */
async function modified(entry, base) {
  if (!entry && !base) return false
  if (entry && !base) return true
  if (!entry && base) return true
  if ((await entry.type()) === 'tree' && (await base.type()) === 'tree') {
    return false
  }
  if (
    (await entry.type()) === (await base.type()) &&
    (await entry.mode()) === (await base.mode()) &&
    (await entry.oid()) === (await base.oid())
  ) {
    return false
  }
  return true
}

/**
 *
 * @param {Object} args
 * @param {import('../models/FileSystem').FileSystem} args.fs
 * @param {string} args.gitdir
 * @param {string} args.path
 * @param {WalkerEntry} args.ours
 * @param {WalkerEntry} args.base
 * @param {WalkerEntry} args.theirs
 * @param {string} [args.ourName]
 * @param {string} [args.baseName]
 * @param {string} [args.theirName]
 * @param {string} [args.format]
 * @param {number} [args.markerSize]
 * @param {boolean} [args.dryRun = false]
 *
 */
async function mergeBlobs({
  fs,
  gitdir,
  path,
  ours,
  base,
  theirs,
  ourName,
  theirName,
  baseName,
  format,
  markerSize,
  dryRun,
}) {
  const type = 'blob';
  // Compute the new mode.
  // Since there are ONLY two valid blob modes ('100755' and '100644') it boils down to this
  const mode =
    (await base.mode()) === (await ours.mode())
      ? await theirs.mode()
      : await ours.mode();
  // The trivial case: nothing to merge except maybe mode
  if ((await ours.oid()) === (await theirs.oid())) {
    return { mode, path, oid: await ours.oid(), type }
  }
  // if only one side made oid changes, return that side's oid
  if ((await ours.oid()) === (await base.oid())) {
    return { mode, path, oid: await theirs.oid(), type }
  }
  if ((await theirs.oid()) === (await base.oid())) {
    return { mode, path, oid: await ours.oid(), type }
  }
  // if both sides made changes do a merge
  const { mergedText, cleanMerge } = mergeFile({
    ourContent: Buffer.from(await ours.content()).toString('utf8'),
    baseContent: Buffer.from(await base.content()).toString('utf8'),
    theirContent: Buffer.from(await theirs.content()).toString('utf8'),
    ourName,
    theirName,
    baseName,
    format,
    markerSize,
  });
  if (!cleanMerge) {
    // all other types of conflicts fail
    throw new MergeNotSupportedError()
  }
  const oid = await _writeObject({
    fs,
    gitdir,
    type: 'blob',
    object: Buffer.from(mergedText, 'utf8'),
    dryRun,
  });
  return { mode, path, oid, type }
}

// @ts-check

// import diff3 from 'node-diff3'
/**
 *
 * @typedef {Object} MergeResult - Returns an object with a schema like this:
 * @property {string} [oid] - The SHA-1 object id that is now at the head of the branch. Absent only if `dryRun` was specified and `mergeCommit` is true.
 * @property {boolean} [alreadyMerged] - True if the branch was already merged so no changes were made
 * @property {boolean} [fastForward] - True if it was a fast-forward merge
 * @property {boolean} [mergeCommit] - True if merge resulted in a merge commit
 * @property {string} [tree] - The SHA-1 object id of the tree resulting from a merge commit
 *
 */

/**
 * @param {object} args
 * @param {import('../models/FileSystem.js').FileSystem} args.fs
 * @param {object} args.cache
 * @param {string} args.gitdir
 * @param {string} [args.ours]
 * @param {string} args.theirs
 * @param {boolean} args.fastForwardOnly
 * @param {boolean} args.dryRun
 * @param {boolean} args.noUpdateBranch
 * @param {string} [args.message]
 * @param {Object} args.author
 * @param {string} args.author.name
 * @param {string} args.author.email
 * @param {number} args.author.timestamp
 * @param {number} args.author.timezoneOffset
 * @param {Object} args.committer
 * @param {string} args.committer.name
 * @param {string} args.committer.email
 * @param {number} args.committer.timestamp
 * @param {number} args.committer.timezoneOffset
 * @param {string} [args.signingKey]
 *
 * @returns {Promise<MergeResult>} Resolves to a description of the merge operation
 *
 */
async function _merge({
  fs,
  cache,
  gitdir,
  ours,
  theirs,
  fastForwardOnly = false,
  dryRun = false,
  noUpdateBranch = false,
  message,
  author,
  committer,
  signingKey,
}) {
  if (ours === undefined) {
    ours = await _currentBranch({ fs, gitdir, fullname: true });
  }
  ours = await GitRefManager.expand({
    fs,
    gitdir,
    ref: ours,
  });
  theirs = await GitRefManager.expand({
    fs,
    gitdir,
    ref: theirs,
  });
  const ourOid = await GitRefManager.resolve({
    fs,
    gitdir,
    ref: ours,
  });
  const theirOid = await GitRefManager.resolve({
    fs,
    gitdir,
    ref: theirs,
  });
  // find most recent common ancestor of ref a and ref b
  const baseOids = await _findMergeBase({
    fs,
    cache,
    gitdir,
    oids: [ourOid, theirOid],
  });
  if (baseOids.length !== 1) {
    throw new MergeNotSupportedError()
  }
  const baseOid = baseOids[0];
  // handle fast-forward case
  if (baseOid === theirOid) {
    return {
      oid: ourOid,
      alreadyMerged: true,
    }
  }
  if (baseOid === ourOid) {
    if (!dryRun && !noUpdateBranch) {
      await GitRefManager.writeRef({ fs, gitdir, ref: ours, value: theirOid });
    }
    return {
      oid: theirOid,
      fastForward: true,
    }
  } else {
    // not a simple fast-forward
    if (fastForwardOnly) {
      throw new FastForwardError()
    }
    // try a fancier merge
    const tree = await mergeTree({
      fs,
      cache,
      gitdir,
      ourOid,
      theirOid,
      baseOid,
      ourName: ours,
      baseName: 'base',
      theirName: theirs,
      dryRun,
    });
    if (!message) {
      message = `Merge branch '${abbreviateRef(theirs)}' into ${abbreviateRef(
        ours
      )}`;
    }
    const oid = await _commit({
      fs,
      cache,
      gitdir,
      message,
      ref: ours,
      tree,
      parent: [ourOid, theirOid],
      author,
      committer,
      signingKey,
      dryRun,
      noUpdateBranch,
    });
    return {
      oid,
      tree,
      mergeCommit: true,
    }
  }
}

// @ts-check

/**
 * @param {object} args
 * @param {import('../models/FileSystem.js').FileSystem} args.fs
 * @param {object} args.cache
 * @param {HttpClient} args.http
 * @param {ProgressCallback} [args.onProgress]
 * @param {MessageCallback} [args.onMessage]
 * @param {AuthCallback} [args.onAuth]
 * @param {AuthFailureCallback} [args.onAuthFailure]
 * @param {AuthSuccessCallback} [args.onAuthSuccess]
 * @param {string} args.dir
 * @param {string} args.gitdir
 * @param {string} args.ref
 * @param {string} [args.url]
 * @param {string} [args.remote]
 * @param {string} [args.remoteRef]
 * @param {string} [args.corsProxy]
 * @param {boolean} args.singleBranch
 * @param {boolean} args.fastForwardOnly
 * @param {Object<string, string>} [args.headers]
 * @param {Object} args.author
 * @param {string} args.author.name
 * @param {string} args.author.email
 * @param {number} args.author.timestamp
 * @param {number} args.author.timezoneOffset
 * @param {Object} args.committer
 * @param {string} args.committer.name
 * @param {string} args.committer.email
 * @param {number} args.committer.timestamp
 * @param {number} args.committer.timezoneOffset
 * @param {string} [args.signingKey]
 *
 * @returns {Promise<void>} Resolves successfully when pull operation completes
 *
 */
async function _pull({
  fs,
  cache,
  http,
  onProgress,
  onMessage,
  onAuth,
  onAuthSuccess,
  onAuthFailure,
  dir,
  gitdir,
  ref,
  url,
  remote,
  remoteRef,
  fastForwardOnly,
  corsProxy,
  singleBranch,
  headers,
  author,
  committer,
  signingKey,
}) {
  try {
    // If ref is undefined, use 'HEAD'
    if (!ref) {
      const head = await _currentBranch({ fs, gitdir });
      // TODO: use a better error.
      if (!head) {
        throw new MissingParameterError('ref')
      }
      ref = head;
    }

    const { fetchHead, fetchHeadDescription } = await _fetch({
      fs,
      cache,
      http,
      onProgress,
      onMessage,
      onAuth,
      onAuthSuccess,
      onAuthFailure,
      gitdir,
      corsProxy,
      ref,
      url,
      remote,
      remoteRef,
      singleBranch,
      headers,
    });
    // Merge the remote tracking branch into the local one.
    await _merge({
      fs,
      cache,
      gitdir,
      ours: ref,
      theirs: fetchHead,
      fastForwardOnly,
      message: `Merge ${fetchHeadDescription}`,
      author,
      committer,
      signingKey,
      dryRun: false,
      noUpdateBranch: false,
    });
    await _checkout({
      fs,
      cache,
      onProgress,
      dir,
      gitdir,
      ref,
      remote,
      noCheckout: false,
    });
  } catch (err) {
    err.caller = 'git.pull';
    throw err
  }
}

// @ts-check

/**
 * Like `pull`, but hard-coded with `fastForward: true` so there is no need for an `author` parameter.
 *
 * @param {object} args
 * @param {FsClient} args.fs - a file system client
 * @param {HttpClient} args.http - an HTTP client
 * @param {ProgressCallback} [args.onProgress] - optional progress event callback
 * @param {MessageCallback} [args.onMessage] - optional message event callback
 * @param {AuthCallback} [args.onAuth] - optional auth fill callback
 * @param {AuthFailureCallback} [args.onAuthFailure] - optional auth rejected callback
 * @param {AuthSuccessCallback} [args.onAuthSuccess] - optional auth approved callback
 * @param {string} args.dir] - The [working tree](dir-vs-gitdir.md) directory path
 * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path
 * @param {string} [args.ref] - Which branch to merge into. By default this is the currently checked out branch.
 * @param {string} [args.url] - (Added in 1.1.0) The URL of the remote repository. The default is the value set in the git config for that remote.
 * @param {string} [args.remote] - (Added in 1.1.0) If URL is not specified, determines which remote to use.
 * @param {string} [args.remoteRef] - (Added in 1.1.0) The name of the branch on the remote to fetch. By default this is the configured remote tracking branch.
 * @param {string} [args.corsProxy] - Optional [CORS proxy](https://www.npmjs.com/%40isomorphic-git/cors-proxy). Overrides value in repo config.
 * @param {boolean} [args.singleBranch = false] - Instead of the default behavior of fetching all the branches, only fetch a single branch.
 * @param {Object<string, string>} [args.headers] - Additional headers to include in HTTP requests, similar to git's `extraHeader` config
 * @param {object} [args.cache] - a [cache](cache.md) object
 *
 * @returns {Promise<void>} Resolves successfully when pull operation completes
 *
 * @example
 * await git.fastForward({
 *   fs,
 *   http,
 *   dir: '/tutorial',
 *   ref: 'main',
 *   singleBranch: true
 * })
 * console.log('done')
 *
 */
async function fastForward({
  fs,
  http,
  onProgress,
  onMessage,
  onAuth,
  onAuthSuccess,
  onAuthFailure,
  dir,
  gitdir = join(dir, '.git'),
  ref,
  url,
  remote,
  remoteRef,
  corsProxy,
  singleBranch,
  headers = {},
  cache = {},
}) {
  try {
    assertParameter('fs', fs);
    assertParameter('http', http);
    assertParameter('gitdir', gitdir);

    const thisWillNotBeUsed = {
      name: '',
      email: '',
      timestamp: Date.now(),
      timezoneOffset: 0,
    };

    return await _pull({
      fs: new FileSystem(fs),
      cache,
      http,
      onProgress,
      onMessage,
      onAuth,
      onAuthSuccess,
      onAuthFailure,
      dir,
      gitdir,
      ref,
      url,
      remote,
      remoteRef,
      fastForwardOnly: true,
      corsProxy,
      singleBranch,
      headers,
      author: thisWillNotBeUsed,
      committer: thisWillNotBeUsed,
    })
  } catch (err) {
    err.caller = 'git.fastForward';
    throw err
  }
}

// @ts-check

/**
 *
 * @typedef {object} FetchResult - The object returned has the following schema:
 * @property {string | null} defaultBranch - The branch that is cloned if no branch is specified
 * @property {string | null} fetchHead - The SHA-1 object id of the fetched head commit
 * @property {string | null} fetchHeadDescription - a textual description of the branch that was fetched
 * @property {Object<string, string>} [headers] - The HTTP response headers returned by the git server
 * @property {string[]} [pruned] - A list of branches that were pruned, if you provided the `prune` parameter
 *
 */

/**
 * Fetch commits from a remote repository
 *
 * @param {object} args
 * @param {FsClient} args.fs - a file system client
 * @param {HttpClient} args.http - an HTTP client
 * @param {ProgressCallback} [args.onProgress] - optional progress event callback
 * @param {MessageCallback} [args.onMessage] - optional message event callback
 * @param {AuthCallback} [args.onAuth] - optional auth fill callback
 * @param {AuthFailureCallback} [args.onAuthFailure] - optional auth rejected callback
 * @param {AuthSuccessCallback} [args.onAuthSuccess] - optional auth approved callback
 * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path
 * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path
 * @param {string} [args.url] - The URL of the remote repository. The default is the value set in the git config for that remote.
 * @param {string} [args.remote] - If URL is not specified, determines which remote to use.
 * @param {boolean} [args.singleBranch = false] - Instead of the default behavior of fetching all the branches, only fetch a single branch.
 * @param {string} [args.ref] - Which branch to fetch if `singleBranch` is true. By default this is the current branch or the remote's default branch.
 * @param {string} [args.remoteRef] - The name of the branch on the remote to fetch if `singleBranch` is true. By default this is the configured remote tracking branch.
 * @param {boolean} [args.tags = false] - Also fetch tags
 * @param {number} [args.depth] - Integer. Determines how much of the git repository's history to retrieve
 * @param {boolean} [args.relative = false] - Changes the meaning of `depth` to be measured from the current shallow depth rather than from the branch tip.
 * @param {Date} [args.since] - Only fetch commits created after the given date. Mutually exclusive with `depth`.
 * @param {string[]} [args.exclude = []] - A list of branches or tags. Instructs the remote server not to send us any commits reachable from these refs.
 * @param {boolean} [args.prune] - Delete local remote-tracking branches that are not present on the remote
 * @param {boolean} [args.pruneTags] - Prune local tags that dont exist on the remote, and force-update those tags that differ
 * @param {string} [args.corsProxy] - Optional [CORS proxy](https://www.npmjs.com/%40isomorphic-git/cors-proxy). Overrides value in repo config.
 * @param {Object<string, string>} [args.headers] - Additional headers to include in HTTP requests, similar to git's `extraHeader` config
 * @param {object} [args.cache] - a [cache](cache.md) object
 *
 * @returns {Promise<FetchResult>} Resolves successfully when fetch completes
 * @see FetchResult
 *
 * @example
 * let result = await git.fetch({
 *   fs,
 *   http,
 *   dir: '/tutorial',
 *   corsProxy: 'https://cors.isomorphic-git.org',
 *   url: 'https://github.com/isomorphic-git/isomorphic-git',
 *   ref: 'main',
 *   depth: 1,
 *   singleBranch: true,
 *   tags: false
 * })
 * console.log(result)
 *
 */
async function fetch({
  fs,
  http,
  onProgress,
  onMessage,
  onAuth,
  onAuthSuccess,
  onAuthFailure,
  dir,
  gitdir = join(dir, '.git'),
  ref,
  remote,
  remoteRef,
  url,
  corsProxy,
  depth = null,
  since = null,
  exclude = [],
  relative = false,
  tags = false,
  singleBranch = false,
  headers = {},
  prune = false,
  pruneTags = false,
  cache = {},
}) {
  try {
    assertParameter('fs', fs);
    assertParameter('http', http);
    assertParameter('gitdir', gitdir);

    return await _fetch({
      fs: new FileSystem(fs),
      cache,
      http,
      onProgress,
      onMessage,
      onAuth,
      onAuthSuccess,
      onAuthFailure,
      gitdir,
      ref,
      remote,
      remoteRef,
      url,
      corsProxy,
      depth,
      since,
      exclude,
      relative,
      tags,
      singleBranch,
      headers,
      prune,
      pruneTags,
    })
  } catch (err) {
    err.caller = 'git.fetch';
    throw err
  }
}

// @ts-check

/**
 * Find the merge base for a set of commits
 *
 * @param {object} args
 * @param {FsClient} args.fs - a file system client
 * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path
 * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path
 * @param {string[]} args.oids - Which commits
 * @param {object} [args.cache] - a [cache](cache.md) object
 *
 */
async function findMergeBase({
  fs,
  dir,
  gitdir = join(dir, '.git'),
  oids,
  cache = {},
}) {
  try {
    assertParameter('fs', fs);
    assertParameter('gitdir', gitdir);
    assertParameter('oids', oids);

    return await _findMergeBase({
      fs: new FileSystem(fs),
      cache,
      gitdir,
      oids,
    })
  } catch (err) {
    err.caller = 'git.findMergeBase';
    throw err
  }
}

// @ts-check

/**
 * Find the root git directory
 *
 * Starting at `filepath`, walks upward until it finds a directory that contains a subdirectory called '.git'.
 *
 * @param {Object} args
 * @param {import('../models/FileSystem.js').FileSystem} args.fs
 * @param {string} args.filepath
 *
 * @returns {Promise<string>} Resolves successfully with a root git directory path
 */
async function _findRoot({ fs, filepath }) {
  if (await fs.exists(join(filepath, '.git'))) {
    return filepath
  } else {
    const parent = dirname(filepath);
    if (parent === filepath) {
      throw new NotFoundError(`git root for ${filepath}`)
    }
    return _findRoot({ fs, filepath: parent })
  }
}

// @ts-check

/**
 * Find the root git directory
 *
 * Starting at `filepath`, walks upward until it finds a directory that contains a subdirectory called '.git'.
 *
 * @param {Object} args
 * @param {FsClient} args.fs - a file system client
 * @param {string} args.filepath - The file directory to start searching in.
 *
 * @returns {Promise<string>} Resolves successfully with a root git directory path
 * @throws {NotFoundError}
 *
 * @example
 * let gitroot = await git.findRoot({
 *   fs,
 *   filepath: '/tutorial/src/utils'
 * })
 * console.log(gitroot)
 *
 */
async function findRoot({ fs, filepath }) {
  try {
    assertParameter('fs', fs);
    assertParameter('filepath', filepath);

    return await _findRoot({ fs: new FileSystem(fs), filepath })
  } catch (err) {
    err.caller = 'git.findRoot';
    throw err
  }
}

// @ts-check

/**
 * Read an entry from the git config files.
 *
 * *Caveats:*
 * - Currently only the local `$GIT_DIR/config` file can be read or written. However support for the global `~/.gitconfig` and system `$(prefix)/etc/gitconfig` will be added in the future.
 * - The current parser does not support the more exotic features of the git-config file format such as `[include]` and `[includeIf]`.
 *
 * @param {Object} args
 * @param {FsClient} args.fs - a file system implementation
 * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path
 * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path
 * @param {string} args.path - The key of the git config entry
 *
 * @returns {Promise<any>} Resolves with the config value
 *
 * @example
 * // Read config value
 * let value = await git.getConfig({
 *   fs,
 *   dir: '/tutorial',
 *   path: 'remote.origin.url'
 * })
 * console.log(value)
 *
 */
async function getConfig({ fs, dir, gitdir = join(dir, '.git'), path }) {
  try {
    assertParameter('fs', fs);
    assertParameter('gitdir', gitdir);
    assertParameter('path', path);

    return await _getConfig({
      fs: new FileSystem(fs),
      gitdir,
      path,
    })
  } catch (err) {
    err.caller = 'git.getConfig';
    throw err
  }
}

// @ts-check

/**
 * @param {Object} args
 * @param {import('../models/FileSystem.js').FileSystem} args.fs
 * @param {string} args.gitdir
 * @param {string} args.path
 *
 * @returns {Promise<Array<any>>} Resolves with an array of the config value
 *
 */
async function _getConfigAll({ fs, gitdir, path }) {
  const config = await GitConfigManager.get({ fs, gitdir });
  return config.getall(path)
}

// @ts-check

/**
 * Read a multi-valued entry from the git config files.
 *
 * *Caveats:*
 * - Currently only the local `$GIT_DIR/config` file can be read or written. However support for the global `~/.gitconfig` and system `$(prefix)/etc/gitconfig` will be added in the future.
 * - The current parser does not support the more exotic features of the git-config file format such as `[include]` and `[includeIf]`.
 *
 * @param {Object} args
 * @param {FsClient} args.fs - a file system implementation
 * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path
 * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path
 * @param {string} args.path - The key of the git config entry
 *
 * @returns {Promise<Array<any>>} Resolves with the config value
 *
 */
async function getConfigAll({
  fs,
  dir,
  gitdir = join(dir, '.git'),
  path,
}) {
  try {
    assertParameter('fs', fs);
    assertParameter('gitdir', gitdir);
    assertParameter('path', path);

    return await _getConfigAll({
      fs: new FileSystem(fs),
      gitdir,
      path,
    })
  } catch (err) {
    err.caller = 'git.getConfigAll';
    throw err
  }
}

// @ts-check

/**
 *
 * @typedef {Object} GetRemoteInfoResult - The object returned has the following schema:
 * @property {string[]} capabilities - The list of capabilities returned by the server (part of the Git protocol)
 * @property {Object} [refs]
 * @property {Object<string, string>} [refs.heads] - The branches on the remote
 * @property {Object<string, string>} [refs.pull] - The special branches representing pull requests (non-standard)
 * @property {Object<string, string>} [refs.tags] - The tags on the remote
 *
 */

/**
 * List a remote servers branches, tags, and capabilities.
 *
 * This is a rare command that doesn't require an `fs`, `dir`, or even `gitdir` argument.
 * It just communicates to a remote git server, using the first step of the `git-upload-pack` handshake, but stopping short of fetching the packfile.
 *
 * @param {object} args
 * @param {HttpClient} args.http - an HTTP client
 * @param {AuthCallback} [args.onAuth] - optional auth fill callback
 * @param {AuthFailureCallback} [args.onAuthFailure] - optional auth rejected callback
 * @param {AuthSuccessCallback} [args.onAuthSuccess] - optional auth approved callback
 * @param {string} args.url - The URL of the remote repository. Will be gotten from gitconfig if absent.
 * @param {string} [args.corsProxy] - Optional [CORS proxy](https://www.npmjs.com/%40isomorphic-git/cors-proxy). Overrides value in repo config.
 * @param {boolean} [args.forPush = false] - By default, the command queries the 'fetch' capabilities. If true, it will ask for the 'push' capabilities.
 * @param {Object<string, string>} [args.headers] - Additional headers to include in HTTP requests, similar to git's `extraHeader` config
 *
 * @returns {Promise<GetRemoteInfoResult>} Resolves successfully with an object listing the branches, tags, and capabilities of the remote.
 * @see GetRemoteInfoResult
 *
 * @example
 * let info = await git.getRemoteInfo({
 *   http,
 *   url:
 *     "https://cors.isomorphic-git.org/github.com/isomorphic-git/isomorphic-git.git"
 * });
 * console.log(info);
 *
 */
async function getRemoteInfo({
  http,
  onAuth,
  onAuthSuccess,
  onAuthFailure,
  corsProxy,
  url,
  headers = {},
  forPush = false,
}) {
  try {
    assertParameter('http', http);
    assertParameter('url', url);

    const GitRemoteHTTP = GitRemoteManager.getRemoteHelperFor({ url });
    const remote = await GitRemoteHTTP.discover({
      http,
      onAuth,
      onAuthSuccess,
      onAuthFailure,
      corsProxy,
      service: forPush ? 'git-receive-pack' : 'git-upload-pack',
      url,
      headers,
      protocolVersion: 1,
    });

    // Note: remote.capabilities, remote.refs, and remote.symrefs are Set and Map objects,
    // but one of the objectives of the public API is to always return JSON-compatible objects
    // so we must JSONify them.
    const result = {
      capabilities: [...remote.capabilities],
    };
    // Convert the flat list into an object tree, because I figure 99% of the time
    // that will be easier to use.
    for (const [ref, oid] of remote.refs) {
      const parts = ref.split('/');
      const last = parts.pop();
      let o = result;
      for (const part of parts) {
        o[part] = o[part] || {};
        o = o[part];
      }
      o[last] = oid;
    }
    // Merge symrefs on top of refs to more closely match actual git repo layouts
    for (const [symref, ref] of remote.symrefs) {
      const parts = symref.split('/');
      const last = parts.pop();
      let o = result;
      for (const part of parts) {
        o[part] = o[part] || {};
        o = o[part];
      }
      o[last] = ref;
    }
    return result
  } catch (err) {
    err.caller = 'git.getRemoteInfo';
    throw err
  }
}

// @ts-check

/**
 * @param {any} remote
 * @param {string} prefix
 * @param {boolean} symrefs
 * @param {boolean} peelTags
 * @returns {ServerRef[]}
 */
function formatInfoRefs(remote, prefix, symrefs, peelTags) {
  const refs = [];
  for (const [key, value] of remote.refs) {
    if (prefix && !key.startsWith(prefix)) continue

    if (key.endsWith('^{}')) {
      if (peelTags) {
        const _key = key.replace('^{}', '');
        // Peeled tags are almost always listed immediately after the original tag
        const last = refs[refs.length - 1];
        const r = last.ref === _key ? last : refs.find(x => x.ref === _key);
        if (r === undefined) {
          throw new Error('I did not expect this to happen')
        }
        r.peeled = value;
      }
      continue
    }
    /** @type ServerRef */
    const ref = { ref: key, oid: value };
    if (symrefs) {
      if (remote.symrefs.has(key)) {
        ref.target = remote.symrefs.get(key);
      }
    }
    refs.push(ref);
  }
  return refs
}

// @ts-check

/**
 * @typedef {Object} GetRemoteInfo2Result - This object has the following schema:
 * @property {1 | 2} protocolVersion - Git protocol version the server supports
 * @property {Object<string, string | true>} capabilities - An object of capabilities represented as keys and values
 * @property {ServerRef[]} [refs] - Server refs (they get returned by protocol version 1 whether you want them or not)
 */

/**
 * List a remote server's capabilities.
 *
 * This is a rare command that doesn't require an `fs`, `dir`, or even `gitdir` argument.
 * It just communicates to a remote git server, determining what protocol version, commands, and features it supports.
 *
 * > The successor to [`getRemoteInfo`](./getRemoteInfo.md), this command supports Git Wire Protocol Version 2.
 * > Therefore its return type is more complicated as either:
 * >
 * > - v1 capabilities (and refs) or
 * > - v2 capabilities (and no refs)
 * >
 * > are returned.
 * > If you just care about refs, use [`listServerRefs`](./listServerRefs.md)
 *
 * @param {object} args
 * @param {HttpClient} args.http - an HTTP client
 * @param {AuthCallback} [args.onAuth] - optional auth fill callback
 * @param {AuthFailureCallback} [args.onAuthFailure] - optional auth rejected callback
 * @param {AuthSuccessCallback} [args.onAuthSuccess] - optional auth approved callback
 * @param {string} args.url - The URL of the remote repository. Will be gotten from gitconfig if absent.
 * @param {string} [args.corsProxy] - Optional [CORS proxy](https://www.npmjs.com/%40isomorphic-git/cors-proxy). Overrides value in repo config.
 * @param {boolean} [args.forPush = false] - By default, the command queries the 'fetch' capabilities. If true, it will ask for the 'push' capabilities.
 * @param {Object<string, string>} [args.headers] - Additional headers to include in HTTP requests, similar to git's `extraHeader` config
 * @param {1 | 2} [args.protocolVersion = 2] - Which version of the Git Protocol to use.
 *
 * @returns {Promise<GetRemoteInfo2Result>} Resolves successfully with an object listing the capabilities of the remote.
 * @see GetRemoteInfo2Result
 * @see ServerRef
 *
 * @example
 * let info = await git.getRemoteInfo2({
 *   http,
 *   corsProxy: "https://cors.isomorphic-git.org",
 *   url: "https://github.com/isomorphic-git/isomorphic-git.git"
 * });
 * console.log(info);
 *
 */
async function getRemoteInfo2({
  http,
  onAuth,
  onAuthSuccess,
  onAuthFailure,
  corsProxy,
  url,
  headers = {},
  forPush = false,
  protocolVersion = 2,
}) {
  try {
    assertParameter('http', http);
    assertParameter('url', url);

    const GitRemoteHTTP = GitRemoteManager.getRemoteHelperFor({ url });
    const remote = await GitRemoteHTTP.discover({
      http,
      onAuth,
      onAuthSuccess,
      onAuthFailure,
      corsProxy,
      service: forPush ? 'git-receive-pack' : 'git-upload-pack',
      url,
      headers,
      protocolVersion,
    });

    if (remote.protocolVersion === 2) {
      /** @type GetRemoteInfo2Result */
      return {
        protocolVersion: remote.protocolVersion,
        capabilities: remote.capabilities2,
      }
    }

    // Note: remote.capabilities, remote.refs, and remote.symrefs are Set and Map objects,
    // but one of the objectives of the public API is to always return JSON-compatible objects
    // so we must JSONify them.
    /** @type Object<string, true> */
    const capabilities = {};
    for (const cap of remote.capabilities) {
      const [key, value] = cap.split('=');
      if (value) {
        capabilities[key] = value;
      } else {
        capabilities[key] = true;
      }
    }
    /** @type GetRemoteInfo2Result */
    return {
      protocolVersion: 1,
      capabilities,
      refs: formatInfoRefs(remote, undefined, true, true),
    }
  } catch (err) {
    err.caller = 'git.getRemoteInfo2';
    throw err
  }
}

async function hashObject({
  type,
  object,
  format = 'content',
  oid = undefined,
}) {
  if (format !== 'deflated') {
    if (format !== 'wrapped') {
      object = GitObject.wrap({ type, object });
    }
    oid = await shasum(object);
  }
  return { oid, object }
}

// @ts-check

/**
 *
 * @typedef {object} HashBlobResult - The object returned has the following schema:
 * @property {string} oid - The SHA-1 object id
 * @property {'blob'} type - The type of the object
 * @property {Uint8Array} object - The wrapped git object (the thing that is hashed)
 * @property {'wrapped'} format - The format of the object
 *
 */

/**
 * Compute what the SHA-1 object id of a file would be
 *
 * @param {object} args
 * @param {Uint8Array|string} args.object - The object to write. If `object` is a String then it will be converted to a Uint8Array using UTF-8 encoding.
 *
 * @returns {Promise<HashBlobResult>} Resolves successfully with the SHA-1 object id and the wrapped object Uint8Array.
 * @see HashBlobResult
 *
 * @example
 * let { oid, type, object, format } = await git.hashBlob({
 *   object: 'Hello world!',
 * })
 *
 * console.log('oid', oid)
 * console.log('type', type)
 * console.log('object', object)
 * console.log('format', format)
 *
 */
async function hashBlob({ object }) {
  try {
    assertParameter('object', object);

    // Convert object to buffer
    if (typeof object === 'string') {
      object = Buffer.from(object, 'utf8');
    } else {
      object = Buffer.from(object);
    }

    const type = 'blob';
    const { oid, object: _object } = await hashObject({
      type: 'blob',
      format: 'content',
      object,
    });
    return { oid, type, object: new Uint8Array(_object), format: 'wrapped' }
  } catch (err) {
    err.caller = 'git.hashBlob';
    throw err
  }
}

// @ts-check

/**
 * @param {object} args
 * @param {import('../models/FileSystem.js').FileSystem} args.fs
 * @param {any} args.cache
 * @param {ProgressCallback} [args.onProgress]
 * @param {string} args.dir
 * @param {string} args.gitdir
 * @param {string} args.filepath
 *
 * @returns {Promise<{oids: string[]}>}
 */
async function _indexPack({
  fs,
  cache,
  onProgress,
  dir,
  gitdir,
  filepath,
}) {
  try {
    filepath = join(dir, filepath);
    const pack = await fs.read(filepath);
    const getExternalRefDelta = oid => _readObject({ fs, cache, gitdir, oid });
    const idx = await GitPackIndex.fromPack({
      pack,
      getExternalRefDelta,
      onProgress,
    });
    await fs.write(filepath.replace(/\.pack$/, '.idx'), await idx.toBuffer());
    return {
      oids: [...idx.hashes],
    }
  } catch (err) {
    err.caller = 'git.indexPack';
    throw err
  }
}

// @ts-check

/**
 * Create the .idx file for a given .pack file
 *
 * @param {object} args
 * @param {FsClient} args.fs - a file system client
 * @param {ProgressCallback} [args.onProgress] - optional progress event callback
 * @param {string} args.dir - The [working tree](dir-vs-gitdir.md) directory path
 * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path
 * @param {string} args.filepath - The path to the .pack file to index
 * @param {object} [args.cache] - a [cache](cache.md) object
 *
 * @returns {Promise<{oids: string[]}>} Resolves with a list of the SHA-1 object ids contained in the packfile
 *
 * @example
 * let packfiles = await fs.promises.readdir('/tutorial/.git/objects/pack')
 * packfiles = packfiles.filter(name => name.endsWith('.pack'))
 * console.log('packfiles', packfiles)
 *
 * const { oids } = await git.indexPack({
 *   fs,
 *   dir: '/tutorial',
 *   filepath: `.git/objects/pack/${packfiles[0]}`,
 *   async onProgress (evt) {
 *     console.log(`${evt.phase}: ${evt.loaded} / ${evt.total}`)
 *   }
 * })
 * console.log(oids)
 *
 */
async function indexPack({
  fs,
  onProgress,
  dir,
  gitdir = join(dir, '.git'),
  filepath,
  cache = {},
}) {
  try {
    assertParameter('fs', fs);
    assertParameter('dir', dir);
    assertParameter('gitdir', dir);
    assertParameter('filepath', filepath);

    return await _indexPack({
      fs: new FileSystem(fs),
      cache,
      onProgress,
      dir,
      gitdir,
      filepath,
    })
  } catch (err) {
    err.caller = 'git.indexPack';
    throw err
  }
}

// @ts-check

/**
 * Initialize a new repository
 *
 * @param {object} args
 * @param {FsClient} args.fs - a file system client
 * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path
 * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path
 * @param {boolean} [args.bare = false] - Initialize a bare repository
 * @param {string} [args.defaultBranch = 'master'] - The name of the default branch (might be changed to a required argument in 2.0.0)
 * @returns {Promise<void>}  Resolves successfully when filesystem operations are complete
 *
 * @example
 * await git.init({ fs, dir: '/tutorial' })
 * console.log('done')
 *
 */
async function init({
  fs,
  bare = false,
  dir,
  gitdir = bare ? dir : join(dir, '.git'),
  defaultBranch = 'master',
}) {
  try {
    assertParameter('fs', fs);
    assertParameter('gitdir', gitdir);
    if (!bare) {
      assertParameter('dir', dir);
    }

    return await _init({
      fs: new FileSystem(fs),
      bare,
      dir,
      gitdir,
      defaultBranch,
    })
  } catch (err) {
    err.caller = 'git.init';
    throw err
  }
}

// @ts-check

/**
 * @param {object} args
 * @param {import('../models/FileSystem.js').FileSystem} args.fs
 * @param {any} args.cache
 * @param {string} args.gitdir
 * @param {string} args.oid
 * @param {string} args.ancestor
 * @param {number} args.depth - Maximum depth to search before giving up. -1 means no maximum depth.
 *
 * @returns {Promise<boolean>}
 */
async function _isDescendent({
  fs,
  cache,
  gitdir,
  oid,
  ancestor,
  depth,
}) {
  const shallows = await GitShallowManager.read({ fs, gitdir });
  if (!oid) {
    throw new MissingParameterError('oid')
  }
  if (!ancestor) {
    throw new MissingParameterError('ancestor')
  }
  // If you don't like this behavior, add your own check.
  // Edge cases are hard to define a perfect solution.
  if (oid === ancestor) return false
  // We do not use recursion here, because that would lead to depth-first traversal,
  // and we want to maintain a breadth-first traversal to avoid hitting shallow clone depth cutoffs.
  const queue = [oid];
  const visited = new Set();
  let searchdepth = 0;
  while (queue.length) {
    if (searchdepth++ === depth) {
      throw new MaxDepthError(depth)
    }
    const oid = queue.shift();
    const { type, object } = await _readObject({
      fs,
      cache,
      gitdir,
      oid,
    });
    if (type !== 'commit') {
      throw new ObjectTypeError(oid, type, 'commit')
    }
    const commit = GitCommit.from(object).parse();
    // Are any of the parents the sought-after ancestor?
    for (const parent of commit.parent) {
      if (parent === ancestor) return true
    }
    // If not, add them to heads (unless we know this is a shallow commit)
    if (!shallows.has(oid)) {
      for (const parent of commit.parent) {
        if (!visited.has(parent)) {
          queue.push(parent);
          visited.add(parent);
        }
      }
    }
    // Eventually, we'll travel entire tree to the roots where all the parents are empty arrays,
    // or hit the shallow depth and throw an error. Excluding the possibility of grafts, or
    // different branches cloned to different depths, you would hit this error at the same time
    // for all parents, so trying to continue is futile.
  }
  return false
}

// @ts-check

/**
 * Check whether a git commit is descended from another
 *
 * @param {object} args
 * @param {FsClient} args.fs - a file system client
 * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path
 * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path
 * @param {string} args.oid - The descendent commit
 * @param {string} args.ancestor - The (proposed) ancestor commit
 * @param {number} [args.depth = -1] - Maximum depth to search before giving up. -1 means no maximum depth.
 * @param {object} [args.cache] - a [cache](cache.md) object
 *
 * @returns {Promise<boolean>} Resolves to true if `oid` is a descendent of `ancestor`
 *
 * @example
 * let oid = await git.resolveRef({ fs, dir: '/tutorial', ref: 'main' })
 * let ancestor = await git.resolveRef({ fs, dir: '/tutorial', ref: 'v0.20.0' })
 * console.log(oid, ancestor)
 * await git.isDescendent({ fs, dir: '/tutorial', oid, ancestor, depth: -1 })
 *
 */
async function isDescendent({
  fs,
  dir,
  gitdir = join(dir, '.git'),
  oid,
  ancestor,
  depth = -1,
  cache = {},
}) {
  try {
    assertParameter('fs', fs);
    assertParameter('gitdir', gitdir);
    assertParameter('oid', oid);
    assertParameter('ancestor', ancestor);

    return await _isDescendent({
      fs: new FileSystem(fs),
      cache,
      gitdir,
      oid,
      ancestor,
      depth,
    })
  } catch (err) {
    err.caller = 'git.isDescendent';
    throw err
  }
}

// @ts-check

/**
 * List branches
 *
 * By default it lists local branches. If a 'remote' is specified, it lists the remote's branches. When listing remote branches, the HEAD branch is not filtered out, so it may be included in the list of results.
 *
 * Note that specifying a remote does not actually contact the server and update the list of branches.
 * If you want an up-to-date list, first do a `fetch` to that remote.
 * (Which branch you fetch doesn't matter - the list of branches available on the remote is updated during the fetch handshake.)
 *
 * @param {object} args
 * @param {FsClient} args.fs - a file system client
 * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path
 * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path
 * @param {string} [args.remote] - Instead of the branches in `refs/heads`, list the branches in `refs/remotes/${remote}`.
 *
 * @returns {Promise<Array<string>>} Resolves successfully with an array of branch names
 *
 * @example
 * let branches = await git.listBranches({ fs, dir: '/tutorial' })
 * console.log(branches)
 * let remoteBranches = await git.listBranches({ fs, dir: '/tutorial', remote: 'origin' })
 * console.log(remoteBranches)
 *
 */
async function listBranches({
  fs,
  dir,
  gitdir = join(dir, '.git'),
  remote,
}) {
  try {
    assertParameter('fs', fs);
    assertParameter('gitdir', gitdir);

    return GitRefManager.listBranches({
      fs: new FileSystem(fs),
      gitdir,
      remote,
    })
  } catch (err) {
    err.caller = 'git.listBranches';
    throw err
  }
}

// @ts-check

/**
 * @param {object} args
 * @param {import('../models/FileSystem.js').FileSystem} args.fs
 * @param {object} args.cache
 * @param {string} args.gitdir
 * @param {string} [args.ref]
 *
 * @returns {Promise<Array<string>>}
 */
async function _listFiles({ fs, gitdir, ref, cache }) {
  if (ref) {
    const oid = await GitRefManager.resolve({ gitdir, fs, ref });
    const filenames = [];
    await accumulateFilesFromOid({
      fs,
      cache,
      gitdir,
      oid,
      filenames,
      prefix: '',
    });
    return filenames
  } else {
    return GitIndexManager.acquire({ fs, gitdir, cache }, async function(
      index
    ) {
      return index.entries.map(x => x.path)
    })
  }
}

async function accumulateFilesFromOid({
  fs,
  cache,
  gitdir,
  oid,
  filenames,
  prefix,
}) {
  const { tree } = await _readTree({ fs, cache, gitdir, oid });
  // TODO: Use `walk` to do this. Should be faster.
  for (const entry of tree) {
    if (entry.type === 'tree') {
      await accumulateFilesFromOid({
        fs,
        cache,
        gitdir,
        oid: entry.oid,
        filenames,
        prefix: join(prefix, entry.path),
      });
    } else {
      filenames.push(join(prefix, entry.path));
    }
  }
}

// @ts-check

/**
 * List all the files in the git index or a commit
 *
 * > Note: This function is efficient for listing the files in the staging area, but listing all the files in a commit requires recursively walking through the git object store.
 * > If you do not require a complete list of every file, better performance can be achieved by using [walk](./walk) and ignoring subdirectories you don't care about.
 *
 * @param {object} args
 * @param {FsClient} args.fs - a file system client
 * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path
 * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path
 * @param {string} [args.ref] - Return a list of all the files in the commit at `ref` instead of the files currently in the git index (aka staging area)
 * @param {object} [args.cache] - a [cache](cache.md) object
 *
 * @returns {Promise<Array<string>>} Resolves successfully with an array of filepaths
 *
 * @example
 * // All the files in the previous commit
 * let files = await git.listFiles({ fs, dir: '/tutorial', ref: 'HEAD' })
 * console.log(files)
 * // All the files in the current staging area
 * files = await git.listFiles({ fs, dir: '/tutorial' })
 * console.log(files)
 *
 */
async function listFiles({
  fs,
  dir,
  gitdir = join(dir, '.git'),
  ref,
  cache = {},
}) {
  try {
    assertParameter('fs', fs);
    assertParameter('gitdir', gitdir);

    return await _listFiles({
      fs: new FileSystem(fs),
      cache,
      gitdir,
      ref,
    })
  } catch (err) {
    err.caller = 'git.listFiles';
    throw err
  }
}

// @ts-check

/**
 * List all the object notes
 *
 * @param {object} args
 * @param {import('../models/FileSystem.js').FileSystem} args.fs
 * @param {any} args.cache
 * @param {string} args.gitdir
 * @param {string} args.ref
 *
 * @returns {Promise<Array<{target: string, note: string}>>}
 */

async function _listNotes({ fs, cache, gitdir, ref }) {
  // Get the current note commit
  let parent;
  try {
    parent = await GitRefManager.resolve({ gitdir, fs, ref });
  } catch (err) {
    if (err instanceof NotFoundError) {
      return []
    }
  }

  // Create the current note tree
  const result = await _readTree({
    fs,
    cache,
    gitdir,
    oid: parent,
  });

  // Format the tree entries
  const notes = result.tree.map(entry => ({
    target: entry.path,
    note: entry.oid,
  }));
  return notes
}

// @ts-check

/**
 * List all the object notes
 *
 * @param {object} args
 * @param {FsClient} args.fs - a file system client
 * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path
 * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path
 * @param {string} [args.ref] - The notes ref to look under
 * @param {object} [args.cache] - a [cache](cache.md) object
 *
 * @returns {Promise<Array<{target: string, note: string}>>} Resolves successfully with an array of entries containing SHA-1 object ids of the note and the object the note targets
 */

async function listNotes({
  fs,
  dir,
  gitdir = join(dir, '.git'),
  ref = 'refs/notes/commits',
  cache = {},
}) {
  try {
    assertParameter('fs', fs);
    assertParameter('gitdir', gitdir);
    assertParameter('ref', ref);

    return await _listNotes({
      fs: new FileSystem(fs),
      cache,
      gitdir,
      ref,
    })
  } catch (err) {
    err.caller = 'git.listNotes';
    throw err
  }
}

// @ts-check

/**
 * @param {object} args
 * @param {import('../models/FileSystem.js').FileSystem} args.fs
 * @param {string} args.gitdir
 *
 * @returns {Promise<Array<{remote: string, url: string}>>}
 */
async function _listRemotes({ fs, gitdir }) {
  const config = await GitConfigManager.get({ fs, gitdir });
  const remoteNames = await config.getSubsections('remote');
  const remotes = Promise.all(
    remoteNames.map(async remote => {
      const url = await config.get(`remote.${remote}.url`);
      return { remote, url }
    })
  );
  return remotes
}

// @ts-check

/**
 * List remotes
 *
 * @param {object} args
 * @param {FsClient} args.fs - a file system client
 * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path
 * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path
 *
 * @returns {Promise<Array<{remote: string, url: string}>>} Resolves successfully with an array of `{remote, url}` objects
 *
 * @example
 * let remotes = await git.listRemotes({ fs, dir: '/tutorial' })
 * console.log(remotes)
 *
 */
async function listRemotes({ fs, dir, gitdir = join(dir, '.git') }) {
  try {
    assertParameter('fs', fs);
    assertParameter('gitdir', gitdir);

    return await _listRemotes({
      fs: new FileSystem(fs),
      gitdir,
    })
  } catch (err) {
    err.caller = 'git.listRemotes';
    throw err
  }
}

/**
 * @typedef {Object} ServerRef - This object has the following schema:
 * @property {string} ref - The name of the ref
 * @property {string} oid - The SHA-1 object id the ref points to
 * @property {string} [target] - The target ref pointed to by a symbolic ref
 * @property {string} [peeled] - If the oid is the SHA-1 object id of an annotated tag, this is the SHA-1 object id that the annotated tag points to
 */

async function parseListRefsResponse(stream) {
  const read = GitPktLine.streamReader(stream);

  // TODO: when we re-write everything to minimize memory usage,
  // we could make this a generator
  const refs = [];

  let line;
  while (true) {
    line = await read();
    if (line === true) break
    if (line === null) continue
    line = line.toString('utf8').replace(/\n$/, '');
    const [oid, ref, ...attrs] = line.split(' ');
    const r = { ref, oid };
    for (const attr of attrs) {
      const [name, value] = attr.split(':');
      if (name === 'symref-target') {
        r.target = value;
      } else if (name === 'peeled') {
        r.peeled = value;
      }
    }
    refs.push(r);
  }

  return refs
}

/**
 * @param {object} args
 * @param {string} [args.prefix] - Only list refs that start with this prefix
 * @param {boolean} [args.symrefs = false] - Include symbolic ref targets
 * @param {boolean} [args.peelTags = false] - Include peeled tags values
 * @returns {Uint8Array[]}
 */
async function writeListRefsRequest({ prefix, symrefs, peelTags }) {
  const packstream = [];
  // command
  packstream.push(GitPktLine.encode('command=ls-refs\n'));
  // capability-list
  packstream.push(GitPktLine.encode(`agent=${pkg.agent}\n`));
  // [command-args]
  if (peelTags || symrefs || prefix) {
    packstream.push(GitPktLine.delim());
  }
  if (peelTags) packstream.push(GitPktLine.encode('peel'));
  if (symrefs) packstream.push(GitPktLine.encode('symrefs'));
  if (prefix) packstream.push(GitPktLine.encode(`ref-prefix ${prefix}`));
  packstream.push(GitPktLine.flush());
  return packstream
}

// @ts-check

/**
 * Fetch a list of refs (branches, tags, etc) from a server.
 *
 * This is a rare command that doesn't require an `fs`, `dir`, or even `gitdir` argument.
 * It just requires an `http` argument.
 *
 * ### About `protocolVersion`
 *
 * There's a rather fun trade-off between Git Protocol Version 1 and Git Protocol Version 2.
 * Version 2 actually requires 2 HTTP requests instead of 1, making it similar to fetch or push in that regard.
 * However, version 2 supports server-side filtering by prefix, whereas that filtering is done client-side in version 1.
 * Which protocol is most efficient therefore depends on the number of refs on the remote, the latency of the server, and speed of the network connection.
 * For an small repos (or fast Internet connections), the requirement to make two trips to the server makes protocol 2 slower.
 * But for large repos (or slow Internet connections), the decreased payload size of the second request makes up for the additional request.
 *
 * Hard numbers vary by situation, but here's some numbers from my machine:
 *
 * Using isomorphic-git in a browser, with a CORS proxy, listing only the branches (refs/heads) of https://github.com/isomorphic-git/isomorphic-git
 * - Protocol Version 1 took ~300ms and transfered 84 KB.
 * - Protocol Version 2 took ~500ms and transfered 4.1 KB.
 *
 * Using isomorphic-git in a browser, with a CORS proxy, listing only the branches (refs/heads) of https://gitlab.com/gitlab-org/gitlab
 * - Protocol Version 1 took ~4900ms and transfered 9.41 MB.
 * - Protocol Version 2 took ~1280ms and transfered 433 KB.
 *
 * Finally, there is a fun quirk regarding the `symrefs` parameter.
 * Protocol Version 1 will generally only return the `HEAD` symref and not others.
 * Historically, this meant that servers don't use symbolic refs except for `HEAD`, which is used to point at the "default branch".
 * However Protocol Version 2 can return *all* the symbolic refs on the server.
 * So if you are running your own git server, you could take advantage of that I guess.
 *
 * #### TL;DR
 * If you are _not_ taking advantage of `prefix` I would recommend `protocolVersion: 1`.
 * Otherwise, I recommend to use the default which is `protocolVersion: 2`.
 *
 * @param {object} args
 * @param {HttpClient} args.http - an HTTP client
 * @param {AuthCallback} [args.onAuth] - optional auth fill callback
 * @param {AuthFailureCallback} [args.onAuthFailure] - optional auth rejected callback
 * @param {AuthSuccessCallback} [args.onAuthSuccess] - optional auth approved callback
 * @param {string} args.url - The URL of the remote repository. Will be gotten from gitconfig if absent.
 * @param {string} [args.corsProxy] - Optional [CORS proxy](https://www.npmjs.com/%40isomorphic-git/cors-proxy). Overrides value in repo config.
 * @param {boolean} [args.forPush = false] - By default, the command queries the 'fetch' capabilities. If true, it will ask for the 'push' capabilities.
 * @param {Object<string, string>} [args.headers] - Additional headers to include in HTTP requests, similar to git's `extraHeader` config
 * @param {1 | 2} [args.protocolVersion = 2] - Which version of the Git Protocol to use.
 * @param {string} [args.prefix] - Only list refs that start with this prefix
 * @param {boolean} [args.symrefs = false] - Include symbolic ref targets
 * @param {boolean} [args.peelTags = false] - Include annotated tag peeled targets
 *
 * @returns {Promise<ServerRef[]>} Resolves successfully with an array of ServerRef objects
 * @see ServerRef
 *
 * @example
 * // List all the branches on a repo
 * let refs = await git.listServerRefs({
 *   http,
 *   corsProxy: "https://cors.isomorphic-git.org",
 *   url: "https://github.com/isomorphic-git/isomorphic-git.git",
 *   prefix: "refs/heads/",
 * });
 * console.log(refs);
 *
 * @example
 * // Get the default branch on a repo
 * let refs = await git.listServerRefs({
 *   http,
 *   corsProxy: "https://cors.isomorphic-git.org",
 *   url: "https://github.com/isomorphic-git/isomorphic-git.git",
 *   prefix: "HEAD",
 *   symrefs: true,
 * });
 * console.log(refs);
 *
 * @example
 * // List all the tags on a repo
 * let refs = await git.listServerRefs({
 *   http,
 *   corsProxy: "https://cors.isomorphic-git.org",
 *   url: "https://github.com/isomorphic-git/isomorphic-git.git",
 *   prefix: "refs/tags/",
 *   peelTags: true,
 * });
 * console.log(refs);
 *
 * @example
 * // List all the pull requests on a repo
 * let refs = await git.listServerRefs({
 *   http,
 *   corsProxy: "https://cors.isomorphic-git.org",
 *   url: "https://github.com/isomorphic-git/isomorphic-git.git",
 *   prefix: "refs/pull/",
 * });
 * console.log(refs);
 *
 */
async function listServerRefs({
  http,
  onAuth,
  onAuthSuccess,
  onAuthFailure,
  corsProxy,
  url,
  headers = {},
  forPush = false,
  protocolVersion = 2,
  prefix,
  symrefs,
  peelTags,
}) {
  try {
    assertParameter('http', http);
    assertParameter('url', url);

    const remote = await GitRemoteHTTP.discover({
      http,
      onAuth,
      onAuthSuccess,
      onAuthFailure,
      corsProxy,
      service: forPush ? 'git-receive-pack' : 'git-upload-pack',
      url,
      headers,
      protocolVersion,
    });

    if (remote.protocolVersion === 1) {
      return formatInfoRefs(remote, prefix, symrefs, peelTags)
    }

    // Protocol Version 2
    const body = await writeListRefsRequest({ prefix, symrefs, peelTags });

    const res = await GitRemoteHTTP.connect({
      http,
      auth: remote.auth,
      headers,
      corsProxy,
      service: forPush ? 'git-receive-pack' : 'git-upload-pack',
      url,
      body,
    });

    return parseListRefsResponse(res.body)
  } catch (err) {
    err.caller = 'git.listServerRefs';
    throw err
  }
}

// @ts-check

/**
 * List tags
 *
 * @param {object} args
 * @param {FsClient} args.fs - a file system client
 * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path
 * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path
 *
 * @returns {Promise<Array<string>>} Resolves successfully with an array of tag names
 *
 * @example
 * let tags = await git.listTags({ fs, dir: '/tutorial' })
 * console.log(tags)
 *
 */
async function listTags({ fs, dir, gitdir = join(dir, '.git') }) {
  try {
    assertParameter('fs', fs);
    assertParameter('gitdir', gitdir);
    return GitRefManager.listTags({ fs: new FileSystem(fs), gitdir })
  } catch (err) {
    err.caller = 'git.listTags';
    throw err
  }
}

async function resolveCommit({ fs, cache, gitdir, oid }) {
  const { type, object } = await _readObject({ fs, cache, gitdir, oid });
  // Resolve annotated tag objects to whatever
  if (type === 'tag') {
    oid = GitAnnotatedTag.from(object).parse().object;
    return resolveCommit({ fs, cache, gitdir, oid })
  }
  if (type !== 'commit') {
    throw new ObjectTypeError(oid, type, 'commit')
  }
  return { commit: GitCommit.from(object), oid }
}

// @ts-check

/**
 * @param {object} args
 * @param {import('../models/FileSystem.js').FileSystem} args.fs
 * @param {any} args.cache
 * @param {string} args.gitdir
 * @param {string} args.oid
 *
 * @returns {Promise<ReadCommitResult>} Resolves successfully with a git commit object
 * @see ReadCommitResult
 * @see CommitObject
 *
 */
async function _readCommit({ fs, cache, gitdir, oid }) {
  const { commit, oid: commitOid } = await resolveCommit({
    fs,
    cache,
    gitdir,
    oid,
  });
  const result = {
    oid: commitOid,
    commit: commit.parse(),
    payload: commit.withoutSignature(),
  };
  // @ts-ignore
  return result
}

function compareAge(a, b) {
  return a.committer.timestamp - b.committer.timestamp
}

// @ts-check

/**
 * Get commit descriptions from the git history
 *
 * @param {object} args
 * @param {import('../models/FileSystem.js').FileSystem} args.fs
 * @param {any} args.cache
 * @param {string} args.gitdir
 * @param {string} args.ref
 * @param {number|void} args.depth
 * @param {Date|void} args.since
 *
 * @returns {Promise<Array<ReadCommitResult>>}
 */
async function _log({ fs, cache, gitdir, ref, depth, since }) {
  const sinceTimestamp =
    typeof since === 'undefined'
      ? undefined
      : Math.floor(since.valueOf() / 1000);
  // TODO: In the future, we may want to have an API where we return a
  // async iterator that emits commits.
  const commits = [];
  const shallowCommits = await GitShallowManager.read({ fs, gitdir });
  const oid = await GitRefManager.resolve({ fs, gitdir, ref });
  const tips = [await _readCommit({ fs, cache, gitdir, oid })];

  while (true) {
    const commit = tips.pop();

    // Stop the log if we've hit the age limit
    if (
      sinceTimestamp !== undefined &&
      commit.commit.committer.timestamp <= sinceTimestamp
    ) {
      break
    }

    commits.push(commit);

    // Stop the loop if we have enough commits now.
    if (depth !== undefined && commits.length === depth) break

    // If this is not a shallow commit...
    if (!shallowCommits.has(commit.oid)) {
      // Add the parents of this commit to the queue
      // Note: for the case of a commit with no parents, it will concat an empty array, having no net effect.
      for (const oid of commit.commit.parent) {
        const commit = await _readCommit({ fs, cache, gitdir, oid });
        if (!tips.map(commit => commit.oid).includes(commit.oid)) {
          tips.push(commit);
        }
      }
    }

    // Stop the loop if there are no more commit parents
    if (tips.length === 0) break

    // Process tips in order by age
    tips.sort((a, b) => compareAge(a.commit, b.commit));
  }
  return commits
}

// @ts-check

/**
 * Get commit descriptions from the git history
 *
 * @param {object} args
 * @param {FsClient} args.fs - a file system client
 * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path
 * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path
 * @param {string} [args.ref = 'HEAD'] - The commit to begin walking backwards through the history from
 * @param {number} [args.depth] - Limit the number of commits returned. No limit by default.
 * @param {Date} [args.since] - Return history newer than the given date. Can be combined with `depth` to get whichever is shorter.
 * @param {object} [args.cache] - a [cache](cache.md) object
 *
 * @returns {Promise<Array<ReadCommitResult>>} Resolves to an array of ReadCommitResult objects
 * @see ReadCommitResult
 * @see CommitObject
 *
 * @example
 * let commits = await git.log({
 *   fs,
 *   dir: '/tutorial',
 *   depth: 5,
 *   ref: 'main'
 * })
 * console.log(commits)
 *
 */
async function log({
  fs,
  dir,
  gitdir = join(dir, '.git'),
  ref = 'HEAD',
  depth,
  since, // Date
  cache = {},
}) {
  try {
    assertParameter('fs', fs);
    assertParameter('gitdir', gitdir);
    assertParameter('ref', ref);

    return await _log({
      fs: new FileSystem(fs),
      cache,
      gitdir,
      ref,
      depth,
      since,
    })
  } catch (err) {
    err.caller = 'git.log';
    throw err
  }
}

// @ts-check

/**
 *
 * @typedef {Object} MergeResult - Returns an object with a schema like this:
 * @property {string} [oid] - The SHA-1 object id that is now at the head of the branch. Absent only if `dryRun` was specified and `mergeCommit` is true.
 * @property {boolean} [alreadyMerged] - True if the branch was already merged so no changes were made
 * @property {boolean} [fastForward] - True if it was a fast-forward merge
 * @property {boolean} [mergeCommit] - True if merge resulted in a merge commit
 * @property {string} [tree] - The SHA-1 object id of the tree resulting from a merge commit
 *
 */

/**
 * Merge two branches
 *
 * ## Limitations
 *
 * Currently it does not support incomplete merges. That is, if there are merge conflicts it cannot solve
 * with the built in diff3 algorithm it will not modify the working dir, and will throw a [`MergeNotSupportedError`](./errors.md#mergenotsupportedError) error.
 *
 * Currently it will fail if multiple candidate merge bases are found. (It doesn't yet implement the recursive merge strategy.)
 *
 * Currently it does not support selecting alternative merge strategies.
 *
 * @param {object} args
 * @param {FsClient} args.fs - a file system client
 * @param {SignCallback} [args.onSign] - a PGP signing implementation
 * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path
 * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path
 * @param {string} [args.ours] - The branch receiving the merge. If undefined, defaults to the current branch.
 * @param {string} args.theirs - The branch to be merged
 * @param {boolean} [args.fastForwardOnly = false] - If true, then non-fast-forward merges will throw an Error instead of performing a merge.
 * @param {boolean} [args.dryRun = false] - If true, simulates a merge so you can test whether it would succeed.
 * @param {boolean} [args.noUpdateBranch = false] - If true, does not update the branch pointer after creating the commit.
 * @param {string} [args.message] - Overrides the default auto-generated merge commit message
 * @param {Object} [args.author] - passed to [commit](commit.md) when creating a merge commit
 * @param {string} [args.author.name] - Default is `user.name` config.
 * @param {string} [args.author.email] - Default is `user.email` config.
 * @param {number} [args.author.timestamp=Math.floor(Date.now()/1000)] - Set the author timestamp field. This is the integer number of seconds since the Unix epoch (1970-01-01 00:00:00).
 * @param {number} [args.author.timezoneOffset] - Set the author timezone offset field. This is the difference, in minutes, from the current timezone to UTC. Default is `(new Date()).getTimezoneOffset()`.
 * @param {Object} [args.committer] - passed to [commit](commit.md) when creating a merge commit
 * @param {string} [args.committer.name] - Default is `user.name` config.
 * @param {string} [args.committer.email] - Default is `user.email` config.
 * @param {number} [args.committer.timestamp=Math.floor(Date.now()/1000)] - Set the committer timestamp field. This is the integer number of seconds since the Unix epoch (1970-01-01 00:00:00).
 * @param {number} [args.committer.timezoneOffset] - Set the committer timezone offset field. This is the difference, in minutes, from the current timezone to UTC. Default is `(new Date()).getTimezoneOffset()`.
 * @param {string} [args.signingKey] - passed to [commit](commit.md) when creating a merge commit
 * @param {object} [args.cache] - a [cache](cache.md) object
 *
 * @returns {Promise<MergeResult>} Resolves to a description of the merge operation
 * @see MergeResult
 *
 * @example
 * let m = await git.merge({
 *   fs,
 *   dir: '/tutorial',
 *   ours: 'main',
 *   theirs: 'remotes/origin/main'
 * })
 * console.log(m)
 *
 */
async function merge({
  fs: _fs,
  onSign,
  dir,
  gitdir = join(dir, '.git'),
  ours,
  theirs,
  fastForwardOnly = false,
  dryRun = false,
  noUpdateBranch = false,
  message,
  author: _author,
  committer: _committer,
  signingKey,
  cache = {},
}) {
  try {
    assertParameter('fs', _fs);
    if (signingKey) {
      assertParameter('onSign', onSign);
    }
    const fs = new FileSystem(_fs);

    const author = await normalizeAuthorObject({ fs, gitdir, author: _author });
    if (!author && !fastForwardOnly) throw new MissingNameError('author')

    const committer = await normalizeCommitterObject({
      fs,
      gitdir,
      author,
      committer: _committer,
    });
    if (!committer && !fastForwardOnly) {
      throw new MissingNameError('committer')
    }

    return await _merge({
      fs,
      cache,
      gitdir,
      ours,
      theirs,
      fastForwardOnly,
      dryRun,
      noUpdateBranch,
      message,
      author,
      committer,
      signingKey,
    })
  } catch (err) {
    err.caller = 'git.merge';
    throw err
  }
}

/**
 * @enum {number}
 */
const types = {
  commit: 0b0010000,
  tree: 0b0100000,
  blob: 0b0110000,
  tag: 0b1000000,
  ofs_delta: 0b1100000,
  ref_delta: 0b1110000,
};

/**
 * @param {object} args
 * @param {import('../models/FileSystem.js').FileSystem} args.fs
 * @param {any} args.cache
 * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path
 * @param {string} [args.gitdir=join(dir, '.git')] - [required] The [git directory](dir-vs-gitdir.md) path
 * @param {string[]} args.oids
 */
async function _pack({
  fs,
  cache,
  dir,
  gitdir = join(dir, '.git'),
  oids,
}) {
  const hash = new sha1();
  const outputStream = [];
  function write(chunk, enc) {
    const buff = Buffer.from(chunk, enc);
    outputStream.push(buff);
    hash.update(buff);
  }
  async function writeObject({ stype, object }) {
    // Object type is encoded in bits 654
    const type = types[stype];
    // The length encoding gets complicated.
    let length = object.length;
    // Whether the next byte is part of the variable-length encoded number
    // is encoded in bit 7
    let multibyte = length > 0b1111 ? 0b10000000 : 0b0;
    // Last four bits of length is encoded in bits 3210
    const lastFour = length & 0b1111;
    // Discard those bits
    length = length >>> 4;
    // The first byte is then (1-bit multibyte?), (3-bit type), (4-bit least sig 4-bits of length)
    let byte = (multibyte | type | lastFour).toString(16);
    write(byte, 'hex');
    // Now we keep chopping away at length 7-bits at a time until its zero,
    // writing out the bytes in what amounts to little-endian order.
    while (multibyte) {
      multibyte = length > 0b01111111 ? 0b10000000 : 0b0;
      byte = multibyte | (length & 0b01111111);
      write(padHex(2, byte), 'hex');
      length = length >>> 7;
    }
    // Lastly, we can compress and write the object.
    write(Buffer.from(await deflate(object)));
  }
  write('PACK');
  write('00000002', 'hex');
  // Write a 4 byte (32-bit) int
  write(padHex(8, oids.length), 'hex');
  for (const oid of oids) {
    const { type, object } = await _readObject({ fs, cache, gitdir, oid });
    await writeObject({ write, object, stype: type });
  }
  // Write SHA1 checksum
  const digest = hash.digest();
  outputStream.push(digest);
  return outputStream
}

// @ts-check

/**
 *
 * @typedef {Object} PackObjectsResult The packObjects command returns an object with two properties:
 * @property {string} filename - The suggested filename for the packfile if you want to save it to disk somewhere. It includes the packfile SHA.
 * @property {Uint8Array} [packfile] - The packfile contents. Not present if `write` parameter was true, in which case the packfile was written straight to disk.
 */

/**
 * @param {object} args
 * @param {import('../models/FileSystem.js').FileSystem} args.fs
 * @param {any} args.cache
 * @param {string} args.gitdir
 * @param {string[]} args.oids
 * @param {boolean} args.write
 *
 * @returns {Promise<PackObjectsResult>}
 * @see PackObjectsResult
 */
async function _packObjects({ fs, cache, gitdir, oids, write }) {
  const buffers = await _pack({ fs, cache, gitdir, oids });
  const packfile = Buffer.from(await collect(buffers));
  const packfileSha = packfile.slice(-20).toString('hex');
  const filename = `pack-${packfileSha}.pack`;
  if (write) {
    await fs.write(join(gitdir, `objects/pack/${filename}`), packfile);
    return { filename }
  }
  return {
    filename,
    packfile: new Uint8Array(packfile),
  }
}

// @ts-check

/**
 *
 * @typedef {Object} PackObjectsResult The packObjects command returns an object with two properties:
 * @property {string} filename - The suggested filename for the packfile if you want to save it to disk somewhere. It includes the packfile SHA.
 * @property {Uint8Array} [packfile] - The packfile contents. Not present if `write` parameter was true, in which case the packfile was written straight to disk.
 */

/**
 * Create a packfile from an array of SHA-1 object ids
 *
 * @param {object} args
 * @param {FsClient} args.fs - a file system client
 * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path
 * @param {string} [args.gitdir=join(dir, '.git')] - [required] The [git directory](dir-vs-gitdir.md) path
 * @param {string[]} args.oids - An array of SHA-1 object ids to be included in the packfile
 * @param {boolean} [args.write = false] - Whether to save the packfile to disk or not
 * @param {object} [args.cache] - a [cache](cache.md) object
 *
 * @returns {Promise<PackObjectsResult>} Resolves successfully when the packfile is ready with the filename and buffer
 * @see PackObjectsResult
 *
 * @example
 * // Create a packfile containing only an empty tree
 * let { packfile } = await git.packObjects({
 *   fs,
 *   dir: '/tutorial',
 *   oids: ['4b825dc642cb6eb9a060e54bf8d69288fbee4904']
 * })
 * console.log(packfile)
 *
 */
async function packObjects({
  fs,
  dir,
  gitdir = join(dir, '.git'),
  oids,
  write = false,
  cache = {},
}) {
  try {
    assertParameter('fs', fs);
    assertParameter('gitdir', gitdir);
    assertParameter('oids', oids);

    return await _packObjects({
      fs: new FileSystem(fs),
      cache,
      gitdir,
      oids,
      write,
    })
  } catch (err) {
    err.caller = 'git.packObjects';
    throw err
  }
}

// @ts-check

/**
 * Fetch and merge commits from a remote repository
 *
 * @param {object} args
 * @param {FsClient} args.fs - a file system client
 * @param {HttpClient} args.http - an HTTP client
 * @param {ProgressCallback} [args.onProgress] - optional progress event callback
 * @param {MessageCallback} [args.onMessage] - optional message event callback
 * @param {AuthCallback} [args.onAuth] - optional auth fill callback
 * @param {AuthFailureCallback} [args.onAuthFailure] - optional auth rejected callback
 * @param {AuthSuccessCallback} [args.onAuthSuccess] - optional auth approved callback
 * @param {string} args.dir] - The [working tree](dir-vs-gitdir.md) directory path
 * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path
 * @param {string} [args.ref] - Which branch to merge into. By default this is the currently checked out branch.
 * @param {string} [args.url] - (Added in 1.1.0) The URL of the remote repository. The default is the value set in the git config for that remote.
 * @param {string} [args.remote] - (Added in 1.1.0) If URL is not specified, determines which remote to use.
 * @param {string} [args.remoteRef] - (Added in 1.1.0) The name of the branch on the remote to fetch. By default this is the configured remote tracking branch.
 * @param {string} [args.corsProxy] - Optional [CORS proxy](https://www.npmjs.com/%40isomorphic-git/cors-proxy). Overrides value in repo config.
 * @param {boolean} [args.singleBranch = false] - Instead of the default behavior of fetching all the branches, only fetch a single branch.
 * @param {boolean} [args.fastForwardOnly = false] - Only perform simple fast-forward merges. (Don't create merge commits.)
 * @param {Object<string, string>} [args.headers] - Additional headers to include in HTTP requests, similar to git's `extraHeader` config
 * @param {Object} [args.author] - The details about the author.
 * @param {string} [args.author.name] - Default is `user.name` config.
 * @param {string} [args.author.email] - Default is `user.email` config.
 * @param {number} [args.author.timestamp=Math.floor(Date.now()/1000)] - Set the author timestamp field. This is the integer number of seconds since the Unix epoch (1970-01-01 00:00:00).
 * @param {number} [args.author.timezoneOffset] - Set the author timezone offset field. This is the difference, in minutes, from the current timezone to UTC. Default is `(new Date()).getTimezoneOffset()`.
 * @param {Object} [args.committer = author] - The details about the commit committer, in the same format as the author parameter. If not specified, the author details are used.
 * @param {string} [args.committer.name] - Default is `user.name` config.
 * @param {string} [args.committer.email] - Default is `user.email` config.
 * @param {number} [args.committer.timestamp=Math.floor(Date.now()/1000)] - Set the committer timestamp field. This is the integer number of seconds since the Unix epoch (1970-01-01 00:00:00).
 * @param {number} [args.committer.timezoneOffset] - Set the committer timezone offset field. This is the difference, in minutes, from the current timezone to UTC. Default is `(new Date()).getTimezoneOffset()`.
 * @param {string} [args.signingKey] - passed to [commit](commit.md) when creating a merge commit
 * @param {object} [args.cache] - a [cache](cache.md) object
 *
 * @returns {Promise<void>} Resolves successfully when pull operation completes
 *
 * @example
 * await git.pull({
 *   fs,
 *   http,
 *   dir: '/tutorial',
 *   ref: 'main',
 *   singleBranch: true
 * })
 * console.log('done')
 *
 */
async function pull({
  fs: _fs,
  http,
  onProgress,
  onMessage,
  onAuth,
  onAuthSuccess,
  onAuthFailure,
  dir,
  gitdir = join(dir, '.git'),
  ref,
  url,
  remote,
  remoteRef,
  fastForwardOnly = false,
  corsProxy,
  singleBranch,
  headers = {},
  author: _author,
  committer: _committer,
  signingKey,
  cache = {},
}) {
  try {
    assertParameter('fs', _fs);
    assertParameter('gitdir', gitdir);

    const fs = new FileSystem(_fs);

    const author = await normalizeAuthorObject({ fs, gitdir, author: _author });
    if (!author) throw new MissingNameError('author')

    const committer = await normalizeCommitterObject({
      fs,
      gitdir,
      author,
      committer: _committer,
    });
    if (!committer) throw new MissingNameError('committer')

    return await _pull({
      fs,
      cache,
      http,
      onProgress,
      onMessage,
      onAuth,
      onAuthSuccess,
      onAuthFailure,
      dir,
      gitdir,
      ref,
      url,
      remote,
      remoteRef,
      fastForwardOnly,
      corsProxy,
      singleBranch,
      headers,
      author,
      committer,
      signingKey,
    })
  } catch (err) {
    err.caller = 'git.pull';
    throw err
  }
}

/**
 * @param {object} args
 * @param {import('../models/FileSystem.js').FileSystem} args.fs
 * @param {any} args.cache
 * @param {string} [args.dir]
 * @param {string} args.gitdir
 * @param {Iterable<string>} args.start
 * @param {Iterable<string>} args.finish
 * @returns {Promise<Set<string>>}
 */
async function listCommitsAndTags({
  fs,
  cache,
  dir,
  gitdir = join(dir, '.git'),
  start,
  finish,
}) {
  const shallows = await GitShallowManager.read({ fs, gitdir });
  const startingSet = new Set();
  const finishingSet = new Set();
  for (const ref of start) {
    startingSet.add(await GitRefManager.resolve({ fs, gitdir, ref }));
  }
  for (const ref of finish) {
    // We may not have these refs locally so we must try/catch
    try {
      const oid = await GitRefManager.resolve({ fs, gitdir, ref });
      finishingSet.add(oid);
    } catch (err) {}
  }
  const visited = new Set();
  // Because git commits are named by their hash, there is no
  // way to construct a cycle. Therefore we won't worry about
  // setting a default recursion limit.
  async function walk(oid) {
    visited.add(oid);
    const { type, object } = await _readObject({ fs, cache, gitdir, oid });
    // Recursively resolve annotated tags
    if (type === 'tag') {
      const tag = GitAnnotatedTag.from(object);
      const commit = tag.headers().object;
      return walk(commit)
    }
    if (type !== 'commit') {
      throw new ObjectTypeError(oid, type, 'commit')
    }
    if (!shallows.has(oid)) {
      const commit = GitCommit.from(object);
      const parents = commit.headers().parent;
      for (oid of parents) {
        if (!finishingSet.has(oid) && !visited.has(oid)) {
          await walk(oid);
        }
      }
    }
  }
  // Let's go walking!
  for (const oid of startingSet) {
    await walk(oid);
  }
  return visited
}

/**
 * @param {object} args
 * @param {import('../models/FileSystem.js').FileSystem} args.fs
 * @param {any} args.cache
 * @param {string} [args.dir]
 * @param {string} args.gitdir
 * @param {Iterable<string>} args.oids
 * @returns {Promise<Set<string>>}
 */
async function listObjects({
  fs,
  cache,
  dir,
  gitdir = join(dir, '.git'),
  oids,
}) {
  const visited = new Set();
  // We don't do the purest simplest recursion, because we can
  // avoid reading Blob objects entirely since the Tree objects
  // tell us which oids are Blobs and which are Trees.
  async function walk(oid) {
    if (visited.has(oid)) return
    visited.add(oid);
    const { type, object } = await _readObject({ fs, cache, gitdir, oid });
    if (type === 'tag') {
      const tag = GitAnnotatedTag.from(object);
      const obj = tag.headers().object;
      await walk(obj);
    } else if (type === 'commit') {
      const commit = GitCommit.from(object);
      const tree = commit.headers().tree;
      await walk(tree);
    } else if (type === 'tree') {
      const tree = GitTree.from(object);
      for (const entry of tree) {
        // add blobs to the set
        // skip over submodules whose type is 'commit'
        if (entry.type === 'blob') {
          visited.add(entry.oid);
        }
        // recurse for trees
        if (entry.type === 'tree') {
          await walk(entry.oid);
        }
      }
    }
  }
  // Let's go walking!
  for (const oid of oids) {
    await walk(oid);
  }
  return visited
}

async function parseReceivePackResponse(packfile) {
  /** @type PushResult */
  const result = {};
  let response = '';
  const read = GitPktLine.streamReader(packfile);
  let line = await read();
  while (line !== true) {
    if (line !== null) response += line.toString('utf8') + '\n';
    line = await read();
  }

  const lines = response.toString('utf8').split('\n');
  // We're expecting "unpack {unpack-result}"
  line = lines.shift();
  if (!line.startsWith('unpack ')) {
    throw new ParseError('unpack ok" or "unpack [error message]', line)
  }
  result.ok = line === 'unpack ok';
  if (!result.ok) {
    result.error = line.slice('unpack '.length);
  }
  result.refs = {};
  for (const line of lines) {
    if (line.trim() === '') continue
    const status = line.slice(0, 2);
    const refAndMessage = line.slice(3);
    let space = refAndMessage.indexOf(' ');
    if (space === -1) space = refAndMessage.length;
    const ref = refAndMessage.slice(0, space);
    const error = refAndMessage.slice(space + 1);
    result.refs[ref] = {
      ok: status === 'ok',
      error,
    };
  }
  return result
}

async function writeReceivePackRequest({
  capabilities = [],
  triplets = [],
}) {
  const packstream = [];
  let capsFirstLine = `\x00 ${capabilities.join(' ')}`;
  for (const trip of triplets) {
    packstream.push(
      GitPktLine.encode(
        `${trip.oldoid} ${trip.oid} ${trip.fullRef}${capsFirstLine}\n`
      )
    );
    capsFirstLine = '';
  }
  packstream.push(GitPktLine.flush());
  return packstream
}

// @ts-check

/**
 * @param {object} args
 * @param {import('../models/FileSystem.js').FileSystem} args.fs
 * @param {any} args.cache
 * @param {HttpClient} args.http
 * @param {ProgressCallback} [args.onProgress]
 * @param {MessageCallback} [args.onMessage]
 * @param {AuthCallback} [args.onAuth]
 * @param {AuthFailureCallback} [args.onAuthFailure]
 * @param {AuthSuccessCallback} [args.onAuthSuccess]
 * @param {string} args.gitdir
 * @param {string} [args.ref]
 * @param {string} [args.remoteRef]
 * @param {string} [args.remote]
 * @param {boolean} [args.force = false]
 * @param {boolean} [args.delete = false]
 * @param {string} [args.url]
 * @param {string} [args.corsProxy]
 * @param {Object<string, string>} [args.headers]
 *
 * @returns {Promise<PushResult>}
 */
async function _push({
  fs,
  cache,
  http,
  onProgress,
  onMessage,
  onAuth,
  onAuthSuccess,
  onAuthFailure,
  gitdir,
  ref: _ref,
  remoteRef: _remoteRef,
  remote,
  url: _url,
  force = false,
  delete: _delete = false,
  corsProxy,
  headers = {},
}) {
  const ref = _ref || (await _currentBranch({ fs, gitdir }));
  if (typeof ref === 'undefined') {
    throw new MissingParameterError('ref')
  }
  const config = await GitConfigManager.get({ fs, gitdir });
  // Figure out what remote to use.
  remote =
    remote ||
    (await config.get(`branch.${ref}.pushRemote`)) ||
    (await config.get('remote.pushDefault')) ||
    (await config.get(`branch.${ref}.remote`)) ||
    'origin';
  // Lookup the URL for the given remote.
  const url =
    _url ||
    (await config.get(`remote.${remote}.pushurl`)) ||
    (await config.get(`remote.${remote}.url`));
  if (typeof url === 'undefined') {
    throw new MissingParameterError('remote OR url')
  }
  // Figure out what remote ref to use.
  const remoteRef = _remoteRef || (await config.get(`branch.${ref}.merge`));
  if (typeof url === 'undefined') {
    throw new MissingParameterError('remoteRef')
  }

  if (corsProxy === undefined) {
    corsProxy = await config.get('http.corsProxy');
  }

  const fullRef = await GitRefManager.expand({ fs, gitdir, ref });
  const oid = _delete
    ? '0000000000000000000000000000000000000000'
    : await GitRefManager.resolve({ fs, gitdir, ref: fullRef });

  /** @type typeof import("../managers/GitRemoteHTTP").GitRemoteHTTP */
  const GitRemoteHTTP = GitRemoteManager.getRemoteHelperFor({ url });
  const httpRemote = await GitRemoteHTTP.discover({
    http,
    onAuth,
    onAuthSuccess,
    onAuthFailure,
    corsProxy,
    service: 'git-receive-pack',
    url,
    headers,
    protocolVersion: 1,
  });
  const auth = httpRemote.auth; // hack to get new credentials from CredentialManager API
  let fullRemoteRef;
  if (!remoteRef) {
    fullRemoteRef = fullRef;
  } else {
    try {
      fullRemoteRef = await GitRefManager.expandAgainstMap({
        ref: remoteRef,
        map: httpRemote.refs,
      });
    } catch (err) {
      if (err instanceof NotFoundError) {
        // The remote reference doesn't exist yet.
        // If it is fully specified, use that value. Otherwise, treat it as a branch.
        fullRemoteRef = remoteRef.startsWith('refs/')
          ? remoteRef
          : `refs/heads/${remoteRef}`;
      } else {
        throw err
      }
    }
  }
  const oldoid =
    httpRemote.refs.get(fullRemoteRef) ||
    '0000000000000000000000000000000000000000';

  // Remotes can always accept thin-packs UNLESS they specify the 'no-thin' capability
  const thinPack = !httpRemote.capabilities.has('no-thin');

  let objects = new Set();
  if (!_delete) {
    const finish = [...httpRemote.refs.values()];
    let skipObjects = new Set();

    // If remote branch is present, look for a common merge base.
    if (oldoid !== '0000000000000000000000000000000000000000') {
      // trick to speed up common force push scenarios
      const mergebase = await _findMergeBase({
        fs,
        cache,
        gitdir,
        oids: [oid, oldoid],
      });
      for (const oid of mergebase) finish.push(oid);
      if (thinPack) {
        skipObjects = await listObjects({ fs, cache, gitdir, oids: mergebase });
      }
    }

    // If remote does not have the commit, figure out the objects to send
    if (!finish.includes(oid)) {
      const commits = await listCommitsAndTags({
        fs,
        cache,
        gitdir,
        start: [oid],
        finish,
      });
      objects = await listObjects({ fs, cache, gitdir, oids: commits });
    }

    if (thinPack) {
      // If there's a default branch for the remote lets skip those objects too.
      // Since this is an optional optimization, we just catch and continue if there is
      // an error (because we can't find a default branch, or can't find a commit, etc)
      try {
        // Sadly, the discovery phase with 'forPush' doesn't return symrefs, so we have to
        // rely on existing ones.
        const ref = await GitRefManager.resolve({
          fs,
          gitdir,
          ref: `refs/remotes/${remote}/HEAD`,
          depth: 2,
        });
        const { oid } = await GitRefManager.resolveAgainstMap({
          ref: ref.replace(`refs/remotes/${remote}/`, ''),
          fullref: ref,
          map: httpRemote.refs,
        });
        const oids = [oid];
        for (const oid of await listObjects({ fs, cache, gitdir, oids })) {
          skipObjects.add(oid);
        }
      } catch (e) {}

      // Remove objects that we know the remote already has
      for (const oid of skipObjects) {
        objects.delete(oid);
      }
    }

    if (!force) {
      // Is it a tag that already exists?
      if (
        fullRef.startsWith('refs/tags') &&
        oldoid !== '0000000000000000000000000000000000000000'
      ) {
        throw new PushRejectedError('tag-exists')
      }
      // Is it a non-fast-forward commit?
      if (
        oid !== '0000000000000000000000000000000000000000' &&
        oldoid !== '0000000000000000000000000000000000000000' &&
        !(await _isDescendent({
          fs,
          cache,
          gitdir,
          oid,
          ancestor: oldoid,
          depth: -1,
        }))
      ) {
        throw new PushRejectedError('not-fast-forward')
      }
    }
  }
  // We can only safely use capabilities that the server also understands.
  // For instance, AWS CodeCommit aborts a push if you include the `agent`!!!
  const capabilities = filterCapabilities(
    [...httpRemote.capabilities],
    ['report-status', 'side-band-64k', `agent=${pkg.agent}`]
  );
  const packstream1 = await writeReceivePackRequest({
    capabilities,
    triplets: [{ oldoid, oid, fullRef: fullRemoteRef }],
  });
  const packstream2 = _delete
    ? []
    : await _pack({
        fs,
        cache,
        gitdir,
        oids: [...objects],
      });
  const res = await GitRemoteHTTP.connect({
    http,
    onProgress,
    corsProxy,
    service: 'git-receive-pack',
    url,
    auth,
    headers,
    body: [...packstream1, ...packstream2],
  });
  const { packfile, progress } = await GitSideBand.demux(res.body);
  if (onMessage) {
    const lines = splitLines(progress);
    forAwait(lines, async line => {
      await onMessage(line);
    });
  }
  // Parse the response!
  const result = await parseReceivePackResponse(packfile);
  if (res.headers) {
    result.headers = res.headers;
  }

  // Update the local copy of the remote ref
  if (remote && result.ok && result.refs[fullRemoteRef].ok) {
    // TODO: I think this should actually be using a refspec transform rather than assuming 'refs/remotes/{remote}'
    const ref = `refs/remotes/${remote}/${fullRemoteRef.replace(
      'refs/heads',
      ''
    )}`;
    if (_delete) {
      await GitRefManager.deleteRef({ fs, gitdir, ref });
    } else {
      await GitRefManager.writeRef({ fs, gitdir, ref, value: oid });
    }
  }
  if (result.ok && Object.values(result.refs).every(result => result.ok)) {
    return result
  } else {
    const prettyDetails = Object.entries(result.refs)
      .filter(([k, v]) => !v.ok)
      .map(([k, v]) => `\n  - ${k}: ${v.error}`)
      .join('');
    throw new GitPushError(prettyDetails, result)
  }
}

// @ts-check

/**
 * Push a branch or tag
 *
 * The push command returns an object that describes the result of the attempted push operation.
 * *Notes:* If there were no errors, then there will be no `errors` property. There can be a mix of `ok` messages and `errors` messages.
 *
 * | param  | type [= default] | description                                                                                                                                                                                                      |
 * | ------ | ---------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
 * | ok     | Array\<string\>  | The first item is "unpack" if the overall operation was successful. The remaining items are the names of refs that were updated successfully.                                                                    |
 * | errors | Array\<string\>  | If the overall operation threw and error, the first item will be "unpack {Overall error message}". The remaining items are individual refs that failed to be updated in the format "{ref name} {error message}". |
 *
 * @param {object} args
 * @param {FsClient} args.fs - a file system client
 * @param {HttpClient} args.http - an HTTP client
 * @param {ProgressCallback} [args.onProgress] - optional progress event callback
 * @param {MessageCallback} [args.onMessage] - optional message event callback
 * @param {AuthCallback} [args.onAuth] - optional auth fill callback
 * @param {AuthFailureCallback} [args.onAuthFailure] - optional auth rejected callback
 * @param {AuthSuccessCallback} [args.onAuthSuccess] - optional auth approved callback
 * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path
 * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path
 * @param {string} [args.ref] - Which branch to push. By default this is the currently checked out branch.
 * @param {string} [args.url] - The URL of the remote repository. The default is the value set in the git config for that remote.
 * @param {string} [args.remote] - If URL is not specified, determines which remote to use.
 * @param {string} [args.remoteRef] - The name of the receiving branch on the remote. By default this is the configured remote tracking branch.
 * @param {boolean} [args.force = false] - If true, behaves the same as `git push --force`
 * @param {boolean} [args.delete = false] - If true, delete the remote ref
 * @param {string} [args.corsProxy] - Optional [CORS proxy](https://www.npmjs.com/%40isomorphic-git/cors-proxy). Overrides value in repo config.
 * @param {Object<string, string>} [args.headers] - Additional headers to include in HTTP requests, similar to git's `extraHeader` config
 * @param {object} [args.cache] - a [cache](cache.md) object
 *
 * @returns {Promise<PushResult>} Resolves successfully when push completes with a detailed description of the operation from the server.
 * @see PushResult
 * @see RefUpdateStatus
 *
 * @example
 * let pushResult = await git.push({
 *   fs,
 *   http,
 *   dir: '/tutorial',
 *   remote: 'origin',
 *   ref: 'main',
 *   onAuth: () => ({ username: process.env.GITHUB_TOKEN }),
 * })
 * console.log(pushResult)
 *
 */
async function push({
  fs,
  http,
  onProgress,
  onMessage,
  onAuth,
  onAuthSuccess,
  onAuthFailure,
  dir,
  gitdir = join(dir, '.git'),
  ref,
  remoteRef,
  remote = 'origin',
  url,
  force = false,
  delete: _delete = false,
  corsProxy,
  headers = {},
  cache = {},
}) {
  try {
    assertParameter('fs', fs);
    assertParameter('http', http);
    assertParameter('gitdir', gitdir);

    return await _push({
      fs: new FileSystem(fs),
      cache,
      http,
      onProgress,
      onMessage,
      onAuth,
      onAuthSuccess,
      onAuthFailure,
      gitdir,
      ref,
      remoteRef,
      remote,
      url,
      force,
      delete: _delete,
      corsProxy,
      headers,
    })
  } catch (err) {
    err.caller = 'git.push';
    throw err
  }
}

async function resolveBlob({ fs, cache, gitdir, oid }) {
  const { type, object } = await _readObject({ fs, cache, gitdir, oid });
  // Resolve annotated tag objects to whatever
  if (type === 'tag') {
    oid = GitAnnotatedTag.from(object).parse().object;
    return resolveBlob({ fs, cache, gitdir, oid })
  }
  if (type !== 'blob') {
    throw new ObjectTypeError(oid, type, 'blob')
  }
  return { oid, blob: new Uint8Array(object) }
}

// @ts-check

/**
 *
 * @typedef {Object} ReadBlobResult - The object returned has the following schema:
 * @property {string} oid
 * @property {Uint8Array} blob
 *
 */

/**
 * @param {object} args
 * @param {import('../models/FileSystem.js').FileSystem} args.fs
 * @param {any} args.cache
 * @param {string} args.gitdir
 * @param {string} args.oid
 * @param {string} [args.filepath]
 *
 * @returns {Promise<ReadBlobResult>} Resolves successfully with a blob object description
 * @see ReadBlobResult
 */
async function _readBlob({
  fs,
  cache,
  gitdir,
  oid,
  filepath = undefined,
}) {
  if (filepath !== undefined) {
    oid = await resolveFilepath({ fs, cache, gitdir, oid, filepath });
  }
  const blob = await resolveBlob({
    fs,
    cache,
    gitdir,
    oid,
  });
  return blob
}

// @ts-check

/**
 *
 * @typedef {Object} ReadBlobResult - The object returned has the following schema:
 * @property {string} oid
 * @property {Uint8Array} blob
 *
 */

/**
 * Read a blob object directly
 *
 * @param {object} args
 * @param {FsClient} args.fs - a file system client
 * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path
 * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path
 * @param {string} args.oid - The SHA-1 object id to get. Annotated tags, commits, and trees are peeled.
 * @param {string} [args.filepath] - Don't return the object with `oid` itself, but resolve `oid` to a tree and then return the blob object at that filepath.
 * @param {object} [args.cache] - a [cache](cache.md) object
 *
 * @returns {Promise<ReadBlobResult>} Resolves successfully with a blob object description
 * @see ReadBlobResult
 *
 * @example
 * // Get the contents of 'README.md' in the main branch.
 * let commitOid = await git.resolveRef({ fs, dir: '/tutorial', ref: 'main' })
 * console.log(commitOid)
 * let { blob } = await git.readBlob({
 *   fs,
 *   dir: '/tutorial',
 *   oid: commitOid,
 *   filepath: 'README.md'
 * })
 * console.log(Buffer.from(blob).toString('utf8'))
 *
 */
async function readBlob({
  fs,
  dir,
  gitdir = join(dir, '.git'),
  oid,
  filepath,
  cache = {},
}) {
  try {
    assertParameter('fs', fs);
    assertParameter('gitdir', gitdir);
    assertParameter('oid', oid);

    return await _readBlob({
      fs: new FileSystem(fs),
      cache,
      gitdir,
      oid,
      filepath,
    })
  } catch (err) {
    err.caller = 'git.readBlob';
    throw err
  }
}

// @ts-check

/**
 * Read a commit object directly
 *
 * @param {object} args
 * @param {FsClient} args.fs - a file system client
 * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path
 * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path
 * @param {string} args.oid - The SHA-1 object id to get. Annotated tags are peeled.
 * @param {object} [args.cache] - a [cache](cache.md) object
 *
 * @returns {Promise<ReadCommitResult>} Resolves successfully with a git commit object
 * @see ReadCommitResult
 * @see CommitObject
 *
 * @example
 * // Read a commit object
 * let sha = await git.resolveRef({ fs, dir: '/tutorial', ref: 'main' })
 * console.log(sha)
 * let commit = await git.readCommit({ fs, dir: '/tutorial', oid: sha })
 * console.log(commit)
 *
 */
async function readCommit({
  fs,
  dir,
  gitdir = join(dir, '.git'),
  oid,
  cache = {},
}) {
  try {
    assertParameter('fs', fs);
    assertParameter('gitdir', gitdir);
    assertParameter('oid', oid);

    return await _readCommit({
      fs: new FileSystem(fs),
      cache,
      gitdir,
      oid,
    })
  } catch (err) {
    err.caller = 'git.readCommit';
    throw err
  }
}

// @ts-check

/**
 * Read the contents of a note
 *
 * @param {object} args
 * @param {import('../models/FileSystem.js').FileSystem} args.fs
 * @param {any} args.cache
 * @param {string} args.gitdir
 * @param {string} [args.ref] - The notes ref to look under
 * @param {string} args.oid
 *
 * @returns {Promise<Uint8Array>} Resolves successfully with note contents as a Buffer.
 */

async function _readNote({
  fs,
  cache,
  gitdir,
  ref = 'refs/notes/commits',
  oid,
}) {
  const parent = await GitRefManager.resolve({ gitdir, fs, ref });
  const { blob } = await _readBlob({
    fs,
    cache,
    gitdir,
    oid: parent,
    filepath: oid,
  });

  return blob
}

// @ts-check

/**
 * Read the contents of a note
 *
 * @param {object} args
 * @param {FsClient} args.fs - a file system client
 * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path
 * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path
 * @param {string} [args.ref] - The notes ref to look under
 * @param {string} args.oid - The SHA-1 object id of the object to get the note for.
 * @param {object} [args.cache] - a [cache](cache.md) object
 *
 * @returns {Promise<Uint8Array>} Resolves successfully with note contents as a Buffer.
 */

async function readNote({
  fs,
  dir,
  gitdir = join(dir, '.git'),
  ref = 'refs/notes/commits',
  oid,
  cache = {},
}) {
  try {
    assertParameter('fs', fs);
    assertParameter('gitdir', gitdir);
    assertParameter('ref', ref);
    assertParameter('oid', oid);

    return await _readNote({
      fs: new FileSystem(fs),
      cache,
      gitdir,
      ref,
      oid,
    })
  } catch (err) {
    err.caller = 'git.readNote';
    throw err
  }
}

// @ts-check

/**
 *
 * @typedef {Object} DeflatedObject
 * @property {string} oid
 * @property {'deflated'} type
 * @property {'deflated'} format
 * @property {Uint8Array} object
 * @property {string} [source]
 *
 */

/**
 *
 * @typedef {Object} WrappedObject
 * @property {string} oid
 * @property {'wrapped'} type
 * @property {'wrapped'} format
 * @property {Uint8Array} object
 * @property {string} [source]
 *
 */

/**
 *
 * @typedef {Object} RawObject
 * @property {string} oid
 * @property {'blob'|'commit'|'tree'|'tag'} type
 * @property {'content'} format
 * @property {Uint8Array} object
 * @property {string} [source]
 *
 */

/**
 *
 * @typedef {Object} ParsedBlobObject
 * @property {string} oid
 * @property {'blob'} type
 * @property {'parsed'} format
 * @property {string} object
 * @property {string} [source]
 *
 */

/**
 *
 * @typedef {Object} ParsedCommitObject
 * @property {string} oid
 * @property {'commit'} type
 * @property {'parsed'} format
 * @property {CommitObject} object
 * @property {string} [source]
 *
 */

/**
 *
 * @typedef {Object} ParsedTreeObject
 * @property {string} oid
 * @property {'tree'} type
 * @property {'parsed'} format
 * @property {TreeObject} object
 * @property {string} [source]
 *
 */

/**
 *
 * @typedef {Object} ParsedTagObject
 * @property {string} oid
 * @property {'tag'} type
 * @property {'parsed'} format
 * @property {TagObject} object
 * @property {string} [source]
 *
 */

/**
 *
 * @typedef {ParsedBlobObject | ParsedCommitObject | ParsedTreeObject | ParsedTagObject} ParsedObject
 */

/**
 *
 * @typedef {DeflatedObject | WrappedObject | RawObject | ParsedObject } ReadObjectResult
 */

/**
 * Read a git object directly by its SHA-1 object id
 *
 * Regarding `ReadObjectResult`:
 *
 * - `oid` will be the same as the `oid` argument unless the `filepath` argument is provided, in which case it will be the oid of the tree or blob being returned.
 * - `type` of deflated objects is `'deflated'`, and `type` of wrapped objects is `'wrapped'`
 * - `format` is usually, but not always, the format you requested. Packfiles do not store each object individually compressed so if you end up reading the object from a packfile it will be returned in format 'content' even if you requested 'deflated' or 'wrapped'.
 * - `object` will be an actual Object if format is 'parsed' and the object is a commit, tree, or annotated tag. Blobs are still formatted as Buffers unless an encoding is provided in which case they'll be strings. If format is anything other than 'parsed', object will be a Buffer.
 * - `source` is the name of the packfile or loose object file where the object was found.
 *
 * The `format` parameter can have the following values:
 *
 * | param      | description                                                                                                                                                                                               |
 * | ---------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
 * | 'deflated' | Return the raw deflate-compressed buffer for an object if possible. Useful for efficiently shuffling around loose objects when you don't care about the contents and can save time by not inflating them. |
 * | 'wrapped'  | Return the inflated object buffer wrapped in the git object header if possible. This is the raw data used when calculating the SHA-1 object id of a git object.                                           |
 * | 'content'  | Return the object buffer without the git header.                                                                                                                                                          |
 * | 'parsed'   | Returns a parsed representation of the object.                                                                                                                                                            |
 *
 * The result will be in one of the following schemas:
 *
 * ## `'deflated'` format
 *
 * {@link DeflatedObject typedef}
 *
 * ## `'wrapped'` format
 *
 * {@link WrappedObject typedef}
 *
 * ## `'content'` format
 *
 * {@link RawObject typedef}
 *
 * ## `'parsed'` format
 *
 * ### parsed `'blob'` type
 *
 * {@link ParsedBlobObject typedef}
 *
 * ### parsed `'commit'` type
 *
 * {@link ParsedCommitObject typedef}
 * {@link CommitObject typedef}
 *
 * ### parsed `'tree'` type
 *
 * {@link ParsedTreeObject typedef}
 * {@link TreeObject typedef}
 * {@link TreeEntry typedef}
 *
 * ### parsed `'tag'` type
 *
 * {@link ParsedTagObject typedef}
 * {@link TagObject typedef}
 *
 * @deprecated
 * > This command is overly complicated.
 * >
 * > If you know the type of object you are reading, use [`readBlob`](./readBlob.md), [`readCommit`](./readCommit.md), [`readTag`](./readTag.md), or [`readTree`](./readTree.md).
 *
 * @param {object} args
 * @param {FsClient} args.fs - a file system client
 * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path
 * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path
 * @param {string} args.oid - The SHA-1 object id to get
 * @param {'deflated' | 'wrapped' | 'content' | 'parsed'} [args.format = 'parsed'] - What format to return the object in. The choices are described in more detail below.
 * @param {string} [args.filepath] - Don't return the object with `oid` itself, but resolve `oid` to a tree and then return the object at that filepath. To return the root directory of a tree set filepath to `''`
 * @param {string} [args.encoding] - A convenience argument that only affects blobs. Instead of returning `object` as a buffer, it returns a string parsed using the given encoding.
 * @param {object} [args.cache] - a [cache](cache.md) object
 *
 * @returns {Promise<ReadObjectResult>} Resolves successfully with a git object description
 * @see ReadObjectResult
 *
 * @example
 * // Given a ransom SHA-1 object id, figure out what it is
 * let { type, object } = await git.readObject({
 *   fs,
 *   dir: '/tutorial',
 *   oid: '0698a781a02264a6f37ba3ff41d78067eaf0f075'
 * })
 * switch (type) {
 *   case 'commit': {
 *     console.log(object)
 *     break
 *   }
 *   case 'tree': {
 *     console.log(object)
 *     break
 *   }
 *   case 'blob': {
 *     console.log(object)
 *     break
 *   }
 *   case 'tag': {
 *     console.log(object)
 *     break
 *   }
 * }
 *
 */
async function readObject({
  fs: _fs,
  dir,
  gitdir = join(dir, '.git'),
  oid,
  format = 'parsed',
  filepath = undefined,
  encoding = undefined,
  cache = {},
}) {
  try {
    assertParameter('fs', _fs);
    assertParameter('gitdir', gitdir);
    assertParameter('oid', oid);

    const fs = new FileSystem(_fs);
    if (filepath !== undefined) {
      oid = await resolveFilepath({
        fs,
        cache,
        gitdir,
        oid,
        filepath,
      });
    }
    // GitObjectManager does not know how to parse content, so we tweak that parameter before passing it.
    const _format = format === 'parsed' ? 'content' : format;
    const result = await _readObject({
      fs,
      cache,
      gitdir,
      oid,
      format: _format,
    });
    result.oid = oid;
    if (format === 'parsed') {
      result.format = 'parsed';
      switch (result.type) {
        case 'commit':
          result.object = GitCommit.from(result.object).parse();
          break
        case 'tree':
          result.object = GitTree.from(result.object).entries();
          break
        case 'blob':
          // Here we consider returning a raw Buffer as the 'content' format
          // and returning a string as the 'parsed' format
          if (encoding) {
            result.object = result.object.toString(encoding);
          } else {
            result.object = new Uint8Array(result.object);
            result.format = 'content';
          }
          break
        case 'tag':
          result.object = GitAnnotatedTag.from(result.object).parse();
          break
        default:
          throw new ObjectTypeError(
            result.oid,
            result.type,
            'blob|commit|tag|tree'
          )
      }
    } else if (result.format === 'deflated' || result.format === 'wrapped') {
      result.type = result.format;
    }
    return result
  } catch (err) {
    err.caller = 'git.readObject';
    throw err
  }
}

// @ts-check

/**
 *
 * @typedef {Object} ReadTagResult - The object returned has the following schema:
 * @property {string} oid - SHA-1 object id of this tag
 * @property {TagObject} tag - the parsed tag object
 * @property {string} payload - PGP signing payload
 */

/**
 * @param {object} args
 * @param {import('../models/FileSystem.js').FileSystem} args.fs
 * @param {any} args.cache
 * @param {string} args.gitdir
 * @param {string} args.oid
 *
 * @returns {Promise<ReadTagResult>}
 */
async function _readTag({ fs, cache, gitdir, oid }) {
  const { type, object } = await _readObject({
    fs,
    cache,
    gitdir,
    oid,
    format: 'content',
  });
  if (type !== 'tag') {
    throw new ObjectTypeError(oid, type, 'tag')
  }
  const tag = GitAnnotatedTag.from(object);
  const result = {
    oid,
    tag: tag.parse(),
    payload: tag.payload(),
  };
  // @ts-ignore
  return result
}

/**
 *
 * @typedef {Object} ReadTagResult - The object returned has the following schema:
 * @property {string} oid - SHA-1 object id of this tag
 * @property {TagObject} tag - the parsed tag object
 * @property {string} payload - PGP signing payload
 */

/**
 * Read an annotated tag object directly
 *
 * @param {object} args
 * @param {FsClient} args.fs - a file system client
 * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path
 * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path
 * @param {string} args.oid - The SHA-1 object id to get
 * @param {object} [args.cache] - a [cache](cache.md) object
 *
 * @returns {Promise<ReadTagResult>} Resolves successfully with a git object description
 * @see ReadTagResult
 * @see TagObject
 *
 */
async function readTag({
  fs,
  dir,
  gitdir = join(dir, '.git'),
  oid,
  cache = {},
}) {
  try {
    assertParameter('fs', fs);
    assertParameter('gitdir', gitdir);
    assertParameter('oid', oid);

    return await _readTag({
      fs: new FileSystem(fs),
      cache,
      gitdir,
      oid,
    })
  } catch (err) {
    err.caller = 'git.readTag';
    throw err
  }
}

// @ts-check

/**
 *
 * @typedef {Object} ReadTreeResult - The object returned has the following schema:
 * @property {string} oid - SHA-1 object id of this tree
 * @property {TreeObject} tree - the parsed tree object
 */

/**
 * Read a tree object directly
 *
 * @param {object} args
 * @param {FsClient} args.fs - a file system client
 * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path
 * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path
 * @param {string} args.oid - The SHA-1 object id to get. Annotated tags and commits are peeled.
 * @param {string} [args.filepath] - Don't return the object with `oid` itself, but resolve `oid` to a tree and then return the tree object at that filepath.
 * @param {object} [args.cache] - a [cache](cache.md) object
 *
 * @returns {Promise<ReadTreeResult>} Resolves successfully with a git tree object
 * @see ReadTreeResult
 * @see TreeObject
 * @see TreeEntry
 *
 */
async function readTree({
  fs,
  dir,
  gitdir = join(dir, '.git'),
  oid,
  filepath = undefined,
  cache = {},
}) {
  try {
    assertParameter('fs', fs);
    assertParameter('gitdir', gitdir);
    assertParameter('oid', oid);

    return await _readTree({
      fs: new FileSystem(fs),
      cache,
      gitdir,
      oid,
      filepath,
    })
  } catch (err) {
    err.caller = 'git.readTree';
    throw err
  }
}

// @ts-check

/**
 * Remove a file from the git index (aka staging area)
 *
 * Note that this does NOT delete the file in the working directory.
 *
 * @param {object} args
 * @param {FsClient} args.fs - a file system client
 * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path
 * @param {string} [args.gitdir=join(dir, '.git')] - [required] The [git directory](dir-vs-gitdir.md) path
 * @param {string} args.filepath - The path to the file to remove from the index
 * @param {object} [args.cache] - a [cache](cache.md) object
 *
 * @returns {Promise<void>} Resolves successfully once the git index has been updated
 *
 * @example
 * await git.remove({ fs, dir: '/tutorial', filepath: 'README.md' })
 * console.log('done')
 *
 */
async function remove({
  fs: _fs,
  dir,
  gitdir = join(dir, '.git'),
  filepath,
  cache = {},
}) {
  try {
    assertParameter('fs', _fs);
    assertParameter('gitdir', gitdir);
    assertParameter('filepath', filepath);

    await GitIndexManager.acquire(
      { fs: new FileSystem(_fs), gitdir, cache },
      async function(index) {
        index.delete({ filepath });
      }
    );
  } catch (err) {
    err.caller = 'git.remove';
    throw err
  }
}

// @ts-check

/**
 * @param {object} args
 * @param {import('../models/FileSystem.js').FileSystem} args.fs
 * @param {object} args.cache
 * @param {SignCallback} [args.onSign]
 * @param {string} [args.dir]
 * @param {string} [args.gitdir=join(dir,'.git')]
 * @param {string} [args.ref]
 * @param {string} args.oid
 * @param {Object} args.author
 * @param {string} args.author.name
 * @param {string} args.author.email
 * @param {number} args.author.timestamp
 * @param {number} args.author.timezoneOffset
 * @param {Object} args.committer
 * @param {string} args.committer.name
 * @param {string} args.committer.email
 * @param {number} args.committer.timestamp
 * @param {number} args.committer.timezoneOffset
 * @param {string} [args.signingKey]
 *
 * @returns {Promise<string>}
 */

async function _removeNote({
  fs,
  cache,
  onSign,
  gitdir,
  ref = 'refs/notes/commits',
  oid,
  author,
  committer,
  signingKey,
}) {
  // Get the current note commit
  let parent;
  try {
    parent = await GitRefManager.resolve({ gitdir, fs, ref });
  } catch (err) {
    if (!(err instanceof NotFoundError)) {
      throw err
    }
  }

  // I'm using the "empty tree" magic number here for brevity
  const result = await _readTree({
    fs,
    gitdir,
    oid: parent || '4b825dc642cb6eb9a060e54bf8d69288fbee4904',
  });
  let tree = result.tree;

  // Remove the note blob entry from the tree
  tree = tree.filter(entry => entry.path !== oid);

  // Create the new note tree
  const treeOid = await _writeTree({
    fs,
    gitdir,
    tree,
  });

  // Create the new note commit
  const commitOid = await _commit({
    fs,
    cache,
    onSign,
    gitdir,
    ref,
    tree: treeOid,
    parent: parent && [parent],
    message: `Note removed by 'isomorphic-git removeNote'\n`,
    author,
    committer,
    signingKey,
  });

  return commitOid
}

// @ts-check

/**
 * Remove an object note
 *
 * @param {object} args
 * @param {FsClient} args.fs - a file system client
 * @param {SignCallback} [args.onSign] - a PGP signing implementation
 * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path
 * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path
 * @param {string} [args.ref] - The notes ref to look under
 * @param {string} args.oid - The SHA-1 object id of the object to remove the note from.
 * @param {Object} [args.author] - The details about the author.
 * @param {string} [args.author.name] - Default is `user.name` config.
 * @param {string} [args.author.email] - Default is `user.email` config.
 * @param {number} [args.author.timestamp=Math.floor(Date.now()/1000)] - Set the author timestamp field. This is the integer number of seconds since the Unix epoch (1970-01-01 00:00:00).
 * @param {number} [args.author.timezoneOffset] - Set the author timezone offset field. This is the difference, in minutes, from the current timezone to UTC. Default is `(new Date()).getTimezoneOffset()`.
 * @param {Object} [args.committer = author] - The details about the note committer, in the same format as the author parameter. If not specified, the author details are used.
 * @param {string} [args.committer.name] - Default is `user.name` config.
 * @param {string} [args.committer.email] - Default is `user.email` config.
 * @param {number} [args.committer.timestamp=Math.floor(Date.now()/1000)] - Set the committer timestamp field. This is the integer number of seconds since the Unix epoch (1970-01-01 00:00:00).
 * @param {number} [args.committer.timezoneOffset] - Set the committer timezone offset field. This is the difference, in minutes, from the current timezone to UTC. Default is `(new Date()).getTimezoneOffset()`.
 * @param {string} [args.signingKey] - Sign the tag object using this private PGP key.
 * @param {object} [args.cache] - a [cache](cache.md) object
 *
 * @returns {Promise<string>} Resolves successfully with the SHA-1 object id of the commit object for the note removal.
 */

async function removeNote({
  fs: _fs,
  onSign,
  dir,
  gitdir = join(dir, '.git'),
  ref = 'refs/notes/commits',
  oid,
  author: _author,
  committer: _committer,
  signingKey,
  cache = {},
}) {
  try {
    assertParameter('fs', _fs);
    assertParameter('gitdir', gitdir);
    assertParameter('oid', oid);

    const fs = new FileSystem(_fs);

    const author = await normalizeAuthorObject({ fs, gitdir, author: _author });
    if (!author) throw new MissingNameError('author')

    const committer = await normalizeCommitterObject({
      fs,
      gitdir,
      author,
      committer: _committer,
    });
    if (!committer) throw new MissingNameError('committer')

    return await _removeNote({
      fs,
      cache,
      onSign,
      gitdir,
      ref,
      oid,
      author,
      committer,
      signingKey,
    })
  } catch (err) {
    err.caller = 'git.removeNote';
    throw err
  }
}

// @ts-check

/**
 * Rename a branch
 *
 * @param {object} args
 * @param {import('../models/FileSystem.js').FileSystem} args.fs
 * @param {string} args.gitdir
 * @param {string} args.ref - The name of the new branch
 * @param {string} args.oldref - The name of the old branch
 * @param {boolean} [args.checkout = false]
 *
 * @returns {Promise<void>} Resolves successfully when filesystem operations are complete
 */
async function _renameBranch({
  fs,
  gitdir,
  oldref,
  ref,
  checkout = false,
}) {
  if (ref !== lib.clean(ref)) {
    throw new InvalidRefNameError(ref, lib.clean(ref))
  }

  if (oldref !== lib.clean(oldref)) {
    throw new InvalidRefNameError(oldref, lib.clean(oldref))
  }

  const fulloldref = `refs/heads/${oldref}`;
  const fullnewref = `refs/heads/${ref}`;

  const newexist = await GitRefManager.exists({ fs, gitdir, ref: fullnewref });

  if (newexist) {
    throw new AlreadyExistsError('branch', ref, false)
  }

  const value = await GitRefManager.resolve({
    fs,
    gitdir,
    ref: fulloldref,
    depth: 1,
  });

  await GitRefManager.writeRef({ fs, gitdir, ref: fullnewref, value });
  await GitRefManager.deleteRef({ fs, gitdir, ref: fulloldref });

  if (checkout) {
    // Update HEAD
    await GitRefManager.writeSymbolicRef({
      fs,
      gitdir,
      ref: 'HEAD',
      value: fullnewref,
    });
  }
}

// @ts-check

/**
 * Rename a branch
 *
 * @param {object} args
 * @param {FsClient} args.fs - a file system implementation
 * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path
 * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path
 * @param {string} args.ref - What to name the branch
 * @param {string} args.oldref - What the name of the branch was
 * @param {boolean} [args.checkout = false] - Update `HEAD` to point at the newly created branch
 *
 * @returns {Promise<void>} Resolves successfully when filesystem operations are complete
 *
 * @example
 * await git.renameBranch({ fs, dir: '/tutorial', ref: 'main', oldref: 'master' })
 * console.log('done')
 *
 */
async function renameBranch({
  fs,
  dir,
  gitdir = join(dir, '.git'),
  ref,
  oldref,
  checkout = false,
}) {
  try {
    assertParameter('fs', fs);
    assertParameter('gitdir', gitdir);
    assertParameter('ref', ref);
    assertParameter('oldref', oldref);
    return await _renameBranch({
      fs: new FileSystem(fs),
      gitdir,
      ref,
      oldref,
      checkout,
    })
  } catch (err) {
    err.caller = 'git.renameBranch';
    throw err
  }
}

async function hashObject$1({ gitdir, type, object }) {
  return shasum(GitObject.wrap({ type, object }))
}

// @ts-check

/**
 * Reset a file in the git index (aka staging area)
 *
 * Note that this does NOT modify the file in the working directory.
 *
 * @param {object} args
 * @param {FsClient} args.fs - a file system client
 * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path
 * @param {string} [args.gitdir=join(dir, '.git')] - [required] The [git directory](dir-vs-gitdir.md) path
 * @param {string} args.filepath - The path to the file to reset in the index
 * @param {string} [args.ref = 'HEAD'] - A ref to the commit to use
 * @param {object} [args.cache] - a [cache](cache.md) object
 *
 * @returns {Promise<void>} Resolves successfully once the git index has been updated
 *
 * @example
 * await git.resetIndex({ fs, dir: '/tutorial', filepath: 'README.md' })
 * console.log('done')
 *
 */
async function resetIndex({
  fs: _fs,
  dir,
  gitdir = join(dir, '.git'),
  filepath,
  ref = 'HEAD',
  cache = {},
}) {
  try {
    assertParameter('fs', _fs);
    assertParameter('gitdir', gitdir);
    assertParameter('filepath', filepath);
    assertParameter('ref', ref);

    const fs = new FileSystem(_fs);
    // Resolve commit
    let oid = await GitRefManager.resolve({ fs, gitdir, ref });
    let workdirOid;
    try {
      // Resolve blob
      oid = await resolveFilepath({
        fs,
        cache,
        gitdir,
        oid,
        filepath,
      });
    } catch (e) {
      // This means we're resetting the file to a "deleted" state
      oid = null;
    }
    // For files that aren't in the workdir use zeros
    let stats = {
      ctime: new Date(0),
      mtime: new Date(0),
      dev: 0,
      ino: 0,
      mode: 0,
      uid: 0,
      gid: 0,
      size: 0,
    };
    // If the file exists in the workdir...
    const object = dir && (await fs.read(join(dir, filepath)));
    if (object) {
      // ... and has the same hash as the desired state...
      workdirOid = await hashObject$1({
        gitdir,
        type: 'blob',
        object,
      });
      if (oid === workdirOid) {
        // ... use the workdir Stats object
        stats = await fs.lstat(join(dir, filepath));
      }
    }
    await GitIndexManager.acquire({ fs, gitdir, cache }, async function(index) {
      index.delete({ filepath });
      if (oid) {
        index.insert({ filepath, stats, oid });
      }
    });
  } catch (err) {
    err.caller = 'git.reset';
    throw err
  }
}

// @ts-check

/**
 * Get the value of a symbolic ref or resolve a ref to its SHA-1 object id
 *
 * @param {object} args
 * @param {FsClient} args.fs - a file system client
 * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path
 * @param {string} [args.gitdir=join(dir, '.git')] - [required] The [git directory](dir-vs-gitdir.md) path
 * @param {string} args.ref - The ref to resolve
 * @param {number} [args.depth = undefined] - How many symbolic references to follow before returning
 *
 * @returns {Promise<string>} Resolves successfully with a SHA-1 object id or the value of a symbolic ref
 *
 * @example
 * let currentCommit = await git.resolveRef({ fs, dir: '/tutorial', ref: 'HEAD' })
 * console.log(currentCommit)
 * let currentBranch = await git.resolveRef({ fs, dir: '/tutorial', ref: 'HEAD', depth: 2 })
 * console.log(currentBranch)
 *
 */
async function resolveRef({
  fs,
  dir,
  gitdir = join(dir, '.git'),
  ref,
  depth,
}) {
  try {
    assertParameter('fs', fs);
    assertParameter('gitdir', gitdir);
    assertParameter('ref', ref);

    const oid = await GitRefManager.resolve({
      fs: new FileSystem(fs),
      gitdir,
      ref,
      depth,
    });
    return oid
  } catch (err) {
    err.caller = 'git.resolveRef';
    throw err
  }
}

// @ts-check

/**
 * Write an entry to the git config files.
 *
 * *Caveats:*
 * - Currently only the local `$GIT_DIR/config` file can be read or written. However support for the global `~/.gitconfig` and system `$(prefix)/etc/gitconfig` will be added in the future.
 * - The current parser does not support the more exotic features of the git-config file format such as `[include]` and `[includeIf]`.
 *
 * @param {Object} args
 * @param {FsClient} args.fs - a file system implementation
 * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path
 * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path
 * @param {string} args.path - The key of the git config entry
 * @param {string | boolean | number | void} args.value - A value to store at that path. (Use `undefined` as the value to delete a config entry.)
 * @param {boolean} [args.append = false] - If true, will append rather than replace when setting (use with multi-valued config options).
 *
 * @returns {Promise<void>} Resolves successfully when operation completed
 *
 * @example
 * // Write config value
 * await git.setConfig({
 *   fs,
 *   dir: '/tutorial',
 *   path: 'user.name',
 *   value: 'Mr. Test'
 * })
 *
 * // Print out config file
 * let file = await fs.promises.readFile('/tutorial/.git/config', 'utf8')
 * console.log(file)
 *
 * // Delete a config entry
 * await git.setConfig({
 *   fs,
 *   dir: '/tutorial',
 *   path: 'user.name',
 *   value: undefined
 * })
 *
 * // Print out config file
 * file = await fs.promises.readFile('/tutorial/.git/config', 'utf8')
 * console.log(file)
 */
async function setConfig({
  fs: _fs,
  dir,
  gitdir = join(dir, '.git'),
  path,
  value,
  append = false,
}) {
  try {
    assertParameter('fs', _fs);
    assertParameter('gitdir', gitdir);
    assertParameter('path', path);
    // assertParameter('value', value) // We actually allow 'undefined' as a value to unset/delete

    const fs = new FileSystem(_fs);
    const config = await GitConfigManager.get({ fs, gitdir });
    if (append) {
      await config.append(path, value);
    } else {
      await config.set(path, value);
    }
    await GitConfigManager.save({ fs, gitdir, config });
  } catch (err) {
    err.caller = 'git.setConfig';
    throw err
  }
}

// @ts-check

/**
 * Tell whether a file has been changed
 *
 * The possible resolve values are:
 *
 * | status                | description                                                                           |
 * | --------------------- | ------------------------------------------------------------------------------------- |
 * | `"ignored"`           | file ignored by a .gitignore rule                                                     |
 * | `"unmodified"`        | file unchanged from HEAD commit                                                       |
 * | `"*modified"`         | file has modifications, not yet staged                                                |
 * | `"*deleted"`          | file has been removed, but the removal is not yet staged                              |
 * | `"*added"`            | file is untracked, not yet staged                                                     |
 * | `"absent"`            | file not present in HEAD commit, staging area, or working dir                         |
 * | `"modified"`          | file has modifications, staged                                                        |
 * | `"deleted"`           | file has been removed, staged                                                         |
 * | `"added"`             | previously untracked file, staged                                                     |
 * | `"*unmodified"`       | working dir and HEAD commit match, but index differs                                  |
 * | `"*absent"`           | file not present in working dir or HEAD commit, but present in the index              |
 * | `"*undeleted"`        | file was deleted from the index, but is still in the working dir                      |
 * | `"*undeletemodified"` | file was deleted from the index, but is present with modifications in the working dir |
 *
 * @param {object} args
 * @param {FsClient} args.fs - a file system client
 * @param {string} args.dir - The [working tree](dir-vs-gitdir.md) directory path
 * @param {string} [args.gitdir=join(dir, '.git')] - [required] The [git directory](dir-vs-gitdir.md) path
 * @param {string} args.filepath - The path to the file to query
 * @param {object} [args.cache] - a [cache](cache.md) object
 *
 * @returns {Promise<'ignored'|'unmodified'|'*modified'|'*deleted'|'*added'|'absent'|'modified'|'deleted'|'added'|'*unmodified'|'*absent'|'*undeleted'|'*undeletemodified'>} Resolves successfully with the file's git status
 *
 * @example
 * let status = await git.status({ fs, dir: '/tutorial', filepath: 'README.md' })
 * console.log(status)
 *
 */
async function status({
  fs: _fs,
  dir,
  gitdir = join(dir, '.git'),
  filepath,
  cache = {},
}) {
  try {
    assertParameter('fs', _fs);
    assertParameter('gitdir', gitdir);
    assertParameter('filepath', filepath);

    const fs = new FileSystem(_fs);
    const ignored = await GitIgnoreManager.isIgnored({
      fs,
      gitdir,
      dir,
      filepath,
    });
    if (ignored) {
      return 'ignored'
    }
    const headTree = await getHeadTree({ fs, cache, gitdir });
    const treeOid = await getOidAtPath({
      fs,
      cache,
      gitdir,
      tree: headTree,
      path: filepath,
    });
    const indexEntry = await GitIndexManager.acquire(
      { fs, gitdir, cache },
      async function(index) {
        for (const entry of index) {
          if (entry.path === filepath) return entry
        }
        return null
      }
    );
    const stats = await fs.lstat(join(dir, filepath));

    const H = treeOid !== null; // head
    const I = indexEntry !== null; // index
    const W = stats !== null; // working dir

    const getWorkdirOid = async () => {
      if (I && !compareStats(indexEntry, stats)) {
        return indexEntry.oid
      } else {
        const object = await fs.read(join(dir, filepath));
        const workdirOid = await hashObject$1({
          gitdir,
          type: 'blob',
          object,
        });
        // If the oid in the index === working dir oid but stats differed update cache
        if (I && indexEntry.oid === workdirOid) {
          // and as long as our fs.stats aren't bad.
          // size of -1 happens over a BrowserFS HTTP Backend that doesn't serve Content-Length headers
          // (like the Karma webserver) because BrowserFS HTTP Backend uses HTTP HEAD requests to do fs.stat
          if (stats.size !== -1) {
            // We don't await this so we can return faster for one-off cases.
            GitIndexManager.acquire({ fs, gitdir, cache }, async function(
              index
            ) {
              index.insert({ filepath, stats, oid: workdirOid });
            });
          }
        }
        return workdirOid
      }
    };

    if (!H && !W && !I) return 'absent' // ---
    if (!H && !W && I) return '*absent' // -A-
    if (!H && W && !I) return '*added' // --A
    if (!H && W && I) {
      const workdirOid = await getWorkdirOid();
      // @ts-ignore
      return workdirOid === indexEntry.oid ? 'added' : '*added' // -AA : -AB
    }
    if (H && !W && !I) return 'deleted' // A--
    if (H && !W && I) {
      // @ts-ignore
      return treeOid === indexEntry.oid ? '*deleted' : '*deleted' // AA- : AB-
    }
    if (H && W && !I) {
      const workdirOid = await getWorkdirOid();
      return workdirOid === treeOid ? '*undeleted' : '*undeletemodified' // A-A : A-B
    }
    if (H && W && I) {
      const workdirOid = await getWorkdirOid();
      if (workdirOid === treeOid) {
        // @ts-ignore
        return workdirOid === indexEntry.oid ? 'unmodified' : '*unmodified' // AAA : ABA
      } else {
        // @ts-ignore
        return workdirOid === indexEntry.oid ? 'modified' : '*modified' // ABB : AAB
      }
    }
    /*
    ---
    -A-
    --A
    -AA
    -AB
    A--
    AA-
    AB-
    A-A
    A-B
    AAA
    ABA
    ABB
    AAB
    */
  } catch (err) {
    err.caller = 'git.status';
    throw err
  }
}

async function getOidAtPath({ fs, cache, gitdir, tree, path }) {
  if (typeof path === 'string') path = path.split('/');
  const dirname = path.shift();
  for (const entry of tree) {
    if (entry.path === dirname) {
      if (path.length === 0) {
        return entry.oid
      }
      const { type, object } = await _readObject({
        fs,
        cache,
        gitdir,
        oid: entry.oid,
      });
      if (type === 'tree') {
        const tree = GitTree.from(object);
        return getOidAtPath({ fs, cache, gitdir, tree, path })
      }
      if (type === 'blob') {
        throw new ObjectTypeError(entry.oid, type, 'blob', path.join('/'))
      }
    }
  }
  return null
}

async function getHeadTree({ fs, cache, gitdir }) {
  // Get the tree from the HEAD commit.
  let oid;
  try {
    oid = await GitRefManager.resolve({ fs, gitdir, ref: 'HEAD' });
  } catch (e) {
    // Handle fresh branches with no commits
    if (e instanceof NotFoundError) {
      return []
    }
  }
  const { tree } = await _readTree({ fs, cache, gitdir, oid });
  return tree
}

// @ts-check

/**
 * Efficiently get the status of multiple files at once.
 *
 * The returned `StatusMatrix` is admittedly not the easiest format to read.
 * However it conveys a large amount of information in dense format that should make it easy to create reports about the current state of the repository;
 * without having to do multiple, time-consuming isomorphic-git calls.
 * My hope is that the speed and flexibility of the function will make up for the learning curve of interpreting the return value.
 *
 * ```js live
 * // get the status of all the files in 'src'
 * let status = await git.statusMatrix({
 *   fs,
 *   dir: '/tutorial',
 *   filter: f => f.startsWith('src/')
 * })
 * console.log(status)
 * ```
 *
 * ```js live
 * // get the status of all the JSON and Markdown files
 * let status = await git.statusMatrix({
 *   fs,
 *   dir: '/tutorial',
 *   filter: f => f.endsWith('.json') || f.endsWith('.md')
 * })
 * console.log(status)
 * ```
 *
 * The result is returned as a 2D array.
 * The outer array represents the files and/or blobs in the repo, in alphabetical order.
 * The inner arrays describe the status of the file:
 * the first value is the filepath, and the next three are integers
 * representing the HEAD status, WORKDIR status, and STAGE status of the entry.
 *
 * ```js
 * // example StatusMatrix
 * [
 *   ["a.txt", 0, 2, 0], // new, untracked
 *   ["b.txt", 0, 2, 2], // added, staged
 *   ["c.txt", 0, 2, 3], // added, staged, with unstaged changes
 *   ["d.txt", 1, 1, 1], // unmodified
 *   ["e.txt", 1, 2, 1], // modified, unstaged
 *   ["f.txt", 1, 2, 2], // modified, staged
 *   ["g.txt", 1, 2, 3], // modified, staged, with unstaged changes
 *   ["h.txt", 1, 0, 1], // deleted, unstaged
 *   ["i.txt", 1, 0, 0], // deleted, staged
 * ]
 * ```
 *
 * - The HEAD status is either absent (0) or present (1).
 * - The WORKDIR status is either absent (0), identical to HEAD (1), or different from HEAD (2).
 * - The STAGE status is either absent (0), identical to HEAD (1), identical to WORKDIR (2), or different from WORKDIR (3).
 *
 * ```ts
 * type Filename      = string
 * type HeadStatus    = 0 | 1
 * type WorkdirStatus = 0 | 1 | 2
 * type StageStatus   = 0 | 1 | 2 | 3
 *
 * type StatusRow     = [Filename, HeadStatus, WorkdirStatus, StageStatus]
 *
 * type StatusMatrix  = StatusRow[]
 * ```
 *
 * > Think of the natural progression of file modifications as being from HEAD (previous) -> WORKDIR (current) -> STAGE (next).
 * > Then HEAD is "version 1", WORKDIR is "version 2", and STAGE is "version 3".
 * > Then, imagine a "version 0" which is before the file was created.
 * > Then the status value in each column corresponds to the oldest version of the file it is identical to.
 * > (For a file to be identical to "version 0" means the file is deleted.)
 *
 * Here are some examples of queries you can answer using the result:
 *
 * #### Q: What files have been deleted?
 * ```js
 * const FILE = 0, WORKDIR = 2
 *
 * const filenames = (await statusMatrix({ dir }))
 *   .filter(row => row[WORKDIR] === 0)
 *   .map(row => row[FILE])
 * ```
 *
 * #### Q: What files have unstaged changes?
 * ```js
 * const FILE = 0, WORKDIR = 2, STAGE = 3
 *
 * const filenames = (await statusMatrix({ dir }))
 *   .filter(row => row[WORKDIR] !== row[STAGE])
 *   .map(row => row[FILE])
 * ```
 *
 * #### Q: What files have been modified since the last commit?
 * ```js
 * const FILE = 0, HEAD = 1, WORKDIR = 2
 *
 * const filenames = (await statusMatrix({ dir }))
 *   .filter(row => row[HEAD] !== row[WORKDIR])
 *   .map(row => row[FILE])
 * ```
 *
 * #### Q: What files will NOT be changed if I commit right now?
 * ```js
 * const FILE = 0, HEAD = 1, STAGE = 3
 *
 * const filenames = (await statusMatrix({ dir }))
 *   .filter(row => row[HEAD] === row[STAGE])
 *   .map(row => row[FILE])
 * ```
 *
 * For reference, here are all possible combinations:
 *
 * | HEAD | WORKDIR | STAGE | `git status --short` equivalent |
 * | ---- | ------- | ----- | ------------------------------- |
 * | 0    | 0       | 0     | ``                              |
 * | 0    | 0       | 3     | `AD`                            |
 * | 0    | 2       | 0     | `??`                            |
 * | 0    | 2       | 2     | `A `                            |
 * | 0    | 2       | 3     | `AM`                            |
 * | 1    | 0       | 0     | `D `                            |
 * | 1    | 0       | 1     | ` D`                            |
 * | 1    | 0       | 3     | `MD`                            |
 * | 1    | 1       | 0     | `D ` + `??`                     |
 * | 1    | 1       | 1     | ``                              |
 * | 1    | 1       | 3     | `MM`                            |
 * | 1    | 2       | 0     | `D ` + `??`                     |
 * | 1    | 2       | 1     | ` M`                            |
 * | 1    | 2       | 2     | `M `                            |
 * | 1    | 2       | 3     | `MM`                            |
 *
 * @param {object} args
 * @param {FsClient} args.fs - a file system client
 * @param {string} args.dir - The [working tree](dir-vs-gitdir.md) directory path
 * @param {string} [args.gitdir=join(dir, '.git')] - [required] The [git directory](dir-vs-gitdir.md) path
 * @param {string} [args.ref = 'HEAD'] - Optionally specify a different commit to compare against the workdir and stage instead of the HEAD
 * @param {string[]} [args.filepaths = ['.']] - Limit the query to the given files and directories
 * @param {function(string): boolean} [args.filter] - Filter the results to only those whose filepath matches a function.
 * @param {object} [args.cache] - a [cache](cache.md) object
 *
 * @returns {Promise<Array<StatusRow>>} Resolves with a status matrix, described below.
 * @see StatusRow
 */
async function statusMatrix({
  fs: _fs,
  dir,
  gitdir = join(dir, '.git'),
  ref = 'HEAD',
  filepaths = ['.'],
  filter,
  cache = {},
}) {
  try {
    assertParameter('fs', _fs);
    assertParameter('gitdir', gitdir);
    assertParameter('ref', ref);

    const fs = new FileSystem(_fs);
    return await _walk({
      fs,
      cache,
      dir,
      gitdir,
      trees: [TREE({ ref }), WORKDIR(), STAGE()],
      map: async function(filepath, [head, workdir, stage]) {
        // Ignore ignored files, but only if they are not already tracked.
        if (!head && !stage && workdir) {
          if (
            await GitIgnoreManager.isIgnored({
              fs,
              dir,
              filepath,
            })
          ) {
            return null
          }
        }
        // match against base paths
        if (!filepaths.some(base => worthWalking(filepath, base))) {
          return null
        }
        // Late filter against file names
        if (filter) {
          if (!filter(filepath)) return
        }

        // For now, just bail on directories
        const headType = head && (await head.type());
        if (headType === 'tree' || headType === 'special') return
        if (headType === 'commit') return null

        const workdirType = workdir && (await workdir.type());
        if (workdirType === 'tree' || workdirType === 'special') return

        const stageType = stage && (await stage.type());
        if (stageType === 'commit') return null
        if (stageType === 'tree' || stageType === 'special') return

        // Figure out the oids, using the staged oid for the working dir oid if the stats match.
        const headOid = head ? await head.oid() : undefined;
        const stageOid = stage ? await stage.oid() : undefined;
        let workdirOid;
        if (!head && workdir && !stage) {
          // We don't actually NEED the sha. Any sha will do
          // TODO: update this logic to handle N trees instead of just 3.
          workdirOid = '42';
        } else if (workdir) {
          workdirOid = await workdir.oid();
        }
        const entry = [undefined, headOid, workdirOid, stageOid];
        const result = entry.map(value => entry.indexOf(value));
        result.shift(); // remove leading undefined entry
        return [filepath, ...result]
      },
    })
  } catch (err) {
    err.caller = 'git.statusMatrix';
    throw err
  }
}

// @ts-check

/**
 * Create a lightweight tag
 *
 * @param {object} args
 * @param {FsClient} args.fs - a file system client
 * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path
 * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path
 * @param {string} args.ref - What to name the tag
 * @param {string} [args.object = 'HEAD'] - What oid the tag refers to. (Will resolve to oid if value is a ref.) By default, the commit object which is referred by the current `HEAD` is used.
 * @param {boolean} [args.force = false] - Instead of throwing an error if a tag named `ref` already exists, overwrite the existing tag.
 *
 * @returns {Promise<void>} Resolves successfully when filesystem operations are complete
 *
 * @example
 * await git.tag({ fs, dir: '/tutorial', ref: 'test-tag' })
 * console.log('done')
 *
 */
async function tag({
  fs: _fs,
  dir,
  gitdir = join(dir, '.git'),
  ref,
  object,
  force = false,
}) {
  try {
    assertParameter('fs', _fs);
    assertParameter('gitdir', gitdir);
    assertParameter('ref', ref);

    const fs = new FileSystem(_fs);

    if (ref === undefined) {
      throw new MissingParameterError('ref')
    }

    ref = ref.startsWith('refs/tags/') ? ref : `refs/tags/${ref}`;

    // Resolve passed object
    const value = await GitRefManager.resolve({
      fs,
      gitdir,
      ref: object || 'HEAD',
    });

    if (!force && (await GitRefManager.exists({ fs, gitdir, ref }))) {
      throw new AlreadyExistsError('tag', ref)
    }

    await GitRefManager.writeRef({ fs, gitdir, ref, value });
  } catch (err) {
    err.caller = 'git.tag';
    throw err
  }
}

// @ts-check

/**
 * Return the version number of isomorphic-git
 *
 * I don't know why you might need this. I added it just so I could check that I was getting
 * the correct version of the library and not a cached version.
 *
 * @returns {string} the version string taken from package.json at publication time
 *
 * @example
 * console.log(git.version())
 *
 */
function version() {
  try {
    return pkg.version
  } catch (err) {
    err.caller = 'git.version';
    throw err
  }
}

// @ts-check

/**
 * @callback WalkerMap
 * @param {string} filename
 * @param {?WalkerEntry[]} entries
 * @returns {Promise<any>}
 */

/**
 * @callback WalkerReduce
 * @param {any} parent
 * @param {any[]} children
 * @returns {Promise<any>}
 */

/**
 * @callback WalkerIterateCallback
 * @param {WalkerEntry[]} entries
 * @returns {Promise<any[]>}
 */

/**
 * @callback WalkerIterate
 * @param {WalkerIterateCallback} walk
 * @param {IterableIterator<WalkerEntry[]>} children
 * @returns {Promise<any[]>}
 */

/**
 * A powerful recursive tree-walking utility.
 *
 * The `walk` API simplifies gathering detailed information about a tree or comparing all the filepaths in two or more trees.
 * Trees can be git commits, the working directory, or the or git index (staging area).
 * As long as a file or directory is present in at least one of the trees, it will be traversed.
 * Entries are traversed in alphabetical order.
 *
 * The arguments to `walk` are the `trees` you want to traverse, and 3 optional transform functions:
 *  `map`, `reduce`, and `iterate`.
 *
 * ## `TREE`, `WORKDIR`, and `STAGE`
 *
 * Tree walkers are represented by three separate functions that can be imported:
 *
 * ```js
 * import { TREE, WORKDIR, STAGE } from 'isomorphic-git'
 * ```
 *
 * These functions return opaque handles called `Walker`s.
 * The only thing that `Walker` objects are good for is passing into `walk`.
 * Here are the three `Walker`s passed into `walk` by the `statusMatrix` command for example:
 *
 * ```js
 * let ref = 'HEAD'
 *
 * let trees = [TREE({ ref }), WORKDIR(), STAGE()]
 * ```
 *
 * For the arguments, see the doc pages for [TREE](./TREE.md), [WORKDIR](./WORKDIR.md), and [STAGE](./STAGE.md).
 *
 * `map`, `reduce`, and `iterate` allow you control the recursive walk by pruning and transforming `WalkerEntry`s into the desired result.
 *
 * ## WalkerEntry
 *
 * {@link WalkerEntry typedef}
 *
 * `map` receives an array of `WalkerEntry[]` as its main argument, one `WalkerEntry` for each `Walker` in the `trees` argument.
 * The methods are memoized per `WalkerEntry` so calling them multiple times in a `map` function does not adversely impact performance.
 * By only computing these values if needed, you build can build lean, mean, efficient walking machines.
 *
 * ### WalkerEntry#type()
 *
 * Returns the kind as a string. This is normally either `tree` or `blob`.
 *
 * `TREE`, `STAGE`, and `WORKDIR` walkers all return a string.
 *
 * Possible values:
 *
 * - `'tree'` directory
 * - `'blob'` file
 * - `'special'` used by `WORKDIR` to represent irregular files like sockets and FIFOs
 * - `'commit'` used by `TREE` to represent submodules
 *
 * ```js
 * await entry.type()
 * ```
 *
 * ### WalkerEntry#mode()
 *
 * Returns the file mode as a number. Use this to distinguish between regular files, symlinks, and executable files.
 *
 * `TREE`, `STAGE`, and `WORKDIR` walkers all return a number for all `type`s of entries.
 *
 * It has been normalized to one of the 4 values that are allowed in git commits:
 *
 * - `0o40000` directory
 * - `0o100644` file
 * - `0o100755` file (executable)
 * - `0o120000` symlink
 *
 * Tip: to make modes more readable, you can print them to octal using `.toString(8)`.
 *
 * ```js
 * await entry.mode()
 * ```
 *
 * ### WalkerEntry#oid()
 *
 * Returns the SHA-1 object id for blobs and trees.
 *
 * `TREE` walkers return a string for `blob` and `tree` entries.
 *
 * `STAGE` and `WORKDIR` walkers return a string for `blob` entries and `undefined` for `tree` entries.
 *
 * ```js
 * await entry.oid()
 * ```
 *
 * ### WalkerEntry#content()
 *
 * Returns the file contents as a Buffer.
 *
 * `TREE` and `WORKDIR` walkers return a Buffer for `blob` entries and `undefined` for `tree` entries.
 *
 * `STAGE` walkers always return `undefined` since the file contents are never stored in the stage.
 *
 * ```js
 * await entry.content()
 * ```
 *
 * ### WalkerEntry#stat()
 *
 * Returns a normalized subset of filesystem Stat data.
 *
 * `WORKDIR` walkers return a `Stat` for `blob` and `tree` entries.
 *
 * `STAGE` walkers return a `Stat` for `blob` entries and `undefined` for `tree` entries.
 *
 * `TREE` walkers return `undefined` for all entry types.
 *
 * ```js
 * await entry.stat()
 * ```
 *
 * {@link Stat typedef}
 *
 * ## map(string, Array<WalkerEntry|null>) => Promise<any>
 *
 * {@link WalkerMap typedef}
 *
 * This is the function that is called once per entry BEFORE visiting the children of that node.
 *
 * If you return `null` for a `tree` entry, then none of the children of that `tree` entry will be walked.
 *
 * This is a good place for query logic, such as examining the contents of a file.
 * Ultimately, compare all the entries and return any values you are interested in.
 * If you do not return a value (or return undefined) that entry will be filtered from the results.
 *
 * Example 1: Find all the files containing the word 'foo'.
 * ```js
 * async function map(filepath, [head, workdir]) {
 *   let content = (await workdir.content()).toString('utf8')
 *   if (content.contains('foo')) {
 *     return {
 *       filepath,
 *       content
 *     }
 *   }
 * }
 * ```
 *
 * Example 2: Return the difference between the working directory and the HEAD commit
 * ```js
 * const diff = require('diff-lines')
 * async function map(filepath, [head, workdir]) {
 *   return {
 *     filepath,
 *     oid: await head.oid(),
 *     diff: diff((await head.content()).toString('utf8'), (await workdir.content()).toString('utf8'))
 *   }
 * }
 * ```
 *
 * Example 3:
 * ```js
 * let path = require('path')
 * // Only examine files in the directory `cwd`
 * let cwd = 'src/app'
 * async function map (filepath, [head, workdir, stage]) {
 *   if (
 *     // don't skip the root directory
 *     head.fullpath !== '.' &&
 *     // return true for 'src' and 'src/app'
 *     !cwd.startsWith(filepath) &&
 *     // return true for 'src/app/*'
 *     path.dirname(filepath) !== cwd
 *   ) {
 *     return null
 *   } else {
 *     return filepath
 *   }
 * }
 * ```
 *
 * ## reduce(parent, children)
 *
 * {@link WalkerReduce typedef}
 *
 * This is the function that is called once per entry AFTER visiting the children of that node.
 *
 * Default: `async (parent, children) => parent === undefined ? children.flat() : [parent, children].flat()`
 *
 * The default implementation of this function returns all directories and children in a giant flat array.
 * You can define a different accumulation method though.
 *
 * Example: Return a hierarchical structure
 * ```js
 * async function reduce (parent, children) {
 *   return Object.assign(parent, { children })
 * }
 * ```
 *
 * ## iterate(walk, children)
 *
 * {@link WalkerIterate typedef}
 *
 * {@link WalkerIterateCallback typedef}
 *
 * Default: `(walk, children) => Promise.all([...children].map(walk))`
 *
 * The default implementation recurses all children concurrently using Promise.all.
 * However you could use a custom function to traverse children serially or use a global queue to throttle recursion.
 *
 * @param {object} args
 * @param {FsClient} args.fs - a file system client
 * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path
 * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path
 * @param {Walker[]} args.trees - The trees you want to traverse
 * @param {WalkerMap} [args.map] - Transform `WalkerEntry`s into a result form
 * @param {WalkerReduce} [args.reduce] - Control how mapped entries are combined with their parent result
 * @param {WalkerIterate} [args.iterate] - Fine-tune how entries within a tree are iterated over
 * @param {object} [args.cache] - a [cache](cache.md) object
 *
 * @returns {Promise<any>} The finished tree-walking result
 */
async function walk({
  fs,
  dir,
  gitdir = join(dir, '.git'),
  trees,
  map,
  reduce,
  iterate,
  cache = {},
}) {
  try {
    assertParameter('fs', fs);
    assertParameter('gitdir', gitdir);
    assertParameter('trees', trees);

    return await _walk({
      fs: new FileSystem(fs),
      cache,
      dir,
      gitdir,
      trees,
      map,
      reduce,
      iterate,
    })
  } catch (err) {
    err.caller = 'git.walk';
    throw err
  }
}

// @ts-check

/**
 * Write a blob object directly
 *
 * @param {object} args
 * @param {FsClient} args.fs - a file system client
 * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path
 * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path
 * @param {Uint8Array} args.blob - The blob object to write
 *
 * @returns {Promise<string>} Resolves successfully with the SHA-1 object id of the newly written object
 *
 * @example
 * // Manually create a blob.
 * let oid = await git.writeBlob({
 *   fs,
 *   dir: '/tutorial',
 *   blob: new Uint8Array([])
 * })
 *
 * console.log('oid', oid) // should be 'e69de29bb2d1d6434b8b29ae775ad8c2e48c5391'
 *
 */
async function writeBlob({ fs, dir, gitdir = join(dir, '.git'), blob }) {
  try {
    assertParameter('fs', fs);
    assertParameter('gitdir', gitdir);
    assertParameter('blob', blob);

    return await _writeObject({
      fs: new FileSystem(fs),
      gitdir,
      type: 'blob',
      object: blob,
      format: 'content',
    })
  } catch (err) {
    err.caller = 'git.writeBlob';
    throw err
  }
}

// @ts-check

/**
 * @param {object} args
 * @param {import('../models/FileSystem.js').FileSystem} args.fs
 * @param {string} args.gitdir
 * @param {CommitObject} args.commit
 *
 * @returns {Promise<string>}
 * @see CommitObject
 *
 */
async function _writeCommit({ fs, gitdir, commit }) {
  // Convert object to buffer
  const object = GitCommit.from(commit).toObject();
  const oid = await _writeObject({
    fs,
    gitdir,
    type: 'commit',
    object,
    format: 'content',
  });
  return oid
}

// @ts-check

/**
 * Write a commit object directly
 *
 * @param {object} args
 * @param {FsClient} args.fs - a file system client
 * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path
 * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path
 * @param {CommitObject} args.commit - The object to write
 *
 * @returns {Promise<string>} Resolves successfully with the SHA-1 object id of the newly written object
 * @see CommitObject
 *
 */
async function writeCommit({
  fs,
  dir,
  gitdir = join(dir, '.git'),
  commit,
}) {
  try {
    assertParameter('fs', fs);
    assertParameter('gitdir', gitdir);
    assertParameter('commit', commit);

    return await _writeCommit({
      fs: new FileSystem(fs),
      gitdir,
      commit,
    })
  } catch (err) {
    err.caller = 'git.writeCommit';
    throw err
  }
}

// @ts-check

/**
 * Write a git object directly
 *
 * `format` can have the following values:
 *
 * | param      | description                                                                                                                                                      |
 * | ---------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------- |
 * | 'deflated' | Treat `object` as the raw deflate-compressed buffer for an object, meaning can be written to `.git/objects/**` as-is.                                           |
 * | 'wrapped'  | Treat `object` as the inflated object buffer wrapped in the git object header. This is the raw buffer used when calculating the SHA-1 object id of a git object. |
 * | 'content'  | Treat `object` as the object buffer without the git header.                                                                                                      |
 * | 'parsed'   | Treat `object` as a parsed representation of the object.                                                                                                         |
 *
 * If `format` is `'parsed'`, then `object` must match one of the schemas for `CommitObject`, `TreeObject`, `TagObject`, or a `string` (for blobs).
 *
 * {@link CommitObject typedef}
 *
 * {@link TreeObject typedef}
 *
 * {@link TagObject typedef}
 *
 * If `format` is `'content'`, `'wrapped'`, or `'deflated'`, `object` should be a `Uint8Array`.
 *
 * @deprecated
 * > This command is overly complicated.
 * >
 * > If you know the type of object you are writing, use [`writeBlob`](./writeBlob.md), [`writeCommit`](./writeCommit.md), [`writeTag`](./writeTag.md), or [`writeTree`](./writeTree.md).
 *
 * @param {object} args
 * @param {FsClient} args.fs - a file system client
 * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path
 * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path
 * @param {string | Uint8Array | CommitObject | TreeObject | TagObject} args.object - The object to write.
 * @param {'blob'|'tree'|'commit'|'tag'} [args.type] - The kind of object to write.
 * @param {'deflated' | 'wrapped' | 'content' | 'parsed'} [args.format = 'parsed'] - What format the object is in. The possible choices are listed below.
 * @param {string} [args.oid] - If `format` is `'deflated'` then this param is required. Otherwise it is calculated.
 * @param {string} [args.encoding] - If `type` is `'blob'` then `object` will be converted to a Uint8Array using `encoding`.
 *
 * @returns {Promise<string>} Resolves successfully with the SHA-1 object id of the newly written object.
 *
 * @example
 * // Manually create an annotated tag.
 * let sha = await git.resolveRef({ fs, dir: '/tutorial', ref: 'HEAD' })
 * console.log('commit', sha)
 *
 * let oid = await git.writeObject({
 *   fs,
 *   dir: '/tutorial',
 *   type: 'tag',
 *   object: {
 *     object: sha,
 *     type: 'commit',
 *     tag: 'my-tag',
 *     tagger: {
 *       name: 'your name',
 *       email: 'email@example.com',
 *       timestamp: Math.floor(Date.now()/1000),
 *       timezoneOffset: new Date().getTimezoneOffset()
 *     },
 *     message: 'Optional message'
 *   }
 * })
 *
 * console.log('tag', oid)
 *
 */
async function writeObject({
  fs: _fs,
  dir,
  gitdir = join(dir, '.git'),
  type,
  object,
  format = 'parsed',
  oid,
  encoding = undefined,
}) {
  try {
    const fs = new FileSystem(_fs);
    // Convert object to buffer
    if (format === 'parsed') {
      switch (type) {
        case 'commit':
          object = GitCommit.from(object).toObject();
          break
        case 'tree':
          object = GitTree.from(object).toObject();
          break
        case 'blob':
          object = Buffer.from(object, encoding);
          break
        case 'tag':
          object = GitAnnotatedTag.from(object).toObject();
          break
        default:
          throw new ObjectTypeError(oid || '', type, 'blob|commit|tag|tree')
      }
      // GitObjectManager does not know how to serialize content, so we tweak that parameter before passing it.
      format = 'content';
    }
    oid = await _writeObject({
      fs,
      gitdir,
      type,
      object,
      oid,
      format,
    });
    return oid
  } catch (err) {
    err.caller = 'git.writeObject';
    throw err
  }
}

// @ts-check

/**
 * Write a ref which refers to the specified SHA-1 object id, or a symbolic ref which refers to the specified ref.
 *
 * @param {object} args
 * @param {FsClient} args.fs - a file system client
 * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path
 * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path
 * @param {string} args.ref - The name of the ref to write
 * @param {string} args.value - When `symbolic` is false, a ref or an SHA-1 object id. When true, a ref starting with `refs/`.
 * @param {boolean} [args.force = false] - Instead of throwing an error if a ref named `ref` already exists, overwrite the existing ref.
 * @param {boolean} [args.symbolic = false] - Whether the ref is symbolic or not.
 *
 * @returns {Promise<void>} Resolves successfully when filesystem operations are complete
 *
 * @example
 * await git.writeRef({
 *   fs,
 *   dir: '/tutorial',
 *   ref: 'refs/heads/another-branch',
 *   value: 'HEAD'
 * })
 * await git.writeRef({
 *   fs,
 *   dir: '/tutorial',
 *   ref: 'HEAD',
 *   value: 'refs/heads/another-branch',
 *   force: true,
 *   symbolic: true
 * })
 * console.log('done')
 *
 */
async function writeRef({
  fs: _fs,
  dir,
  gitdir = join(dir, '.git'),
  ref,
  value,
  force = false,
  symbolic = false,
}) {
  try {
    assertParameter('fs', _fs);
    assertParameter('gitdir', gitdir);
    assertParameter('ref', ref);
    assertParameter('value', value);

    const fs = new FileSystem(_fs);

    if (ref !== lib.clean(ref)) {
      throw new InvalidRefNameError(ref, lib.clean(ref))
    }

    if (!force && (await GitRefManager.exists({ fs, gitdir, ref }))) {
      throw new AlreadyExistsError('ref', ref)
    }

    if (symbolic) {
      await GitRefManager.writeSymbolicRef({
        fs,
        gitdir,
        ref,
        value,
      });
    } else {
      value = await GitRefManager.resolve({
        fs,
        gitdir,
        ref: value,
      });
      await GitRefManager.writeRef({
        fs,
        gitdir,
        ref,
        value,
      });
    }
  } catch (err) {
    err.caller = 'git.writeRef';
    throw err
  }
}

// @ts-check

/**
 * @param {object} args
 * @param {import('../models/FileSystem.js').FileSystem} args.fs
 * @param {string} args.gitdir
 * @param {TagObject} args.tag
 *
 * @returns {Promise<string>}
 */
async function _writeTag({ fs, gitdir, tag }) {
  // Convert object to buffer
  const object = GitAnnotatedTag.from(tag).toObject();
  const oid = await _writeObject({
    fs,
    gitdir,
    type: 'tag',
    object,
    format: 'content',
  });
  return oid
}

// @ts-check

/**
 * Write an annotated tag object directly
 *
 * @param {object} args
 * @param {FsClient} args.fs - a file system client
 * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path
 * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path
 * @param {TagObject} args.tag - The object to write
 *
 * @returns {Promise<string>} Resolves successfully with the SHA-1 object id of the newly written object
 * @see TagObject
 *
 * @example
 * // Manually create an annotated tag.
 * let sha = await git.resolveRef({ fs, dir: '/tutorial', ref: 'HEAD' })
 * console.log('commit', sha)
 *
 * let oid = await git.writeTag({
 *   fs,
 *   dir: '/tutorial',
 *   tag: {
 *     object: sha,
 *     type: 'commit',
 *     tag: 'my-tag',
 *     tagger: {
 *       name: 'your name',
 *       email: 'email@example.com',
 *       timestamp: Math.floor(Date.now()/1000),
 *       timezoneOffset: new Date().getTimezoneOffset()
 *     },
 *     message: 'Optional message'
 *   }
 * })
 *
 * console.log('tag', oid)
 *
 */
async function writeTag({ fs, dir, gitdir = join(dir, '.git'), tag }) {
  try {
    assertParameter('fs', fs);
    assertParameter('gitdir', gitdir);
    assertParameter('tag', tag);

    return await _writeTag({
      fs: new FileSystem(fs),
      gitdir,
      tag,
    })
  } catch (err) {
    err.caller = 'git.writeTag';
    throw err
  }
}

// @ts-check

/**
 * Write a tree object directly
 *
 * @param {object} args
 * @param {FsClient} args.fs - a file system client
 * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path
 * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path
 * @param {TreeObject} args.tree - The object to write
 *
 * @returns {Promise<string>} Resolves successfully with the SHA-1 object id of the newly written object.
 * @see TreeObject
 * @see TreeEntry
 *
 */
async function writeTree({ fs, dir, gitdir = join(dir, '.git'), tree }) {
  try {
    assertParameter('fs', fs);
    assertParameter('gitdir', gitdir);
    assertParameter('tree', tree);

    return await _writeTree({
      fs: new FileSystem(fs),
      gitdir,
      tree,
    })
  } catch (err) {
    err.caller = 'git.writeTree';
    throw err
  }
}

// default export
var index = {
  Errors,
  STAGE,
  TREE,
  WORKDIR,
  add,
  addNote,
  addRemote,
  annotatedTag,
  branch,
  checkout,
  clone,
  commit,
  getConfig,
  getConfigAll,
  setConfig,
  currentBranch,
  deleteBranch,
  deleteRef,
  deleteRemote,
  deleteTag,
  expandOid,
  expandRef,
  fastForward,
  fetch,
  findMergeBase,
  findRoot,
  getRemoteInfo,
  getRemoteInfo2,
  hashBlob,
  indexPack,
  init,
  isDescendent,
  listBranches,
  listFiles,
  listNotes,
  listRemotes,
  listServerRefs,
  listTags,
  log,
  merge,
  packObjects,
  pull,
  push,
  readBlob,
  readCommit,
  readNote,
  readObject,
  readTag,
  readTree,
  remove,
  removeNote,
  renameBranch,
  resetIndex,
  resolveRef,
  status,
  statusMatrix,
  tag,
  version,
  walk,
  writeBlob,
  writeCommit,
  writeObject,
  writeRef,
  writeTag,
  writeTree,
};

const fs = require("fs");
const path = require("path");
const util = require("util");
const lstat = util.promisify(fs.lstat);
class GitStore extends obsidian.Plugin {
    constructor() {
        super(...arguments);
        //@ts-ignore
        this.BASEPATH = this.app.vault.adapter.basePath;
    }
    /**
     * Checks if this vault contains a .git folder
     * @returns boolean
     */
    async gitIsInitialized() {
        try {
            const gitDir = path.join(this.BASEPATH, ".git");
            if (fs.existsSync(gitDir)) {
                const stats = await lstat(gitDir);
                const isInit = stats.isDirectory();
                console.log("git init", isInit);
                return true;
            }
            else {
                return false;
            }
        }
        catch (err) {
            console.warn(err);
            return false;
        }
    }
    async initGit() {
        await index.init({ fs, dir: this.BASEPATH });
    }
    async onload() {
        console.log("Loading git store.");
        obsidian.addIcon("git-compare", `<svg ig="git-compare" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path d="M102.4 51.2v25.6c14.1 0 25.6 11.5 25.6 25.6 0 14.1-11.5 25.6-25.6 25.6-14.1 0-25.6-11.5-25.6-25.6 0-14.1 11.5-25.6 25.6-25.6V25.6C60 25.6 25.6 60 25.6 102.4s34.4 76.8 76.8 76.8 76.8-34.4 76.8-76.8-34.4-76.8-76.8-76.8v25.6zM409.6 358.4V384c14.1 0 25.6 11.5 25.6 25.6 0 14.1-11.5 25.6-25.6 25.6-14.1 0-25.6-11.5-25.6-25.6 0-14.1 11.5-25.6 25.6-25.6v-51.2c-42.4 0-76.8 34.4-76.8 76.8s34.4 76.8 76.8 76.8 76.8-34.4 76.8-76.8-34.4-76.8-76.8-76.8v25.6z"/><path d="M230.4 128h128c14.1 0 25.6 11.5 25.6 25.6v204.8c0 14.1 11.5 25.6 25.6 25.6s25.6-11.5 25.6-25.6V153.6c0-42.4-34.4-76.8-76.8-76.8h-128c-14.1 0-25.6 11.5-25.6 25.6 0 14.1 11.5 25.6 25.6 25.6z"/><path d="M325.3 161.1l-58.7-58.7 58.7-58.7c10-10 10-26.2 0-36.2-10-10-26.2-10-36.2 0l-76.8 76.8c-4.8 4.8-7.5 11.4-7.5 18.1 0 6.7 2.7 13.3 7.5 18.1l76.8 76.8c10 10 26.2 10 36.2 0 10-10 10-26.2 0-36.2zM281.6 384h-128c-14.1 0-25.6-11.5-25.6-25.6V153.6c0-14.1-11.5-25.6-25.6-25.6-14.1 0-25.6 11.5-25.6 25.6v204.8c0 42.4 34.4 76.8 76.8 76.8h128c14.1 0 25.6-11.5 25.6-25.6 0-14.1-11.5-25.6-25.6-25.6z"/><path d="M186.7 350.9l58.7 58.7-58.7 58.7c-10 10-10 26.2 0 36.2 10 10 26.2 10 36.2 0l76.8-76.8c4.8-4.8 7.5-11.4 7.5-18.1 0-6.7-2.7-13.3-7.5-18.1l-76.8-76.8c-10-10-26.2-10-36.2 0-10 10-10 26.2 0 36.2z"/></svg>`);
        this.addRibbonIcon("git-compare", "git sync", (eve) => {
            console.log(eve);
        });
        const gitReady = await this.gitIsInitialized();
        if (!gitReady) {
            this.initGit();
        }
        let status = await index.status({
            fs,
            dir: this.BASEPATH,
            filepath: "readme.md",
        });
        console.log(status);
        console.log(this.BASEPATH);
        /* this.registerObsidianProtocolHandler("open", ()=>{
                console.log('overriden open obsidian protocol')
            }) */
    }
}

module.exports = GitStore;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWFpbi5qcyIsInNvdXJjZXMiOlsiLi4vbm9kZV9tb2R1bGVzL2FzeW5jLWxvY2svbGliL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2FzeW5jLWxvY2svaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvaW5oZXJpdHMvaW5oZXJpdHNfYnJvd3Nlci5qcyIsIi4uL25vZGVfbW9kdWxlcy9pbmhlcml0cy9pbmhlcml0cy5qcyIsIi4uL25vZGVfbW9kdWxlcy9zYWZlLWJ1ZmZlci9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9zaGEuanMvaGFzaC5qcyIsIi4uL25vZGVfbW9kdWxlcy9zaGEuanMvc2hhMS5qcyIsIi4uL25vZGVfbW9kdWxlcy9jcmMtMzIvY3JjMzIuanMiLCIuLi9ub2RlX21vZHVsZXMvcGFrby9saWIvdXRpbHMvY29tbW9uLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvdHJlZXMuanMiLCIuLi9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9hZGxlcjMyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvY3JjMzIuanMiLCIuLi9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9tZXNzYWdlcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2RlZmxhdGUuanMiLCIuLi9ub2RlX21vZHVsZXMvcGFrby9saWIvdXRpbHMvc3RyaW5ncy5qcyIsIi4uL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL3pzdHJlYW0uanMiLCIuLi9ub2RlX21vZHVsZXMvcGFrby9saWIvZGVmbGF0ZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2luZmZhc3QuanMiLCIuLi9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9pbmZ0cmVlcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2luZmxhdGUuanMiLCIuLi9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9jb25zdGFudHMuanMiLCIuLi9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9nemhlYWRlci5qcyIsIi4uL25vZGVfbW9kdWxlcy9wYWtvL2xpYi9pbmZsYXRlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3Bha28vaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvaWdub3JlL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2lzb21vcnBoaWMtZ2l0L25vZGVfbW9kdWxlcy9waWZ5L2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NsZWFuLWdpdC1yZWYvbGliL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2RpZmYzL29ucC5qcyIsIi4uL25vZGVfbW9kdWxlcy9kaWZmMy9kaWZmMy5qcyIsIi4uL25vZGVfbW9kdWxlcy9pc29tb3JwaGljLWdpdC9pbmRleC5qcyIsIi4uL3NyYy9tYWluLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIEFzeW5jTG9jayA9IGZ1bmN0aW9uIChvcHRzKSB7XG5cdG9wdHMgPSBvcHRzIHx8IHt9O1xuXG5cdHRoaXMuUHJvbWlzZSA9IG9wdHMuUHJvbWlzZSB8fCBQcm9taXNlO1xuXG5cdC8vIGZvcm1hdDoge2tleSA6IFtmbiwgZm5dfVxuXHQvLyBxdWV1ZXNba2V5XSA9IG51bGwgaW5kaWNhdGVzIG5vIGpvYiBydW5uaW5nIGZvciBrZXlcblx0dGhpcy5xdWV1ZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG5cdC8vIGxvY2sgaXMgcmVlbnRyYW50IGZvciBzYW1lIGRvbWFpblxuXHR0aGlzLmRvbWFpblJlZW50cmFudCA9IG9wdHMuZG9tYWluUmVlbnRyYW50IHx8IGZhbHNlO1xuXHRpZiAodGhpcy5kb21haW5SZWVudHJhbnQpIHtcblx0XHRpZiAodHlwZW9mIHByb2Nlc3MgPT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiBwcm9jZXNzLmRvbWFpbiA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihcblx0XHRcdFx0J0RvbWFpbi1yZWVudHJhbnQgbG9ja3MgcmVxdWlyZSBgcHJvY2Vzcy5kb21haW5gIHRvIGV4aXN0LiBQbGVhc2UgZmxpcCBgb3B0cy5kb21haW5SZWVudHJhbnQgPSBmYWxzZWAsICcgK1xuXHRcdFx0XHQndXNlIGEgTm9kZUpTIHZlcnNpb24gdGhhdCBzdGlsbCBpbXBsZW1lbnRzIERvbWFpbiwgb3IgaW5zdGFsbCBhIGJyb3dzZXIgcG9seWZpbGwuJyk7XG5cdFx0fVxuXHRcdC8vIGRvbWFpbiBvZiBjdXJyZW50IHJ1bm5pbmcgZnVuYyB7a2V5IDogZm59XG5cdFx0dGhpcy5kb21haW5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblx0fVxuXG5cdHRoaXMudGltZW91dCA9IG9wdHMudGltZW91dCB8fCBBc3luY0xvY2suREVGQVVMVF9USU1FT1VUO1xuXHRpZiAob3B0cy5tYXhQZW5kaW5nID09PSBJbmZpbml0eSB8fCAoTnVtYmVyLmlzSW50ZWdlcihvcHRzLm1heFBlbmRpbmcpICYmIG9wdHMubWF4UGVuZGluZyA+PSAwKSkge1xuXHRcdHRoaXMubWF4UGVuZGluZyA9IG9wdHMubWF4UGVuZGluZztcblx0fSBlbHNlIHtcblx0XHR0aGlzLm1heFBlbmRpbmcgPSBBc3luY0xvY2suREVGQVVMVF9NQVhfUEVORElORztcblx0fVxufTtcblxuQXN5bmNMb2NrLkRFRkFVTFRfVElNRU9VVCA9IDA7IC8vTmV2ZXJcbkFzeW5jTG9jay5ERUZBVUxUX01BWF9QRU5ESU5HID0gMTAwMDtcblxuLyoqXG4gKiBBY3F1aXJlIExvY2tzXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IGtleSBcdHJlc291cmNlIGtleSBvciBrZXlzIHRvIGxvY2tcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGZuIFx0YXN5bmMgZnVuY3Rpb25cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNiIFx0Y2FsbGJhY2sgZnVuY3Rpb24sIG90aGVyd2lzZSB3aWxsIHJldHVybiBhIHByb21pc2VcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIFx0b3B0aW9uc1xuICovXG5Bc3luY0xvY2sucHJvdG90eXBlLmFjcXVpcmUgPSBmdW5jdGlvbiAoa2V5LCBmbiwgY2IsIG9wdHMpIHtcblx0aWYgKEFycmF5LmlzQXJyYXkoa2V5KSkge1xuXHRcdHJldHVybiB0aGlzLl9hY3F1aXJlQmF0Y2goa2V5LCBmbiwgY2IsIG9wdHMpO1xuXHR9XG5cblx0aWYgKHR5cGVvZiAoZm4pICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCdZb3UgbXVzdCBwYXNzIGEgZnVuY3Rpb24gdG8gZXhlY3V0ZScpO1xuXHR9XG5cblx0Ly8gZmF1eC1kZWZlcnJlZCBwcm9taXNlIHVzaW5nIG5ldyBQcm9taXNlKCkgKGFzIFByb21pc2UuZGVmZXIgaXMgZGVwcmVjYXRlZClcblx0dmFyIGRlZmVycmVkUmVzb2x2ZSA9IG51bGw7XG5cdHZhciBkZWZlcnJlZFJlamVjdCA9IG51bGw7XG5cdHZhciBkZWZlcnJlZCA9IG51bGw7XG5cblx0aWYgKHR5cGVvZiAoY2IpICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0b3B0cyA9IGNiO1xuXHRcdGNiID0gbnVsbDtcblxuXHRcdC8vIHdpbGwgcmV0dXJuIGEgcHJvbWlzZVxuXHRcdGRlZmVycmVkID0gbmV3IHRoaXMuUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcblx0XHRcdGRlZmVycmVkUmVzb2x2ZSA9IHJlc29sdmU7XG5cdFx0XHRkZWZlcnJlZFJlamVjdCA9IHJlamVjdDtcblx0XHR9KTtcblx0fVxuXG5cdG9wdHMgPSBvcHRzIHx8IHt9O1xuXG5cdHZhciByZXNvbHZlZCA9IGZhbHNlO1xuXHR2YXIgdGltZXIgPSBudWxsO1xuXHR2YXIgc2VsZiA9IHRoaXM7XG5cblx0dmFyIGRvbmUgPSBmdW5jdGlvbiAobG9ja2VkLCBlcnIsIHJldCkge1xuXHRcdGlmIChsb2NrZWQpIHtcblx0XHRcdGlmIChzZWxmLnF1ZXVlc1trZXldLmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0XHRkZWxldGUgc2VsZi5xdWV1ZXNba2V5XTtcblx0XHRcdH1cblx0XHRcdGlmIChzZWxmLmRvbWFpblJlZW50cmFudCkge1xuXHRcdFx0XHRkZWxldGUgc2VsZi5kb21haW5zW2tleV07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCFyZXNvbHZlZCkge1xuXHRcdFx0aWYgKCFkZWZlcnJlZCkge1xuXHRcdFx0XHRpZiAodHlwZW9mIChjYikgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0XHRjYihlcnIsIHJldCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHQvL3Byb21pc2UgbW9kZVxuXHRcdFx0XHRpZiAoZXJyKSB7XG5cdFx0XHRcdFx0ZGVmZXJyZWRSZWplY3QoZXJyKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRkZWZlcnJlZFJlc29sdmUocmV0KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmVzb2x2ZWQgPSB0cnVlO1xuXHRcdH1cblxuXHRcdGlmIChsb2NrZWQpIHtcblx0XHRcdC8vcnVuIG5leHQgZnVuY1xuXHRcdFx0aWYgKCEhc2VsZi5xdWV1ZXNba2V5XSAmJiBzZWxmLnF1ZXVlc1trZXldLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0c2VsZi5xdWV1ZXNba2V5XS5zaGlmdCgpKCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdHZhciBleGVjID0gZnVuY3Rpb24gKGxvY2tlZCkge1xuXHRcdGlmIChyZXNvbHZlZCkgeyAvLyBtYXkgZHVlIHRvIHRpbWVkIG91dFxuXHRcdFx0cmV0dXJuIGRvbmUobG9ja2VkKTtcblx0XHR9XG5cblx0XHRpZiAodGltZXIpIHtcblx0XHRcdGNsZWFyVGltZW91dCh0aW1lcik7XG5cdFx0XHR0aW1lciA9IG51bGw7XG5cdFx0fVxuXG5cdFx0aWYgKHNlbGYuZG9tYWluUmVlbnRyYW50ICYmIGxvY2tlZCkge1xuXHRcdFx0c2VsZi5kb21haW5zW2tleV0gPSBwcm9jZXNzLmRvbWFpbjtcblx0XHR9XG5cblx0XHQvLyBDYWxsYmFjayBtb2RlXG5cdFx0aWYgKGZuLmxlbmd0aCA9PT0gMSkge1xuXHRcdFx0dmFyIGNhbGxlZCA9IGZhbHNlO1xuXHRcdFx0Zm4oZnVuY3Rpb24gKGVyciwgcmV0KSB7XG5cdFx0XHRcdGlmICghY2FsbGVkKSB7XG5cdFx0XHRcdFx0Y2FsbGVkID0gdHJ1ZTtcblx0XHRcdFx0XHRkb25lKGxvY2tlZCwgZXJyLCByZXQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHQvLyBQcm9taXNlIG1vZGVcblx0XHRcdHNlbGYuX3Byb21pc2VUcnkoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRyZXR1cm4gZm4oKTtcblx0XHRcdH0pXG5cdFx0XHQudGhlbihmdW5jdGlvbihyZXQpe1xuXHRcdFx0XHRkb25lKGxvY2tlZCwgdW5kZWZpbmVkLCByZXQpO1xuXHRcdFx0fSwgZnVuY3Rpb24oZXJyb3Ipe1xuXHRcdFx0XHRkb25lKGxvY2tlZCwgZXJyb3IpO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHR9O1xuXHRpZiAoc2VsZi5kb21haW5SZWVudHJhbnQgJiYgISFwcm9jZXNzLmRvbWFpbikge1xuXHRcdGV4ZWMgPSBwcm9jZXNzLmRvbWFpbi5iaW5kKGV4ZWMpO1xuXHR9XG5cblx0aWYgKCFzZWxmLnF1ZXVlc1trZXldKSB7XG5cdFx0c2VsZi5xdWV1ZXNba2V5XSA9IFtdO1xuXHRcdGV4ZWModHJ1ZSk7XG5cdH1cblx0ZWxzZSBpZiAoc2VsZi5kb21haW5SZWVudHJhbnQgJiYgISFwcm9jZXNzLmRvbWFpbiAmJiBwcm9jZXNzLmRvbWFpbiA9PT0gc2VsZi5kb21haW5zW2tleV0pIHtcblx0XHQvLyBJZiBjb2RlIGlzIGluIHRoZSBzYW1lIGRvbWFpbiBvZiBjdXJyZW50IHJ1bm5pbmcgdGFzaywgcnVuIGl0IGRpcmVjdGx5XG5cdFx0Ly8gU2luY2UgbG9jayBpcyByZS1lbnRlcmFibGVcblx0XHRleGVjKGZhbHNlKTtcblx0fVxuXHRlbHNlIGlmIChzZWxmLnF1ZXVlc1trZXldLmxlbmd0aCA+PSBzZWxmLm1heFBlbmRpbmcpIHtcblx0XHRkb25lKGZhbHNlLCBuZXcgRXJyb3IoJ1RvbyBtdWNoIHBlbmRpbmcgdGFza3MnKSk7XG5cdH1cblx0ZWxzZSB7XG5cdFx0dmFyIHRhc2tGbiA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdGV4ZWModHJ1ZSk7XG5cdFx0fTtcblx0XHRpZiAob3B0cy5za2lwUXVldWUpIHtcblx0XHRcdHNlbGYucXVldWVzW2tleV0udW5zaGlmdCh0YXNrRm4pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzZWxmLnF1ZXVlc1trZXldLnB1c2godGFza0ZuKTtcblx0XHR9XG5cblx0XHR2YXIgdGltZW91dCA9IG9wdHMudGltZW91dCB8fCBzZWxmLnRpbWVvdXQ7XG5cdFx0aWYgKHRpbWVvdXQpIHtcblx0XHRcdHRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHRpbWVyID0gbnVsbDtcblx0XHRcdFx0ZG9uZShmYWxzZSwgbmV3IEVycm9yKCdhc3luYy1sb2NrIHRpbWVkIG91dCcpKTtcblx0XHRcdH0sIHRpbWVvdXQpO1xuXHRcdH1cblx0fVxuXG5cdGlmIChkZWZlcnJlZCkge1xuXHRcdHJldHVybiBkZWZlcnJlZDtcblx0fVxufTtcblxuLypcbiAqIEJlbG93IGlzIGhvdyB0aGlzIGZ1bmN0aW9uIHdvcmtzOlxuICpcbiAqIEVxdWl2YWxlbnQgY29kZTpcbiAqIHNlbGYuYWNxdWlyZShrZXkxLCBmdW5jdGlvbihjYil7XG4gKiAgICAgc2VsZi5hY3F1aXJlKGtleTIsIGZ1bmN0aW9uKGNiKXtcbiAqICAgICAgICAgc2VsZi5hY3F1aXJlKGtleTMsIGZuLCBjYik7XG4gKiAgICAgfSwgY2IpO1xuICogfSwgY2IpO1xuICpcbiAqIEVxdWl2YWxlbnQgY29kZTpcbiAqIHZhciBmbjMgPSBnZXRGbihrZXkzLCBmbik7XG4gKiB2YXIgZm4yID0gZ2V0Rm4oa2V5MiwgZm4zKTtcbiAqIHZhciBmbjEgPSBnZXRGbihrZXkxLCBmbjIpO1xuICogZm4xKGNiKTtcbiAqL1xuQXN5bmNMb2NrLnByb3RvdHlwZS5fYWNxdWlyZUJhdGNoID0gZnVuY3Rpb24gKGtleXMsIGZuLCBjYiwgb3B0cykge1xuXHRpZiAodHlwZW9mIChjYikgIT09ICdmdW5jdGlvbicpIHtcblx0XHRvcHRzID0gY2I7XG5cdFx0Y2IgPSBudWxsO1xuXHR9XG5cblx0dmFyIHNlbGYgPSB0aGlzO1xuXHR2YXIgZ2V0Rm4gPSBmdW5jdGlvbiAoa2V5LCBmbikge1xuXHRcdHJldHVybiBmdW5jdGlvbiAoY2IpIHtcblx0XHRcdHNlbGYuYWNxdWlyZShrZXksIGZuLCBjYiwgb3B0cyk7XG5cdFx0fTtcblx0fTtcblxuXHR2YXIgZm54ID0gZm47XG5cdGtleXMucmV2ZXJzZSgpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuXHRcdGZueCA9IGdldEZuKGtleSwgZm54KTtcblx0fSk7XG5cblx0aWYgKHR5cGVvZiAoY2IpID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0Zm54KGNiKTtcblx0fVxuXHRlbHNlIHtcblx0XHRyZXR1cm4gbmV3IHRoaXMuUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG5cdFx0XHQvLyBjaGVjayBmb3IgcHJvbWlzZSBtb2RlIGluIGNhc2Uga2V5cyBpcyBlbXB0eSBhcnJheVxuXHRcdFx0aWYgKGZueC5sZW5ndGggPT09IDEpIHtcblx0XHRcdFx0Zm54KGZ1bmN0aW9uIChlcnIsIHJldCkge1xuXHRcdFx0XHRcdGlmIChlcnIpIHtcblx0XHRcdFx0XHRcdHJlamVjdChlcnIpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdHJlc29sdmUocmV0KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmVzb2x2ZShmbngoKSk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH1cbn07XG5cbi8qXG4gKlx0V2hldGhlciB0aGVyZSBpcyBhbnkgcnVubmluZyBvciBwZW5kaW5nIGFzeW5jRnVuY1xuICpcbiAqXHRAcGFyYW0ge1N0cmluZ30ga2V5XG4gKi9cbkFzeW5jTG9jay5wcm90b3R5cGUuaXNCdXN5ID0gZnVuY3Rpb24gKGtleSkge1xuXHRpZiAoIWtleSkge1xuXHRcdHJldHVybiBPYmplY3Qua2V5cyh0aGlzLnF1ZXVlcykubGVuZ3RoID4gMDtcblx0fVxuXHRlbHNlIHtcblx0XHRyZXR1cm4gISF0aGlzLnF1ZXVlc1trZXldO1xuXHR9XG59O1xuXG4vKipcbiAqIFByb21pc2UudHJ5KCkgaW1wbGVtZW50YXRpb24gdG8gYmVjb21lIGluZGVwZW5kZW50IG9mIFEtc3BlY2lmaWMgbWV0aG9kc1xuICovXG5Bc3luY0xvY2sucHJvdG90eXBlLl9wcm9taXNlVHJ5ID0gZnVuY3Rpb24oZm4pIHtcblx0dHJ5IHtcblx0XHRyZXR1cm4gdGhpcy5Qcm9taXNlLnJlc29sdmUoZm4oKSk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRyZXR1cm4gdGhpcy5Qcm9taXNlLnJlamVjdChlKTtcblx0fVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBBc3luY0xvY2s7XG4iLCIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliJyk7XG4iLCJpZiAodHlwZW9mIE9iamVjdC5jcmVhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgLy8gaW1wbGVtZW50YXRpb24gZnJvbSBzdGFuZGFyZCBub2RlLmpzICd1dGlsJyBtb2R1bGVcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBpZiAoc3VwZXJDdG9yKSB7XG4gICAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgICAgY3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ3Rvci5wcm90b3R5cGUsIHtcbiAgICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgICB2YWx1ZTogY3RvcixcbiAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gIH07XG59IGVsc2Uge1xuICAvLyBvbGQgc2Nob29sIHNoaW0gZm9yIG9sZCBicm93c2Vyc1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGlmIChzdXBlckN0b3IpIHtcbiAgICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgICB2YXIgVGVtcEN0b3IgPSBmdW5jdGlvbiAoKSB7fVxuICAgICAgVGVtcEN0b3IucHJvdG90eXBlID0gc3VwZXJDdG9yLnByb3RvdHlwZVxuICAgICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKVxuICAgICAgY3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjdG9yXG4gICAgfVxuICB9XG59XG4iLCJ0cnkge1xuICB2YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgaWYgKHR5cGVvZiB1dGlsLmluaGVyaXRzICE9PSAnZnVuY3Rpb24nKSB0aHJvdyAnJztcbiAgbW9kdWxlLmV4cG9ydHMgPSB1dGlsLmluaGVyaXRzO1xufSBjYXRjaCAoZSkge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vaW5oZXJpdHNfYnJvd3Nlci5qcycpO1xufVxuIiwiLyogZXNsaW50LWRpc2FibGUgbm9kZS9uby1kZXByZWNhdGVkLWFwaSAqL1xudmFyIGJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpXG52YXIgQnVmZmVyID0gYnVmZmVyLkJ1ZmZlclxuXG4vLyBhbHRlcm5hdGl2ZSB0byB1c2luZyBPYmplY3Qua2V5cyBmb3Igb2xkIGJyb3dzZXJzXG5mdW5jdGlvbiBjb3B5UHJvcHMgKHNyYywgZHN0KSB7XG4gIGZvciAodmFyIGtleSBpbiBzcmMpIHtcbiAgICBkc3Rba2V5XSA9IHNyY1trZXldXG4gIH1cbn1cbmlmIChCdWZmZXIuZnJvbSAmJiBCdWZmZXIuYWxsb2MgJiYgQnVmZmVyLmFsbG9jVW5zYWZlICYmIEJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBidWZmZXJcbn0gZWxzZSB7XG4gIC8vIENvcHkgcHJvcGVydGllcyBmcm9tIHJlcXVpcmUoJ2J1ZmZlcicpXG4gIGNvcHlQcm9wcyhidWZmZXIsIGV4cG9ydHMpXG4gIGV4cG9ydHMuQnVmZmVyID0gU2FmZUJ1ZmZlclxufVxuXG5mdW5jdGlvbiBTYWZlQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG4vLyBDb3B5IHN0YXRpYyBtZXRob2RzIGZyb20gQnVmZmVyXG5jb3B5UHJvcHMoQnVmZmVyLCBTYWZlQnVmZmVyKVxuXG5TYWZlQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBub3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHJldHVybiBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cblNhZmVCdWZmZXIuYWxsb2MgPSBmdW5jdGlvbiAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHZhciBidWYgPSBCdWZmZXIoc2l6ZSlcbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnKSB7XG4gICAgICBidWYuZmlsbChmaWxsLCBlbmNvZGluZylcbiAgICB9IGVsc2Uge1xuICAgICAgYnVmLmZpbGwoZmlsbClcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYnVmLmZpbGwoMClcbiAgfVxuICByZXR1cm4gYnVmXG59XG5cblNhZmVCdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlcihzaXplKVxufVxuXG5TYWZlQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfVxuICByZXR1cm4gYnVmZmVyLlNsb3dCdWZmZXIoc2l6ZSlcbn1cbiIsInZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxuXG4vLyBwcm90b3R5cGUgY2xhc3MgZm9yIGhhc2ggZnVuY3Rpb25zXG5mdW5jdGlvbiBIYXNoIChibG9ja1NpemUsIGZpbmFsU2l6ZSkge1xuICB0aGlzLl9ibG9jayA9IEJ1ZmZlci5hbGxvYyhibG9ja1NpemUpXG4gIHRoaXMuX2ZpbmFsU2l6ZSA9IGZpbmFsU2l6ZVxuICB0aGlzLl9ibG9ja1NpemUgPSBibG9ja1NpemVcbiAgdGhpcy5fbGVuID0gMFxufVxuXG5IYXNoLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoZGF0YSwgZW5jKSB7XG4gIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmMgPSBlbmMgfHwgJ3V0ZjgnXG4gICAgZGF0YSA9IEJ1ZmZlci5mcm9tKGRhdGEsIGVuYylcbiAgfVxuXG4gIHZhciBibG9jayA9IHRoaXMuX2Jsb2NrXG4gIHZhciBibG9ja1NpemUgPSB0aGlzLl9ibG9ja1NpemVcbiAgdmFyIGxlbmd0aCA9IGRhdGEubGVuZ3RoXG4gIHZhciBhY2N1bSA9IHRoaXMuX2xlblxuXG4gIGZvciAodmFyIG9mZnNldCA9IDA7IG9mZnNldCA8IGxlbmd0aDspIHtcbiAgICB2YXIgYXNzaWduZWQgPSBhY2N1bSAlIGJsb2NrU2l6ZVxuICAgIHZhciByZW1haW5kZXIgPSBNYXRoLm1pbihsZW5ndGggLSBvZmZzZXQsIGJsb2NrU2l6ZSAtIGFzc2lnbmVkKVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZW1haW5kZXI7IGkrKykge1xuICAgICAgYmxvY2tbYXNzaWduZWQgKyBpXSA9IGRhdGFbb2Zmc2V0ICsgaV1cbiAgICB9XG5cbiAgICBhY2N1bSArPSByZW1haW5kZXJcbiAgICBvZmZzZXQgKz0gcmVtYWluZGVyXG5cbiAgICBpZiAoKGFjY3VtICUgYmxvY2tTaXplKSA9PT0gMCkge1xuICAgICAgdGhpcy5fdXBkYXRlKGJsb2NrKVxuICAgIH1cbiAgfVxuXG4gIHRoaXMuX2xlbiArPSBsZW5ndGhcbiAgcmV0dXJuIHRoaXNcbn1cblxuSGFzaC5wcm90b3R5cGUuZGlnZXN0ID0gZnVuY3Rpb24gKGVuYykge1xuICB2YXIgcmVtID0gdGhpcy5fbGVuICUgdGhpcy5fYmxvY2tTaXplXG5cbiAgdGhpcy5fYmxvY2tbcmVtXSA9IDB4ODBcblxuICAvLyB6ZXJvIChyZW0gKyAxKSB0cmFpbGluZyBiaXRzLCB3aGVyZSAocmVtICsgMSkgaXMgdGhlIHNtYWxsZXN0XG4gIC8vIG5vbi1uZWdhdGl2ZSBzb2x1dGlvbiB0byB0aGUgZXF1YXRpb24gKGxlbmd0aCArIDEgKyAocmVtICsgMSkpID09PSBmaW5hbFNpemUgbW9kIGJsb2NrU2l6ZVxuICB0aGlzLl9ibG9jay5maWxsKDAsIHJlbSArIDEpXG5cbiAgaWYgKHJlbSA+PSB0aGlzLl9maW5hbFNpemUpIHtcbiAgICB0aGlzLl91cGRhdGUodGhpcy5fYmxvY2spXG4gICAgdGhpcy5fYmxvY2suZmlsbCgwKVxuICB9XG5cbiAgdmFyIGJpdHMgPSB0aGlzLl9sZW4gKiA4XG5cbiAgLy8gdWludDMyXG4gIGlmIChiaXRzIDw9IDB4ZmZmZmZmZmYpIHtcbiAgICB0aGlzLl9ibG9jay53cml0ZVVJbnQzMkJFKGJpdHMsIHRoaXMuX2Jsb2NrU2l6ZSAtIDQpXG5cbiAgLy8gdWludDY0XG4gIH0gZWxzZSB7XG4gICAgdmFyIGxvd0JpdHMgPSAoYml0cyAmIDB4ZmZmZmZmZmYpID4+PiAwXG4gICAgdmFyIGhpZ2hCaXRzID0gKGJpdHMgLSBsb3dCaXRzKSAvIDB4MTAwMDAwMDAwXG5cbiAgICB0aGlzLl9ibG9jay53cml0ZVVJbnQzMkJFKGhpZ2hCaXRzLCB0aGlzLl9ibG9ja1NpemUgLSA4KVxuICAgIHRoaXMuX2Jsb2NrLndyaXRlVUludDMyQkUobG93Qml0cywgdGhpcy5fYmxvY2tTaXplIC0gNClcbiAgfVxuXG4gIHRoaXMuX3VwZGF0ZSh0aGlzLl9ibG9jaylcbiAgdmFyIGhhc2ggPSB0aGlzLl9oYXNoKClcblxuICByZXR1cm4gZW5jID8gaGFzaC50b1N0cmluZyhlbmMpIDogaGFzaFxufVxuXG5IYXNoLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ191cGRhdGUgbXVzdCBiZSBpbXBsZW1lbnRlZCBieSBzdWJjbGFzcycpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gSGFzaFxuIiwiLypcbiAqIEEgSmF2YVNjcmlwdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgU2VjdXJlIEhhc2ggQWxnb3JpdGhtLCBTSEEtMSwgYXMgZGVmaW5lZFxuICogaW4gRklQUyBQVUIgMTgwLTFcbiAqIFZlcnNpb24gMi4xYSBDb3B5cmlnaHQgUGF1bCBKb2huc3RvbiAyMDAwIC0gMjAwMi5cbiAqIE90aGVyIGNvbnRyaWJ1dG9yczogR3JlZyBIb2x0LCBBbmRyZXcgS2VwZXJ0LCBZZG5hciwgTG9zdGluZXRcbiAqIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSBCU0QgTGljZW5zZVxuICogU2VlIGh0dHA6Ly9wYWpob21lLm9yZy51ay9jcnlwdC9tZDUgZm9yIGRldGFpbHMuXG4gKi9cblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIEhhc2ggPSByZXF1aXJlKCcuL2hhc2gnKVxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyXG5cbnZhciBLID0gW1xuICAweDVhODI3OTk5LCAweDZlZDllYmExLCAweDhmMWJiY2RjIHwgMCwgMHhjYTYyYzFkNiB8IDBcbl1cblxudmFyIFcgPSBuZXcgQXJyYXkoODApXG5cbmZ1bmN0aW9uIFNoYTEgKCkge1xuICB0aGlzLmluaXQoKVxuICB0aGlzLl93ID0gV1xuXG4gIEhhc2guY2FsbCh0aGlzLCA2NCwgNTYpXG59XG5cbmluaGVyaXRzKFNoYTEsIEhhc2gpXG5cblNoYTEucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuX2EgPSAweDY3NDUyMzAxXG4gIHRoaXMuX2IgPSAweGVmY2RhYjg5XG4gIHRoaXMuX2MgPSAweDk4YmFkY2ZlXG4gIHRoaXMuX2QgPSAweDEwMzI1NDc2XG4gIHRoaXMuX2UgPSAweGMzZDJlMWYwXG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuZnVuY3Rpb24gcm90bDEgKG51bSkge1xuICByZXR1cm4gKG51bSA8PCAxKSB8IChudW0gPj4+IDMxKVxufVxuXG5mdW5jdGlvbiByb3RsNSAobnVtKSB7XG4gIHJldHVybiAobnVtIDw8IDUpIHwgKG51bSA+Pj4gMjcpXG59XG5cbmZ1bmN0aW9uIHJvdGwzMCAobnVtKSB7XG4gIHJldHVybiAobnVtIDw8IDMwKSB8IChudW0gPj4+IDIpXG59XG5cbmZ1bmN0aW9uIGZ0IChzLCBiLCBjLCBkKSB7XG4gIGlmIChzID09PSAwKSByZXR1cm4gKGIgJiBjKSB8ICgofmIpICYgZClcbiAgaWYgKHMgPT09IDIpIHJldHVybiAoYiAmIGMpIHwgKGIgJiBkKSB8IChjICYgZClcbiAgcmV0dXJuIGIgXiBjIF4gZFxufVxuXG5TaGExLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKE0pIHtcbiAgdmFyIFcgPSB0aGlzLl93XG5cbiAgdmFyIGEgPSB0aGlzLl9hIHwgMFxuICB2YXIgYiA9IHRoaXMuX2IgfCAwXG4gIHZhciBjID0gdGhpcy5fYyB8IDBcbiAgdmFyIGQgPSB0aGlzLl9kIHwgMFxuICB2YXIgZSA9IHRoaXMuX2UgfCAwXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAxNjsgKytpKSBXW2ldID0gTS5yZWFkSW50MzJCRShpICogNClcbiAgZm9yICg7IGkgPCA4MDsgKytpKSBXW2ldID0gcm90bDEoV1tpIC0gM10gXiBXW2kgLSA4XSBeIFdbaSAtIDE0XSBeIFdbaSAtIDE2XSlcblxuICBmb3IgKHZhciBqID0gMDsgaiA8IDgwOyArK2opIHtcbiAgICB2YXIgcyA9IH5+KGogLyAyMClcbiAgICB2YXIgdCA9IChyb3RsNShhKSArIGZ0KHMsIGIsIGMsIGQpICsgZSArIFdbal0gKyBLW3NdKSB8IDBcblxuICAgIGUgPSBkXG4gICAgZCA9IGNcbiAgICBjID0gcm90bDMwKGIpXG4gICAgYiA9IGFcbiAgICBhID0gdFxuICB9XG5cbiAgdGhpcy5fYSA9IChhICsgdGhpcy5fYSkgfCAwXG4gIHRoaXMuX2IgPSAoYiArIHRoaXMuX2IpIHwgMFxuICB0aGlzLl9jID0gKGMgKyB0aGlzLl9jKSB8IDBcbiAgdGhpcy5fZCA9IChkICsgdGhpcy5fZCkgfCAwXG4gIHRoaXMuX2UgPSAoZSArIHRoaXMuX2UpIHwgMFxufVxuXG5TaGExLnByb3RvdHlwZS5faGFzaCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIEggPSBCdWZmZXIuYWxsb2NVbnNhZmUoMjApXG5cbiAgSC53cml0ZUludDMyQkUodGhpcy5fYSB8IDAsIDApXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2IgfCAwLCA0KVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9jIHwgMCwgOClcbiAgSC53cml0ZUludDMyQkUodGhpcy5fZCB8IDAsIDEyKVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9lIHwgMCwgMTYpXG5cbiAgcmV0dXJuIEhcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTaGExXG4iLCIvKiBjcmMzMi5qcyAoQykgMjAxNC1wcmVzZW50IFNoZWV0SlMgLS0gaHR0cDovL3NoZWV0anMuY29tICovXG4vKiB2aW06IHNldCB0cz0yOiAqL1xuLypleHBvcnRlZCBDUkMzMiAqL1xudmFyIENSQzMyO1xuKGZ1bmN0aW9uIChmYWN0b3J5KSB7XG5cdC8qanNoaW50IGlnbm9yZTpzdGFydCAqL1xuXHQvKmVzbGludC1kaXNhYmxlICovXG5cdGlmKHR5cGVvZiBET19OT1RfRVhQT1JUX0NSQyA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRpZignb2JqZWN0JyA9PT0gdHlwZW9mIGV4cG9ydHMpIHtcblx0XHRcdGZhY3RvcnkoZXhwb3J0cyk7XG5cdFx0fSBlbHNlIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgZGVmaW5lICYmIGRlZmluZS5hbWQpIHtcblx0XHRcdGRlZmluZShmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHZhciBtb2R1bGUgPSB7fTtcblx0XHRcdFx0ZmFjdG9yeShtb2R1bGUpO1xuXHRcdFx0XHRyZXR1cm4gbW9kdWxlO1xuXHRcdFx0fSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGZhY3RvcnkoQ1JDMzIgPSB7fSk7XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdGZhY3RvcnkoQ1JDMzIgPSB7fSk7XG5cdH1cblx0Lyplc2xpbnQtZW5hYmxlICovXG5cdC8qanNoaW50IGlnbm9yZTplbmQgKi9cbn0oZnVuY3Rpb24oQ1JDMzIpIHtcbkNSQzMyLnZlcnNpb24gPSAnMS4yLjAnO1xuLyogc2VlIHBlcmYvY3JjMzJ0YWJsZS5qcyAqL1xuLypnbG9iYWwgSW50MzJBcnJheSAqL1xuZnVuY3Rpb24gc2lnbmVkX2NyY190YWJsZSgpIHtcblx0dmFyIGMgPSAwLCB0YWJsZSA9IG5ldyBBcnJheSgyNTYpO1xuXG5cdGZvcih2YXIgbiA9MDsgbiAhPSAyNTY7ICsrbil7XG5cdFx0YyA9IG47XG5cdFx0YyA9ICgoYyYxKSA/ICgtMzA2Njc0OTEyIF4gKGMgPj4+IDEpKSA6IChjID4+PiAxKSk7XG5cdFx0YyA9ICgoYyYxKSA/ICgtMzA2Njc0OTEyIF4gKGMgPj4+IDEpKSA6IChjID4+PiAxKSk7XG5cdFx0YyA9ICgoYyYxKSA/ICgtMzA2Njc0OTEyIF4gKGMgPj4+IDEpKSA6IChjID4+PiAxKSk7XG5cdFx0YyA9ICgoYyYxKSA/ICgtMzA2Njc0OTEyIF4gKGMgPj4+IDEpKSA6IChjID4+PiAxKSk7XG5cdFx0YyA9ICgoYyYxKSA/ICgtMzA2Njc0OTEyIF4gKGMgPj4+IDEpKSA6IChjID4+PiAxKSk7XG5cdFx0YyA9ICgoYyYxKSA/ICgtMzA2Njc0OTEyIF4gKGMgPj4+IDEpKSA6IChjID4+PiAxKSk7XG5cdFx0YyA9ICgoYyYxKSA/ICgtMzA2Njc0OTEyIF4gKGMgPj4+IDEpKSA6IChjID4+PiAxKSk7XG5cdFx0YyA9ICgoYyYxKSA/ICgtMzA2Njc0OTEyIF4gKGMgPj4+IDEpKSA6IChjID4+PiAxKSk7XG5cdFx0dGFibGVbbl0gPSBjO1xuXHR9XG5cblx0cmV0dXJuIHR5cGVvZiBJbnQzMkFycmF5ICE9PSAndW5kZWZpbmVkJyA/IG5ldyBJbnQzMkFycmF5KHRhYmxlKSA6IHRhYmxlO1xufVxuXG52YXIgVCA9IHNpZ25lZF9jcmNfdGFibGUoKTtcbmZ1bmN0aW9uIGNyYzMyX2JzdHIoYnN0ciwgc2VlZCkge1xuXHR2YXIgQyA9IHNlZWQgXiAtMSwgTCA9IGJzdHIubGVuZ3RoIC0gMTtcblx0Zm9yKHZhciBpID0gMDsgaSA8IEw7KSB7XG5cdFx0QyA9IChDPj4+OCkgXiBUWyhDXmJzdHIuY2hhckNvZGVBdChpKyspKSYweEZGXTtcblx0XHRDID0gKEM+Pj44KSBeIFRbKENeYnN0ci5jaGFyQ29kZUF0KGkrKykpJjB4RkZdO1xuXHR9XG5cdGlmKGkgPT09IEwpIEMgPSAoQz4+PjgpIF4gVFsoQyBeIGJzdHIuY2hhckNvZGVBdChpKSkmMHhGRl07XG5cdHJldHVybiBDIF4gLTE7XG59XG5cbmZ1bmN0aW9uIGNyYzMyX2J1ZihidWYsIHNlZWQpIHtcblx0aWYoYnVmLmxlbmd0aCA+IDEwMDAwKSByZXR1cm4gY3JjMzJfYnVmXzgoYnVmLCBzZWVkKTtcblx0dmFyIEMgPSBzZWVkIF4gLTEsIEwgPSBidWYubGVuZ3RoIC0gMztcblx0Zm9yKHZhciBpID0gMDsgaSA8IEw7KSB7XG5cdFx0QyA9IChDPj4+OCkgXiBUWyhDXmJ1ZltpKytdKSYweEZGXTtcblx0XHRDID0gKEM+Pj44KSBeIFRbKENeYnVmW2krK10pJjB4RkZdO1xuXHRcdEMgPSAoQz4+PjgpIF4gVFsoQ15idWZbaSsrXSkmMHhGRl07XG5cdFx0QyA9IChDPj4+OCkgXiBUWyhDXmJ1ZltpKytdKSYweEZGXTtcblx0fVxuXHR3aGlsZShpIDwgTCszKSBDID0gKEM+Pj44KSBeIFRbKENeYnVmW2krK10pJjB4RkZdO1xuXHRyZXR1cm4gQyBeIC0xO1xufVxuXG5mdW5jdGlvbiBjcmMzMl9idWZfOChidWYsIHNlZWQpIHtcblx0dmFyIEMgPSBzZWVkIF4gLTEsIEwgPSBidWYubGVuZ3RoIC0gNztcblx0Zm9yKHZhciBpID0gMDsgaSA8IEw7KSB7XG5cdFx0QyA9IChDPj4+OCkgXiBUWyhDXmJ1ZltpKytdKSYweEZGXTtcblx0XHRDID0gKEM+Pj44KSBeIFRbKENeYnVmW2krK10pJjB4RkZdO1xuXHRcdEMgPSAoQz4+PjgpIF4gVFsoQ15idWZbaSsrXSkmMHhGRl07XG5cdFx0QyA9IChDPj4+OCkgXiBUWyhDXmJ1ZltpKytdKSYweEZGXTtcblx0XHRDID0gKEM+Pj44KSBeIFRbKENeYnVmW2krK10pJjB4RkZdO1xuXHRcdEMgPSAoQz4+PjgpIF4gVFsoQ15idWZbaSsrXSkmMHhGRl07XG5cdFx0QyA9IChDPj4+OCkgXiBUWyhDXmJ1ZltpKytdKSYweEZGXTtcblx0XHRDID0gKEM+Pj44KSBeIFRbKENeYnVmW2krK10pJjB4RkZdO1xuXHR9XG5cdHdoaWxlKGkgPCBMKzcpIEMgPSAoQz4+PjgpIF4gVFsoQ15idWZbaSsrXSkmMHhGRl07XG5cdHJldHVybiBDIF4gLTE7XG59XG5cbmZ1bmN0aW9uIGNyYzMyX3N0cihzdHIsIHNlZWQpIHtcblx0dmFyIEMgPSBzZWVkIF4gLTE7XG5cdGZvcih2YXIgaSA9IDAsIEw9c3RyLmxlbmd0aCwgYywgZDsgaSA8IEw7KSB7XG5cdFx0YyA9IHN0ci5jaGFyQ29kZUF0KGkrKyk7XG5cdFx0aWYoYyA8IDB4ODApIHtcblx0XHRcdEMgPSAoQz4+PjgpIF4gVFsoQyBeIGMpJjB4RkZdO1xuXHRcdH0gZWxzZSBpZihjIDwgMHg4MDApIHtcblx0XHRcdEMgPSAoQz4+PjgpIF4gVFsoQyBeICgxOTJ8KChjPj42KSYzMSkpKSYweEZGXTtcblx0XHRcdEMgPSAoQz4+PjgpIF4gVFsoQyBeICgxMjh8KGMmNjMpKSkmMHhGRl07XG5cdFx0fSBlbHNlIGlmKGMgPj0gMHhEODAwICYmIGMgPCAweEUwMDApIHtcblx0XHRcdGMgPSAoYyYxMDIzKSs2NDsgZCA9IHN0ci5jaGFyQ29kZUF0KGkrKykmMTAyMztcblx0XHRcdEMgPSAoQz4+PjgpIF4gVFsoQyBeICgyNDB8KChjPj44KSY3KSkpJjB4RkZdO1xuXHRcdFx0QyA9IChDPj4+OCkgXiBUWyhDIF4gKDEyOHwoKGM+PjIpJjYzKSkpJjB4RkZdO1xuXHRcdFx0QyA9IChDPj4+OCkgXiBUWyhDIF4gKDEyOHwoKGQ+PjYpJjE1KXwoKGMmMyk8PDQpKSkmMHhGRl07XG5cdFx0XHRDID0gKEM+Pj44KSBeIFRbKEMgXiAoMTI4fChkJjYzKSkpJjB4RkZdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRDID0gKEM+Pj44KSBeIFRbKEMgXiAoMjI0fCgoYz4+MTIpJjE1KSkpJjB4RkZdO1xuXHRcdFx0QyA9IChDPj4+OCkgXiBUWyhDIF4gKDEyOHwoKGM+PjYpJjYzKSkpJjB4RkZdO1xuXHRcdFx0QyA9IChDPj4+OCkgXiBUWyhDIF4gKDEyOHwoYyY2MykpKSYweEZGXTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIEMgXiAtMTtcbn1cbkNSQzMyLnRhYmxlID0gVDtcbi8vICRGbG93SWdub3JlXG5DUkMzMi5ic3RyID0gY3JjMzJfYnN0cjtcbi8vICRGbG93SWdub3JlXG5DUkMzMi5idWYgPSBjcmMzMl9idWY7XG4vLyAkRmxvd0lnbm9yZVxuQ1JDMzIuc3RyID0gY3JjMzJfc3RyO1xufSkpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBUWVBFRF9PSyA9ICAodHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnKSAmJlxuICAgICAgICAgICAgICAgICh0eXBlb2YgVWludDE2QXJyYXkgIT09ICd1bmRlZmluZWQnKSAmJlxuICAgICAgICAgICAgICAgICh0eXBlb2YgSW50MzJBcnJheSAhPT0gJ3VuZGVmaW5lZCcpO1xuXG5mdW5jdGlvbiBfaGFzKG9iaiwga2V5KSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpO1xufVxuXG5leHBvcnRzLmFzc2lnbiA9IGZ1bmN0aW9uIChvYmogLypmcm9tMSwgZnJvbTIsIGZyb20zLCAuLi4qLykge1xuICB2YXIgc291cmNlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gIHdoaWxlIChzb3VyY2VzLmxlbmd0aCkge1xuICAgIHZhciBzb3VyY2UgPSBzb3VyY2VzLnNoaWZ0KCk7XG4gICAgaWYgKCFzb3VyY2UpIHsgY29udGludWU7IH1cblxuICAgIGlmICh0eXBlb2Ygc291cmNlICE9PSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzb3VyY2UgKyAnbXVzdCBiZSBub24tb2JqZWN0Jyk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgcCBpbiBzb3VyY2UpIHtcbiAgICAgIGlmIChfaGFzKHNvdXJjZSwgcCkpIHtcbiAgICAgICAgb2JqW3BdID0gc291cmNlW3BdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvYmo7XG59O1xuXG5cbi8vIHJlZHVjZSBidWZmZXIgc2l6ZSwgYXZvaWRpbmcgbWVtIGNvcHlcbmV4cG9ydHMuc2hyaW5rQnVmID0gZnVuY3Rpb24gKGJ1Ziwgc2l6ZSkge1xuICBpZiAoYnVmLmxlbmd0aCA9PT0gc2l6ZSkgeyByZXR1cm4gYnVmOyB9XG4gIGlmIChidWYuc3ViYXJyYXkpIHsgcmV0dXJuIGJ1Zi5zdWJhcnJheSgwLCBzaXplKTsgfVxuICBidWYubGVuZ3RoID0gc2l6ZTtcbiAgcmV0dXJuIGJ1Zjtcbn07XG5cblxudmFyIGZuVHlwZWQgPSB7XG4gIGFycmF5U2V0OiBmdW5jdGlvbiAoZGVzdCwgc3JjLCBzcmNfb2ZmcywgbGVuLCBkZXN0X29mZnMpIHtcbiAgICBpZiAoc3JjLnN1YmFycmF5ICYmIGRlc3Quc3ViYXJyYXkpIHtcbiAgICAgIGRlc3Quc2V0KHNyYy5zdWJhcnJheShzcmNfb2Zmcywgc3JjX29mZnMgKyBsZW4pLCBkZXN0X29mZnMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBGYWxsYmFjayB0byBvcmRpbmFyeSBhcnJheVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGRlc3RbZGVzdF9vZmZzICsgaV0gPSBzcmNbc3JjX29mZnMgKyBpXTtcbiAgICB9XG4gIH0sXG4gIC8vIEpvaW4gYXJyYXkgb2YgY2h1bmtzIHRvIHNpbmdsZSBhcnJheS5cbiAgZmxhdHRlbkNodW5rczogZnVuY3Rpb24gKGNodW5rcykge1xuICAgIHZhciBpLCBsLCBsZW4sIHBvcywgY2h1bmssIHJlc3VsdDtcblxuICAgIC8vIGNhbGN1bGF0ZSBkYXRhIGxlbmd0aFxuICAgIGxlbiA9IDA7XG4gICAgZm9yIChpID0gMCwgbCA9IGNodW5rcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGxlbiArPSBjaHVua3NbaV0ubGVuZ3RoO1xuICAgIH1cblxuICAgIC8vIGpvaW4gY2h1bmtzXG4gICAgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkobGVuKTtcbiAgICBwb3MgPSAwO1xuICAgIGZvciAoaSA9IDAsIGwgPSBjaHVua3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBjaHVuayA9IGNodW5rc1tpXTtcbiAgICAgIHJlc3VsdC5zZXQoY2h1bmssIHBvcyk7XG4gICAgICBwb3MgKz0gY2h1bmsubGVuZ3RoO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn07XG5cbnZhciBmblVudHlwZWQgPSB7XG4gIGFycmF5U2V0OiBmdW5jdGlvbiAoZGVzdCwgc3JjLCBzcmNfb2ZmcywgbGVuLCBkZXN0X29mZnMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBkZXN0W2Rlc3Rfb2ZmcyArIGldID0gc3JjW3NyY19vZmZzICsgaV07XG4gICAgfVxuICB9LFxuICAvLyBKb2luIGFycmF5IG9mIGNodW5rcyB0byBzaW5nbGUgYXJyYXkuXG4gIGZsYXR0ZW5DaHVua3M6IGZ1bmN0aW9uIChjaHVua3MpIHtcbiAgICByZXR1cm4gW10uY29uY2F0LmFwcGx5KFtdLCBjaHVua3MpO1xuICB9XG59O1xuXG5cbi8vIEVuYWJsZS9EaXNhYmxlIHR5cGVkIGFycmF5cyB1c2UsIGZvciB0ZXN0aW5nXG4vL1xuZXhwb3J0cy5zZXRUeXBlZCA9IGZ1bmN0aW9uIChvbikge1xuICBpZiAob24pIHtcbiAgICBleHBvcnRzLkJ1ZjggID0gVWludDhBcnJheTtcbiAgICBleHBvcnRzLkJ1ZjE2ID0gVWludDE2QXJyYXk7XG4gICAgZXhwb3J0cy5CdWYzMiA9IEludDMyQXJyYXk7XG4gICAgZXhwb3J0cy5hc3NpZ24oZXhwb3J0cywgZm5UeXBlZCk7XG4gIH0gZWxzZSB7XG4gICAgZXhwb3J0cy5CdWY4ICA9IEFycmF5O1xuICAgIGV4cG9ydHMuQnVmMTYgPSBBcnJheTtcbiAgICBleHBvcnRzLkJ1ZjMyID0gQXJyYXk7XG4gICAgZXhwb3J0cy5hc3NpZ24oZXhwb3J0cywgZm5VbnR5cGVkKTtcbiAgfVxufTtcblxuZXhwb3J0cy5zZXRUeXBlZChUWVBFRF9PSyk7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxuLyogZXNsaW50LWRpc2FibGUgc3BhY2UtdW5hcnktb3BzICovXG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL2NvbW1vbicpO1xuXG4vKiBQdWJsaWMgY29uc3RhbnRzID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG4vL3ZhciBaX0ZJTFRFUkVEICAgICAgICAgID0gMTtcbi8vdmFyIFpfSFVGRk1BTl9PTkxZICAgICAgPSAyO1xuLy92YXIgWl9STEUgICAgICAgICAgICAgICA9IDM7XG52YXIgWl9GSVhFRCAgICAgICAgICAgICAgID0gNDtcbi8vdmFyIFpfREVGQVVMVF9TVFJBVEVHWSAgPSAwO1xuXG4vKiBQb3NzaWJsZSB2YWx1ZXMgb2YgdGhlIGRhdGFfdHlwZSBmaWVsZCAodGhvdWdoIHNlZSBpbmZsYXRlKCkpICovXG52YXIgWl9CSU5BUlkgICAgICAgICAgICAgID0gMDtcbnZhciBaX1RFWFQgICAgICAgICAgICAgICAgPSAxO1xuLy92YXIgWl9BU0NJSSAgICAgICAgICAgICA9IDE7IC8vID0gWl9URVhUXG52YXIgWl9VTktOT1dOICAgICAgICAgICAgID0gMjtcblxuLyo9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG5mdW5jdGlvbiB6ZXJvKGJ1ZikgeyB2YXIgbGVuID0gYnVmLmxlbmd0aDsgd2hpbGUgKC0tbGVuID49IDApIHsgYnVmW2xlbl0gPSAwOyB9IH1cblxuLy8gRnJvbSB6dXRpbC5oXG5cbnZhciBTVE9SRURfQkxPQ0sgPSAwO1xudmFyIFNUQVRJQ19UUkVFUyA9IDE7XG52YXIgRFlOX1RSRUVTICAgID0gMjtcbi8qIFRoZSB0aHJlZSBraW5kcyBvZiBibG9jayB0eXBlICovXG5cbnZhciBNSU5fTUFUQ0ggICAgPSAzO1xudmFyIE1BWF9NQVRDSCAgICA9IDI1ODtcbi8qIFRoZSBtaW5pbXVtIGFuZCBtYXhpbXVtIG1hdGNoIGxlbmd0aHMgKi9cblxuLy8gRnJvbSBkZWZsYXRlLmhcbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogSW50ZXJuYWwgY29tcHJlc3Npb24gc3RhdGUuXG4gKi9cblxudmFyIExFTkdUSF9DT0RFUyAgPSAyOTtcbi8qIG51bWJlciBvZiBsZW5ndGggY29kZXMsIG5vdCBjb3VudGluZyB0aGUgc3BlY2lhbCBFTkRfQkxPQ0sgY29kZSAqL1xuXG52YXIgTElURVJBTFMgICAgICA9IDI1Njtcbi8qIG51bWJlciBvZiBsaXRlcmFsIGJ5dGVzIDAuLjI1NSAqL1xuXG52YXIgTF9DT0RFUyAgICAgICA9IExJVEVSQUxTICsgMSArIExFTkdUSF9DT0RFUztcbi8qIG51bWJlciBvZiBMaXRlcmFsIG9yIExlbmd0aCBjb2RlcywgaW5jbHVkaW5nIHRoZSBFTkRfQkxPQ0sgY29kZSAqL1xuXG52YXIgRF9DT0RFUyAgICAgICA9IDMwO1xuLyogbnVtYmVyIG9mIGRpc3RhbmNlIGNvZGVzICovXG5cbnZhciBCTF9DT0RFUyAgICAgID0gMTk7XG4vKiBudW1iZXIgb2YgY29kZXMgdXNlZCB0byB0cmFuc2ZlciB0aGUgYml0IGxlbmd0aHMgKi9cblxudmFyIEhFQVBfU0laRSAgICAgPSAyICogTF9DT0RFUyArIDE7XG4vKiBtYXhpbXVtIGhlYXAgc2l6ZSAqL1xuXG52YXIgTUFYX0JJVFMgICAgICA9IDE1O1xuLyogQWxsIGNvZGVzIG11c3Qgbm90IGV4Y2VlZCBNQVhfQklUUyBiaXRzICovXG5cbnZhciBCdWZfc2l6ZSAgICAgID0gMTY7XG4vKiBzaXplIG9mIGJpdCBidWZmZXIgaW4gYmlfYnVmICovXG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb25zdGFudHNcbiAqL1xuXG52YXIgTUFYX0JMX0JJVFMgPSA3O1xuLyogQml0IGxlbmd0aCBjb2RlcyBtdXN0IG5vdCBleGNlZWQgTUFYX0JMX0JJVFMgYml0cyAqL1xuXG52YXIgRU5EX0JMT0NLICAgPSAyNTY7XG4vKiBlbmQgb2YgYmxvY2sgbGl0ZXJhbCBjb2RlICovXG5cbnZhciBSRVBfM182ICAgICA9IDE2O1xuLyogcmVwZWF0IHByZXZpb3VzIGJpdCBsZW5ndGggMy02IHRpbWVzICgyIGJpdHMgb2YgcmVwZWF0IGNvdW50KSAqL1xuXG52YXIgUkVQWl8zXzEwICAgPSAxNztcbi8qIHJlcGVhdCBhIHplcm8gbGVuZ3RoIDMtMTAgdGltZXMgICgzIGJpdHMgb2YgcmVwZWF0IGNvdW50KSAqL1xuXG52YXIgUkVQWl8xMV8xMzggPSAxODtcbi8qIHJlcGVhdCBhIHplcm8gbGVuZ3RoIDExLTEzOCB0aW1lcyAgKDcgYml0cyBvZiByZXBlYXQgY291bnQpICovXG5cbi8qIGVzbGludC1kaXNhYmxlIGNvbW1hLXNwYWNpbmcsYXJyYXktYnJhY2tldC1zcGFjaW5nICovXG52YXIgZXh0cmFfbGJpdHMgPSAgIC8qIGV4dHJhIGJpdHMgZm9yIGVhY2ggbGVuZ3RoIGNvZGUgKi9cbiAgWzAsMCwwLDAsMCwwLDAsMCwxLDEsMSwxLDIsMiwyLDIsMywzLDMsMyw0LDQsNCw0LDUsNSw1LDUsMF07XG5cbnZhciBleHRyYV9kYml0cyA9ICAgLyogZXh0cmEgYml0cyBmb3IgZWFjaCBkaXN0YW5jZSBjb2RlICovXG4gIFswLDAsMCwwLDEsMSwyLDIsMywzLDQsNCw1LDUsNiw2LDcsNyw4LDgsOSw5LDEwLDEwLDExLDExLDEyLDEyLDEzLDEzXTtcblxudmFyIGV4dHJhX2JsYml0cyA9ICAvKiBleHRyYSBiaXRzIGZvciBlYWNoIGJpdCBsZW5ndGggY29kZSAqL1xuICBbMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwyLDMsN107XG5cbnZhciBibF9vcmRlciA9XG4gIFsxNiwxNywxOCwwLDgsNyw5LDYsMTAsNSwxMSw0LDEyLDMsMTMsMiwxNCwxLDE1XTtcbi8qIGVzbGludC1lbmFibGUgY29tbWEtc3BhY2luZyxhcnJheS1icmFja2V0LXNwYWNpbmcgKi9cblxuLyogVGhlIGxlbmd0aHMgb2YgdGhlIGJpdCBsZW5ndGggY29kZXMgYXJlIHNlbnQgaW4gb3JkZXIgb2YgZGVjcmVhc2luZ1xuICogcHJvYmFiaWxpdHksIHRvIGF2b2lkIHRyYW5zbWl0dGluZyB0aGUgbGVuZ3RocyBmb3IgdW51c2VkIGJpdCBsZW5ndGggY29kZXMuXG4gKi9cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBMb2NhbCBkYXRhLiBUaGVzZSBhcmUgaW5pdGlhbGl6ZWQgb25seSBvbmNlLlxuICovXG5cbi8vIFdlIHByZS1maWxsIGFycmF5cyB3aXRoIDAgdG8gYXZvaWQgdW5pbml0aWFsaXplZCBnYXBzXG5cbnZhciBESVNUX0NPREVfTEVOID0gNTEyOyAvKiBzZWUgZGVmaW5pdGlvbiBvZiBhcnJheSBkaXN0X2NvZGUgYmVsb3cgKi9cblxuLy8gISEhISBVc2UgZmxhdCBhcnJheSBpbnN0ZWFkIG9mIHN0cnVjdHVyZSwgRnJlcSA9IGkqMiwgTGVuID0gaSoyKzFcbnZhciBzdGF0aWNfbHRyZWUgID0gbmV3IEFycmF5KChMX0NPREVTICsgMikgKiAyKTtcbnplcm8oc3RhdGljX2x0cmVlKTtcbi8qIFRoZSBzdGF0aWMgbGl0ZXJhbCB0cmVlLiBTaW5jZSB0aGUgYml0IGxlbmd0aHMgYXJlIGltcG9zZWQsIHRoZXJlIGlzIG5vXG4gKiBuZWVkIGZvciB0aGUgTF9DT0RFUyBleHRyYSBjb2RlcyB1c2VkIGR1cmluZyBoZWFwIGNvbnN0cnVjdGlvbi4gSG93ZXZlclxuICogVGhlIGNvZGVzIDI4NiBhbmQgMjg3IGFyZSBuZWVkZWQgdG8gYnVpbGQgYSBjYW5vbmljYWwgdHJlZSAoc2VlIF90cl9pbml0XG4gKiBiZWxvdykuXG4gKi9cblxudmFyIHN0YXRpY19kdHJlZSAgPSBuZXcgQXJyYXkoRF9DT0RFUyAqIDIpO1xuemVybyhzdGF0aWNfZHRyZWUpO1xuLyogVGhlIHN0YXRpYyBkaXN0YW5jZSB0cmVlLiAoQWN0dWFsbHkgYSB0cml2aWFsIHRyZWUgc2luY2UgYWxsIGNvZGVzIHVzZVxuICogNSBiaXRzLilcbiAqL1xuXG52YXIgX2Rpc3RfY29kZSAgICA9IG5ldyBBcnJheShESVNUX0NPREVfTEVOKTtcbnplcm8oX2Rpc3RfY29kZSk7XG4vKiBEaXN0YW5jZSBjb2Rlcy4gVGhlIGZpcnN0IDI1NiB2YWx1ZXMgY29ycmVzcG9uZCB0byB0aGUgZGlzdGFuY2VzXG4gKiAzIC4uIDI1OCwgdGhlIGxhc3QgMjU2IHZhbHVlcyBjb3JyZXNwb25kIHRvIHRoZSB0b3AgOCBiaXRzIG9mXG4gKiB0aGUgMTUgYml0IGRpc3RhbmNlcy5cbiAqL1xuXG52YXIgX2xlbmd0aF9jb2RlICA9IG5ldyBBcnJheShNQVhfTUFUQ0ggLSBNSU5fTUFUQ0ggKyAxKTtcbnplcm8oX2xlbmd0aF9jb2RlKTtcbi8qIGxlbmd0aCBjb2RlIGZvciBlYWNoIG5vcm1hbGl6ZWQgbWF0Y2ggbGVuZ3RoICgwID09IE1JTl9NQVRDSCkgKi9cblxudmFyIGJhc2VfbGVuZ3RoICAgPSBuZXcgQXJyYXkoTEVOR1RIX0NPREVTKTtcbnplcm8oYmFzZV9sZW5ndGgpO1xuLyogRmlyc3Qgbm9ybWFsaXplZCBsZW5ndGggZm9yIGVhY2ggY29kZSAoMCA9IE1JTl9NQVRDSCkgKi9cblxudmFyIGJhc2VfZGlzdCAgICAgPSBuZXcgQXJyYXkoRF9DT0RFUyk7XG56ZXJvKGJhc2VfZGlzdCk7XG4vKiBGaXJzdCBub3JtYWxpemVkIGRpc3RhbmNlIGZvciBlYWNoIGNvZGUgKDAgPSBkaXN0YW5jZSBvZiAxKSAqL1xuXG5cbmZ1bmN0aW9uIFN0YXRpY1RyZWVEZXNjKHN0YXRpY190cmVlLCBleHRyYV9iaXRzLCBleHRyYV9iYXNlLCBlbGVtcywgbWF4X2xlbmd0aCkge1xuXG4gIHRoaXMuc3RhdGljX3RyZWUgID0gc3RhdGljX3RyZWU7ICAvKiBzdGF0aWMgdHJlZSBvciBOVUxMICovXG4gIHRoaXMuZXh0cmFfYml0cyAgID0gZXh0cmFfYml0czsgICAvKiBleHRyYSBiaXRzIGZvciBlYWNoIGNvZGUgb3IgTlVMTCAqL1xuICB0aGlzLmV4dHJhX2Jhc2UgICA9IGV4dHJhX2Jhc2U7ICAgLyogYmFzZSBpbmRleCBmb3IgZXh0cmFfYml0cyAqL1xuICB0aGlzLmVsZW1zICAgICAgICA9IGVsZW1zOyAgICAgICAgLyogbWF4IG51bWJlciBvZiBlbGVtZW50cyBpbiB0aGUgdHJlZSAqL1xuICB0aGlzLm1heF9sZW5ndGggICA9IG1heF9sZW5ndGg7ICAgLyogbWF4IGJpdCBsZW5ndGggZm9yIHRoZSBjb2RlcyAqL1xuXG4gIC8vIHNob3cgaWYgYHN0YXRpY190cmVlYCBoYXMgZGF0YSBvciBkdW1teSAtIG5lZWRlZCBmb3IgbW9ub21vcnBoaWMgb2JqZWN0c1xuICB0aGlzLmhhc19zdHJlZSAgICA9IHN0YXRpY190cmVlICYmIHN0YXRpY190cmVlLmxlbmd0aDtcbn1cblxuXG52YXIgc3RhdGljX2xfZGVzYztcbnZhciBzdGF0aWNfZF9kZXNjO1xudmFyIHN0YXRpY19ibF9kZXNjO1xuXG5cbmZ1bmN0aW9uIFRyZWVEZXNjKGR5bl90cmVlLCBzdGF0X2Rlc2MpIHtcbiAgdGhpcy5keW5fdHJlZSA9IGR5bl90cmVlOyAgICAgLyogdGhlIGR5bmFtaWMgdHJlZSAqL1xuICB0aGlzLm1heF9jb2RlID0gMDsgICAgICAgICAgICAvKiBsYXJnZXN0IGNvZGUgd2l0aCBub24gemVybyBmcmVxdWVuY3kgKi9cbiAgdGhpcy5zdGF0X2Rlc2MgPSBzdGF0X2Rlc2M7ICAgLyogdGhlIGNvcnJlc3BvbmRpbmcgc3RhdGljIHRyZWUgKi9cbn1cblxuXG5cbmZ1bmN0aW9uIGRfY29kZShkaXN0KSB7XG4gIHJldHVybiBkaXN0IDwgMjU2ID8gX2Rpc3RfY29kZVtkaXN0XSA6IF9kaXN0X2NvZGVbMjU2ICsgKGRpc3QgPj4+IDcpXTtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIE91dHB1dCBhIHNob3J0IExTQiBmaXJzdCBvbiB0aGUgc3RyZWFtLlxuICogSU4gYXNzZXJ0aW9uOiB0aGVyZSBpcyBlbm91Z2ggcm9vbSBpbiBwZW5kaW5nQnVmLlxuICovXG5mdW5jdGlvbiBwdXRfc2hvcnQocywgdykge1xuLy8gICAgcHV0X2J5dGUocywgKHVjaCkoKHcpICYgMHhmZikpO1xuLy8gICAgcHV0X2J5dGUocywgKHVjaCkoKHVzaCkodykgPj4gOCkpO1xuICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9ICh3KSAmIDB4ZmY7XG4gIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gKHcgPj4+IDgpICYgMHhmZjtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNlbmQgYSB2YWx1ZSBvbiBhIGdpdmVuIG51bWJlciBvZiBiaXRzLlxuICogSU4gYXNzZXJ0aW9uOiBsZW5ndGggPD0gMTYgYW5kIHZhbHVlIGZpdHMgaW4gbGVuZ3RoIGJpdHMuXG4gKi9cbmZ1bmN0aW9uIHNlbmRfYml0cyhzLCB2YWx1ZSwgbGVuZ3RoKSB7XG4gIGlmIChzLmJpX3ZhbGlkID4gKEJ1Zl9zaXplIC0gbGVuZ3RoKSkge1xuICAgIHMuYmlfYnVmIHw9ICh2YWx1ZSA8PCBzLmJpX3ZhbGlkKSAmIDB4ZmZmZjtcbiAgICBwdXRfc2hvcnQocywgcy5iaV9idWYpO1xuICAgIHMuYmlfYnVmID0gdmFsdWUgPj4gKEJ1Zl9zaXplIC0gcy5iaV92YWxpZCk7XG4gICAgcy5iaV92YWxpZCArPSBsZW5ndGggLSBCdWZfc2l6ZTtcbiAgfSBlbHNlIHtcbiAgICBzLmJpX2J1ZiB8PSAodmFsdWUgPDwgcy5iaV92YWxpZCkgJiAweGZmZmY7XG4gICAgcy5iaV92YWxpZCArPSBsZW5ndGg7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBzZW5kX2NvZGUocywgYywgdHJlZSkge1xuICBzZW5kX2JpdHMocywgdHJlZVtjICogMl0vKi5Db2RlKi8sIHRyZWVbYyAqIDIgKyAxXS8qLkxlbiovKTtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFJldmVyc2UgdGhlIGZpcnN0IGxlbiBiaXRzIG9mIGEgY29kZSwgdXNpbmcgc3RyYWlnaHRmb3J3YXJkIGNvZGUgKGEgZmFzdGVyXG4gKiBtZXRob2Qgd291bGQgdXNlIGEgdGFibGUpXG4gKiBJTiBhc3NlcnRpb246IDEgPD0gbGVuIDw9IDE1XG4gKi9cbmZ1bmN0aW9uIGJpX3JldmVyc2UoY29kZSwgbGVuKSB7XG4gIHZhciByZXMgPSAwO1xuICBkbyB7XG4gICAgcmVzIHw9IGNvZGUgJiAxO1xuICAgIGNvZGUgPj4+PSAxO1xuICAgIHJlcyA8PD0gMTtcbiAgfSB3aGlsZSAoLS1sZW4gPiAwKTtcbiAgcmV0dXJuIHJlcyA+Pj4gMTtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEZsdXNoIHRoZSBiaXQgYnVmZmVyLCBrZWVwaW5nIGF0IG1vc3QgNyBiaXRzIGluIGl0LlxuICovXG5mdW5jdGlvbiBiaV9mbHVzaChzKSB7XG4gIGlmIChzLmJpX3ZhbGlkID09PSAxNikge1xuICAgIHB1dF9zaG9ydChzLCBzLmJpX2J1Zik7XG4gICAgcy5iaV9idWYgPSAwO1xuICAgIHMuYmlfdmFsaWQgPSAwO1xuXG4gIH0gZWxzZSBpZiAocy5iaV92YWxpZCA+PSA4KSB7XG4gICAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSBzLmJpX2J1ZiAmIDB4ZmY7XG4gICAgcy5iaV9idWYgPj49IDg7XG4gICAgcy5iaV92YWxpZCAtPSA4O1xuICB9XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb21wdXRlIHRoZSBvcHRpbWFsIGJpdCBsZW5ndGhzIGZvciBhIHRyZWUgYW5kIHVwZGF0ZSB0aGUgdG90YWwgYml0IGxlbmd0aFxuICogZm9yIHRoZSBjdXJyZW50IGJsb2NrLlxuICogSU4gYXNzZXJ0aW9uOiB0aGUgZmllbGRzIGZyZXEgYW5kIGRhZCBhcmUgc2V0LCBoZWFwW2hlYXBfbWF4XSBhbmRcbiAqICAgIGFib3ZlIGFyZSB0aGUgdHJlZSBub2RlcyBzb3J0ZWQgYnkgaW5jcmVhc2luZyBmcmVxdWVuY3kuXG4gKiBPVVQgYXNzZXJ0aW9uczogdGhlIGZpZWxkIGxlbiBpcyBzZXQgdG8gdGhlIG9wdGltYWwgYml0IGxlbmd0aCwgdGhlXG4gKiAgICAgYXJyYXkgYmxfY291bnQgY29udGFpbnMgdGhlIGZyZXF1ZW5jaWVzIGZvciBlYWNoIGJpdCBsZW5ndGguXG4gKiAgICAgVGhlIGxlbmd0aCBvcHRfbGVuIGlzIHVwZGF0ZWQ7IHN0YXRpY19sZW4gaXMgYWxzbyB1cGRhdGVkIGlmIHN0cmVlIGlzXG4gKiAgICAgbm90IG51bGwuXG4gKi9cbmZ1bmN0aW9uIGdlbl9iaXRsZW4ocywgZGVzYylcbi8vICAgIGRlZmxhdGVfc3RhdGUgKnM7XG4vLyAgICB0cmVlX2Rlc2MgKmRlc2M7ICAgIC8qIHRoZSB0cmVlIGRlc2NyaXB0b3IgKi9cbntcbiAgdmFyIHRyZWUgICAgICAgICAgICA9IGRlc2MuZHluX3RyZWU7XG4gIHZhciBtYXhfY29kZSAgICAgICAgPSBkZXNjLm1heF9jb2RlO1xuICB2YXIgc3RyZWUgICAgICAgICAgID0gZGVzYy5zdGF0X2Rlc2Muc3RhdGljX3RyZWU7XG4gIHZhciBoYXNfc3RyZWUgICAgICAgPSBkZXNjLnN0YXRfZGVzYy5oYXNfc3RyZWU7XG4gIHZhciBleHRyYSAgICAgICAgICAgPSBkZXNjLnN0YXRfZGVzYy5leHRyYV9iaXRzO1xuICB2YXIgYmFzZSAgICAgICAgICAgID0gZGVzYy5zdGF0X2Rlc2MuZXh0cmFfYmFzZTtcbiAgdmFyIG1heF9sZW5ndGggICAgICA9IGRlc2Muc3RhdF9kZXNjLm1heF9sZW5ndGg7XG4gIHZhciBoOyAgICAgICAgICAgICAgLyogaGVhcCBpbmRleCAqL1xuICB2YXIgbiwgbTsgICAgICAgICAgIC8qIGl0ZXJhdGUgb3ZlciB0aGUgdHJlZSBlbGVtZW50cyAqL1xuICB2YXIgYml0czsgICAgICAgICAgIC8qIGJpdCBsZW5ndGggKi9cbiAgdmFyIHhiaXRzOyAgICAgICAgICAvKiBleHRyYSBiaXRzICovXG4gIHZhciBmOyAgICAgICAgICAgICAgLyogZnJlcXVlbmN5ICovXG4gIHZhciBvdmVyZmxvdyA9IDA7ICAgLyogbnVtYmVyIG9mIGVsZW1lbnRzIHdpdGggYml0IGxlbmd0aCB0b28gbGFyZ2UgKi9cblxuICBmb3IgKGJpdHMgPSAwOyBiaXRzIDw9IE1BWF9CSVRTOyBiaXRzKyspIHtcbiAgICBzLmJsX2NvdW50W2JpdHNdID0gMDtcbiAgfVxuXG4gIC8qIEluIGEgZmlyc3QgcGFzcywgY29tcHV0ZSB0aGUgb3B0aW1hbCBiaXQgbGVuZ3RocyAod2hpY2ggbWF5XG4gICAqIG92ZXJmbG93IGluIHRoZSBjYXNlIG9mIHRoZSBiaXQgbGVuZ3RoIHRyZWUpLlxuICAgKi9cbiAgdHJlZVtzLmhlYXBbcy5oZWFwX21heF0gKiAyICsgMV0vKi5MZW4qLyA9IDA7IC8qIHJvb3Qgb2YgdGhlIGhlYXAgKi9cblxuICBmb3IgKGggPSBzLmhlYXBfbWF4ICsgMTsgaCA8IEhFQVBfU0laRTsgaCsrKSB7XG4gICAgbiA9IHMuaGVhcFtoXTtcbiAgICBiaXRzID0gdHJlZVt0cmVlW24gKiAyICsgMV0vKi5EYWQqLyAqIDIgKyAxXS8qLkxlbiovICsgMTtcbiAgICBpZiAoYml0cyA+IG1heF9sZW5ndGgpIHtcbiAgICAgIGJpdHMgPSBtYXhfbGVuZ3RoO1xuICAgICAgb3ZlcmZsb3crKztcbiAgICB9XG4gICAgdHJlZVtuICogMiArIDFdLyouTGVuKi8gPSBiaXRzO1xuICAgIC8qIFdlIG92ZXJ3cml0ZSB0cmVlW25dLkRhZCB3aGljaCBpcyBubyBsb25nZXIgbmVlZGVkICovXG5cbiAgICBpZiAobiA+IG1heF9jb2RlKSB7IGNvbnRpbnVlOyB9IC8qIG5vdCBhIGxlYWYgbm9kZSAqL1xuXG4gICAgcy5ibF9jb3VudFtiaXRzXSsrO1xuICAgIHhiaXRzID0gMDtcbiAgICBpZiAobiA+PSBiYXNlKSB7XG4gICAgICB4Yml0cyA9IGV4dHJhW24gLSBiYXNlXTtcbiAgICB9XG4gICAgZiA9IHRyZWVbbiAqIDJdLyouRnJlcSovO1xuICAgIHMub3B0X2xlbiArPSBmICogKGJpdHMgKyB4Yml0cyk7XG4gICAgaWYgKGhhc19zdHJlZSkge1xuICAgICAgcy5zdGF0aWNfbGVuICs9IGYgKiAoc3RyZWVbbiAqIDIgKyAxXS8qLkxlbiovICsgeGJpdHMpO1xuICAgIH1cbiAgfVxuICBpZiAob3ZlcmZsb3cgPT09IDApIHsgcmV0dXJuOyB9XG5cbiAgLy8gVHJhY2UoKHN0ZGVycixcIlxcbmJpdCBsZW5ndGggb3ZlcmZsb3dcXG5cIikpO1xuICAvKiBUaGlzIGhhcHBlbnMgZm9yIGV4YW1wbGUgb24gb2JqMiBhbmQgcGljIG9mIHRoZSBDYWxnYXJ5IGNvcnB1cyAqL1xuXG4gIC8qIEZpbmQgdGhlIGZpcnN0IGJpdCBsZW5ndGggd2hpY2ggY291bGQgaW5jcmVhc2U6ICovXG4gIGRvIHtcbiAgICBiaXRzID0gbWF4X2xlbmd0aCAtIDE7XG4gICAgd2hpbGUgKHMuYmxfY291bnRbYml0c10gPT09IDApIHsgYml0cy0tOyB9XG4gICAgcy5ibF9jb3VudFtiaXRzXS0tOyAgICAgIC8qIG1vdmUgb25lIGxlYWYgZG93biB0aGUgdHJlZSAqL1xuICAgIHMuYmxfY291bnRbYml0cyArIDFdICs9IDI7IC8qIG1vdmUgb25lIG92ZXJmbG93IGl0ZW0gYXMgaXRzIGJyb3RoZXIgKi9cbiAgICBzLmJsX2NvdW50W21heF9sZW5ndGhdLS07XG4gICAgLyogVGhlIGJyb3RoZXIgb2YgdGhlIG92ZXJmbG93IGl0ZW0gYWxzbyBtb3ZlcyBvbmUgc3RlcCB1cCxcbiAgICAgKiBidXQgdGhpcyBkb2VzIG5vdCBhZmZlY3QgYmxfY291bnRbbWF4X2xlbmd0aF1cbiAgICAgKi9cbiAgICBvdmVyZmxvdyAtPSAyO1xuICB9IHdoaWxlIChvdmVyZmxvdyA+IDApO1xuXG4gIC8qIE5vdyByZWNvbXB1dGUgYWxsIGJpdCBsZW5ndGhzLCBzY2FubmluZyBpbiBpbmNyZWFzaW5nIGZyZXF1ZW5jeS5cbiAgICogaCBpcyBzdGlsbCBlcXVhbCB0byBIRUFQX1NJWkUuIChJdCBpcyBzaW1wbGVyIHRvIHJlY29uc3RydWN0IGFsbFxuICAgKiBsZW5ndGhzIGluc3RlYWQgb2YgZml4aW5nIG9ubHkgdGhlIHdyb25nIG9uZXMuIFRoaXMgaWRlYSBpcyB0YWtlblxuICAgKiBmcm9tICdhcicgd3JpdHRlbiBieSBIYXJ1aGlrbyBPa3VtdXJhLilcbiAgICovXG4gIGZvciAoYml0cyA9IG1heF9sZW5ndGg7IGJpdHMgIT09IDA7IGJpdHMtLSkge1xuICAgIG4gPSBzLmJsX2NvdW50W2JpdHNdO1xuICAgIHdoaWxlIChuICE9PSAwKSB7XG4gICAgICBtID0gcy5oZWFwWy0taF07XG4gICAgICBpZiAobSA+IG1heF9jb2RlKSB7IGNvbnRpbnVlOyB9XG4gICAgICBpZiAodHJlZVttICogMiArIDFdLyouTGVuKi8gIT09IGJpdHMpIHtcbiAgICAgICAgLy8gVHJhY2UoKHN0ZGVycixcImNvZGUgJWQgYml0cyAlZC0+JWRcXG5cIiwgbSwgdHJlZVttXS5MZW4sIGJpdHMpKTtcbiAgICAgICAgcy5vcHRfbGVuICs9IChiaXRzIC0gdHJlZVttICogMiArIDFdLyouTGVuKi8pICogdHJlZVttICogMl0vKi5GcmVxKi87XG4gICAgICAgIHRyZWVbbSAqIDIgKyAxXS8qLkxlbiovID0gYml0cztcbiAgICAgIH1cbiAgICAgIG4tLTtcbiAgICB9XG4gIH1cbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEdlbmVyYXRlIHRoZSBjb2RlcyBmb3IgYSBnaXZlbiB0cmVlIGFuZCBiaXQgY291bnRzICh3aGljaCBuZWVkIG5vdCBiZVxuICogb3B0aW1hbCkuXG4gKiBJTiBhc3NlcnRpb246IHRoZSBhcnJheSBibF9jb3VudCBjb250YWlucyB0aGUgYml0IGxlbmd0aCBzdGF0aXN0aWNzIGZvclxuICogdGhlIGdpdmVuIHRyZWUgYW5kIHRoZSBmaWVsZCBsZW4gaXMgc2V0IGZvciBhbGwgdHJlZSBlbGVtZW50cy5cbiAqIE9VVCBhc3NlcnRpb246IHRoZSBmaWVsZCBjb2RlIGlzIHNldCBmb3IgYWxsIHRyZWUgZWxlbWVudHMgb2Ygbm9uXG4gKiAgICAgemVybyBjb2RlIGxlbmd0aC5cbiAqL1xuZnVuY3Rpb24gZ2VuX2NvZGVzKHRyZWUsIG1heF9jb2RlLCBibF9jb3VudClcbi8vICAgIGN0X2RhdGEgKnRyZWU7ICAgICAgICAgICAgIC8qIHRoZSB0cmVlIHRvIGRlY29yYXRlICovXG4vLyAgICBpbnQgbWF4X2NvZGU7ICAgICAgICAgICAgICAvKiBsYXJnZXN0IGNvZGUgd2l0aCBub24gemVybyBmcmVxdWVuY3kgKi9cbi8vICAgIHVzaGYgKmJsX2NvdW50OyAgICAgICAgICAgIC8qIG51bWJlciBvZiBjb2RlcyBhdCBlYWNoIGJpdCBsZW5ndGggKi9cbntcbiAgdmFyIG5leHRfY29kZSA9IG5ldyBBcnJheShNQVhfQklUUyArIDEpOyAvKiBuZXh0IGNvZGUgdmFsdWUgZm9yIGVhY2ggYml0IGxlbmd0aCAqL1xuICB2YXIgY29kZSA9IDA7ICAgICAgICAgICAgICAvKiBydW5uaW5nIGNvZGUgdmFsdWUgKi9cbiAgdmFyIGJpdHM7ICAgICAgICAgICAgICAgICAgLyogYml0IGluZGV4ICovXG4gIHZhciBuOyAgICAgICAgICAgICAgICAgICAgIC8qIGNvZGUgaW5kZXggKi9cblxuICAvKiBUaGUgZGlzdHJpYnV0aW9uIGNvdW50cyBhcmUgZmlyc3QgdXNlZCB0byBnZW5lcmF0ZSB0aGUgY29kZSB2YWx1ZXNcbiAgICogd2l0aG91dCBiaXQgcmV2ZXJzYWwuXG4gICAqL1xuICBmb3IgKGJpdHMgPSAxOyBiaXRzIDw9IE1BWF9CSVRTOyBiaXRzKyspIHtcbiAgICBuZXh0X2NvZGVbYml0c10gPSBjb2RlID0gKGNvZGUgKyBibF9jb3VudFtiaXRzIC0gMV0pIDw8IDE7XG4gIH1cbiAgLyogQ2hlY2sgdGhhdCB0aGUgYml0IGNvdW50cyBpbiBibF9jb3VudCBhcmUgY29uc2lzdGVudC4gVGhlIGxhc3QgY29kZVxuICAgKiBtdXN0IGJlIGFsbCBvbmVzLlxuICAgKi9cbiAgLy9Bc3NlcnQgKGNvZGUgKyBibF9jb3VudFtNQVhfQklUU10tMSA9PSAoMTw8TUFYX0JJVFMpLTEsXG4gIC8vICAgICAgICBcImluY29uc2lzdGVudCBiaXQgY291bnRzXCIpO1xuICAvL1RyYWNldigoc3RkZXJyLFwiXFxuZ2VuX2NvZGVzOiBtYXhfY29kZSAlZCBcIiwgbWF4X2NvZGUpKTtcblxuICBmb3IgKG4gPSAwOyAgbiA8PSBtYXhfY29kZTsgbisrKSB7XG4gICAgdmFyIGxlbiA9IHRyZWVbbiAqIDIgKyAxXS8qLkxlbiovO1xuICAgIGlmIChsZW4gPT09IDApIHsgY29udGludWU7IH1cbiAgICAvKiBOb3cgcmV2ZXJzZSB0aGUgYml0cyAqL1xuICAgIHRyZWVbbiAqIDJdLyouQ29kZSovID0gYmlfcmV2ZXJzZShuZXh0X2NvZGVbbGVuXSsrLCBsZW4pO1xuXG4gICAgLy9UcmFjZWN2KHRyZWUgIT0gc3RhdGljX2x0cmVlLCAoc3RkZXJyLFwiXFxubiAlM2QgJWMgbCAlMmQgYyAlNHggKCV4KSBcIixcbiAgICAvLyAgICAgbiwgKGlzZ3JhcGgobikgPyBuIDogJyAnKSwgbGVuLCB0cmVlW25dLkNvZGUsIG5leHRfY29kZVtsZW5dLTEpKTtcbiAgfVxufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogSW5pdGlhbGl6ZSB0aGUgdmFyaW91cyAnY29uc3RhbnQnIHRhYmxlcy5cbiAqL1xuZnVuY3Rpb24gdHJfc3RhdGljX2luaXQoKSB7XG4gIHZhciBuOyAgICAgICAgLyogaXRlcmF0ZXMgb3ZlciB0cmVlIGVsZW1lbnRzICovXG4gIHZhciBiaXRzOyAgICAgLyogYml0IGNvdW50ZXIgKi9cbiAgdmFyIGxlbmd0aDsgICAvKiBsZW5ndGggdmFsdWUgKi9cbiAgdmFyIGNvZGU7ICAgICAvKiBjb2RlIHZhbHVlICovXG4gIHZhciBkaXN0OyAgICAgLyogZGlzdGFuY2UgaW5kZXggKi9cbiAgdmFyIGJsX2NvdW50ID0gbmV3IEFycmF5KE1BWF9CSVRTICsgMSk7XG4gIC8qIG51bWJlciBvZiBjb2RlcyBhdCBlYWNoIGJpdCBsZW5ndGggZm9yIGFuIG9wdGltYWwgdHJlZSAqL1xuXG4gIC8vIGRvIGNoZWNrIGluIF90cl9pbml0KClcbiAgLy9pZiAoc3RhdGljX2luaXRfZG9uZSkgcmV0dXJuO1xuXG4gIC8qIEZvciBzb21lIGVtYmVkZGVkIHRhcmdldHMsIGdsb2JhbCB2YXJpYWJsZXMgYXJlIG5vdCBpbml0aWFsaXplZDogKi9cbi8qI2lmZGVmIE5PX0lOSVRfR0xPQkFMX1BPSU5URVJTXG4gIHN0YXRpY19sX2Rlc2Muc3RhdGljX3RyZWUgPSBzdGF0aWNfbHRyZWU7XG4gIHN0YXRpY19sX2Rlc2MuZXh0cmFfYml0cyA9IGV4dHJhX2xiaXRzO1xuICBzdGF0aWNfZF9kZXNjLnN0YXRpY190cmVlID0gc3RhdGljX2R0cmVlO1xuICBzdGF0aWNfZF9kZXNjLmV4dHJhX2JpdHMgPSBleHRyYV9kYml0cztcbiAgc3RhdGljX2JsX2Rlc2MuZXh0cmFfYml0cyA9IGV4dHJhX2JsYml0cztcbiNlbmRpZiovXG5cbiAgLyogSW5pdGlhbGl6ZSB0aGUgbWFwcGluZyBsZW5ndGggKDAuLjI1NSkgLT4gbGVuZ3RoIGNvZGUgKDAuLjI4KSAqL1xuICBsZW5ndGggPSAwO1xuICBmb3IgKGNvZGUgPSAwOyBjb2RlIDwgTEVOR1RIX0NPREVTIC0gMTsgY29kZSsrKSB7XG4gICAgYmFzZV9sZW5ndGhbY29kZV0gPSBsZW5ndGg7XG4gICAgZm9yIChuID0gMDsgbiA8ICgxIDw8IGV4dHJhX2xiaXRzW2NvZGVdKTsgbisrKSB7XG4gICAgICBfbGVuZ3RoX2NvZGVbbGVuZ3RoKytdID0gY29kZTtcbiAgICB9XG4gIH1cbiAgLy9Bc3NlcnQgKGxlbmd0aCA9PSAyNTYsIFwidHJfc3RhdGljX2luaXQ6IGxlbmd0aCAhPSAyNTZcIik7XG4gIC8qIE5vdGUgdGhhdCB0aGUgbGVuZ3RoIDI1NSAobWF0Y2ggbGVuZ3RoIDI1OCkgY2FuIGJlIHJlcHJlc2VudGVkXG4gICAqIGluIHR3byBkaWZmZXJlbnQgd2F5czogY29kZSAyODQgKyA1IGJpdHMgb3IgY29kZSAyODUsIHNvIHdlXG4gICAqIG92ZXJ3cml0ZSBsZW5ndGhfY29kZVsyNTVdIHRvIHVzZSB0aGUgYmVzdCBlbmNvZGluZzpcbiAgICovXG4gIF9sZW5ndGhfY29kZVtsZW5ndGggLSAxXSA9IGNvZGU7XG5cbiAgLyogSW5pdGlhbGl6ZSB0aGUgbWFwcGluZyBkaXN0ICgwLi4zMkspIC0+IGRpc3QgY29kZSAoMC4uMjkpICovXG4gIGRpc3QgPSAwO1xuICBmb3IgKGNvZGUgPSAwOyBjb2RlIDwgMTY7IGNvZGUrKykge1xuICAgIGJhc2VfZGlzdFtjb2RlXSA9IGRpc3Q7XG4gICAgZm9yIChuID0gMDsgbiA8ICgxIDw8IGV4dHJhX2RiaXRzW2NvZGVdKTsgbisrKSB7XG4gICAgICBfZGlzdF9jb2RlW2Rpc3QrK10gPSBjb2RlO1xuICAgIH1cbiAgfVxuICAvL0Fzc2VydCAoZGlzdCA9PSAyNTYsIFwidHJfc3RhdGljX2luaXQ6IGRpc3QgIT0gMjU2XCIpO1xuICBkaXN0ID4+PSA3OyAvKiBmcm9tIG5vdyBvbiwgYWxsIGRpc3RhbmNlcyBhcmUgZGl2aWRlZCBieSAxMjggKi9cbiAgZm9yICg7IGNvZGUgPCBEX0NPREVTOyBjb2RlKyspIHtcbiAgICBiYXNlX2Rpc3RbY29kZV0gPSBkaXN0IDw8IDc7XG4gICAgZm9yIChuID0gMDsgbiA8ICgxIDw8IChleHRyYV9kYml0c1tjb2RlXSAtIDcpKTsgbisrKSB7XG4gICAgICBfZGlzdF9jb2RlWzI1NiArIGRpc3QrK10gPSBjb2RlO1xuICAgIH1cbiAgfVxuICAvL0Fzc2VydCAoZGlzdCA9PSAyNTYsIFwidHJfc3RhdGljX2luaXQ6IDI1NitkaXN0ICE9IDUxMlwiKTtcblxuICAvKiBDb25zdHJ1Y3QgdGhlIGNvZGVzIG9mIHRoZSBzdGF0aWMgbGl0ZXJhbCB0cmVlICovXG4gIGZvciAoYml0cyA9IDA7IGJpdHMgPD0gTUFYX0JJVFM7IGJpdHMrKykge1xuICAgIGJsX2NvdW50W2JpdHNdID0gMDtcbiAgfVxuXG4gIG4gPSAwO1xuICB3aGlsZSAobiA8PSAxNDMpIHtcbiAgICBzdGF0aWNfbHRyZWVbbiAqIDIgKyAxXS8qLkxlbiovID0gODtcbiAgICBuKys7XG4gICAgYmxfY291bnRbOF0rKztcbiAgfVxuICB3aGlsZSAobiA8PSAyNTUpIHtcbiAgICBzdGF0aWNfbHRyZWVbbiAqIDIgKyAxXS8qLkxlbiovID0gOTtcbiAgICBuKys7XG4gICAgYmxfY291bnRbOV0rKztcbiAgfVxuICB3aGlsZSAobiA8PSAyNzkpIHtcbiAgICBzdGF0aWNfbHRyZWVbbiAqIDIgKyAxXS8qLkxlbiovID0gNztcbiAgICBuKys7XG4gICAgYmxfY291bnRbN10rKztcbiAgfVxuICB3aGlsZSAobiA8PSAyODcpIHtcbiAgICBzdGF0aWNfbHRyZWVbbiAqIDIgKyAxXS8qLkxlbiovID0gODtcbiAgICBuKys7XG4gICAgYmxfY291bnRbOF0rKztcbiAgfVxuICAvKiBDb2RlcyAyODYgYW5kIDI4NyBkbyBub3QgZXhpc3QsIGJ1dCB3ZSBtdXN0IGluY2x1ZGUgdGhlbSBpbiB0aGVcbiAgICogdHJlZSBjb25zdHJ1Y3Rpb24gdG8gZ2V0IGEgY2Fub25pY2FsIEh1ZmZtYW4gdHJlZSAobG9uZ2VzdCBjb2RlXG4gICAqIGFsbCBvbmVzKVxuICAgKi9cbiAgZ2VuX2NvZGVzKHN0YXRpY19sdHJlZSwgTF9DT0RFUyArIDEsIGJsX2NvdW50KTtcblxuICAvKiBUaGUgc3RhdGljIGRpc3RhbmNlIHRyZWUgaXMgdHJpdmlhbDogKi9cbiAgZm9yIChuID0gMDsgbiA8IERfQ09ERVM7IG4rKykge1xuICAgIHN0YXRpY19kdHJlZVtuICogMiArIDFdLyouTGVuKi8gPSA1O1xuICAgIHN0YXRpY19kdHJlZVtuICogMl0vKi5Db2RlKi8gPSBiaV9yZXZlcnNlKG4sIDUpO1xuICB9XG5cbiAgLy8gTm93IGRhdGEgcmVhZHkgYW5kIHdlIGNhbiBpbml0IHN0YXRpYyB0cmVlc1xuICBzdGF0aWNfbF9kZXNjID0gbmV3IFN0YXRpY1RyZWVEZXNjKHN0YXRpY19sdHJlZSwgZXh0cmFfbGJpdHMsIExJVEVSQUxTICsgMSwgTF9DT0RFUywgTUFYX0JJVFMpO1xuICBzdGF0aWNfZF9kZXNjID0gbmV3IFN0YXRpY1RyZWVEZXNjKHN0YXRpY19kdHJlZSwgZXh0cmFfZGJpdHMsIDAsICAgICAgICAgIERfQ09ERVMsIE1BWF9CSVRTKTtcbiAgc3RhdGljX2JsX2Rlc2MgPSBuZXcgU3RhdGljVHJlZURlc2MobmV3IEFycmF5KDApLCBleHRyYV9ibGJpdHMsIDAsICAgICAgICAgQkxfQ09ERVMsIE1BWF9CTF9CSVRTKTtcblxuICAvL3N0YXRpY19pbml0X2RvbmUgPSB0cnVlO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogSW5pdGlhbGl6ZSBhIG5ldyBibG9jay5cbiAqL1xuZnVuY3Rpb24gaW5pdF9ibG9jayhzKSB7XG4gIHZhciBuOyAvKiBpdGVyYXRlcyBvdmVyIHRyZWUgZWxlbWVudHMgKi9cblxuICAvKiBJbml0aWFsaXplIHRoZSB0cmVlcy4gKi9cbiAgZm9yIChuID0gMDsgbiA8IExfQ09ERVM7ICBuKyspIHsgcy5keW5fbHRyZWVbbiAqIDJdLyouRnJlcSovID0gMDsgfVxuICBmb3IgKG4gPSAwOyBuIDwgRF9DT0RFUzsgIG4rKykgeyBzLmR5bl9kdHJlZVtuICogMl0vKi5GcmVxKi8gPSAwOyB9XG4gIGZvciAobiA9IDA7IG4gPCBCTF9DT0RFUzsgbisrKSB7IHMuYmxfdHJlZVtuICogMl0vKi5GcmVxKi8gPSAwOyB9XG5cbiAgcy5keW5fbHRyZWVbRU5EX0JMT0NLICogMl0vKi5GcmVxKi8gPSAxO1xuICBzLm9wdF9sZW4gPSBzLnN0YXRpY19sZW4gPSAwO1xuICBzLmxhc3RfbGl0ID0gcy5tYXRjaGVzID0gMDtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEZsdXNoIHRoZSBiaXQgYnVmZmVyIGFuZCBhbGlnbiB0aGUgb3V0cHV0IG9uIGEgYnl0ZSBib3VuZGFyeVxuICovXG5mdW5jdGlvbiBiaV93aW5kdXAocylcbntcbiAgaWYgKHMuYmlfdmFsaWQgPiA4KSB7XG4gICAgcHV0X3Nob3J0KHMsIHMuYmlfYnVmKTtcbiAgfSBlbHNlIGlmIChzLmJpX3ZhbGlkID4gMCkge1xuICAgIC8vcHV0X2J5dGUocywgKEJ5dGUpcy0+YmlfYnVmKTtcbiAgICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9IHMuYmlfYnVmO1xuICB9XG4gIHMuYmlfYnVmID0gMDtcbiAgcy5iaV92YWxpZCA9IDA7XG59XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29weSBhIHN0b3JlZCBibG9jaywgc3RvcmluZyBmaXJzdCB0aGUgbGVuZ3RoIGFuZCBpdHNcbiAqIG9uZSdzIGNvbXBsZW1lbnQgaWYgcmVxdWVzdGVkLlxuICovXG5mdW5jdGlvbiBjb3B5X2Jsb2NrKHMsIGJ1ZiwgbGVuLCBoZWFkZXIpXG4vL0RlZmxhdGVTdGF0ZSAqcztcbi8vY2hhcmYgICAgKmJ1ZjsgICAgLyogdGhlIGlucHV0IGRhdGEgKi9cbi8vdW5zaWduZWQgbGVuOyAgICAgLyogaXRzIGxlbmd0aCAqL1xuLy9pbnQgICAgICBoZWFkZXI7ICAvKiB0cnVlIGlmIGJsb2NrIGhlYWRlciBtdXN0IGJlIHdyaXR0ZW4gKi9cbntcbiAgYmlfd2luZHVwKHMpOyAgICAgICAgLyogYWxpZ24gb24gYnl0ZSBib3VuZGFyeSAqL1xuXG4gIGlmIChoZWFkZXIpIHtcbiAgICBwdXRfc2hvcnQocywgbGVuKTtcbiAgICBwdXRfc2hvcnQocywgfmxlbik7XG4gIH1cbi8vICB3aGlsZSAobGVuLS0pIHtcbi8vICAgIHB1dF9ieXRlKHMsICpidWYrKyk7XG4vLyAgfVxuICB1dGlscy5hcnJheVNldChzLnBlbmRpbmdfYnVmLCBzLndpbmRvdywgYnVmLCBsZW4sIHMucGVuZGluZyk7XG4gIHMucGVuZGluZyArPSBsZW47XG59XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29tcGFyZXMgdG8gc3VidHJlZXMsIHVzaW5nIHRoZSB0cmVlIGRlcHRoIGFzIHRpZSBicmVha2VyIHdoZW5cbiAqIHRoZSBzdWJ0cmVlcyBoYXZlIGVxdWFsIGZyZXF1ZW5jeS4gVGhpcyBtaW5pbWl6ZXMgdGhlIHdvcnN0IGNhc2UgbGVuZ3RoLlxuICovXG5mdW5jdGlvbiBzbWFsbGVyKHRyZWUsIG4sIG0sIGRlcHRoKSB7XG4gIHZhciBfbjIgPSBuICogMjtcbiAgdmFyIF9tMiA9IG0gKiAyO1xuICByZXR1cm4gKHRyZWVbX24yXS8qLkZyZXEqLyA8IHRyZWVbX20yXS8qLkZyZXEqLyB8fFxuICAgICAgICAgKHRyZWVbX24yXS8qLkZyZXEqLyA9PT0gdHJlZVtfbTJdLyouRnJlcSovICYmIGRlcHRoW25dIDw9IGRlcHRoW21dKSk7XG59XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogUmVzdG9yZSB0aGUgaGVhcCBwcm9wZXJ0eSBieSBtb3ZpbmcgZG93biB0aGUgdHJlZSBzdGFydGluZyBhdCBub2RlIGssXG4gKiBleGNoYW5naW5nIGEgbm9kZSB3aXRoIHRoZSBzbWFsbGVzdCBvZiBpdHMgdHdvIHNvbnMgaWYgbmVjZXNzYXJ5LCBzdG9wcGluZ1xuICogd2hlbiB0aGUgaGVhcCBwcm9wZXJ0eSBpcyByZS1lc3RhYmxpc2hlZCAoZWFjaCBmYXRoZXIgc21hbGxlciB0aGFuIGl0c1xuICogdHdvIHNvbnMpLlxuICovXG5mdW5jdGlvbiBwcWRvd25oZWFwKHMsIHRyZWUsIGspXG4vLyAgICBkZWZsYXRlX3N0YXRlICpzO1xuLy8gICAgY3RfZGF0YSAqdHJlZTsgIC8qIHRoZSB0cmVlIHRvIHJlc3RvcmUgKi9cbi8vICAgIGludCBrOyAgICAgICAgICAgICAgIC8qIG5vZGUgdG8gbW92ZSBkb3duICovXG57XG4gIHZhciB2ID0gcy5oZWFwW2tdO1xuICB2YXIgaiA9IGsgPDwgMTsgIC8qIGxlZnQgc29uIG9mIGsgKi9cbiAgd2hpbGUgKGogPD0gcy5oZWFwX2xlbikge1xuICAgIC8qIFNldCBqIHRvIHRoZSBzbWFsbGVzdCBvZiB0aGUgdHdvIHNvbnM6ICovXG4gICAgaWYgKGogPCBzLmhlYXBfbGVuICYmXG4gICAgICBzbWFsbGVyKHRyZWUsIHMuaGVhcFtqICsgMV0sIHMuaGVhcFtqXSwgcy5kZXB0aCkpIHtcbiAgICAgIGorKztcbiAgICB9XG4gICAgLyogRXhpdCBpZiB2IGlzIHNtYWxsZXIgdGhhbiBib3RoIHNvbnMgKi9cbiAgICBpZiAoc21hbGxlcih0cmVlLCB2LCBzLmhlYXBbal0sIHMuZGVwdGgpKSB7IGJyZWFrOyB9XG5cbiAgICAvKiBFeGNoYW5nZSB2IHdpdGggdGhlIHNtYWxsZXN0IHNvbiAqL1xuICAgIHMuaGVhcFtrXSA9IHMuaGVhcFtqXTtcbiAgICBrID0gajtcblxuICAgIC8qIEFuZCBjb250aW51ZSBkb3duIHRoZSB0cmVlLCBzZXR0aW5nIGogdG8gdGhlIGxlZnQgc29uIG9mIGsgKi9cbiAgICBqIDw8PSAxO1xuICB9XG4gIHMuaGVhcFtrXSA9IHY7XG59XG5cblxuLy8gaW5saW5lZCBtYW51YWxseVxuLy8gdmFyIFNNQUxMRVNUID0gMTtcblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTZW5kIHRoZSBibG9jayBkYXRhIGNvbXByZXNzZWQgdXNpbmcgdGhlIGdpdmVuIEh1ZmZtYW4gdHJlZXNcbiAqL1xuZnVuY3Rpb24gY29tcHJlc3NfYmxvY2socywgbHRyZWUsIGR0cmVlKVxuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIGNvbnN0IGN0X2RhdGEgKmx0cmVlOyAvKiBsaXRlcmFsIHRyZWUgKi9cbi8vICAgIGNvbnN0IGN0X2RhdGEgKmR0cmVlOyAvKiBkaXN0YW5jZSB0cmVlICovXG57XG4gIHZhciBkaXN0OyAgICAgICAgICAgLyogZGlzdGFuY2Ugb2YgbWF0Y2hlZCBzdHJpbmcgKi9cbiAgdmFyIGxjOyAgICAgICAgICAgICAvKiBtYXRjaCBsZW5ndGggb3IgdW5tYXRjaGVkIGNoYXIgKGlmIGRpc3QgPT0gMCkgKi9cbiAgdmFyIGx4ID0gMDsgICAgICAgICAvKiBydW5uaW5nIGluZGV4IGluIGxfYnVmICovXG4gIHZhciBjb2RlOyAgICAgICAgICAgLyogdGhlIGNvZGUgdG8gc2VuZCAqL1xuICB2YXIgZXh0cmE7ICAgICAgICAgIC8qIG51bWJlciBvZiBleHRyYSBiaXRzIHRvIHNlbmQgKi9cblxuICBpZiAocy5sYXN0X2xpdCAhPT0gMCkge1xuICAgIGRvIHtcbiAgICAgIGRpc3QgPSAocy5wZW5kaW5nX2J1ZltzLmRfYnVmICsgbHggKiAyXSA8PCA4KSB8IChzLnBlbmRpbmdfYnVmW3MuZF9idWYgKyBseCAqIDIgKyAxXSk7XG4gICAgICBsYyA9IHMucGVuZGluZ19idWZbcy5sX2J1ZiArIGx4XTtcbiAgICAgIGx4Kys7XG5cbiAgICAgIGlmIChkaXN0ID09PSAwKSB7XG4gICAgICAgIHNlbmRfY29kZShzLCBsYywgbHRyZWUpOyAvKiBzZW5kIGEgbGl0ZXJhbCBieXRlICovXG4gICAgICAgIC8vVHJhY2Vjdihpc2dyYXBoKGxjKSwgKHN0ZGVycixcIiAnJWMnIFwiLCBsYykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLyogSGVyZSwgbGMgaXMgdGhlIG1hdGNoIGxlbmd0aCAtIE1JTl9NQVRDSCAqL1xuICAgICAgICBjb2RlID0gX2xlbmd0aF9jb2RlW2xjXTtcbiAgICAgICAgc2VuZF9jb2RlKHMsIGNvZGUgKyBMSVRFUkFMUyArIDEsIGx0cmVlKTsgLyogc2VuZCB0aGUgbGVuZ3RoIGNvZGUgKi9cbiAgICAgICAgZXh0cmEgPSBleHRyYV9sYml0c1tjb2RlXTtcbiAgICAgICAgaWYgKGV4dHJhICE9PSAwKSB7XG4gICAgICAgICAgbGMgLT0gYmFzZV9sZW5ndGhbY29kZV07XG4gICAgICAgICAgc2VuZF9iaXRzKHMsIGxjLCBleHRyYSk7ICAgICAgIC8qIHNlbmQgdGhlIGV4dHJhIGxlbmd0aCBiaXRzICovXG4gICAgICAgIH1cbiAgICAgICAgZGlzdC0tOyAvKiBkaXN0IGlzIG5vdyB0aGUgbWF0Y2ggZGlzdGFuY2UgLSAxICovXG4gICAgICAgIGNvZGUgPSBkX2NvZGUoZGlzdCk7XG4gICAgICAgIC8vQXNzZXJ0IChjb2RlIDwgRF9DT0RFUywgXCJiYWQgZF9jb2RlXCIpO1xuXG4gICAgICAgIHNlbmRfY29kZShzLCBjb2RlLCBkdHJlZSk7ICAgICAgIC8qIHNlbmQgdGhlIGRpc3RhbmNlIGNvZGUgKi9cbiAgICAgICAgZXh0cmEgPSBleHRyYV9kYml0c1tjb2RlXTtcbiAgICAgICAgaWYgKGV4dHJhICE9PSAwKSB7XG4gICAgICAgICAgZGlzdCAtPSBiYXNlX2Rpc3RbY29kZV07XG4gICAgICAgICAgc2VuZF9iaXRzKHMsIGRpc3QsIGV4dHJhKTsgICAvKiBzZW5kIHRoZSBleHRyYSBkaXN0YW5jZSBiaXRzICovXG4gICAgICAgIH1cbiAgICAgIH0gLyogbGl0ZXJhbCBvciBtYXRjaCBwYWlyID8gKi9cblxuICAgICAgLyogQ2hlY2sgdGhhdCB0aGUgb3ZlcmxheSBiZXR3ZWVuIHBlbmRpbmdfYnVmIGFuZCBkX2J1ZitsX2J1ZiBpcyBvazogKi9cbiAgICAgIC8vQXNzZXJ0KCh1SW50KShzLT5wZW5kaW5nKSA8IHMtPmxpdF9idWZzaXplICsgMipseCxcbiAgICAgIC8vICAgICAgIFwicGVuZGluZ0J1ZiBvdmVyZmxvd1wiKTtcblxuICAgIH0gd2hpbGUgKGx4IDwgcy5sYXN0X2xpdCk7XG4gIH1cblxuICBzZW5kX2NvZGUocywgRU5EX0JMT0NLLCBsdHJlZSk7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb25zdHJ1Y3Qgb25lIEh1ZmZtYW4gdHJlZSBhbmQgYXNzaWducyB0aGUgY29kZSBiaXQgc3RyaW5ncyBhbmQgbGVuZ3Rocy5cbiAqIFVwZGF0ZSB0aGUgdG90YWwgYml0IGxlbmd0aCBmb3IgdGhlIGN1cnJlbnQgYmxvY2suXG4gKiBJTiBhc3NlcnRpb246IHRoZSBmaWVsZCBmcmVxIGlzIHNldCBmb3IgYWxsIHRyZWUgZWxlbWVudHMuXG4gKiBPVVQgYXNzZXJ0aW9uczogdGhlIGZpZWxkcyBsZW4gYW5kIGNvZGUgYXJlIHNldCB0byB0aGUgb3B0aW1hbCBiaXQgbGVuZ3RoXG4gKiAgICAgYW5kIGNvcnJlc3BvbmRpbmcgY29kZS4gVGhlIGxlbmd0aCBvcHRfbGVuIGlzIHVwZGF0ZWQ7IHN0YXRpY19sZW4gaXNcbiAqICAgICBhbHNvIHVwZGF0ZWQgaWYgc3RyZWUgaXMgbm90IG51bGwuIFRoZSBmaWVsZCBtYXhfY29kZSBpcyBzZXQuXG4gKi9cbmZ1bmN0aW9uIGJ1aWxkX3RyZWUocywgZGVzYylcbi8vICAgIGRlZmxhdGVfc3RhdGUgKnM7XG4vLyAgICB0cmVlX2Rlc2MgKmRlc2M7IC8qIHRoZSB0cmVlIGRlc2NyaXB0b3IgKi9cbntcbiAgdmFyIHRyZWUgICAgID0gZGVzYy5keW5fdHJlZTtcbiAgdmFyIHN0cmVlICAgID0gZGVzYy5zdGF0X2Rlc2Muc3RhdGljX3RyZWU7XG4gIHZhciBoYXNfc3RyZWUgPSBkZXNjLnN0YXRfZGVzYy5oYXNfc3RyZWU7XG4gIHZhciBlbGVtcyAgICA9IGRlc2Muc3RhdF9kZXNjLmVsZW1zO1xuICB2YXIgbiwgbTsgICAgICAgICAgLyogaXRlcmF0ZSBvdmVyIGhlYXAgZWxlbWVudHMgKi9cbiAgdmFyIG1heF9jb2RlID0gLTE7IC8qIGxhcmdlc3QgY29kZSB3aXRoIG5vbiB6ZXJvIGZyZXF1ZW5jeSAqL1xuICB2YXIgbm9kZTsgICAgICAgICAgLyogbmV3IG5vZGUgYmVpbmcgY3JlYXRlZCAqL1xuXG4gIC8qIENvbnN0cnVjdCB0aGUgaW5pdGlhbCBoZWFwLCB3aXRoIGxlYXN0IGZyZXF1ZW50IGVsZW1lbnQgaW5cbiAgICogaGVhcFtTTUFMTEVTVF0uIFRoZSBzb25zIG9mIGhlYXBbbl0gYXJlIGhlYXBbMipuXSBhbmQgaGVhcFsyKm4rMV0uXG4gICAqIGhlYXBbMF0gaXMgbm90IHVzZWQuXG4gICAqL1xuICBzLmhlYXBfbGVuID0gMDtcbiAgcy5oZWFwX21heCA9IEhFQVBfU0laRTtcblxuICBmb3IgKG4gPSAwOyBuIDwgZWxlbXM7IG4rKykge1xuICAgIGlmICh0cmVlW24gKiAyXS8qLkZyZXEqLyAhPT0gMCkge1xuICAgICAgcy5oZWFwWysrcy5oZWFwX2xlbl0gPSBtYXhfY29kZSA9IG47XG4gICAgICBzLmRlcHRoW25dID0gMDtcblxuICAgIH0gZWxzZSB7XG4gICAgICB0cmVlW24gKiAyICsgMV0vKi5MZW4qLyA9IDA7XG4gICAgfVxuICB9XG5cbiAgLyogVGhlIHBremlwIGZvcm1hdCByZXF1aXJlcyB0aGF0IGF0IGxlYXN0IG9uZSBkaXN0YW5jZSBjb2RlIGV4aXN0cyxcbiAgICogYW5kIHRoYXQgYXQgbGVhc3Qgb25lIGJpdCBzaG91bGQgYmUgc2VudCBldmVuIGlmIHRoZXJlIGlzIG9ubHkgb25lXG4gICAqIHBvc3NpYmxlIGNvZGUuIFNvIHRvIGF2b2lkIHNwZWNpYWwgY2hlY2tzIGxhdGVyIG9uIHdlIGZvcmNlIGF0IGxlYXN0XG4gICAqIHR3byBjb2RlcyBvZiBub24gemVybyBmcmVxdWVuY3kuXG4gICAqL1xuICB3aGlsZSAocy5oZWFwX2xlbiA8IDIpIHtcbiAgICBub2RlID0gcy5oZWFwWysrcy5oZWFwX2xlbl0gPSAobWF4X2NvZGUgPCAyID8gKyttYXhfY29kZSA6IDApO1xuICAgIHRyZWVbbm9kZSAqIDJdLyouRnJlcSovID0gMTtcbiAgICBzLmRlcHRoW25vZGVdID0gMDtcbiAgICBzLm9wdF9sZW4tLTtcblxuICAgIGlmIChoYXNfc3RyZWUpIHtcbiAgICAgIHMuc3RhdGljX2xlbiAtPSBzdHJlZVtub2RlICogMiArIDFdLyouTGVuKi87XG4gICAgfVxuICAgIC8qIG5vZGUgaXMgMCBvciAxIHNvIGl0IGRvZXMgbm90IGhhdmUgZXh0cmEgYml0cyAqL1xuICB9XG4gIGRlc2MubWF4X2NvZGUgPSBtYXhfY29kZTtcblxuICAvKiBUaGUgZWxlbWVudHMgaGVhcFtoZWFwX2xlbi8yKzEgLi4gaGVhcF9sZW5dIGFyZSBsZWF2ZXMgb2YgdGhlIHRyZWUsXG4gICAqIGVzdGFibGlzaCBzdWItaGVhcHMgb2YgaW5jcmVhc2luZyBsZW5ndGhzOlxuICAgKi9cbiAgZm9yIChuID0gKHMuaGVhcF9sZW4gPj4gMS8qaW50IC8yKi8pOyBuID49IDE7IG4tLSkgeyBwcWRvd25oZWFwKHMsIHRyZWUsIG4pOyB9XG5cbiAgLyogQ29uc3RydWN0IHRoZSBIdWZmbWFuIHRyZWUgYnkgcmVwZWF0ZWRseSBjb21iaW5pbmcgdGhlIGxlYXN0IHR3b1xuICAgKiBmcmVxdWVudCBub2Rlcy5cbiAgICovXG4gIG5vZGUgPSBlbGVtczsgICAgICAgICAgICAgIC8qIG5leHQgaW50ZXJuYWwgbm9kZSBvZiB0aGUgdHJlZSAqL1xuICBkbyB7XG4gICAgLy9wcXJlbW92ZShzLCB0cmVlLCBuKTsgIC8qIG4gPSBub2RlIG9mIGxlYXN0IGZyZXF1ZW5jeSAqL1xuICAgIC8qKiogcHFyZW1vdmUgKioqL1xuICAgIG4gPSBzLmhlYXBbMS8qU01BTExFU1QqL107XG4gICAgcy5oZWFwWzEvKlNNQUxMRVNUKi9dID0gcy5oZWFwW3MuaGVhcF9sZW4tLV07XG4gICAgcHFkb3duaGVhcChzLCB0cmVlLCAxLypTTUFMTEVTVCovKTtcbiAgICAvKioqL1xuXG4gICAgbSA9IHMuaGVhcFsxLypTTUFMTEVTVCovXTsgLyogbSA9IG5vZGUgb2YgbmV4dCBsZWFzdCBmcmVxdWVuY3kgKi9cblxuICAgIHMuaGVhcFstLXMuaGVhcF9tYXhdID0gbjsgLyoga2VlcCB0aGUgbm9kZXMgc29ydGVkIGJ5IGZyZXF1ZW5jeSAqL1xuICAgIHMuaGVhcFstLXMuaGVhcF9tYXhdID0gbTtcblxuICAgIC8qIENyZWF0ZSBhIG5ldyBub2RlIGZhdGhlciBvZiBuIGFuZCBtICovXG4gICAgdHJlZVtub2RlICogMl0vKi5GcmVxKi8gPSB0cmVlW24gKiAyXS8qLkZyZXEqLyArIHRyZWVbbSAqIDJdLyouRnJlcSovO1xuICAgIHMuZGVwdGhbbm9kZV0gPSAocy5kZXB0aFtuXSA+PSBzLmRlcHRoW21dID8gcy5kZXB0aFtuXSA6IHMuZGVwdGhbbV0pICsgMTtcbiAgICB0cmVlW24gKiAyICsgMV0vKi5EYWQqLyA9IHRyZWVbbSAqIDIgKyAxXS8qLkRhZCovID0gbm9kZTtcblxuICAgIC8qIGFuZCBpbnNlcnQgdGhlIG5ldyBub2RlIGluIHRoZSBoZWFwICovXG4gICAgcy5oZWFwWzEvKlNNQUxMRVNUKi9dID0gbm9kZSsrO1xuICAgIHBxZG93bmhlYXAocywgdHJlZSwgMS8qU01BTExFU1QqLyk7XG5cbiAgfSB3aGlsZSAocy5oZWFwX2xlbiA+PSAyKTtcblxuICBzLmhlYXBbLS1zLmhlYXBfbWF4XSA9IHMuaGVhcFsxLypTTUFMTEVTVCovXTtcblxuICAvKiBBdCB0aGlzIHBvaW50LCB0aGUgZmllbGRzIGZyZXEgYW5kIGRhZCBhcmUgc2V0LiBXZSBjYW4gbm93XG4gICAqIGdlbmVyYXRlIHRoZSBiaXQgbGVuZ3Rocy5cbiAgICovXG4gIGdlbl9iaXRsZW4ocywgZGVzYyk7XG5cbiAgLyogVGhlIGZpZWxkIGxlbiBpcyBub3cgc2V0LCB3ZSBjYW4gZ2VuZXJhdGUgdGhlIGJpdCBjb2RlcyAqL1xuICBnZW5fY29kZXModHJlZSwgbWF4X2NvZGUsIHMuYmxfY291bnQpO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2NhbiBhIGxpdGVyYWwgb3IgZGlzdGFuY2UgdHJlZSB0byBkZXRlcm1pbmUgdGhlIGZyZXF1ZW5jaWVzIG9mIHRoZSBjb2Rlc1xuICogaW4gdGhlIGJpdCBsZW5ndGggdHJlZS5cbiAqL1xuZnVuY3Rpb24gc2Nhbl90cmVlKHMsIHRyZWUsIG1heF9jb2RlKVxuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIGN0X2RhdGEgKnRyZWU7ICAgLyogdGhlIHRyZWUgdG8gYmUgc2Nhbm5lZCAqL1xuLy8gICAgaW50IG1heF9jb2RlOyAgICAvKiBhbmQgaXRzIGxhcmdlc3QgY29kZSBvZiBub24gemVybyBmcmVxdWVuY3kgKi9cbntcbiAgdmFyIG47ICAgICAgICAgICAgICAgICAgICAgLyogaXRlcmF0ZXMgb3ZlciBhbGwgdHJlZSBlbGVtZW50cyAqL1xuICB2YXIgcHJldmxlbiA9IC0xOyAgICAgICAgICAvKiBsYXN0IGVtaXR0ZWQgbGVuZ3RoICovXG4gIHZhciBjdXJsZW47ICAgICAgICAgICAgICAgIC8qIGxlbmd0aCBvZiBjdXJyZW50IGNvZGUgKi9cblxuICB2YXIgbmV4dGxlbiA9IHRyZWVbMCAqIDIgKyAxXS8qLkxlbiovOyAvKiBsZW5ndGggb2YgbmV4dCBjb2RlICovXG5cbiAgdmFyIGNvdW50ID0gMDsgICAgICAgICAgICAgLyogcmVwZWF0IGNvdW50IG9mIHRoZSBjdXJyZW50IGNvZGUgKi9cbiAgdmFyIG1heF9jb3VudCA9IDc7ICAgICAgICAgLyogbWF4IHJlcGVhdCBjb3VudCAqL1xuICB2YXIgbWluX2NvdW50ID0gNDsgICAgICAgICAvKiBtaW4gcmVwZWF0IGNvdW50ICovXG5cbiAgaWYgKG5leHRsZW4gPT09IDApIHtcbiAgICBtYXhfY291bnQgPSAxMzg7XG4gICAgbWluX2NvdW50ID0gMztcbiAgfVxuICB0cmVlWyhtYXhfY29kZSArIDEpICogMiArIDFdLyouTGVuKi8gPSAweGZmZmY7IC8qIGd1YXJkICovXG5cbiAgZm9yIChuID0gMDsgbiA8PSBtYXhfY29kZTsgbisrKSB7XG4gICAgY3VybGVuID0gbmV4dGxlbjtcbiAgICBuZXh0bGVuID0gdHJlZVsobiArIDEpICogMiArIDFdLyouTGVuKi87XG5cbiAgICBpZiAoKytjb3VudCA8IG1heF9jb3VudCAmJiBjdXJsZW4gPT09IG5leHRsZW4pIHtcbiAgICAgIGNvbnRpbnVlO1xuXG4gICAgfSBlbHNlIGlmIChjb3VudCA8IG1pbl9jb3VudCkge1xuICAgICAgcy5ibF90cmVlW2N1cmxlbiAqIDJdLyouRnJlcSovICs9IGNvdW50O1xuXG4gICAgfSBlbHNlIGlmIChjdXJsZW4gIT09IDApIHtcblxuICAgICAgaWYgKGN1cmxlbiAhPT0gcHJldmxlbikgeyBzLmJsX3RyZWVbY3VybGVuICogMl0vKi5GcmVxKi8rKzsgfVxuICAgICAgcy5ibF90cmVlW1JFUF8zXzYgKiAyXS8qLkZyZXEqLysrO1xuXG4gICAgfSBlbHNlIGlmIChjb3VudCA8PSAxMCkge1xuICAgICAgcy5ibF90cmVlW1JFUFpfM18xMCAqIDJdLyouRnJlcSovKys7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgcy5ibF90cmVlW1JFUFpfMTFfMTM4ICogMl0vKi5GcmVxKi8rKztcbiAgICB9XG5cbiAgICBjb3VudCA9IDA7XG4gICAgcHJldmxlbiA9IGN1cmxlbjtcblxuICAgIGlmIChuZXh0bGVuID09PSAwKSB7XG4gICAgICBtYXhfY291bnQgPSAxMzg7XG4gICAgICBtaW5fY291bnQgPSAzO1xuXG4gICAgfSBlbHNlIGlmIChjdXJsZW4gPT09IG5leHRsZW4pIHtcbiAgICAgIG1heF9jb3VudCA9IDY7XG4gICAgICBtaW5fY291bnQgPSAzO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIG1heF9jb3VudCA9IDc7XG4gICAgICBtaW5fY291bnQgPSA0O1xuICAgIH1cbiAgfVxufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2VuZCBhIGxpdGVyYWwgb3IgZGlzdGFuY2UgdHJlZSBpbiBjb21wcmVzc2VkIGZvcm0sIHVzaW5nIHRoZSBjb2RlcyBpblxuICogYmxfdHJlZS5cbiAqL1xuZnVuY3Rpb24gc2VuZF90cmVlKHMsIHRyZWUsIG1heF9jb2RlKVxuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIGN0X2RhdGEgKnRyZWU7IC8qIHRoZSB0cmVlIHRvIGJlIHNjYW5uZWQgKi9cbi8vICAgIGludCBtYXhfY29kZTsgICAgICAgLyogYW5kIGl0cyBsYXJnZXN0IGNvZGUgb2Ygbm9uIHplcm8gZnJlcXVlbmN5ICovXG57XG4gIHZhciBuOyAgICAgICAgICAgICAgICAgICAgIC8qIGl0ZXJhdGVzIG92ZXIgYWxsIHRyZWUgZWxlbWVudHMgKi9cbiAgdmFyIHByZXZsZW4gPSAtMTsgICAgICAgICAgLyogbGFzdCBlbWl0dGVkIGxlbmd0aCAqL1xuICB2YXIgY3VybGVuOyAgICAgICAgICAgICAgICAvKiBsZW5ndGggb2YgY3VycmVudCBjb2RlICovXG5cbiAgdmFyIG5leHRsZW4gPSB0cmVlWzAgKiAyICsgMV0vKi5MZW4qLzsgLyogbGVuZ3RoIG9mIG5leHQgY29kZSAqL1xuXG4gIHZhciBjb3VudCA9IDA7ICAgICAgICAgICAgIC8qIHJlcGVhdCBjb3VudCBvZiB0aGUgY3VycmVudCBjb2RlICovXG4gIHZhciBtYXhfY291bnQgPSA3OyAgICAgICAgIC8qIG1heCByZXBlYXQgY291bnQgKi9cbiAgdmFyIG1pbl9jb3VudCA9IDQ7ICAgICAgICAgLyogbWluIHJlcGVhdCBjb3VudCAqL1xuXG4gIC8qIHRyZWVbbWF4X2NvZGUrMV0uTGVuID0gLTE7ICovICAvKiBndWFyZCBhbHJlYWR5IHNldCAqL1xuICBpZiAobmV4dGxlbiA9PT0gMCkge1xuICAgIG1heF9jb3VudCA9IDEzODtcbiAgICBtaW5fY291bnQgPSAzO1xuICB9XG5cbiAgZm9yIChuID0gMDsgbiA8PSBtYXhfY29kZTsgbisrKSB7XG4gICAgY3VybGVuID0gbmV4dGxlbjtcbiAgICBuZXh0bGVuID0gdHJlZVsobiArIDEpICogMiArIDFdLyouTGVuKi87XG5cbiAgICBpZiAoKytjb3VudCA8IG1heF9jb3VudCAmJiBjdXJsZW4gPT09IG5leHRsZW4pIHtcbiAgICAgIGNvbnRpbnVlO1xuXG4gICAgfSBlbHNlIGlmIChjb3VudCA8IG1pbl9jb3VudCkge1xuICAgICAgZG8geyBzZW5kX2NvZGUocywgY3VybGVuLCBzLmJsX3RyZWUpOyB9IHdoaWxlICgtLWNvdW50ICE9PSAwKTtcblxuICAgIH0gZWxzZSBpZiAoY3VybGVuICE9PSAwKSB7XG4gICAgICBpZiAoY3VybGVuICE9PSBwcmV2bGVuKSB7XG4gICAgICAgIHNlbmRfY29kZShzLCBjdXJsZW4sIHMuYmxfdHJlZSk7XG4gICAgICAgIGNvdW50LS07XG4gICAgICB9XG4gICAgICAvL0Fzc2VydChjb3VudCA+PSAzICYmIGNvdW50IDw9IDYsIFwiIDNfNj9cIik7XG4gICAgICBzZW5kX2NvZGUocywgUkVQXzNfNiwgcy5ibF90cmVlKTtcbiAgICAgIHNlbmRfYml0cyhzLCBjb3VudCAtIDMsIDIpO1xuXG4gICAgfSBlbHNlIGlmIChjb3VudCA8PSAxMCkge1xuICAgICAgc2VuZF9jb2RlKHMsIFJFUFpfM18xMCwgcy5ibF90cmVlKTtcbiAgICAgIHNlbmRfYml0cyhzLCBjb3VudCAtIDMsIDMpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIHNlbmRfY29kZShzLCBSRVBaXzExXzEzOCwgcy5ibF90cmVlKTtcbiAgICAgIHNlbmRfYml0cyhzLCBjb3VudCAtIDExLCA3KTtcbiAgICB9XG5cbiAgICBjb3VudCA9IDA7XG4gICAgcHJldmxlbiA9IGN1cmxlbjtcbiAgICBpZiAobmV4dGxlbiA9PT0gMCkge1xuICAgICAgbWF4X2NvdW50ID0gMTM4O1xuICAgICAgbWluX2NvdW50ID0gMztcblxuICAgIH0gZWxzZSBpZiAoY3VybGVuID09PSBuZXh0bGVuKSB7XG4gICAgICBtYXhfY291bnQgPSA2O1xuICAgICAgbWluX2NvdW50ID0gMztcblxuICAgIH0gZWxzZSB7XG4gICAgICBtYXhfY291bnQgPSA3O1xuICAgICAgbWluX2NvdW50ID0gNDtcbiAgICB9XG4gIH1cbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvbnN0cnVjdCB0aGUgSHVmZm1hbiB0cmVlIGZvciB0aGUgYml0IGxlbmd0aHMgYW5kIHJldHVybiB0aGUgaW5kZXggaW5cbiAqIGJsX29yZGVyIG9mIHRoZSBsYXN0IGJpdCBsZW5ndGggY29kZSB0byBzZW5kLlxuICovXG5mdW5jdGlvbiBidWlsZF9ibF90cmVlKHMpIHtcbiAgdmFyIG1heF9ibGluZGV4OyAgLyogaW5kZXggb2YgbGFzdCBiaXQgbGVuZ3RoIGNvZGUgb2Ygbm9uIHplcm8gZnJlcSAqL1xuXG4gIC8qIERldGVybWluZSB0aGUgYml0IGxlbmd0aCBmcmVxdWVuY2llcyBmb3IgbGl0ZXJhbCBhbmQgZGlzdGFuY2UgdHJlZXMgKi9cbiAgc2Nhbl90cmVlKHMsIHMuZHluX2x0cmVlLCBzLmxfZGVzYy5tYXhfY29kZSk7XG4gIHNjYW5fdHJlZShzLCBzLmR5bl9kdHJlZSwgcy5kX2Rlc2MubWF4X2NvZGUpO1xuXG4gIC8qIEJ1aWxkIHRoZSBiaXQgbGVuZ3RoIHRyZWU6ICovXG4gIGJ1aWxkX3RyZWUocywgcy5ibF9kZXNjKTtcbiAgLyogb3B0X2xlbiBub3cgaW5jbHVkZXMgdGhlIGxlbmd0aCBvZiB0aGUgdHJlZSByZXByZXNlbnRhdGlvbnMsIGV4Y2VwdFxuICAgKiB0aGUgbGVuZ3RocyBvZiB0aGUgYml0IGxlbmd0aHMgY29kZXMgYW5kIHRoZSA1KzUrNCBiaXRzIGZvciB0aGUgY291bnRzLlxuICAgKi9cblxuICAvKiBEZXRlcm1pbmUgdGhlIG51bWJlciBvZiBiaXQgbGVuZ3RoIGNvZGVzIHRvIHNlbmQuIFRoZSBwa3ppcCBmb3JtYXRcbiAgICogcmVxdWlyZXMgdGhhdCBhdCBsZWFzdCA0IGJpdCBsZW5ndGggY29kZXMgYmUgc2VudC4gKGFwcG5vdGUudHh0IHNheXNcbiAgICogMyBidXQgdGhlIGFjdHVhbCB2YWx1ZSB1c2VkIGlzIDQuKVxuICAgKi9cbiAgZm9yIChtYXhfYmxpbmRleCA9IEJMX0NPREVTIC0gMTsgbWF4X2JsaW5kZXggPj0gMzsgbWF4X2JsaW5kZXgtLSkge1xuICAgIGlmIChzLmJsX3RyZWVbYmxfb3JkZXJbbWF4X2JsaW5kZXhdICogMiArIDFdLyouTGVuKi8gIT09IDApIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICAvKiBVcGRhdGUgb3B0X2xlbiB0byBpbmNsdWRlIHRoZSBiaXQgbGVuZ3RoIHRyZWUgYW5kIGNvdW50cyAqL1xuICBzLm9wdF9sZW4gKz0gMyAqIChtYXhfYmxpbmRleCArIDEpICsgNSArIDUgKyA0O1xuICAvL1RyYWNldigoc3RkZXJyLCBcIlxcbmR5biB0cmVlczogZHluICVsZCwgc3RhdCAlbGRcIixcbiAgLy8gICAgICAgIHMtPm9wdF9sZW4sIHMtPnN0YXRpY19sZW4pKTtcblxuICByZXR1cm4gbWF4X2JsaW5kZXg7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTZW5kIHRoZSBoZWFkZXIgZm9yIGEgYmxvY2sgdXNpbmcgZHluYW1pYyBIdWZmbWFuIHRyZWVzOiB0aGUgY291bnRzLCB0aGVcbiAqIGxlbmd0aHMgb2YgdGhlIGJpdCBsZW5ndGggY29kZXMsIHRoZSBsaXRlcmFsIHRyZWUgYW5kIHRoZSBkaXN0YW5jZSB0cmVlLlxuICogSU4gYXNzZXJ0aW9uOiBsY29kZXMgPj0gMjU3LCBkY29kZXMgPj0gMSwgYmxjb2RlcyA+PSA0LlxuICovXG5mdW5jdGlvbiBzZW5kX2FsbF90cmVlcyhzLCBsY29kZXMsIGRjb2RlcywgYmxjb2Rlcylcbi8vICAgIGRlZmxhdGVfc3RhdGUgKnM7XG4vLyAgICBpbnQgbGNvZGVzLCBkY29kZXMsIGJsY29kZXM7IC8qIG51bWJlciBvZiBjb2RlcyBmb3IgZWFjaCB0cmVlICovXG57XG4gIHZhciByYW5rOyAgICAgICAgICAgICAgICAgICAgLyogaW5kZXggaW4gYmxfb3JkZXIgKi9cblxuICAvL0Fzc2VydCAobGNvZGVzID49IDI1NyAmJiBkY29kZXMgPj0gMSAmJiBibGNvZGVzID49IDQsIFwibm90IGVub3VnaCBjb2Rlc1wiKTtcbiAgLy9Bc3NlcnQgKGxjb2RlcyA8PSBMX0NPREVTICYmIGRjb2RlcyA8PSBEX0NPREVTICYmIGJsY29kZXMgPD0gQkxfQ09ERVMsXG4gIC8vICAgICAgICBcInRvbyBtYW55IGNvZGVzXCIpO1xuICAvL1RyYWNldigoc3RkZXJyLCBcIlxcbmJsIGNvdW50czogXCIpKTtcbiAgc2VuZF9iaXRzKHMsIGxjb2RlcyAtIDI1NywgNSk7IC8qIG5vdCArMjU1IGFzIHN0YXRlZCBpbiBhcHBub3RlLnR4dCAqL1xuICBzZW5kX2JpdHMocywgZGNvZGVzIC0gMSwgICA1KTtcbiAgc2VuZF9iaXRzKHMsIGJsY29kZXMgLSA0LCAgNCk7IC8qIG5vdCAtMyBhcyBzdGF0ZWQgaW4gYXBwbm90ZS50eHQgKi9cbiAgZm9yIChyYW5rID0gMDsgcmFuayA8IGJsY29kZXM7IHJhbmsrKykge1xuICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiXFxuYmwgY29kZSAlMmQgXCIsIGJsX29yZGVyW3JhbmtdKSk7XG4gICAgc2VuZF9iaXRzKHMsIHMuYmxfdHJlZVtibF9vcmRlcltyYW5rXSAqIDIgKyAxXS8qLkxlbiovLCAzKTtcbiAgfVxuICAvL1RyYWNldigoc3RkZXJyLCBcIlxcbmJsIHRyZWU6IHNlbnQgJWxkXCIsIHMtPmJpdHNfc2VudCkpO1xuXG4gIHNlbmRfdHJlZShzLCBzLmR5bl9sdHJlZSwgbGNvZGVzIC0gMSk7IC8qIGxpdGVyYWwgdHJlZSAqL1xuICAvL1RyYWNldigoc3RkZXJyLCBcIlxcbmxpdCB0cmVlOiBzZW50ICVsZFwiLCBzLT5iaXRzX3NlbnQpKTtcblxuICBzZW5kX3RyZWUocywgcy5keW5fZHRyZWUsIGRjb2RlcyAtIDEpOyAvKiBkaXN0YW5jZSB0cmVlICovXG4gIC8vVHJhY2V2KChzdGRlcnIsIFwiXFxuZGlzdCB0cmVlOiBzZW50ICVsZFwiLCBzLT5iaXRzX3NlbnQpKTtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENoZWNrIGlmIHRoZSBkYXRhIHR5cGUgaXMgVEVYVCBvciBCSU5BUlksIHVzaW5nIHRoZSBmb2xsb3dpbmcgYWxnb3JpdGhtOlxuICogLSBURVhUIGlmIHRoZSB0d28gY29uZGl0aW9ucyBiZWxvdyBhcmUgc2F0aXNmaWVkOlxuICogICAgYSkgVGhlcmUgYXJlIG5vIG5vbi1wb3J0YWJsZSBjb250cm9sIGNoYXJhY3RlcnMgYmVsb25naW5nIHRvIHRoZVxuICogICAgICAgXCJibGFjayBsaXN0XCIgKDAuLjYsIDE0Li4yNSwgMjguLjMxKS5cbiAqICAgIGIpIFRoZXJlIGlzIGF0IGxlYXN0IG9uZSBwcmludGFibGUgY2hhcmFjdGVyIGJlbG9uZ2luZyB0byB0aGVcbiAqICAgICAgIFwid2hpdGUgbGlzdFwiICg5IHtUQUJ9LCAxMCB7TEZ9LCAxMyB7Q1J9LCAzMi4uMjU1KS5cbiAqIC0gQklOQVJZIG90aGVyd2lzZS5cbiAqIC0gVGhlIGZvbGxvd2luZyBwYXJ0aWFsbHktcG9ydGFibGUgY29udHJvbCBjaGFyYWN0ZXJzIGZvcm0gYVxuICogICBcImdyYXkgbGlzdFwiIHRoYXQgaXMgaWdub3JlZCBpbiB0aGlzIGRldGVjdGlvbiBhbGdvcml0aG06XG4gKiAgICg3IHtCRUx9LCA4IHtCU30sIDExIHtWVH0sIDEyIHtGRn0sIDI2IHtTVUJ9LCAyNyB7RVNDfSkuXG4gKiBJTiBhc3NlcnRpb246IHRoZSBmaWVsZHMgRnJlcSBvZiBkeW5fbHRyZWUgYXJlIHNldC5cbiAqL1xuZnVuY3Rpb24gZGV0ZWN0X2RhdGFfdHlwZShzKSB7XG4gIC8qIGJsYWNrX21hc2sgaXMgdGhlIGJpdCBtYXNrIG9mIGJsYWNrLWxpc3RlZCBieXRlc1xuICAgKiBzZXQgYml0cyAwLi42LCAxNC4uMjUsIGFuZCAyOC4uMzFcbiAgICogMHhmM2ZmYzA3ZiA9IGJpbmFyeSAxMTExMDAxMTExMTExMTExMTEwMDAwMDAwMTExMTExMVxuICAgKi9cbiAgdmFyIGJsYWNrX21hc2sgPSAweGYzZmZjMDdmO1xuICB2YXIgbjtcblxuICAvKiBDaGVjayBmb3Igbm9uLXRleHR1YWwgKFwiYmxhY2stbGlzdGVkXCIpIGJ5dGVzLiAqL1xuICBmb3IgKG4gPSAwOyBuIDw9IDMxOyBuKyssIGJsYWNrX21hc2sgPj4+PSAxKSB7XG4gICAgaWYgKChibGFja19tYXNrICYgMSkgJiYgKHMuZHluX2x0cmVlW24gKiAyXS8qLkZyZXEqLyAhPT0gMCkpIHtcbiAgICAgIHJldHVybiBaX0JJTkFSWTtcbiAgICB9XG4gIH1cblxuICAvKiBDaGVjayBmb3IgdGV4dHVhbCAoXCJ3aGl0ZS1saXN0ZWRcIikgYnl0ZXMuICovXG4gIGlmIChzLmR5bl9sdHJlZVs5ICogMl0vKi5GcmVxKi8gIT09IDAgfHwgcy5keW5fbHRyZWVbMTAgKiAyXS8qLkZyZXEqLyAhPT0gMCB8fFxuICAgICAgcy5keW5fbHRyZWVbMTMgKiAyXS8qLkZyZXEqLyAhPT0gMCkge1xuICAgIHJldHVybiBaX1RFWFQ7XG4gIH1cbiAgZm9yIChuID0gMzI7IG4gPCBMSVRFUkFMUzsgbisrKSB7XG4gICAgaWYgKHMuZHluX2x0cmVlW24gKiAyXS8qLkZyZXEqLyAhPT0gMCkge1xuICAgICAgcmV0dXJuIFpfVEVYVDtcbiAgICB9XG4gIH1cblxuICAvKiBUaGVyZSBhcmUgbm8gXCJibGFjay1saXN0ZWRcIiBvciBcIndoaXRlLWxpc3RlZFwiIGJ5dGVzOlxuICAgKiB0aGlzIHN0cmVhbSBlaXRoZXIgaXMgZW1wdHkgb3IgaGFzIHRvbGVyYXRlZCAoXCJncmF5LWxpc3RlZFwiKSBieXRlcyBvbmx5LlxuICAgKi9cbiAgcmV0dXJuIFpfQklOQVJZO1xufVxuXG5cbnZhciBzdGF0aWNfaW5pdF9kb25lID0gZmFsc2U7XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogSW5pdGlhbGl6ZSB0aGUgdHJlZSBkYXRhIHN0cnVjdHVyZXMgZm9yIGEgbmV3IHpsaWIgc3RyZWFtLlxuICovXG5mdW5jdGlvbiBfdHJfaW5pdChzKVxue1xuXG4gIGlmICghc3RhdGljX2luaXRfZG9uZSkge1xuICAgIHRyX3N0YXRpY19pbml0KCk7XG4gICAgc3RhdGljX2luaXRfZG9uZSA9IHRydWU7XG4gIH1cblxuICBzLmxfZGVzYyAgPSBuZXcgVHJlZURlc2Mocy5keW5fbHRyZWUsIHN0YXRpY19sX2Rlc2MpO1xuICBzLmRfZGVzYyAgPSBuZXcgVHJlZURlc2Mocy5keW5fZHRyZWUsIHN0YXRpY19kX2Rlc2MpO1xuICBzLmJsX2Rlc2MgPSBuZXcgVHJlZURlc2Mocy5ibF90cmVlLCBzdGF0aWNfYmxfZGVzYyk7XG5cbiAgcy5iaV9idWYgPSAwO1xuICBzLmJpX3ZhbGlkID0gMDtcblxuICAvKiBJbml0aWFsaXplIHRoZSBmaXJzdCBibG9jayBvZiB0aGUgZmlyc3QgZmlsZTogKi9cbiAgaW5pdF9ibG9jayhzKTtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNlbmQgYSBzdG9yZWQgYmxvY2tcbiAqL1xuZnVuY3Rpb24gX3RyX3N0b3JlZF9ibG9jayhzLCBidWYsIHN0b3JlZF9sZW4sIGxhc3QpXG4vL0RlZmxhdGVTdGF0ZSAqcztcbi8vY2hhcmYgKmJ1ZjsgICAgICAgLyogaW5wdXQgYmxvY2sgKi9cbi8vdWxnIHN0b3JlZF9sZW47ICAgLyogbGVuZ3RoIG9mIGlucHV0IGJsb2NrICovXG4vL2ludCBsYXN0OyAgICAgICAgIC8qIG9uZSBpZiB0aGlzIGlzIHRoZSBsYXN0IGJsb2NrIGZvciBhIGZpbGUgKi9cbntcbiAgc2VuZF9iaXRzKHMsIChTVE9SRURfQkxPQ0sgPDwgMSkgKyAobGFzdCA/IDEgOiAwKSwgMyk7ICAgIC8qIHNlbmQgYmxvY2sgdHlwZSAqL1xuICBjb3B5X2Jsb2NrKHMsIGJ1Ziwgc3RvcmVkX2xlbiwgdHJ1ZSk7IC8qIHdpdGggaGVhZGVyICovXG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTZW5kIG9uZSBlbXB0eSBzdGF0aWMgYmxvY2sgdG8gZ2l2ZSBlbm91Z2ggbG9va2FoZWFkIGZvciBpbmZsYXRlLlxuICogVGhpcyB0YWtlcyAxMCBiaXRzLCBvZiB3aGljaCA3IG1heSByZW1haW4gaW4gdGhlIGJpdCBidWZmZXIuXG4gKi9cbmZ1bmN0aW9uIF90cl9hbGlnbihzKSB7XG4gIHNlbmRfYml0cyhzLCBTVEFUSUNfVFJFRVMgPDwgMSwgMyk7XG4gIHNlbmRfY29kZShzLCBFTkRfQkxPQ0ssIHN0YXRpY19sdHJlZSk7XG4gIGJpX2ZsdXNoKHMpO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogRGV0ZXJtaW5lIHRoZSBiZXN0IGVuY29kaW5nIGZvciB0aGUgY3VycmVudCBibG9jazogZHluYW1pYyB0cmVlcywgc3RhdGljXG4gKiB0cmVlcyBvciBzdG9yZSwgYW5kIG91dHB1dCB0aGUgZW5jb2RlZCBibG9jayB0byB0aGUgemlwIGZpbGUuXG4gKi9cbmZ1bmN0aW9uIF90cl9mbHVzaF9ibG9jayhzLCBidWYsIHN0b3JlZF9sZW4sIGxhc3QpXG4vL0RlZmxhdGVTdGF0ZSAqcztcbi8vY2hhcmYgKmJ1ZjsgICAgICAgLyogaW5wdXQgYmxvY2ssIG9yIE5VTEwgaWYgdG9vIG9sZCAqL1xuLy91bGcgc3RvcmVkX2xlbjsgICAvKiBsZW5ndGggb2YgaW5wdXQgYmxvY2sgKi9cbi8vaW50IGxhc3Q7ICAgICAgICAgLyogb25lIGlmIHRoaXMgaXMgdGhlIGxhc3QgYmxvY2sgZm9yIGEgZmlsZSAqL1xue1xuICB2YXIgb3B0X2xlbmIsIHN0YXRpY19sZW5iOyAgLyogb3B0X2xlbiBhbmQgc3RhdGljX2xlbiBpbiBieXRlcyAqL1xuICB2YXIgbWF4X2JsaW5kZXggPSAwOyAgICAgICAgLyogaW5kZXggb2YgbGFzdCBiaXQgbGVuZ3RoIGNvZGUgb2Ygbm9uIHplcm8gZnJlcSAqL1xuXG4gIC8qIEJ1aWxkIHRoZSBIdWZmbWFuIHRyZWVzIHVubGVzcyBhIHN0b3JlZCBibG9jayBpcyBmb3JjZWQgKi9cbiAgaWYgKHMubGV2ZWwgPiAwKSB7XG5cbiAgICAvKiBDaGVjayBpZiB0aGUgZmlsZSBpcyBiaW5hcnkgb3IgdGV4dCAqL1xuICAgIGlmIChzLnN0cm0uZGF0YV90eXBlID09PSBaX1VOS05PV04pIHtcbiAgICAgIHMuc3RybS5kYXRhX3R5cGUgPSBkZXRlY3RfZGF0YV90eXBlKHMpO1xuICAgIH1cblxuICAgIC8qIENvbnN0cnVjdCB0aGUgbGl0ZXJhbCBhbmQgZGlzdGFuY2UgdHJlZXMgKi9cbiAgICBidWlsZF90cmVlKHMsIHMubF9kZXNjKTtcbiAgICAvLyBUcmFjZXYoKHN0ZGVyciwgXCJcXG5saXQgZGF0YTogZHluICVsZCwgc3RhdCAlbGRcIiwgcy0+b3B0X2xlbixcbiAgICAvLyAgICAgICAgcy0+c3RhdGljX2xlbikpO1xuXG4gICAgYnVpbGRfdHJlZShzLCBzLmRfZGVzYyk7XG4gICAgLy8gVHJhY2V2KChzdGRlcnIsIFwiXFxuZGlzdCBkYXRhOiBkeW4gJWxkLCBzdGF0ICVsZFwiLCBzLT5vcHRfbGVuLFxuICAgIC8vICAgICAgICBzLT5zdGF0aWNfbGVuKSk7XG4gICAgLyogQXQgdGhpcyBwb2ludCwgb3B0X2xlbiBhbmQgc3RhdGljX2xlbiBhcmUgdGhlIHRvdGFsIGJpdCBsZW5ndGhzIG9mXG4gICAgICogdGhlIGNvbXByZXNzZWQgYmxvY2sgZGF0YSwgZXhjbHVkaW5nIHRoZSB0cmVlIHJlcHJlc2VudGF0aW9ucy5cbiAgICAgKi9cblxuICAgIC8qIEJ1aWxkIHRoZSBiaXQgbGVuZ3RoIHRyZWUgZm9yIHRoZSBhYm92ZSB0d28gdHJlZXMsIGFuZCBnZXQgdGhlIGluZGV4XG4gICAgICogaW4gYmxfb3JkZXIgb2YgdGhlIGxhc3QgYml0IGxlbmd0aCBjb2RlIHRvIHNlbmQuXG4gICAgICovXG4gICAgbWF4X2JsaW5kZXggPSBidWlsZF9ibF90cmVlKHMpO1xuXG4gICAgLyogRGV0ZXJtaW5lIHRoZSBiZXN0IGVuY29kaW5nLiBDb21wdXRlIHRoZSBibG9jayBsZW5ndGhzIGluIGJ5dGVzLiAqL1xuICAgIG9wdF9sZW5iID0gKHMub3B0X2xlbiArIDMgKyA3KSA+Pj4gMztcbiAgICBzdGF0aWNfbGVuYiA9IChzLnN0YXRpY19sZW4gKyAzICsgNykgPj4+IDM7XG5cbiAgICAvLyBUcmFjZXYoKHN0ZGVyciwgXCJcXG5vcHQgJWx1KCVsdSkgc3RhdCAlbHUoJWx1KSBzdG9yZWQgJWx1IGxpdCAldSBcIixcbiAgICAvLyAgICAgICAgb3B0X2xlbmIsIHMtPm9wdF9sZW4sIHN0YXRpY19sZW5iLCBzLT5zdGF0aWNfbGVuLCBzdG9yZWRfbGVuLFxuICAgIC8vICAgICAgICBzLT5sYXN0X2xpdCkpO1xuXG4gICAgaWYgKHN0YXRpY19sZW5iIDw9IG9wdF9sZW5iKSB7IG9wdF9sZW5iID0gc3RhdGljX2xlbmI7IH1cblxuICB9IGVsc2Uge1xuICAgIC8vIEFzc2VydChidWYgIT0gKGNoYXIqKTAsIFwibG9zdCBidWZcIik7XG4gICAgb3B0X2xlbmIgPSBzdGF0aWNfbGVuYiA9IHN0b3JlZF9sZW4gKyA1OyAvKiBmb3JjZSBhIHN0b3JlZCBibG9jayAqL1xuICB9XG5cbiAgaWYgKChzdG9yZWRfbGVuICsgNCA8PSBvcHRfbGVuYikgJiYgKGJ1ZiAhPT0gLTEpKSB7XG4gICAgLyogNDogdHdvIHdvcmRzIGZvciB0aGUgbGVuZ3RocyAqL1xuXG4gICAgLyogVGhlIHRlc3QgYnVmICE9IE5VTEwgaXMgb25seSBuZWNlc3NhcnkgaWYgTElUX0JVRlNJWkUgPiBXU0laRS5cbiAgICAgKiBPdGhlcndpc2Ugd2UgY2FuJ3QgaGF2ZSBwcm9jZXNzZWQgbW9yZSB0aGFuIFdTSVpFIGlucHV0IGJ5dGVzIHNpbmNlXG4gICAgICogdGhlIGxhc3QgYmxvY2sgZmx1c2gsIGJlY2F1c2UgY29tcHJlc3Npb24gd291bGQgaGF2ZSBiZWVuXG4gICAgICogc3VjY2Vzc2Z1bC4gSWYgTElUX0JVRlNJWkUgPD0gV1NJWkUsIGl0IGlzIG5ldmVyIHRvbyBsYXRlIHRvXG4gICAgICogdHJhbnNmb3JtIGEgYmxvY2sgaW50byBhIHN0b3JlZCBibG9jay5cbiAgICAgKi9cbiAgICBfdHJfc3RvcmVkX2Jsb2NrKHMsIGJ1Ziwgc3RvcmVkX2xlbiwgbGFzdCk7XG5cbiAgfSBlbHNlIGlmIChzLnN0cmF0ZWd5ID09PSBaX0ZJWEVEIHx8IHN0YXRpY19sZW5iID09PSBvcHRfbGVuYikge1xuXG4gICAgc2VuZF9iaXRzKHMsIChTVEFUSUNfVFJFRVMgPDwgMSkgKyAobGFzdCA/IDEgOiAwKSwgMyk7XG4gICAgY29tcHJlc3NfYmxvY2socywgc3RhdGljX2x0cmVlLCBzdGF0aWNfZHRyZWUpO1xuXG4gIH0gZWxzZSB7XG4gICAgc2VuZF9iaXRzKHMsIChEWU5fVFJFRVMgPDwgMSkgKyAobGFzdCA/IDEgOiAwKSwgMyk7XG4gICAgc2VuZF9hbGxfdHJlZXMocywgcy5sX2Rlc2MubWF4X2NvZGUgKyAxLCBzLmRfZGVzYy5tYXhfY29kZSArIDEsIG1heF9ibGluZGV4ICsgMSk7XG4gICAgY29tcHJlc3NfYmxvY2socywgcy5keW5fbHRyZWUsIHMuZHluX2R0cmVlKTtcbiAgfVxuICAvLyBBc3NlcnQgKHMtPmNvbXByZXNzZWRfbGVuID09IHMtPmJpdHNfc2VudCwgXCJiYWQgY29tcHJlc3NlZCBzaXplXCIpO1xuICAvKiBUaGUgYWJvdmUgY2hlY2sgaXMgbWFkZSBtb2QgMl4zMiwgZm9yIGZpbGVzIGxhcmdlciB0aGFuIDUxMiBNQlxuICAgKiBhbmQgdUxvbmcgaW1wbGVtZW50ZWQgb24gMzIgYml0cy5cbiAgICovXG4gIGluaXRfYmxvY2socyk7XG5cbiAgaWYgKGxhc3QpIHtcbiAgICBiaV93aW5kdXAocyk7XG4gIH1cbiAgLy8gVHJhY2V2KChzdGRlcnIsXCJcXG5jb21wcmxlbiAlbHUoJWx1KSBcIiwgcy0+Y29tcHJlc3NlZF9sZW4+PjMsXG4gIC8vICAgICAgIHMtPmNvbXByZXNzZWRfbGVuLTcqbGFzdCkpO1xufVxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNhdmUgdGhlIG1hdGNoIGluZm8gYW5kIHRhbGx5IHRoZSBmcmVxdWVuY3kgY291bnRzLiBSZXR1cm4gdHJ1ZSBpZlxuICogdGhlIGN1cnJlbnQgYmxvY2sgbXVzdCBiZSBmbHVzaGVkLlxuICovXG5mdW5jdGlvbiBfdHJfdGFsbHkocywgZGlzdCwgbGMpXG4vLyAgICBkZWZsYXRlX3N0YXRlICpzO1xuLy8gICAgdW5zaWduZWQgZGlzdDsgIC8qIGRpc3RhbmNlIG9mIG1hdGNoZWQgc3RyaW5nICovXG4vLyAgICB1bnNpZ25lZCBsYzsgICAgLyogbWF0Y2ggbGVuZ3RoLU1JTl9NQVRDSCBvciB1bm1hdGNoZWQgY2hhciAoaWYgZGlzdD09MCkgKi9cbntcbiAgLy92YXIgb3V0X2xlbmd0aCwgaW5fbGVuZ3RoLCBkY29kZTtcblxuICBzLnBlbmRpbmdfYnVmW3MuZF9idWYgKyBzLmxhc3RfbGl0ICogMl0gICAgID0gKGRpc3QgPj4+IDgpICYgMHhmZjtcbiAgcy5wZW5kaW5nX2J1ZltzLmRfYnVmICsgcy5sYXN0X2xpdCAqIDIgKyAxXSA9IGRpc3QgJiAweGZmO1xuXG4gIHMucGVuZGluZ19idWZbcy5sX2J1ZiArIHMubGFzdF9saXRdID0gbGMgJiAweGZmO1xuICBzLmxhc3RfbGl0Kys7XG5cbiAgaWYgKGRpc3QgPT09IDApIHtcbiAgICAvKiBsYyBpcyB0aGUgdW5tYXRjaGVkIGNoYXIgKi9cbiAgICBzLmR5bl9sdHJlZVtsYyAqIDJdLyouRnJlcSovKys7XG4gIH0gZWxzZSB7XG4gICAgcy5tYXRjaGVzKys7XG4gICAgLyogSGVyZSwgbGMgaXMgdGhlIG1hdGNoIGxlbmd0aCAtIE1JTl9NQVRDSCAqL1xuICAgIGRpc3QtLTsgICAgICAgICAgICAgLyogZGlzdCA9IG1hdGNoIGRpc3RhbmNlIC0gMSAqL1xuICAgIC8vQXNzZXJ0KCh1c2gpZGlzdCA8ICh1c2gpTUFYX0RJU1QocykgJiZcbiAgICAvLyAgICAgICAodXNoKWxjIDw9ICh1c2gpKE1BWF9NQVRDSC1NSU5fTUFUQ0gpICYmXG4gICAgLy8gICAgICAgKHVzaClkX2NvZGUoZGlzdCkgPCAodXNoKURfQ09ERVMsICBcIl90cl90YWxseTogYmFkIG1hdGNoXCIpO1xuXG4gICAgcy5keW5fbHRyZWVbKF9sZW5ndGhfY29kZVtsY10gKyBMSVRFUkFMUyArIDEpICogMl0vKi5GcmVxKi8rKztcbiAgICBzLmR5bl9kdHJlZVtkX2NvZGUoZGlzdCkgKiAyXS8qLkZyZXEqLysrO1xuICB9XG5cbi8vICghKSBUaGlzIGJsb2NrIGlzIGRpc2FibGVkIGluIHpsaWIgZGVmYXVsdHMsXG4vLyBkb24ndCBlbmFibGUgaXQgZm9yIGJpbmFyeSBjb21wYXRpYmlsaXR5XG5cbi8vI2lmZGVmIFRSVU5DQVRFX0JMT0NLXG4vLyAgLyogVHJ5IHRvIGd1ZXNzIGlmIGl0IGlzIHByb2ZpdGFibGUgdG8gc3RvcCB0aGUgY3VycmVudCBibG9jayBoZXJlICovXG4vLyAgaWYgKChzLmxhc3RfbGl0ICYgMHgxZmZmKSA9PT0gMCAmJiBzLmxldmVsID4gMikge1xuLy8gICAgLyogQ29tcHV0ZSBhbiB1cHBlciBib3VuZCBmb3IgdGhlIGNvbXByZXNzZWQgbGVuZ3RoICovXG4vLyAgICBvdXRfbGVuZ3RoID0gcy5sYXN0X2xpdCo4O1xuLy8gICAgaW5fbGVuZ3RoID0gcy5zdHJzdGFydCAtIHMuYmxvY2tfc3RhcnQ7XG4vL1xuLy8gICAgZm9yIChkY29kZSA9IDA7IGRjb2RlIDwgRF9DT0RFUzsgZGNvZGUrKykge1xuLy8gICAgICBvdXRfbGVuZ3RoICs9IHMuZHluX2R0cmVlW2Rjb2RlKjJdLyouRnJlcSovICogKDUgKyBleHRyYV9kYml0c1tkY29kZV0pO1xuLy8gICAgfVxuLy8gICAgb3V0X2xlbmd0aCA+Pj49IDM7XG4vLyAgICAvL1RyYWNldigoc3RkZXJyLFwiXFxubGFzdF9saXQgJXUsIGluICVsZCwgb3V0IH4lbGQoJWxkJSUpIFwiLFxuLy8gICAgLy8gICAgICAgcy0+bGFzdF9saXQsIGluX2xlbmd0aCwgb3V0X2xlbmd0aCxcbi8vICAgIC8vICAgICAgIDEwMEwgLSBvdXRfbGVuZ3RoKjEwMEwvaW5fbGVuZ3RoKSk7XG4vLyAgICBpZiAocy5tYXRjaGVzIDwgKHMubGFzdF9saXQ+PjEpLyppbnQgLzIqLyAmJiBvdXRfbGVuZ3RoIDwgKGluX2xlbmd0aD4+MSkvKmludCAvMiovKSB7XG4vLyAgICAgIHJldHVybiB0cnVlO1xuLy8gICAgfVxuLy8gIH1cbi8vI2VuZGlmXG5cbiAgcmV0dXJuIChzLmxhc3RfbGl0ID09PSBzLmxpdF9idWZzaXplIC0gMSk7XG4gIC8qIFdlIGF2b2lkIGVxdWFsaXR5IHdpdGggbGl0X2J1ZnNpemUgYmVjYXVzZSBvZiB3cmFwYXJvdW5kIGF0IDY0S1xuICAgKiBvbiAxNiBiaXQgbWFjaGluZXMgYW5kIGJlY2F1c2Ugc3RvcmVkIGJsb2NrcyBhcmUgcmVzdHJpY3RlZCB0b1xuICAgKiA2NEstMSBieXRlcy5cbiAgICovXG59XG5cbmV4cG9ydHMuX3RyX2luaXQgID0gX3RyX2luaXQ7XG5leHBvcnRzLl90cl9zdG9yZWRfYmxvY2sgPSBfdHJfc3RvcmVkX2Jsb2NrO1xuZXhwb3J0cy5fdHJfZmx1c2hfYmxvY2sgID0gX3RyX2ZsdXNoX2Jsb2NrO1xuZXhwb3J0cy5fdHJfdGFsbHkgPSBfdHJfdGFsbHk7XG5leHBvcnRzLl90cl9hbGlnbiA9IF90cl9hbGlnbjtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gTm90ZTogYWRsZXIzMiB0YWtlcyAxMiUgZm9yIGxldmVsIDAgYW5kIDIlIGZvciBsZXZlbCA2LlxuLy8gSXQgaXNuJ3Qgd29ydGggaXQgdG8gbWFrZSBhZGRpdGlvbmFsIG9wdGltaXphdGlvbnMgYXMgaW4gb3JpZ2luYWwuXG4vLyBTbWFsbCBzaXplIGlzIHByZWZlcmFibGUuXG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxuZnVuY3Rpb24gYWRsZXIzMihhZGxlciwgYnVmLCBsZW4sIHBvcykge1xuICB2YXIgczEgPSAoYWRsZXIgJiAweGZmZmYpIHwwLFxuICAgICAgczIgPSAoKGFkbGVyID4+PiAxNikgJiAweGZmZmYpIHwwLFxuICAgICAgbiA9IDA7XG5cbiAgd2hpbGUgKGxlbiAhPT0gMCkge1xuICAgIC8vIFNldCBsaW1pdCB+IHR3aWNlIGxlc3MgdGhhbiA1NTUyLCB0byBrZWVwXG4gICAgLy8gczIgaW4gMzEtYml0cywgYmVjYXVzZSB3ZSBmb3JjZSBzaWduZWQgaW50cy5cbiAgICAvLyBpbiBvdGhlciBjYXNlICU9IHdpbGwgZmFpbC5cbiAgICBuID0gbGVuID4gMjAwMCA/IDIwMDAgOiBsZW47XG4gICAgbGVuIC09IG47XG5cbiAgICBkbyB7XG4gICAgICBzMSA9IChzMSArIGJ1Zltwb3MrK10pIHwwO1xuICAgICAgczIgPSAoczIgKyBzMSkgfDA7XG4gICAgfSB3aGlsZSAoLS1uKTtcblxuICAgIHMxICU9IDY1NTIxO1xuICAgIHMyICU9IDY1NTIxO1xuICB9XG5cbiAgcmV0dXJuIChzMSB8IChzMiA8PCAxNikpIHwwO1xufVxuXG5cbm1vZHVsZS5leHBvcnRzID0gYWRsZXIzMjtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gTm90ZTogd2UgY2FuJ3QgZ2V0IHNpZ25pZmljYW50IHNwZWVkIGJvb3N0IGhlcmUuXG4vLyBTbyB3cml0ZSBjb2RlIHRvIG1pbmltaXplIHNpemUgLSBubyBwcmVnZW5lcmF0ZWQgdGFibGVzXG4vLyBhbmQgYXJyYXkgdG9vbHMgZGVwZW5kZW5jaWVzLlxuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbi8vIFVzZSBvcmRpbmFyeSBhcnJheSwgc2luY2UgdW50eXBlZCBtYWtlcyBubyBib29zdCBoZXJlXG5mdW5jdGlvbiBtYWtlVGFibGUoKSB7XG4gIHZhciBjLCB0YWJsZSA9IFtdO1xuXG4gIGZvciAodmFyIG4gPSAwOyBuIDwgMjU2OyBuKyspIHtcbiAgICBjID0gbjtcbiAgICBmb3IgKHZhciBrID0gMDsgayA8IDg7IGsrKykge1xuICAgICAgYyA9ICgoYyAmIDEpID8gKDB4RURCODgzMjAgXiAoYyA+Pj4gMSkpIDogKGMgPj4+IDEpKTtcbiAgICB9XG4gICAgdGFibGVbbl0gPSBjO1xuICB9XG5cbiAgcmV0dXJuIHRhYmxlO1xufVxuXG4vLyBDcmVhdGUgdGFibGUgb24gbG9hZC4gSnVzdCAyNTUgc2lnbmVkIGxvbmdzLiBOb3QgYSBwcm9ibGVtLlxudmFyIGNyY1RhYmxlID0gbWFrZVRhYmxlKCk7XG5cblxuZnVuY3Rpb24gY3JjMzIoY3JjLCBidWYsIGxlbiwgcG9zKSB7XG4gIHZhciB0ID0gY3JjVGFibGUsXG4gICAgICBlbmQgPSBwb3MgKyBsZW47XG5cbiAgY3JjIF49IC0xO1xuXG4gIGZvciAodmFyIGkgPSBwb3M7IGkgPCBlbmQ7IGkrKykge1xuICAgIGNyYyA9IChjcmMgPj4+IDgpIF4gdFsoY3JjIF4gYnVmW2ldKSAmIDB4RkZdO1xuICB9XG5cbiAgcmV0dXJuIChjcmMgXiAoLTEpKTsgLy8gPj4+IDA7XG59XG5cblxubW9kdWxlLmV4cG9ydHMgPSBjcmMzMjtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgMjogICAgICAnbmVlZCBkaWN0aW9uYXJ5JywgICAgIC8qIFpfTkVFRF9ESUNUICAgICAgIDIgICovXG4gIDE6ICAgICAgJ3N0cmVhbSBlbmQnLCAgICAgICAgICAvKiBaX1NUUkVBTV9FTkQgICAgICAxICAqL1xuICAwOiAgICAgICcnLCAgICAgICAgICAgICAgICAgICAgLyogWl9PSyAgICAgICAgICAgICAgMCAgKi9cbiAgJy0xJzogICAnZmlsZSBlcnJvcicsICAgICAgICAgIC8qIFpfRVJSTk8gICAgICAgICAoLTEpICovXG4gICctMic6ICAgJ3N0cmVhbSBlcnJvcicsICAgICAgICAvKiBaX1NUUkVBTV9FUlJPUiAgKC0yKSAqL1xuICAnLTMnOiAgICdkYXRhIGVycm9yJywgICAgICAgICAgLyogWl9EQVRBX0VSUk9SICAgICgtMykgKi9cbiAgJy00JzogICAnaW5zdWZmaWNpZW50IG1lbW9yeScsIC8qIFpfTUVNX0VSUk9SICAgICAoLTQpICovXG4gICctNSc6ICAgJ2J1ZmZlciBlcnJvcicsICAgICAgICAvKiBaX0JVRl9FUlJPUiAgICAgKC01KSAqL1xuICAnLTYnOiAgICdpbmNvbXBhdGlibGUgdmVyc2lvbicgLyogWl9WRVJTSU9OX0VSUk9SICgtNikgKi9cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxudmFyIHV0aWxzICAgPSByZXF1aXJlKCcuLi91dGlscy9jb21tb24nKTtcbnZhciB0cmVlcyAgID0gcmVxdWlyZSgnLi90cmVlcycpO1xudmFyIGFkbGVyMzIgPSByZXF1aXJlKCcuL2FkbGVyMzInKTtcbnZhciBjcmMzMiAgID0gcmVxdWlyZSgnLi9jcmMzMicpO1xudmFyIG1zZyAgICAgPSByZXF1aXJlKCcuL21lc3NhZ2VzJyk7XG5cbi8qIFB1YmxpYyBjb25zdGFudHMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5cbi8qIEFsbG93ZWQgZmx1c2ggdmFsdWVzOyBzZWUgZGVmbGF0ZSgpIGFuZCBpbmZsYXRlKCkgYmVsb3cgZm9yIGRldGFpbHMgKi9cbnZhciBaX05PX0ZMVVNIICAgICAgPSAwO1xudmFyIFpfUEFSVElBTF9GTFVTSCA9IDE7XG4vL3ZhciBaX1NZTkNfRkxVU0ggICAgPSAyO1xudmFyIFpfRlVMTF9GTFVTSCAgICA9IDM7XG52YXIgWl9GSU5JU0ggICAgICAgID0gNDtcbnZhciBaX0JMT0NLICAgICAgICAgPSA1O1xuLy92YXIgWl9UUkVFUyAgICAgICAgID0gNjtcblxuXG4vKiBSZXR1cm4gY29kZXMgZm9yIHRoZSBjb21wcmVzc2lvbi9kZWNvbXByZXNzaW9uIGZ1bmN0aW9ucy4gTmVnYXRpdmUgdmFsdWVzXG4gKiBhcmUgZXJyb3JzLCBwb3NpdGl2ZSB2YWx1ZXMgYXJlIHVzZWQgZm9yIHNwZWNpYWwgYnV0IG5vcm1hbCBldmVudHMuXG4gKi9cbnZhciBaX09LICAgICAgICAgICAgPSAwO1xudmFyIFpfU1RSRUFNX0VORCAgICA9IDE7XG4vL3ZhciBaX05FRURfRElDVCAgICAgPSAyO1xuLy92YXIgWl9FUlJOTyAgICAgICAgID0gLTE7XG52YXIgWl9TVFJFQU1fRVJST1IgID0gLTI7XG52YXIgWl9EQVRBX0VSUk9SICAgID0gLTM7XG4vL3ZhciBaX01FTV9FUlJPUiAgICAgPSAtNDtcbnZhciBaX0JVRl9FUlJPUiAgICAgPSAtNTtcbi8vdmFyIFpfVkVSU0lPTl9FUlJPUiA9IC02O1xuXG5cbi8qIGNvbXByZXNzaW9uIGxldmVscyAqL1xuLy92YXIgWl9OT19DT01QUkVTU0lPTiAgICAgID0gMDtcbi8vdmFyIFpfQkVTVF9TUEVFRCAgICAgICAgICA9IDE7XG4vL3ZhciBaX0JFU1RfQ09NUFJFU1NJT04gICAgPSA5O1xudmFyIFpfREVGQVVMVF9DT01QUkVTU0lPTiA9IC0xO1xuXG5cbnZhciBaX0ZJTFRFUkVEICAgICAgICAgICAgPSAxO1xudmFyIFpfSFVGRk1BTl9PTkxZICAgICAgICA9IDI7XG52YXIgWl9STEUgICAgICAgICAgICAgICAgID0gMztcbnZhciBaX0ZJWEVEICAgICAgICAgICAgICAgPSA0O1xudmFyIFpfREVGQVVMVF9TVFJBVEVHWSAgICA9IDA7XG5cbi8qIFBvc3NpYmxlIHZhbHVlcyBvZiB0aGUgZGF0YV90eXBlIGZpZWxkICh0aG91Z2ggc2VlIGluZmxhdGUoKSkgKi9cbi8vdmFyIFpfQklOQVJZICAgICAgICAgICAgICA9IDA7XG4vL3ZhciBaX1RFWFQgICAgICAgICAgICAgICAgPSAxO1xuLy92YXIgWl9BU0NJSSAgICAgICAgICAgICAgID0gMTsgLy8gPSBaX1RFWFRcbnZhciBaX1VOS05PV04gICAgICAgICAgICAgPSAyO1xuXG5cbi8qIFRoZSBkZWZsYXRlIGNvbXByZXNzaW9uIG1ldGhvZCAqL1xudmFyIFpfREVGTEFURUQgID0gODtcblxuLyo9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG52YXIgTUFYX01FTV9MRVZFTCA9IDk7XG4vKiBNYXhpbXVtIHZhbHVlIGZvciBtZW1MZXZlbCBpbiBkZWZsYXRlSW5pdDIgKi9cbnZhciBNQVhfV0JJVFMgPSAxNTtcbi8qIDMySyBMWjc3IHdpbmRvdyAqL1xudmFyIERFRl9NRU1fTEVWRUwgPSA4O1xuXG5cbnZhciBMRU5HVEhfQ09ERVMgID0gMjk7XG4vKiBudW1iZXIgb2YgbGVuZ3RoIGNvZGVzLCBub3QgY291bnRpbmcgdGhlIHNwZWNpYWwgRU5EX0JMT0NLIGNvZGUgKi9cbnZhciBMSVRFUkFMUyAgICAgID0gMjU2O1xuLyogbnVtYmVyIG9mIGxpdGVyYWwgYnl0ZXMgMC4uMjU1ICovXG52YXIgTF9DT0RFUyAgICAgICA9IExJVEVSQUxTICsgMSArIExFTkdUSF9DT0RFUztcbi8qIG51bWJlciBvZiBMaXRlcmFsIG9yIExlbmd0aCBjb2RlcywgaW5jbHVkaW5nIHRoZSBFTkRfQkxPQ0sgY29kZSAqL1xudmFyIERfQ09ERVMgICAgICAgPSAzMDtcbi8qIG51bWJlciBvZiBkaXN0YW5jZSBjb2RlcyAqL1xudmFyIEJMX0NPREVTICAgICAgPSAxOTtcbi8qIG51bWJlciBvZiBjb2RlcyB1c2VkIHRvIHRyYW5zZmVyIHRoZSBiaXQgbGVuZ3RocyAqL1xudmFyIEhFQVBfU0laRSAgICAgPSAyICogTF9DT0RFUyArIDE7XG4vKiBtYXhpbXVtIGhlYXAgc2l6ZSAqL1xudmFyIE1BWF9CSVRTICA9IDE1O1xuLyogQWxsIGNvZGVzIG11c3Qgbm90IGV4Y2VlZCBNQVhfQklUUyBiaXRzICovXG5cbnZhciBNSU5fTUFUQ0ggPSAzO1xudmFyIE1BWF9NQVRDSCA9IDI1ODtcbnZhciBNSU5fTE9PS0FIRUFEID0gKE1BWF9NQVRDSCArIE1JTl9NQVRDSCArIDEpO1xuXG52YXIgUFJFU0VUX0RJQ1QgPSAweDIwO1xuXG52YXIgSU5JVF9TVEFURSA9IDQyO1xudmFyIEVYVFJBX1NUQVRFID0gNjk7XG52YXIgTkFNRV9TVEFURSA9IDczO1xudmFyIENPTU1FTlRfU1RBVEUgPSA5MTtcbnZhciBIQ1JDX1NUQVRFID0gMTAzO1xudmFyIEJVU1lfU1RBVEUgPSAxMTM7XG52YXIgRklOSVNIX1NUQVRFID0gNjY2O1xuXG52YXIgQlNfTkVFRF9NT1JFICAgICAgPSAxOyAvKiBibG9jayBub3QgY29tcGxldGVkLCBuZWVkIG1vcmUgaW5wdXQgb3IgbW9yZSBvdXRwdXQgKi9cbnZhciBCU19CTE9DS19ET05FICAgICA9IDI7IC8qIGJsb2NrIGZsdXNoIHBlcmZvcm1lZCAqL1xudmFyIEJTX0ZJTklTSF9TVEFSVEVEID0gMzsgLyogZmluaXNoIHN0YXJ0ZWQsIG5lZWQgb25seSBtb3JlIG91dHB1dCBhdCBuZXh0IGRlZmxhdGUgKi9cbnZhciBCU19GSU5JU0hfRE9ORSAgICA9IDQ7IC8qIGZpbmlzaCBkb25lLCBhY2NlcHQgbm8gbW9yZSBpbnB1dCBvciBvdXRwdXQgKi9cblxudmFyIE9TX0NPREUgPSAweDAzOyAvLyBVbml4IDopIC4gRG9uJ3QgZGV0ZWN0LCB1c2UgdGhpcyBkZWZhdWx0LlxuXG5mdW5jdGlvbiBlcnIoc3RybSwgZXJyb3JDb2RlKSB7XG4gIHN0cm0ubXNnID0gbXNnW2Vycm9yQ29kZV07XG4gIHJldHVybiBlcnJvckNvZGU7XG59XG5cbmZ1bmN0aW9uIHJhbmsoZikge1xuICByZXR1cm4gKChmKSA8PCAxKSAtICgoZikgPiA0ID8gOSA6IDApO1xufVxuXG5mdW5jdGlvbiB6ZXJvKGJ1ZikgeyB2YXIgbGVuID0gYnVmLmxlbmd0aDsgd2hpbGUgKC0tbGVuID49IDApIHsgYnVmW2xlbl0gPSAwOyB9IH1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBGbHVzaCBhcyBtdWNoIHBlbmRpbmcgb3V0cHV0IGFzIHBvc3NpYmxlLiBBbGwgZGVmbGF0ZSgpIG91dHB1dCBnb2VzXG4gKiB0aHJvdWdoIHRoaXMgZnVuY3Rpb24gc28gc29tZSBhcHBsaWNhdGlvbnMgbWF5IHdpc2ggdG8gbW9kaWZ5IGl0XG4gKiB0byBhdm9pZCBhbGxvY2F0aW5nIGEgbGFyZ2Ugc3RybS0+b3V0cHV0IGJ1ZmZlciBhbmQgY29weWluZyBpbnRvIGl0LlxuICogKFNlZSBhbHNvIHJlYWRfYnVmKCkpLlxuICovXG5mdW5jdGlvbiBmbHVzaF9wZW5kaW5nKHN0cm0pIHtcbiAgdmFyIHMgPSBzdHJtLnN0YXRlO1xuXG4gIC8vX3RyX2ZsdXNoX2JpdHMocyk7XG4gIHZhciBsZW4gPSBzLnBlbmRpbmc7XG4gIGlmIChsZW4gPiBzdHJtLmF2YWlsX291dCkge1xuICAgIGxlbiA9IHN0cm0uYXZhaWxfb3V0O1xuICB9XG4gIGlmIChsZW4gPT09IDApIHsgcmV0dXJuOyB9XG5cbiAgdXRpbHMuYXJyYXlTZXQoc3RybS5vdXRwdXQsIHMucGVuZGluZ19idWYsIHMucGVuZGluZ19vdXQsIGxlbiwgc3RybS5uZXh0X291dCk7XG4gIHN0cm0ubmV4dF9vdXQgKz0gbGVuO1xuICBzLnBlbmRpbmdfb3V0ICs9IGxlbjtcbiAgc3RybS50b3RhbF9vdXQgKz0gbGVuO1xuICBzdHJtLmF2YWlsX291dCAtPSBsZW47XG4gIHMucGVuZGluZyAtPSBsZW47XG4gIGlmIChzLnBlbmRpbmcgPT09IDApIHtcbiAgICBzLnBlbmRpbmdfb3V0ID0gMDtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIGZsdXNoX2Jsb2NrX29ubHkocywgbGFzdCkge1xuICB0cmVlcy5fdHJfZmx1c2hfYmxvY2socywgKHMuYmxvY2tfc3RhcnQgPj0gMCA/IHMuYmxvY2tfc3RhcnQgOiAtMSksIHMuc3Ryc3RhcnQgLSBzLmJsb2NrX3N0YXJ0LCBsYXN0KTtcbiAgcy5ibG9ja19zdGFydCA9IHMuc3Ryc3RhcnQ7XG4gIGZsdXNoX3BlbmRpbmcocy5zdHJtKTtcbn1cblxuXG5mdW5jdGlvbiBwdXRfYnl0ZShzLCBiKSB7XG4gIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gYjtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBQdXQgYSBzaG9ydCBpbiB0aGUgcGVuZGluZyBidWZmZXIuIFRoZSAxNi1iaXQgdmFsdWUgaXMgcHV0IGluIE1TQiBvcmRlci5cbiAqIElOIGFzc2VydGlvbjogdGhlIHN0cmVhbSBzdGF0ZSBpcyBjb3JyZWN0IGFuZCB0aGVyZSBpcyBlbm91Z2ggcm9vbSBpblxuICogcGVuZGluZ19idWYuXG4gKi9cbmZ1bmN0aW9uIHB1dFNob3J0TVNCKHMsIGIpIHtcbi8vICBwdXRfYnl0ZShzLCAoQnl0ZSkoYiA+PiA4KSk7XG4vLyAgcHV0X2J5dGUocywgKEJ5dGUpKGIgJiAweGZmKSk7XG4gIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gKGIgPj4+IDgpICYgMHhmZjtcbiAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSBiICYgMHhmZjtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFJlYWQgYSBuZXcgYnVmZmVyIGZyb20gdGhlIGN1cnJlbnQgaW5wdXQgc3RyZWFtLCB1cGRhdGUgdGhlIGFkbGVyMzJcbiAqIGFuZCB0b3RhbCBudW1iZXIgb2YgYnl0ZXMgcmVhZC4gIEFsbCBkZWZsYXRlKCkgaW5wdXQgZ29lcyB0aHJvdWdoXG4gKiB0aGlzIGZ1bmN0aW9uIHNvIHNvbWUgYXBwbGljYXRpb25zIG1heSB3aXNoIHRvIG1vZGlmeSBpdCB0byBhdm9pZFxuICogYWxsb2NhdGluZyBhIGxhcmdlIHN0cm0tPmlucHV0IGJ1ZmZlciBhbmQgY29weWluZyBmcm9tIGl0LlxuICogKFNlZSBhbHNvIGZsdXNoX3BlbmRpbmcoKSkuXG4gKi9cbmZ1bmN0aW9uIHJlYWRfYnVmKHN0cm0sIGJ1Ziwgc3RhcnQsIHNpemUpIHtcbiAgdmFyIGxlbiA9IHN0cm0uYXZhaWxfaW47XG5cbiAgaWYgKGxlbiA+IHNpemUpIHsgbGVuID0gc2l6ZTsgfVxuICBpZiAobGVuID09PSAwKSB7IHJldHVybiAwOyB9XG5cbiAgc3RybS5hdmFpbF9pbiAtPSBsZW47XG5cbiAgLy8gem1lbWNweShidWYsIHN0cm0tPm5leHRfaW4sIGxlbik7XG4gIHV0aWxzLmFycmF5U2V0KGJ1Ziwgc3RybS5pbnB1dCwgc3RybS5uZXh0X2luLCBsZW4sIHN0YXJ0KTtcbiAgaWYgKHN0cm0uc3RhdGUud3JhcCA9PT0gMSkge1xuICAgIHN0cm0uYWRsZXIgPSBhZGxlcjMyKHN0cm0uYWRsZXIsIGJ1ZiwgbGVuLCBzdGFydCk7XG4gIH1cblxuICBlbHNlIGlmIChzdHJtLnN0YXRlLndyYXAgPT09IDIpIHtcbiAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgYnVmLCBsZW4sIHN0YXJ0KTtcbiAgfVxuXG4gIHN0cm0ubmV4dF9pbiArPSBsZW47XG4gIHN0cm0udG90YWxfaW4gKz0gbGVuO1xuXG4gIHJldHVybiBsZW47XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTZXQgbWF0Y2hfc3RhcnQgdG8gdGhlIGxvbmdlc3QgbWF0Y2ggc3RhcnRpbmcgYXQgdGhlIGdpdmVuIHN0cmluZyBhbmRcbiAqIHJldHVybiBpdHMgbGVuZ3RoLiBNYXRjaGVzIHNob3J0ZXIgb3IgZXF1YWwgdG8gcHJldl9sZW5ndGggYXJlIGRpc2NhcmRlZCxcbiAqIGluIHdoaWNoIGNhc2UgdGhlIHJlc3VsdCBpcyBlcXVhbCB0byBwcmV2X2xlbmd0aCBhbmQgbWF0Y2hfc3RhcnQgaXNcbiAqIGdhcmJhZ2UuXG4gKiBJTiBhc3NlcnRpb25zOiBjdXJfbWF0Y2ggaXMgdGhlIGhlYWQgb2YgdGhlIGhhc2ggY2hhaW4gZm9yIHRoZSBjdXJyZW50XG4gKiAgIHN0cmluZyAoc3Ryc3RhcnQpIGFuZCBpdHMgZGlzdGFuY2UgaXMgPD0gTUFYX0RJU1QsIGFuZCBwcmV2X2xlbmd0aCA+PSAxXG4gKiBPVVQgYXNzZXJ0aW9uOiB0aGUgbWF0Y2ggbGVuZ3RoIGlzIG5vdCBncmVhdGVyIHRoYW4gcy0+bG9va2FoZWFkLlxuICovXG5mdW5jdGlvbiBsb25nZXN0X21hdGNoKHMsIGN1cl9tYXRjaCkge1xuICB2YXIgY2hhaW5fbGVuZ3RoID0gcy5tYXhfY2hhaW5fbGVuZ3RoOyAgICAgIC8qIG1heCBoYXNoIGNoYWluIGxlbmd0aCAqL1xuICB2YXIgc2NhbiA9IHMuc3Ryc3RhcnQ7IC8qIGN1cnJlbnQgc3RyaW5nICovXG4gIHZhciBtYXRjaDsgICAgICAgICAgICAgICAgICAgICAgIC8qIG1hdGNoZWQgc3RyaW5nICovXG4gIHZhciBsZW47ICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogbGVuZ3RoIG9mIGN1cnJlbnQgbWF0Y2ggKi9cbiAgdmFyIGJlc3RfbGVuID0gcy5wcmV2X2xlbmd0aDsgICAgICAgICAgICAgIC8qIGJlc3QgbWF0Y2ggbGVuZ3RoIHNvIGZhciAqL1xuICB2YXIgbmljZV9tYXRjaCA9IHMubmljZV9tYXRjaDsgICAgICAgICAgICAgLyogc3RvcCBpZiBtYXRjaCBsb25nIGVub3VnaCAqL1xuICB2YXIgbGltaXQgPSAocy5zdHJzdGFydCA+IChzLndfc2l6ZSAtIE1JTl9MT09LQUhFQUQpKSA/XG4gICAgICBzLnN0cnN0YXJ0IC0gKHMud19zaXplIC0gTUlOX0xPT0tBSEVBRCkgOiAwLypOSUwqLztcblxuICB2YXIgX3dpbiA9IHMud2luZG93OyAvLyBzaG9ydGN1dFxuXG4gIHZhciB3bWFzayA9IHMud19tYXNrO1xuICB2YXIgcHJldiAgPSBzLnByZXY7XG5cbiAgLyogU3RvcCB3aGVuIGN1cl9tYXRjaCBiZWNvbWVzIDw9IGxpbWl0LiBUbyBzaW1wbGlmeSB0aGUgY29kZSxcbiAgICogd2UgcHJldmVudCBtYXRjaGVzIHdpdGggdGhlIHN0cmluZyBvZiB3aW5kb3cgaW5kZXggMC5cbiAgICovXG5cbiAgdmFyIHN0cmVuZCA9IHMuc3Ryc3RhcnQgKyBNQVhfTUFUQ0g7XG4gIHZhciBzY2FuX2VuZDEgID0gX3dpbltzY2FuICsgYmVzdF9sZW4gLSAxXTtcbiAgdmFyIHNjYW5fZW5kICAgPSBfd2luW3NjYW4gKyBiZXN0X2xlbl07XG5cbiAgLyogVGhlIGNvZGUgaXMgb3B0aW1pemVkIGZvciBIQVNIX0JJVFMgPj0gOCBhbmQgTUFYX01BVENILTIgbXVsdGlwbGUgb2YgMTYuXG4gICAqIEl0IGlzIGVhc3kgdG8gZ2V0IHJpZCBvZiB0aGlzIG9wdGltaXphdGlvbiBpZiBuZWNlc3NhcnkuXG4gICAqL1xuICAvLyBBc3NlcnQocy0+aGFzaF9iaXRzID49IDggJiYgTUFYX01BVENIID09IDI1OCwgXCJDb2RlIHRvbyBjbGV2ZXJcIik7XG5cbiAgLyogRG8gbm90IHdhc3RlIHRvbyBtdWNoIHRpbWUgaWYgd2UgYWxyZWFkeSBoYXZlIGEgZ29vZCBtYXRjaDogKi9cbiAgaWYgKHMucHJldl9sZW5ndGggPj0gcy5nb29kX21hdGNoKSB7XG4gICAgY2hhaW5fbGVuZ3RoID4+PSAyO1xuICB9XG4gIC8qIERvIG5vdCBsb29rIGZvciBtYXRjaGVzIGJleW9uZCB0aGUgZW5kIG9mIHRoZSBpbnB1dC4gVGhpcyBpcyBuZWNlc3NhcnlcbiAgICogdG8gbWFrZSBkZWZsYXRlIGRldGVybWluaXN0aWMuXG4gICAqL1xuICBpZiAobmljZV9tYXRjaCA+IHMubG9va2FoZWFkKSB7IG5pY2VfbWF0Y2ggPSBzLmxvb2thaGVhZDsgfVxuXG4gIC8vIEFzc2VydCgodWxnKXMtPnN0cnN0YXJ0IDw9IHMtPndpbmRvd19zaXplLU1JTl9MT09LQUhFQUQsIFwibmVlZCBsb29rYWhlYWRcIik7XG5cbiAgZG8ge1xuICAgIC8vIEFzc2VydChjdXJfbWF0Y2ggPCBzLT5zdHJzdGFydCwgXCJubyBmdXR1cmVcIik7XG4gICAgbWF0Y2ggPSBjdXJfbWF0Y2g7XG5cbiAgICAvKiBTa2lwIHRvIG5leHQgbWF0Y2ggaWYgdGhlIG1hdGNoIGxlbmd0aCBjYW5ub3QgaW5jcmVhc2VcbiAgICAgKiBvciBpZiB0aGUgbWF0Y2ggbGVuZ3RoIGlzIGxlc3MgdGhhbiAyLiAgTm90ZSB0aGF0IHRoZSBjaGVja3MgYmVsb3dcbiAgICAgKiBmb3IgaW5zdWZmaWNpZW50IGxvb2thaGVhZCBvbmx5IG9jY3VyIG9jY2FzaW9uYWxseSBmb3IgcGVyZm9ybWFuY2VcbiAgICAgKiByZWFzb25zLiAgVGhlcmVmb3JlIHVuaW5pdGlhbGl6ZWQgbWVtb3J5IHdpbGwgYmUgYWNjZXNzZWQsIGFuZFxuICAgICAqIGNvbmRpdGlvbmFsIGp1bXBzIHdpbGwgYmUgbWFkZSB0aGF0IGRlcGVuZCBvbiB0aG9zZSB2YWx1ZXMuXG4gICAgICogSG93ZXZlciB0aGUgbGVuZ3RoIG9mIHRoZSBtYXRjaCBpcyBsaW1pdGVkIHRvIHRoZSBsb29rYWhlYWQsIHNvXG4gICAgICogdGhlIG91dHB1dCBvZiBkZWZsYXRlIGlzIG5vdCBhZmZlY3RlZCBieSB0aGUgdW5pbml0aWFsaXplZCB2YWx1ZXMuXG4gICAgICovXG5cbiAgICBpZiAoX3dpblttYXRjaCArIGJlc3RfbGVuXSAgICAgIT09IHNjYW5fZW5kICB8fFxuICAgICAgICBfd2luW21hdGNoICsgYmVzdF9sZW4gLSAxXSAhPT0gc2Nhbl9lbmQxIHx8XG4gICAgICAgIF93aW5bbWF0Y2hdICAgICAgICAgICAgICAgICE9PSBfd2luW3NjYW5dIHx8XG4gICAgICAgIF93aW5bKyttYXRjaF0gICAgICAgICAgICAgICE9PSBfd2luW3NjYW4gKyAxXSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLyogVGhlIGNoZWNrIGF0IGJlc3RfbGVuLTEgY2FuIGJlIHJlbW92ZWQgYmVjYXVzZSBpdCB3aWxsIGJlIG1hZGVcbiAgICAgKiBhZ2FpbiBsYXRlci4gKFRoaXMgaGV1cmlzdGljIGlzIG5vdCBhbHdheXMgYSB3aW4uKVxuICAgICAqIEl0IGlzIG5vdCBuZWNlc3NhcnkgdG8gY29tcGFyZSBzY2FuWzJdIGFuZCBtYXRjaFsyXSBzaW5jZSB0aGV5XG4gICAgICogYXJlIGFsd2F5cyBlcXVhbCB3aGVuIHRoZSBvdGhlciBieXRlcyBtYXRjaCwgZ2l2ZW4gdGhhdFxuICAgICAqIHRoZSBoYXNoIGtleXMgYXJlIGVxdWFsIGFuZCB0aGF0IEhBU0hfQklUUyA+PSA4LlxuICAgICAqL1xuICAgIHNjYW4gKz0gMjtcbiAgICBtYXRjaCsrO1xuICAgIC8vIEFzc2VydCgqc2NhbiA9PSAqbWF0Y2gsIFwibWF0Y2hbMl0/XCIpO1xuXG4gICAgLyogV2UgY2hlY2sgZm9yIGluc3VmZmljaWVudCBsb29rYWhlYWQgb25seSBldmVyeSA4dGggY29tcGFyaXNvbjtcbiAgICAgKiB0aGUgMjU2dGggY2hlY2sgd2lsbCBiZSBtYWRlIGF0IHN0cnN0YXJ0KzI1OC5cbiAgICAgKi9cbiAgICBkbyB7XG4gICAgICAvKmpzaGludCBub2VtcHR5OmZhbHNlKi9cbiAgICB9IHdoaWxlIChfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiYgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmXG4gICAgICAgICAgICAgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJlxuICAgICAgICAgICAgIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJiBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiZcbiAgICAgICAgICAgICBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiYgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmXG4gICAgICAgICAgICAgc2NhbiA8IHN0cmVuZCk7XG5cbiAgICAvLyBBc3NlcnQoc2NhbiA8PSBzLT53aW5kb3crKHVuc2lnbmVkKShzLT53aW5kb3dfc2l6ZS0xKSwgXCJ3aWxkIHNjYW5cIik7XG5cbiAgICBsZW4gPSBNQVhfTUFUQ0ggLSAoc3RyZW5kIC0gc2Nhbik7XG4gICAgc2NhbiA9IHN0cmVuZCAtIE1BWF9NQVRDSDtcblxuICAgIGlmIChsZW4gPiBiZXN0X2xlbikge1xuICAgICAgcy5tYXRjaF9zdGFydCA9IGN1cl9tYXRjaDtcbiAgICAgIGJlc3RfbGVuID0gbGVuO1xuICAgICAgaWYgKGxlbiA+PSBuaWNlX21hdGNoKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgc2Nhbl9lbmQxICA9IF93aW5bc2NhbiArIGJlc3RfbGVuIC0gMV07XG4gICAgICBzY2FuX2VuZCAgID0gX3dpbltzY2FuICsgYmVzdF9sZW5dO1xuICAgIH1cbiAgfSB3aGlsZSAoKGN1cl9tYXRjaCA9IHByZXZbY3VyX21hdGNoICYgd21hc2tdKSA+IGxpbWl0ICYmIC0tY2hhaW5fbGVuZ3RoICE9PSAwKTtcblxuICBpZiAoYmVzdF9sZW4gPD0gcy5sb29rYWhlYWQpIHtcbiAgICByZXR1cm4gYmVzdF9sZW47XG4gIH1cbiAgcmV0dXJuIHMubG9va2FoZWFkO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogRmlsbCB0aGUgd2luZG93IHdoZW4gdGhlIGxvb2thaGVhZCBiZWNvbWVzIGluc3VmZmljaWVudC5cbiAqIFVwZGF0ZXMgc3Ryc3RhcnQgYW5kIGxvb2thaGVhZC5cbiAqXG4gKiBJTiBhc3NlcnRpb246IGxvb2thaGVhZCA8IE1JTl9MT09LQUhFQURcbiAqIE9VVCBhc3NlcnRpb25zOiBzdHJzdGFydCA8PSB3aW5kb3dfc2l6ZS1NSU5fTE9PS0FIRUFEXG4gKiAgICBBdCBsZWFzdCBvbmUgYnl0ZSBoYXMgYmVlbiByZWFkLCBvciBhdmFpbF9pbiA9PSAwOyByZWFkcyBhcmVcbiAqICAgIHBlcmZvcm1lZCBmb3IgYXQgbGVhc3QgdHdvIGJ5dGVzIChyZXF1aXJlZCBmb3IgdGhlIHppcCB0cmFuc2xhdGVfZW9sXG4gKiAgICBvcHRpb24gLS0gbm90IHN1cHBvcnRlZCBoZXJlKS5cbiAqL1xuZnVuY3Rpb24gZmlsbF93aW5kb3cocykge1xuICB2YXIgX3dfc2l6ZSA9IHMud19zaXplO1xuICB2YXIgcCwgbiwgbSwgbW9yZSwgc3RyO1xuXG4gIC8vQXNzZXJ0KHMtPmxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQsIFwiYWxyZWFkeSBlbm91Z2ggbG9va2FoZWFkXCIpO1xuXG4gIGRvIHtcbiAgICBtb3JlID0gcy53aW5kb3dfc2l6ZSAtIHMubG9va2FoZWFkIC0gcy5zdHJzdGFydDtcblxuICAgIC8vIEpTIGludHMgaGF2ZSAzMiBiaXQsIGJsb2NrIGJlbG93IG5vdCBuZWVkZWRcbiAgICAvKiBEZWFsIHdpdGggIUAjJCUgNjRLIGxpbWl0OiAqL1xuICAgIC8vaWYgKHNpemVvZihpbnQpIDw9IDIpIHtcbiAgICAvLyAgICBpZiAobW9yZSA9PSAwICYmIHMtPnN0cnN0YXJ0ID09IDAgJiYgcy0+bG9va2FoZWFkID09IDApIHtcbiAgICAvLyAgICAgICAgbW9yZSA9IHdzaXplO1xuICAgIC8vXG4gICAgLy8gIH0gZWxzZSBpZiAobW9yZSA9PSAodW5zaWduZWQpKC0xKSkge1xuICAgIC8vICAgICAgICAvKiBWZXJ5IHVubGlrZWx5LCBidXQgcG9zc2libGUgb24gMTYgYml0IG1hY2hpbmUgaWZcbiAgICAvLyAgICAgICAgICogc3Ryc3RhcnQgPT0gMCAmJiBsb29rYWhlYWQgPT0gMSAoaW5wdXQgZG9uZSBhIGJ5dGUgYXQgdGltZSlcbiAgICAvLyAgICAgICAgICovXG4gICAgLy8gICAgICAgIG1vcmUtLTtcbiAgICAvLyAgICB9XG4gICAgLy99XG5cblxuICAgIC8qIElmIHRoZSB3aW5kb3cgaXMgYWxtb3N0IGZ1bGwgYW5kIHRoZXJlIGlzIGluc3VmZmljaWVudCBsb29rYWhlYWQsXG4gICAgICogbW92ZSB0aGUgdXBwZXIgaGFsZiB0byB0aGUgbG93ZXIgb25lIHRvIG1ha2Ugcm9vbSBpbiB0aGUgdXBwZXIgaGFsZi5cbiAgICAgKi9cbiAgICBpZiAocy5zdHJzdGFydCA+PSBfd19zaXplICsgKF93X3NpemUgLSBNSU5fTE9PS0FIRUFEKSkge1xuXG4gICAgICB1dGlscy5hcnJheVNldChzLndpbmRvdywgcy53aW5kb3csIF93X3NpemUsIF93X3NpemUsIDApO1xuICAgICAgcy5tYXRjaF9zdGFydCAtPSBfd19zaXplO1xuICAgICAgcy5zdHJzdGFydCAtPSBfd19zaXplO1xuICAgICAgLyogd2Ugbm93IGhhdmUgc3Ryc3RhcnQgPj0gTUFYX0RJU1QgKi9cbiAgICAgIHMuYmxvY2tfc3RhcnQgLT0gX3dfc2l6ZTtcblxuICAgICAgLyogU2xpZGUgdGhlIGhhc2ggdGFibGUgKGNvdWxkIGJlIGF2b2lkZWQgd2l0aCAzMiBiaXQgdmFsdWVzXG4gICAgICAgYXQgdGhlIGV4cGVuc2Ugb2YgbWVtb3J5IHVzYWdlKS4gV2Ugc2xpZGUgZXZlbiB3aGVuIGxldmVsID09IDBcbiAgICAgICB0byBrZWVwIHRoZSBoYXNoIHRhYmxlIGNvbnNpc3RlbnQgaWYgd2Ugc3dpdGNoIGJhY2sgdG8gbGV2ZWwgPiAwXG4gICAgICAgbGF0ZXIuIChVc2luZyBsZXZlbCAwIHBlcm1hbmVudGx5IGlzIG5vdCBhbiBvcHRpbWFsIHVzYWdlIG9mXG4gICAgICAgemxpYiwgc28gd2UgZG9uJ3QgY2FyZSBhYm91dCB0aGlzIHBhdGhvbG9naWNhbCBjYXNlLilcbiAgICAgICAqL1xuXG4gICAgICBuID0gcy5oYXNoX3NpemU7XG4gICAgICBwID0gbjtcbiAgICAgIGRvIHtcbiAgICAgICAgbSA9IHMuaGVhZFstLXBdO1xuICAgICAgICBzLmhlYWRbcF0gPSAobSA+PSBfd19zaXplID8gbSAtIF93X3NpemUgOiAwKTtcbiAgICAgIH0gd2hpbGUgKC0tbik7XG5cbiAgICAgIG4gPSBfd19zaXplO1xuICAgICAgcCA9IG47XG4gICAgICBkbyB7XG4gICAgICAgIG0gPSBzLnByZXZbLS1wXTtcbiAgICAgICAgcy5wcmV2W3BdID0gKG0gPj0gX3dfc2l6ZSA/IG0gLSBfd19zaXplIDogMCk7XG4gICAgICAgIC8qIElmIG4gaXMgbm90IG9uIGFueSBoYXNoIGNoYWluLCBwcmV2W25dIGlzIGdhcmJhZ2UgYnV0XG4gICAgICAgICAqIGl0cyB2YWx1ZSB3aWxsIG5ldmVyIGJlIHVzZWQuXG4gICAgICAgICAqL1xuICAgICAgfSB3aGlsZSAoLS1uKTtcblxuICAgICAgbW9yZSArPSBfd19zaXplO1xuICAgIH1cbiAgICBpZiAocy5zdHJtLmF2YWlsX2luID09PSAwKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvKiBJZiB0aGVyZSB3YXMgbm8gc2xpZGluZzpcbiAgICAgKiAgICBzdHJzdGFydCA8PSBXU0laRStNQVhfRElTVC0xICYmIGxvb2thaGVhZCA8PSBNSU5fTE9PS0FIRUFEIC0gMSAmJlxuICAgICAqICAgIG1vcmUgPT0gd2luZG93X3NpemUgLSBsb29rYWhlYWQgLSBzdHJzdGFydFxuICAgICAqID0+IG1vcmUgPj0gd2luZG93X3NpemUgLSAoTUlOX0xPT0tBSEVBRC0xICsgV1NJWkUgKyBNQVhfRElTVC0xKVxuICAgICAqID0+IG1vcmUgPj0gd2luZG93X3NpemUgLSAyKldTSVpFICsgMlxuICAgICAqIEluIHRoZSBCSUdfTUVNIG9yIE1NQVAgY2FzZSAobm90IHlldCBzdXBwb3J0ZWQpLFxuICAgICAqICAgd2luZG93X3NpemUgPT0gaW5wdXRfc2l6ZSArIE1JTl9MT09LQUhFQUQgICYmXG4gICAgICogICBzdHJzdGFydCArIHMtPmxvb2thaGVhZCA8PSBpbnB1dF9zaXplID0+IG1vcmUgPj0gTUlOX0xPT0tBSEVBRC5cbiAgICAgKiBPdGhlcndpc2UsIHdpbmRvd19zaXplID09IDIqV1NJWkUgc28gbW9yZSA+PSAyLlxuICAgICAqIElmIHRoZXJlIHdhcyBzbGlkaW5nLCBtb3JlID49IFdTSVpFLiBTbyBpbiBhbGwgY2FzZXMsIG1vcmUgPj0gMi5cbiAgICAgKi9cbiAgICAvL0Fzc2VydChtb3JlID49IDIsIFwibW9yZSA8IDJcIik7XG4gICAgbiA9IHJlYWRfYnVmKHMuc3RybSwgcy53aW5kb3csIHMuc3Ryc3RhcnQgKyBzLmxvb2thaGVhZCwgbW9yZSk7XG4gICAgcy5sb29rYWhlYWQgKz0gbjtcblxuICAgIC8qIEluaXRpYWxpemUgdGhlIGhhc2ggdmFsdWUgbm93IHRoYXQgd2UgaGF2ZSBzb21lIGlucHV0OiAqL1xuICAgIGlmIChzLmxvb2thaGVhZCArIHMuaW5zZXJ0ID49IE1JTl9NQVRDSCkge1xuICAgICAgc3RyID0gcy5zdHJzdGFydCAtIHMuaW5zZXJ0O1xuICAgICAgcy5pbnNfaCA9IHMud2luZG93W3N0cl07XG5cbiAgICAgIC8qIFVQREFURV9IQVNIKHMsIHMtPmluc19oLCBzLT53aW5kb3dbc3RyICsgMV0pOyAqL1xuICAgICAgcy5pbnNfaCA9ICgocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQpIF4gcy53aW5kb3dbc3RyICsgMV0pICYgcy5oYXNoX21hc2s7XG4vLyNpZiBNSU5fTUFUQ0ggIT0gM1xuLy8gICAgICAgIENhbGwgdXBkYXRlX2hhc2goKSBNSU5fTUFUQ0gtMyBtb3JlIHRpbWVzXG4vLyNlbmRpZlxuICAgICAgd2hpbGUgKHMuaW5zZXJ0KSB7XG4gICAgICAgIC8qIFVQREFURV9IQVNIKHMsIHMtPmluc19oLCBzLT53aW5kb3dbc3RyICsgTUlOX01BVENILTFdKTsgKi9cbiAgICAgICAgcy5pbnNfaCA9ICgocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQpIF4gcy53aW5kb3dbc3RyICsgTUlOX01BVENIIC0gMV0pICYgcy5oYXNoX21hc2s7XG5cbiAgICAgICAgcy5wcmV2W3N0ciAmIHMud19tYXNrXSA9IHMuaGVhZFtzLmluc19oXTtcbiAgICAgICAgcy5oZWFkW3MuaW5zX2hdID0gc3RyO1xuICAgICAgICBzdHIrKztcbiAgICAgICAgcy5pbnNlcnQtLTtcbiAgICAgICAgaWYgKHMubG9va2FoZWFkICsgcy5pbnNlcnQgPCBNSU5fTUFUQ0gpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvKiBJZiB0aGUgd2hvbGUgaW5wdXQgaGFzIGxlc3MgdGhhbiBNSU5fTUFUQ0ggYnl0ZXMsIGluc19oIGlzIGdhcmJhZ2UsXG4gICAgICogYnV0IHRoaXMgaXMgbm90IGltcG9ydGFudCBzaW5jZSBvbmx5IGxpdGVyYWwgYnl0ZXMgd2lsbCBiZSBlbWl0dGVkLlxuICAgICAqL1xuXG4gIH0gd2hpbGUgKHMubG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCAmJiBzLnN0cm0uYXZhaWxfaW4gIT09IDApO1xuXG4gIC8qIElmIHRoZSBXSU5fSU5JVCBieXRlcyBhZnRlciB0aGUgZW5kIG9mIHRoZSBjdXJyZW50IGRhdGEgaGF2ZSBuZXZlciBiZWVuXG4gICAqIHdyaXR0ZW4sIHRoZW4gemVybyB0aG9zZSBieXRlcyBpbiBvcmRlciB0byBhdm9pZCBtZW1vcnkgY2hlY2sgcmVwb3J0cyBvZlxuICAgKiB0aGUgdXNlIG9mIHVuaW5pdGlhbGl6ZWQgKG9yIHVuaW5pdGlhbGlzZWQgYXMgSnVsaWFuIHdyaXRlcykgYnl0ZXMgYnlcbiAgICogdGhlIGxvbmdlc3QgbWF0Y2ggcm91dGluZXMuICBVcGRhdGUgdGhlIGhpZ2ggd2F0ZXIgbWFyayBmb3IgdGhlIG5leHRcbiAgICogdGltZSB0aHJvdWdoIGhlcmUuICBXSU5fSU5JVCBpcyBzZXQgdG8gTUFYX01BVENIIHNpbmNlIHRoZSBsb25nZXN0IG1hdGNoXG4gICAqIHJvdXRpbmVzIGFsbG93IHNjYW5uaW5nIHRvIHN0cnN0YXJ0ICsgTUFYX01BVENILCBpZ25vcmluZyBsb29rYWhlYWQuXG4gICAqL1xuLy8gIGlmIChzLmhpZ2hfd2F0ZXIgPCBzLndpbmRvd19zaXplKSB7XG4vLyAgICB2YXIgY3VyciA9IHMuc3Ryc3RhcnQgKyBzLmxvb2thaGVhZDtcbi8vICAgIHZhciBpbml0ID0gMDtcbi8vXG4vLyAgICBpZiAocy5oaWdoX3dhdGVyIDwgY3Vycikge1xuLy8gICAgICAvKiBQcmV2aW91cyBoaWdoIHdhdGVyIG1hcmsgYmVsb3cgY3VycmVudCBkYXRhIC0tIHplcm8gV0lOX0lOSVRcbi8vICAgICAgICogYnl0ZXMgb3IgdXAgdG8gZW5kIG9mIHdpbmRvdywgd2hpY2hldmVyIGlzIGxlc3MuXG4vLyAgICAgICAqL1xuLy8gICAgICBpbml0ID0gcy53aW5kb3dfc2l6ZSAtIGN1cnI7XG4vLyAgICAgIGlmIChpbml0ID4gV0lOX0lOSVQpXG4vLyAgICAgICAgaW5pdCA9IFdJTl9JTklUO1xuLy8gICAgICB6bWVtemVybyhzLT53aW5kb3cgKyBjdXJyLCAodW5zaWduZWQpaW5pdCk7XG4vLyAgICAgIHMtPmhpZ2hfd2F0ZXIgPSBjdXJyICsgaW5pdDtcbi8vICAgIH1cbi8vICAgIGVsc2UgaWYgKHMtPmhpZ2hfd2F0ZXIgPCAodWxnKWN1cnIgKyBXSU5fSU5JVCkge1xuLy8gICAgICAvKiBIaWdoIHdhdGVyIG1hcmsgYXQgb3IgYWJvdmUgY3VycmVudCBkYXRhLCBidXQgYmVsb3cgY3VycmVudCBkYXRhXG4vLyAgICAgICAqIHBsdXMgV0lOX0lOSVQgLS0gemVybyBvdXQgdG8gY3VycmVudCBkYXRhIHBsdXMgV0lOX0lOSVQsIG9yIHVwXG4vLyAgICAgICAqIHRvIGVuZCBvZiB3aW5kb3csIHdoaWNoZXZlciBpcyBsZXNzLlxuLy8gICAgICAgKi9cbi8vICAgICAgaW5pdCA9ICh1bGcpY3VyciArIFdJTl9JTklUIC0gcy0+aGlnaF93YXRlcjtcbi8vICAgICAgaWYgKGluaXQgPiBzLT53aW5kb3dfc2l6ZSAtIHMtPmhpZ2hfd2F0ZXIpXG4vLyAgICAgICAgaW5pdCA9IHMtPndpbmRvd19zaXplIC0gcy0+aGlnaF93YXRlcjtcbi8vICAgICAgem1lbXplcm8ocy0+d2luZG93ICsgcy0+aGlnaF93YXRlciwgKHVuc2lnbmVkKWluaXQpO1xuLy8gICAgICBzLT5oaWdoX3dhdGVyICs9IGluaXQ7XG4vLyAgICB9XG4vLyAgfVxuLy9cbi8vICBBc3NlcnQoKHVsZylzLT5zdHJzdGFydCA8PSBzLT53aW5kb3dfc2l6ZSAtIE1JTl9MT09LQUhFQUQsXG4vLyAgICBcIm5vdCBlbm91Z2ggcm9vbSBmb3Igc2VhcmNoXCIpO1xufVxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvcHkgd2l0aG91dCBjb21wcmVzc2lvbiBhcyBtdWNoIGFzIHBvc3NpYmxlIGZyb20gdGhlIGlucHV0IHN0cmVhbSwgcmV0dXJuXG4gKiB0aGUgY3VycmVudCBibG9jayBzdGF0ZS5cbiAqIFRoaXMgZnVuY3Rpb24gZG9lcyBub3QgaW5zZXJ0IG5ldyBzdHJpbmdzIGluIHRoZSBkaWN0aW9uYXJ5IHNpbmNlXG4gKiB1bmNvbXByZXNzaWJsZSBkYXRhIGlzIHByb2JhYmx5IG5vdCB1c2VmdWwuIFRoaXMgZnVuY3Rpb24gaXMgdXNlZFxuICogb25seSBmb3IgdGhlIGxldmVsPTAgY29tcHJlc3Npb24gb3B0aW9uLlxuICogTk9URTogdGhpcyBmdW5jdGlvbiBzaG91bGQgYmUgb3B0aW1pemVkIHRvIGF2b2lkIGV4dHJhIGNvcHlpbmcgZnJvbVxuICogd2luZG93IHRvIHBlbmRpbmdfYnVmLlxuICovXG5mdW5jdGlvbiBkZWZsYXRlX3N0b3JlZChzLCBmbHVzaCkge1xuICAvKiBTdG9yZWQgYmxvY2tzIGFyZSBsaW1pdGVkIHRvIDB4ZmZmZiBieXRlcywgcGVuZGluZ19idWYgaXMgbGltaXRlZFxuICAgKiB0byBwZW5kaW5nX2J1Zl9zaXplLCBhbmQgZWFjaCBzdG9yZWQgYmxvY2sgaGFzIGEgNSBieXRlIGhlYWRlcjpcbiAgICovXG4gIHZhciBtYXhfYmxvY2tfc2l6ZSA9IDB4ZmZmZjtcblxuICBpZiAobWF4X2Jsb2NrX3NpemUgPiBzLnBlbmRpbmdfYnVmX3NpemUgLSA1KSB7XG4gICAgbWF4X2Jsb2NrX3NpemUgPSBzLnBlbmRpbmdfYnVmX3NpemUgLSA1O1xuICB9XG5cbiAgLyogQ29weSBhcyBtdWNoIGFzIHBvc3NpYmxlIGZyb20gaW5wdXQgdG8gb3V0cHV0OiAqL1xuICBmb3IgKDs7KSB7XG4gICAgLyogRmlsbCB0aGUgd2luZG93IGFzIG11Y2ggYXMgcG9zc2libGU6ICovXG4gICAgaWYgKHMubG9va2FoZWFkIDw9IDEpIHtcblxuICAgICAgLy9Bc3NlcnQocy0+c3Ryc3RhcnQgPCBzLT53X3NpemUrTUFYX0RJU1QocykgfHxcbiAgICAgIC8vICBzLT5ibG9ja19zdGFydCA+PSAobG9uZylzLT53X3NpemUsIFwic2xpZGUgdG9vIGxhdGVcIik7XG4vLyAgICAgIGlmICghKHMuc3Ryc3RhcnQgPCBzLndfc2l6ZSArIChzLndfc2l6ZSAtIE1JTl9MT09LQUhFQUQpIHx8XG4vLyAgICAgICAgcy5ibG9ja19zdGFydCA+PSBzLndfc2l6ZSkpIHtcbi8vICAgICAgICB0aHJvdyAgbmV3IEVycm9yKFwic2xpZGUgdG9vIGxhdGVcIik7XG4vLyAgICAgIH1cblxuICAgICAgZmlsbF93aW5kb3cocyk7XG4gICAgICBpZiAocy5sb29rYWhlYWQgPT09IDAgJiYgZmx1c2ggPT09IFpfTk9fRkxVU0gpIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cblxuICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgLyogZmx1c2ggdGhlIGN1cnJlbnQgYmxvY2sgKi9cbiAgICB9XG4gICAgLy9Bc3NlcnQocy0+YmxvY2tfc3RhcnQgPj0gMEwsIFwiYmxvY2sgZ29uZVwiKTtcbi8vICAgIGlmIChzLmJsb2NrX3N0YXJ0IDwgMCkgdGhyb3cgbmV3IEVycm9yKFwiYmxvY2sgZ29uZVwiKTtcblxuICAgIHMuc3Ryc3RhcnQgKz0gcy5sb29rYWhlYWQ7XG4gICAgcy5sb29rYWhlYWQgPSAwO1xuXG4gICAgLyogRW1pdCBhIHN0b3JlZCBibG9jayBpZiBwZW5kaW5nX2J1ZiB3aWxsIGJlIGZ1bGw6ICovXG4gICAgdmFyIG1heF9zdGFydCA9IHMuYmxvY2tfc3RhcnQgKyBtYXhfYmxvY2tfc2l6ZTtcblxuICAgIGlmIChzLnN0cnN0YXJ0ID09PSAwIHx8IHMuc3Ryc3RhcnQgPj0gbWF4X3N0YXJ0KSB7XG4gICAgICAvKiBzdHJzdGFydCA9PSAwIGlzIHBvc3NpYmxlIHdoZW4gd3JhcGFyb3VuZCBvbiAxNi1iaXQgbWFjaGluZSAqL1xuICAgICAgcy5sb29rYWhlYWQgPSBzLnN0cnN0YXJ0IC0gbWF4X3N0YXJ0O1xuICAgICAgcy5zdHJzdGFydCA9IG1heF9zdGFydDtcbiAgICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIC8qKiovXG5cblxuICAgIH1cbiAgICAvKiBGbHVzaCBpZiB3ZSBtYXkgaGF2ZSB0byBzbGlkZSwgb3RoZXJ3aXNlIGJsb2NrX3N0YXJ0IG1heSBiZWNvbWVcbiAgICAgKiBuZWdhdGl2ZSBhbmQgdGhlIGRhdGEgd2lsbCBiZSBnb25lOlxuICAgICAqL1xuICAgIGlmIChzLnN0cnN0YXJ0IC0gcy5ibG9ja19zdGFydCA+PSAocy53X3NpemUgLSBNSU5fTE9PS0FIRUFEKSkge1xuICAgICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgLyoqKi9cbiAgICB9XG4gIH1cblxuICBzLmluc2VydCA9IDA7XG5cbiAgaWYgKGZsdXNoID09PSBaX0ZJTklTSCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMSk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIHRydWUpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfRklOSVNIX1NUQVJURUQ7XG4gICAgfVxuICAgIC8qKiovXG4gICAgcmV0dXJuIEJTX0ZJTklTSF9ET05FO1xuICB9XG5cbiAgaWYgKHMuc3Ryc3RhcnQgPiBzLmJsb2NrX3N0YXJ0KSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgIH1cbiAgICAvKioqL1xuICB9XG5cbiAgcmV0dXJuIEJTX05FRURfTU9SRTtcbn1cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb21wcmVzcyBhcyBtdWNoIGFzIHBvc3NpYmxlIGZyb20gdGhlIGlucHV0IHN0cmVhbSwgcmV0dXJuIHRoZSBjdXJyZW50XG4gKiBibG9jayBzdGF0ZS5cbiAqIFRoaXMgZnVuY3Rpb24gZG9lcyBub3QgcGVyZm9ybSBsYXp5IGV2YWx1YXRpb24gb2YgbWF0Y2hlcyBhbmQgaW5zZXJ0c1xuICogbmV3IHN0cmluZ3MgaW4gdGhlIGRpY3Rpb25hcnkgb25seSBmb3IgdW5tYXRjaGVkIHN0cmluZ3Mgb3IgZm9yIHNob3J0XG4gKiBtYXRjaGVzLiBJdCBpcyB1c2VkIG9ubHkgZm9yIHRoZSBmYXN0IGNvbXByZXNzaW9uIG9wdGlvbnMuXG4gKi9cbmZ1bmN0aW9uIGRlZmxhdGVfZmFzdChzLCBmbHVzaCkge1xuICB2YXIgaGFzaF9oZWFkOyAgICAgICAgLyogaGVhZCBvZiB0aGUgaGFzaCBjaGFpbiAqL1xuICB2YXIgYmZsdXNoOyAgICAgICAgICAgLyogc2V0IGlmIGN1cnJlbnQgYmxvY2sgbXVzdCBiZSBmbHVzaGVkICovXG5cbiAgZm9yICg7Oykge1xuICAgIC8qIE1ha2Ugc3VyZSB0aGF0IHdlIGFsd2F5cyBoYXZlIGVub3VnaCBsb29rYWhlYWQsIGV4Y2VwdFxuICAgICAqIGF0IHRoZSBlbmQgb2YgdGhlIGlucHV0IGZpbGUuIFdlIG5lZWQgTUFYX01BVENIIGJ5dGVzXG4gICAgICogZm9yIHRoZSBuZXh0IG1hdGNoLCBwbHVzIE1JTl9NQVRDSCBieXRlcyB0byBpbnNlcnQgdGhlXG4gICAgICogc3RyaW5nIGZvbGxvd2luZyB0aGUgbmV4dCBtYXRjaC5cbiAgICAgKi9cbiAgICBpZiAocy5sb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEKSB7XG4gICAgICBmaWxsX3dpbmRvdyhzKTtcbiAgICAgIGlmIChzLmxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQgJiYgZmx1c2ggPT09IFpfTk9fRkxVU0gpIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkge1xuICAgICAgICBicmVhazsgLyogZmx1c2ggdGhlIGN1cnJlbnQgYmxvY2sgKi9cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKiBJbnNlcnQgdGhlIHN0cmluZyB3aW5kb3dbc3Ryc3RhcnQgLi4gc3Ryc3RhcnQrMl0gaW4gdGhlXG4gICAgICogZGljdGlvbmFyeSwgYW5kIHNldCBoYXNoX2hlYWQgdG8gdGhlIGhlYWQgb2YgdGhlIGhhc2ggY2hhaW46XG4gICAgICovXG4gICAgaGFzaF9oZWFkID0gMC8qTklMKi87XG4gICAgaWYgKHMubG9va2FoZWFkID49IE1JTl9NQVRDSCkge1xuICAgICAgLyoqKiBJTlNFUlRfU1RSSU5HKHMsIHMuc3Ryc3RhcnQsIGhhc2hfaGVhZCk7ICoqKi9cbiAgICAgIHMuaW5zX2ggPSAoKHMuaW5zX2ggPDwgcy5oYXNoX3NoaWZ0KSBeIHMud2luZG93W3Muc3Ryc3RhcnQgKyBNSU5fTUFUQ0ggLSAxXSkgJiBzLmhhc2hfbWFzaztcbiAgICAgIGhhc2hfaGVhZCA9IHMucHJldltzLnN0cnN0YXJ0ICYgcy53X21hc2tdID0gcy5oZWFkW3MuaW5zX2hdO1xuICAgICAgcy5oZWFkW3MuaW5zX2hdID0gcy5zdHJzdGFydDtcbiAgICAgIC8qKiovXG4gICAgfVxuXG4gICAgLyogRmluZCB0aGUgbG9uZ2VzdCBtYXRjaCwgZGlzY2FyZGluZyB0aG9zZSA8PSBwcmV2X2xlbmd0aC5cbiAgICAgKiBBdCB0aGlzIHBvaW50IHdlIGhhdmUgYWx3YXlzIG1hdGNoX2xlbmd0aCA8IE1JTl9NQVRDSFxuICAgICAqL1xuICAgIGlmIChoYXNoX2hlYWQgIT09IDAvKk5JTCovICYmICgocy5zdHJzdGFydCAtIGhhc2hfaGVhZCkgPD0gKHMud19zaXplIC0gTUlOX0xPT0tBSEVBRCkpKSB7XG4gICAgICAvKiBUbyBzaW1wbGlmeSB0aGUgY29kZSwgd2UgcHJldmVudCBtYXRjaGVzIHdpdGggdGhlIHN0cmluZ1xuICAgICAgICogb2Ygd2luZG93IGluZGV4IDAgKGluIHBhcnRpY3VsYXIgd2UgaGF2ZSB0byBhdm9pZCBhIG1hdGNoXG4gICAgICAgKiBvZiB0aGUgc3RyaW5nIHdpdGggaXRzZWxmIGF0IHRoZSBzdGFydCBvZiB0aGUgaW5wdXQgZmlsZSkuXG4gICAgICAgKi9cbiAgICAgIHMubWF0Y2hfbGVuZ3RoID0gbG9uZ2VzdF9tYXRjaChzLCBoYXNoX2hlYWQpO1xuICAgICAgLyogbG9uZ2VzdF9tYXRjaCgpIHNldHMgbWF0Y2hfc3RhcnQgKi9cbiAgICB9XG4gICAgaWYgKHMubWF0Y2hfbGVuZ3RoID49IE1JTl9NQVRDSCkge1xuICAgICAgLy8gY2hlY2tfbWF0Y2gocywgcy5zdHJzdGFydCwgcy5tYXRjaF9zdGFydCwgcy5tYXRjaF9sZW5ndGgpOyAvLyBmb3IgZGVidWcgb25seVxuXG4gICAgICAvKioqIF90cl90YWxseV9kaXN0KHMsIHMuc3Ryc3RhcnQgLSBzLm1hdGNoX3N0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgcy5tYXRjaF9sZW5ndGggLSBNSU5fTUFUQ0gsIGJmbHVzaCk7ICoqKi9cbiAgICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCBzLnN0cnN0YXJ0IC0gcy5tYXRjaF9zdGFydCwgcy5tYXRjaF9sZW5ndGggLSBNSU5fTUFUQ0gpO1xuXG4gICAgICBzLmxvb2thaGVhZCAtPSBzLm1hdGNoX2xlbmd0aDtcblxuICAgICAgLyogSW5zZXJ0IG5ldyBzdHJpbmdzIGluIHRoZSBoYXNoIHRhYmxlIG9ubHkgaWYgdGhlIG1hdGNoIGxlbmd0aFxuICAgICAgICogaXMgbm90IHRvbyBsYXJnZS4gVGhpcyBzYXZlcyB0aW1lIGJ1dCBkZWdyYWRlcyBjb21wcmVzc2lvbi5cbiAgICAgICAqL1xuICAgICAgaWYgKHMubWF0Y2hfbGVuZ3RoIDw9IHMubWF4X2xhenlfbWF0Y2gvKm1heF9pbnNlcnRfbGVuZ3RoKi8gJiYgcy5sb29rYWhlYWQgPj0gTUlOX01BVENIKSB7XG4gICAgICAgIHMubWF0Y2hfbGVuZ3RoLS07IC8qIHN0cmluZyBhdCBzdHJzdGFydCBhbHJlYWR5IGluIHRhYmxlICovXG4gICAgICAgIGRvIHtcbiAgICAgICAgICBzLnN0cnN0YXJ0Kys7XG4gICAgICAgICAgLyoqKiBJTlNFUlRfU1RSSU5HKHMsIHMuc3Ryc3RhcnQsIGhhc2hfaGVhZCk7ICoqKi9cbiAgICAgICAgICBzLmluc19oID0gKChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCkgXiBzLndpbmRvd1tzLnN0cnN0YXJ0ICsgTUlOX01BVENIIC0gMV0pICYgcy5oYXNoX21hc2s7XG4gICAgICAgICAgaGFzaF9oZWFkID0gcy5wcmV2W3Muc3Ryc3RhcnQgJiBzLndfbWFza10gPSBzLmhlYWRbcy5pbnNfaF07XG4gICAgICAgICAgcy5oZWFkW3MuaW5zX2hdID0gcy5zdHJzdGFydDtcbiAgICAgICAgICAvKioqL1xuICAgICAgICAgIC8qIHN0cnN0YXJ0IG5ldmVyIGV4Y2VlZHMgV1NJWkUtTUFYX01BVENILCBzbyB0aGVyZSBhcmVcbiAgICAgICAgICAgKiBhbHdheXMgTUlOX01BVENIIGJ5dGVzIGFoZWFkLlxuICAgICAgICAgICAqL1xuICAgICAgICB9IHdoaWxlICgtLXMubWF0Y2hfbGVuZ3RoICE9PSAwKTtcbiAgICAgICAgcy5zdHJzdGFydCsrO1xuICAgICAgfSBlbHNlXG4gICAgICB7XG4gICAgICAgIHMuc3Ryc3RhcnQgKz0gcy5tYXRjaF9sZW5ndGg7XG4gICAgICAgIHMubWF0Y2hfbGVuZ3RoID0gMDtcbiAgICAgICAgcy5pbnNfaCA9IHMud2luZG93W3Muc3Ryc3RhcnRdO1xuICAgICAgICAvKiBVUERBVEVfSEFTSChzLCBzLmluc19oLCBzLndpbmRvd1tzLnN0cnN0YXJ0KzFdKTsgKi9cbiAgICAgICAgcy5pbnNfaCA9ICgocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQpIF4gcy53aW5kb3dbcy5zdHJzdGFydCArIDFdKSAmIHMuaGFzaF9tYXNrO1xuXG4vLyNpZiBNSU5fTUFUQ0ggIT0gM1xuLy8gICAgICAgICAgICAgICAgQ2FsbCBVUERBVEVfSEFTSCgpIE1JTl9NQVRDSC0zIG1vcmUgdGltZXNcbi8vI2VuZGlmXG4gICAgICAgIC8qIElmIGxvb2thaGVhZCA8IE1JTl9NQVRDSCwgaW5zX2ggaXMgZ2FyYmFnZSwgYnV0IGl0IGRvZXMgbm90XG4gICAgICAgICAqIG1hdHRlciBzaW5jZSBpdCB3aWxsIGJlIHJlY29tcHV0ZWQgYXQgbmV4dCBkZWZsYXRlIGNhbGwuXG4gICAgICAgICAqL1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvKiBObyBtYXRjaCwgb3V0cHV0IGEgbGl0ZXJhbCBieXRlICovXG4gICAgICAvL1RyYWNldnYoKHN0ZGVycixcIiVjXCIsIHMud2luZG93W3Muc3Ryc3RhcnRdKSk7XG4gICAgICAvKioqIF90cl90YWxseV9saXQocywgcy53aW5kb3dbcy5zdHJzdGFydF0sIGJmbHVzaCk7ICoqKi9cbiAgICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCAwLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSk7XG5cbiAgICAgIHMubG9va2FoZWFkLS07XG4gICAgICBzLnN0cnN0YXJ0Kys7XG4gICAgfVxuICAgIGlmIChiZmx1c2gpIHtcbiAgICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIC8qKiovXG4gICAgfVxuICB9XG4gIHMuaW5zZXJ0ID0gKChzLnN0cnN0YXJ0IDwgKE1JTl9NQVRDSCAtIDEpKSA/IHMuc3Ryc3RhcnQgOiBNSU5fTUFUQ0ggLSAxKTtcbiAgaWYgKGZsdXNoID09PSBaX0ZJTklTSCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMSk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIHRydWUpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfRklOSVNIX1NUQVJURUQ7XG4gICAgfVxuICAgIC8qKiovXG4gICAgcmV0dXJuIEJTX0ZJTklTSF9ET05FO1xuICB9XG4gIGlmIChzLmxhc3RfbGl0KSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgIH1cbiAgICAvKioqL1xuICB9XG4gIHJldHVybiBCU19CTE9DS19ET05FO1xufVxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNhbWUgYXMgYWJvdmUsIGJ1dCBhY2hpZXZlcyBiZXR0ZXIgY29tcHJlc3Npb24uIFdlIHVzZSBhIGxhenlcbiAqIGV2YWx1YXRpb24gZm9yIG1hdGNoZXM6IGEgbWF0Y2ggaXMgZmluYWxseSBhZG9wdGVkIG9ubHkgaWYgdGhlcmUgaXNcbiAqIG5vIGJldHRlciBtYXRjaCBhdCB0aGUgbmV4dCB3aW5kb3cgcG9zaXRpb24uXG4gKi9cbmZ1bmN0aW9uIGRlZmxhdGVfc2xvdyhzLCBmbHVzaCkge1xuICB2YXIgaGFzaF9oZWFkOyAgICAgICAgICAvKiBoZWFkIG9mIGhhc2ggY2hhaW4gKi9cbiAgdmFyIGJmbHVzaDsgICAgICAgICAgICAgIC8qIHNldCBpZiBjdXJyZW50IGJsb2NrIG11c3QgYmUgZmx1c2hlZCAqL1xuXG4gIHZhciBtYXhfaW5zZXJ0O1xuXG4gIC8qIFByb2Nlc3MgdGhlIGlucHV0IGJsb2NrLiAqL1xuICBmb3IgKDs7KSB7XG4gICAgLyogTWFrZSBzdXJlIHRoYXQgd2UgYWx3YXlzIGhhdmUgZW5vdWdoIGxvb2thaGVhZCwgZXhjZXB0XG4gICAgICogYXQgdGhlIGVuZCBvZiB0aGUgaW5wdXQgZmlsZS4gV2UgbmVlZCBNQVhfTUFUQ0ggYnl0ZXNcbiAgICAgKiBmb3IgdGhlIG5leHQgbWF0Y2gsIHBsdXMgTUlOX01BVENIIGJ5dGVzIHRvIGluc2VydCB0aGVcbiAgICAgKiBzdHJpbmcgZm9sbG93aW5nIHRoZSBuZXh0IG1hdGNoLlxuICAgICAqL1xuICAgIGlmIChzLmxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQpIHtcbiAgICAgIGZpbGxfd2luZG93KHMpO1xuICAgICAgaWYgKHMubG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCAmJiBmbHVzaCA9PT0gWl9OT19GTFVTSCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7IGJyZWFrOyB9IC8qIGZsdXNoIHRoZSBjdXJyZW50IGJsb2NrICovXG4gICAgfVxuXG4gICAgLyogSW5zZXJ0IHRoZSBzdHJpbmcgd2luZG93W3N0cnN0YXJ0IC4uIHN0cnN0YXJ0KzJdIGluIHRoZVxuICAgICAqIGRpY3Rpb25hcnksIGFuZCBzZXQgaGFzaF9oZWFkIHRvIHRoZSBoZWFkIG9mIHRoZSBoYXNoIGNoYWluOlxuICAgICAqL1xuICAgIGhhc2hfaGVhZCA9IDAvKk5JTCovO1xuICAgIGlmIChzLmxvb2thaGVhZCA+PSBNSU5fTUFUQ0gpIHtcbiAgICAgIC8qKiogSU5TRVJUX1NUUklORyhzLCBzLnN0cnN0YXJ0LCBoYXNoX2hlYWQpOyAqKiovXG4gICAgICBzLmluc19oID0gKChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCkgXiBzLndpbmRvd1tzLnN0cnN0YXJ0ICsgTUlOX01BVENIIC0gMV0pICYgcy5oYXNoX21hc2s7XG4gICAgICBoYXNoX2hlYWQgPSBzLnByZXZbcy5zdHJzdGFydCAmIHMud19tYXNrXSA9IHMuaGVhZFtzLmluc19oXTtcbiAgICAgIHMuaGVhZFtzLmluc19oXSA9IHMuc3Ryc3RhcnQ7XG4gICAgICAvKioqL1xuICAgIH1cblxuICAgIC8qIEZpbmQgdGhlIGxvbmdlc3QgbWF0Y2gsIGRpc2NhcmRpbmcgdGhvc2UgPD0gcHJldl9sZW5ndGguXG4gICAgICovXG4gICAgcy5wcmV2X2xlbmd0aCA9IHMubWF0Y2hfbGVuZ3RoO1xuICAgIHMucHJldl9tYXRjaCA9IHMubWF0Y2hfc3RhcnQ7XG4gICAgcy5tYXRjaF9sZW5ndGggPSBNSU5fTUFUQ0ggLSAxO1xuXG4gICAgaWYgKGhhc2hfaGVhZCAhPT0gMC8qTklMKi8gJiYgcy5wcmV2X2xlbmd0aCA8IHMubWF4X2xhenlfbWF0Y2ggJiZcbiAgICAgICAgcy5zdHJzdGFydCAtIGhhc2hfaGVhZCA8PSAocy53X3NpemUgLSBNSU5fTE9PS0FIRUFEKS8qTUFYX0RJU1QocykqLykge1xuICAgICAgLyogVG8gc2ltcGxpZnkgdGhlIGNvZGUsIHdlIHByZXZlbnQgbWF0Y2hlcyB3aXRoIHRoZSBzdHJpbmdcbiAgICAgICAqIG9mIHdpbmRvdyBpbmRleCAwIChpbiBwYXJ0aWN1bGFyIHdlIGhhdmUgdG8gYXZvaWQgYSBtYXRjaFxuICAgICAgICogb2YgdGhlIHN0cmluZyB3aXRoIGl0c2VsZiBhdCB0aGUgc3RhcnQgb2YgdGhlIGlucHV0IGZpbGUpLlxuICAgICAgICovXG4gICAgICBzLm1hdGNoX2xlbmd0aCA9IGxvbmdlc3RfbWF0Y2gocywgaGFzaF9oZWFkKTtcbiAgICAgIC8qIGxvbmdlc3RfbWF0Y2goKSBzZXRzIG1hdGNoX3N0YXJ0ICovXG5cbiAgICAgIGlmIChzLm1hdGNoX2xlbmd0aCA8PSA1ICYmXG4gICAgICAgICAocy5zdHJhdGVneSA9PT0gWl9GSUxURVJFRCB8fCAocy5tYXRjaF9sZW5ndGggPT09IE1JTl9NQVRDSCAmJiBzLnN0cnN0YXJ0IC0gcy5tYXRjaF9zdGFydCA+IDQwOTYvKlRPT19GQVIqLykpKSB7XG5cbiAgICAgICAgLyogSWYgcHJldl9tYXRjaCBpcyBhbHNvIE1JTl9NQVRDSCwgbWF0Y2hfc3RhcnQgaXMgZ2FyYmFnZVxuICAgICAgICAgKiBidXQgd2Ugd2lsbCBpZ25vcmUgdGhlIGN1cnJlbnQgbWF0Y2ggYW55d2F5LlxuICAgICAgICAgKi9cbiAgICAgICAgcy5tYXRjaF9sZW5ndGggPSBNSU5fTUFUQ0ggLSAxO1xuICAgICAgfVxuICAgIH1cbiAgICAvKiBJZiB0aGVyZSB3YXMgYSBtYXRjaCBhdCB0aGUgcHJldmlvdXMgc3RlcCBhbmQgdGhlIGN1cnJlbnRcbiAgICAgKiBtYXRjaCBpcyBub3QgYmV0dGVyLCBvdXRwdXQgdGhlIHByZXZpb3VzIG1hdGNoOlxuICAgICAqL1xuICAgIGlmIChzLnByZXZfbGVuZ3RoID49IE1JTl9NQVRDSCAmJiBzLm1hdGNoX2xlbmd0aCA8PSBzLnByZXZfbGVuZ3RoKSB7XG4gICAgICBtYXhfaW5zZXJ0ID0gcy5zdHJzdGFydCArIHMubG9va2FoZWFkIC0gTUlOX01BVENIO1xuICAgICAgLyogRG8gbm90IGluc2VydCBzdHJpbmdzIGluIGhhc2ggdGFibGUgYmV5b25kIHRoaXMuICovXG5cbiAgICAgIC8vY2hlY2tfbWF0Y2gocywgcy5zdHJzdGFydC0xLCBzLnByZXZfbWF0Y2gsIHMucHJldl9sZW5ndGgpO1xuXG4gICAgICAvKioqX3RyX3RhbGx5X2Rpc3Qocywgcy5zdHJzdGFydCAtIDEgLSBzLnByZXZfbWF0Y2gsXG4gICAgICAgICAgICAgICAgICAgICBzLnByZXZfbGVuZ3RoIC0gTUlOX01BVENILCBiZmx1c2gpOyoqKi9cbiAgICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCBzLnN0cnN0YXJ0IC0gMSAtIHMucHJldl9tYXRjaCwgcy5wcmV2X2xlbmd0aCAtIE1JTl9NQVRDSCk7XG4gICAgICAvKiBJbnNlcnQgaW4gaGFzaCB0YWJsZSBhbGwgc3RyaW5ncyB1cCB0byB0aGUgZW5kIG9mIHRoZSBtYXRjaC5cbiAgICAgICAqIHN0cnN0YXJ0LTEgYW5kIHN0cnN0YXJ0IGFyZSBhbHJlYWR5IGluc2VydGVkLiBJZiB0aGVyZSBpcyBub3RcbiAgICAgICAqIGVub3VnaCBsb29rYWhlYWQsIHRoZSBsYXN0IHR3byBzdHJpbmdzIGFyZSBub3QgaW5zZXJ0ZWQgaW5cbiAgICAgICAqIHRoZSBoYXNoIHRhYmxlLlxuICAgICAgICovXG4gICAgICBzLmxvb2thaGVhZCAtPSBzLnByZXZfbGVuZ3RoIC0gMTtcbiAgICAgIHMucHJldl9sZW5ndGggLT0gMjtcbiAgICAgIGRvIHtcbiAgICAgICAgaWYgKCsrcy5zdHJzdGFydCA8PSBtYXhfaW5zZXJ0KSB7XG4gICAgICAgICAgLyoqKiBJTlNFUlRfU1RSSU5HKHMsIHMuc3Ryc3RhcnQsIGhhc2hfaGVhZCk7ICoqKi9cbiAgICAgICAgICBzLmluc19oID0gKChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCkgXiBzLndpbmRvd1tzLnN0cnN0YXJ0ICsgTUlOX01BVENIIC0gMV0pICYgcy5oYXNoX21hc2s7XG4gICAgICAgICAgaGFzaF9oZWFkID0gcy5wcmV2W3Muc3Ryc3RhcnQgJiBzLndfbWFza10gPSBzLmhlYWRbcy5pbnNfaF07XG4gICAgICAgICAgcy5oZWFkW3MuaW5zX2hdID0gcy5zdHJzdGFydDtcbiAgICAgICAgICAvKioqL1xuICAgICAgICB9XG4gICAgICB9IHdoaWxlICgtLXMucHJldl9sZW5ndGggIT09IDApO1xuICAgICAgcy5tYXRjaF9hdmFpbGFibGUgPSAwO1xuICAgICAgcy5tYXRjaF9sZW5ndGggPSBNSU5fTUFUQ0ggLSAxO1xuICAgICAgcy5zdHJzdGFydCsrO1xuXG4gICAgICBpZiAoYmZsdXNoKSB7XG4gICAgICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgICAgfVxuICAgICAgICAvKioqL1xuICAgICAgfVxuXG4gICAgfSBlbHNlIGlmIChzLm1hdGNoX2F2YWlsYWJsZSkge1xuICAgICAgLyogSWYgdGhlcmUgd2FzIG5vIG1hdGNoIGF0IHRoZSBwcmV2aW91cyBwb3NpdGlvbiwgb3V0cHV0IGFcbiAgICAgICAqIHNpbmdsZSBsaXRlcmFsLiBJZiB0aGVyZSB3YXMgYSBtYXRjaCBidXQgdGhlIGN1cnJlbnQgbWF0Y2hcbiAgICAgICAqIGlzIGxvbmdlciwgdHJ1bmNhdGUgdGhlIHByZXZpb3VzIG1hdGNoIHRvIGEgc2luZ2xlIGxpdGVyYWwuXG4gICAgICAgKi9cbiAgICAgIC8vVHJhY2V2digoc3RkZXJyLFwiJWNcIiwgcy0+d2luZG93W3MtPnN0cnN0YXJ0LTFdKSk7XG4gICAgICAvKioqIF90cl90YWxseV9saXQocywgcy53aW5kb3dbcy5zdHJzdGFydC0xXSwgYmZsdXNoKTsgKioqL1xuICAgICAgYmZsdXNoID0gdHJlZXMuX3RyX3RhbGx5KHMsIDAsIHMud2luZG93W3Muc3Ryc3RhcnQgLSAxXSk7XG5cbiAgICAgIGlmIChiZmx1c2gpIHtcbiAgICAgICAgLyoqKiBGTFVTSF9CTE9DS19PTkxZKHMsIDApICoqKi9cbiAgICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgICAgIC8qKiovXG4gICAgICB9XG4gICAgICBzLnN0cnN0YXJ0Kys7XG4gICAgICBzLmxvb2thaGVhZC0tO1xuICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLyogVGhlcmUgaXMgbm8gcHJldmlvdXMgbWF0Y2ggdG8gY29tcGFyZSB3aXRoLCB3YWl0IGZvclxuICAgICAgICogdGhlIG5leHQgc3RlcCB0byBkZWNpZGUuXG4gICAgICAgKi9cbiAgICAgIHMubWF0Y2hfYXZhaWxhYmxlID0gMTtcbiAgICAgIHMuc3Ryc3RhcnQrKztcbiAgICAgIHMubG9va2FoZWFkLS07XG4gICAgfVxuICB9XG4gIC8vQXNzZXJ0IChmbHVzaCAhPSBaX05PX0ZMVVNILCBcIm5vIGZsdXNoP1wiKTtcbiAgaWYgKHMubWF0Y2hfYXZhaWxhYmxlKSB7XG4gICAgLy9UcmFjZXZ2KChzdGRlcnIsXCIlY1wiLCBzLT53aW5kb3dbcy0+c3Ryc3RhcnQtMV0pKTtcbiAgICAvKioqIF90cl90YWxseV9saXQocywgcy53aW5kb3dbcy5zdHJzdGFydC0xXSwgYmZsdXNoKTsgKioqL1xuICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCAwLCBzLndpbmRvd1tzLnN0cnN0YXJ0IC0gMV0pO1xuXG4gICAgcy5tYXRjaF9hdmFpbGFibGUgPSAwO1xuICB9XG4gIHMuaW5zZXJ0ID0gcy5zdHJzdGFydCA8IE1JTl9NQVRDSCAtIDEgPyBzLnN0cnN0YXJ0IDogTUlOX01BVENIIC0gMTtcbiAgaWYgKGZsdXNoID09PSBaX0ZJTklTSCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMSk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIHRydWUpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfRklOSVNIX1NUQVJURUQ7XG4gICAgfVxuICAgIC8qKiovXG4gICAgcmV0dXJuIEJTX0ZJTklTSF9ET05FO1xuICB9XG4gIGlmIChzLmxhc3RfbGl0KSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgIH1cbiAgICAvKioqL1xuICB9XG5cbiAgcmV0dXJuIEJTX0JMT0NLX0RPTkU7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBGb3IgWl9STEUsIHNpbXBseSBsb29rIGZvciBydW5zIG9mIGJ5dGVzLCBnZW5lcmF0ZSBtYXRjaGVzIG9ubHkgb2YgZGlzdGFuY2VcbiAqIG9uZS4gIERvIG5vdCBtYWludGFpbiBhIGhhc2ggdGFibGUuICAoSXQgd2lsbCBiZSByZWdlbmVyYXRlZCBpZiB0aGlzIHJ1biBvZlxuICogZGVmbGF0ZSBzd2l0Y2hlcyBhd2F5IGZyb20gWl9STEUuKVxuICovXG5mdW5jdGlvbiBkZWZsYXRlX3JsZShzLCBmbHVzaCkge1xuICB2YXIgYmZsdXNoOyAgICAgICAgICAgIC8qIHNldCBpZiBjdXJyZW50IGJsb2NrIG11c3QgYmUgZmx1c2hlZCAqL1xuICB2YXIgcHJldjsgICAgICAgICAgICAgIC8qIGJ5dGUgYXQgZGlzdGFuY2Ugb25lIHRvIG1hdGNoICovXG4gIHZhciBzY2FuLCBzdHJlbmQ7ICAgICAgLyogc2NhbiBnb2VzIHVwIHRvIHN0cmVuZCBmb3IgbGVuZ3RoIG9mIHJ1biAqL1xuXG4gIHZhciBfd2luID0gcy53aW5kb3c7XG5cbiAgZm9yICg7Oykge1xuICAgIC8qIE1ha2Ugc3VyZSB0aGF0IHdlIGFsd2F5cyBoYXZlIGVub3VnaCBsb29rYWhlYWQsIGV4Y2VwdFxuICAgICAqIGF0IHRoZSBlbmQgb2YgdGhlIGlucHV0IGZpbGUuIFdlIG5lZWQgTUFYX01BVENIIGJ5dGVzXG4gICAgICogZm9yIHRoZSBsb25nZXN0IHJ1biwgcGx1cyBvbmUgZm9yIHRoZSB1bnJvbGxlZCBsb29wLlxuICAgICAqL1xuICAgIGlmIChzLmxvb2thaGVhZCA8PSBNQVhfTUFUQ0gpIHtcbiAgICAgIGZpbGxfd2luZG93KHMpO1xuICAgICAgaWYgKHMubG9va2FoZWFkIDw9IE1BWF9NQVRDSCAmJiBmbHVzaCA9PT0gWl9OT19GTFVTSCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7IGJyZWFrOyB9IC8qIGZsdXNoIHRoZSBjdXJyZW50IGJsb2NrICovXG4gICAgfVxuXG4gICAgLyogU2VlIGhvdyBtYW55IHRpbWVzIHRoZSBwcmV2aW91cyBieXRlIHJlcGVhdHMgKi9cbiAgICBzLm1hdGNoX2xlbmd0aCA9IDA7XG4gICAgaWYgKHMubG9va2FoZWFkID49IE1JTl9NQVRDSCAmJiBzLnN0cnN0YXJ0ID4gMCkge1xuICAgICAgc2NhbiA9IHMuc3Ryc3RhcnQgLSAxO1xuICAgICAgcHJldiA9IF93aW5bc2Nhbl07XG4gICAgICBpZiAocHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0pIHtcbiAgICAgICAgc3RyZW5kID0gcy5zdHJzdGFydCArIE1BWF9NQVRDSDtcbiAgICAgICAgZG8ge1xuICAgICAgICAgIC8qanNoaW50IG5vZW1wdHk6ZmFsc2UqL1xuICAgICAgICB9IHdoaWxlIChwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmXG4gICAgICAgICAgICAgICAgIHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiZcbiAgICAgICAgICAgICAgICAgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSAmJlxuICAgICAgICAgICAgICAgICBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmXG4gICAgICAgICAgICAgICAgIHNjYW4gPCBzdHJlbmQpO1xuICAgICAgICBzLm1hdGNoX2xlbmd0aCA9IE1BWF9NQVRDSCAtIChzdHJlbmQgLSBzY2FuKTtcbiAgICAgICAgaWYgKHMubWF0Y2hfbGVuZ3RoID4gcy5sb29rYWhlYWQpIHtcbiAgICAgICAgICBzLm1hdGNoX2xlbmd0aCA9IHMubG9va2FoZWFkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvL0Fzc2VydChzY2FuIDw9IHMtPndpbmRvdysodUludCkocy0+d2luZG93X3NpemUtMSksIFwid2lsZCBzY2FuXCIpO1xuICAgIH1cblxuICAgIC8qIEVtaXQgbWF0Y2ggaWYgaGF2ZSBydW4gb2YgTUlOX01BVENIIG9yIGxvbmdlciwgZWxzZSBlbWl0IGxpdGVyYWwgKi9cbiAgICBpZiAocy5tYXRjaF9sZW5ndGggPj0gTUlOX01BVENIKSB7XG4gICAgICAvL2NoZWNrX21hdGNoKHMsIHMuc3Ryc3RhcnQsIHMuc3Ryc3RhcnQgLSAxLCBzLm1hdGNoX2xlbmd0aCk7XG5cbiAgICAgIC8qKiogX3RyX3RhbGx5X2Rpc3QocywgMSwgcy5tYXRjaF9sZW5ndGggLSBNSU5fTUFUQ0gsIGJmbHVzaCk7ICoqKi9cbiAgICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCAxLCBzLm1hdGNoX2xlbmd0aCAtIE1JTl9NQVRDSCk7XG5cbiAgICAgIHMubG9va2FoZWFkIC09IHMubWF0Y2hfbGVuZ3RoO1xuICAgICAgcy5zdHJzdGFydCArPSBzLm1hdGNoX2xlbmd0aDtcbiAgICAgIHMubWF0Y2hfbGVuZ3RoID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgLyogTm8gbWF0Y2gsIG91dHB1dCBhIGxpdGVyYWwgYnl0ZSAqL1xuICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsXCIlY1wiLCBzLT53aW5kb3dbcy0+c3Ryc3RhcnRdKSk7XG4gICAgICAvKioqIF90cl90YWxseV9saXQocywgcy53aW5kb3dbcy5zdHJzdGFydF0sIGJmbHVzaCk7ICoqKi9cbiAgICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCAwLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSk7XG5cbiAgICAgIHMubG9va2FoZWFkLS07XG4gICAgICBzLnN0cnN0YXJ0Kys7XG4gICAgfVxuICAgIGlmIChiZmx1c2gpIHtcbiAgICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIC8qKiovXG4gICAgfVxuICB9XG4gIHMuaW5zZXJ0ID0gMDtcbiAgaWYgKGZsdXNoID09PSBaX0ZJTklTSCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMSk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIHRydWUpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfRklOSVNIX1NUQVJURUQ7XG4gICAgfVxuICAgIC8qKiovXG4gICAgcmV0dXJuIEJTX0ZJTklTSF9ET05FO1xuICB9XG4gIGlmIChzLmxhc3RfbGl0KSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgIH1cbiAgICAvKioqL1xuICB9XG4gIHJldHVybiBCU19CTE9DS19ET05FO1xufVxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEZvciBaX0hVRkZNQU5fT05MWSwgZG8gbm90IGxvb2sgZm9yIG1hdGNoZXMuICBEbyBub3QgbWFpbnRhaW4gYSBoYXNoIHRhYmxlLlxuICogKEl0IHdpbGwgYmUgcmVnZW5lcmF0ZWQgaWYgdGhpcyBydW4gb2YgZGVmbGF0ZSBzd2l0Y2hlcyBhd2F5IGZyb20gSHVmZm1hbi4pXG4gKi9cbmZ1bmN0aW9uIGRlZmxhdGVfaHVmZihzLCBmbHVzaCkge1xuICB2YXIgYmZsdXNoOyAgICAgICAgICAgICAvKiBzZXQgaWYgY3VycmVudCBibG9jayBtdXN0IGJlIGZsdXNoZWQgKi9cblxuICBmb3IgKDs7KSB7XG4gICAgLyogTWFrZSBzdXJlIHRoYXQgd2UgaGF2ZSBhIGxpdGVyYWwgdG8gd3JpdGUuICovXG4gICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7XG4gICAgICBmaWxsX3dpbmRvdyhzKTtcbiAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkge1xuICAgICAgICBpZiAoZmx1c2ggPT09IFpfTk9fRkxVU0gpIHtcbiAgICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrOyAgICAgIC8qIGZsdXNoIHRoZSBjdXJyZW50IGJsb2NrICovXG4gICAgICB9XG4gICAgfVxuXG4gICAgLyogT3V0cHV0IGEgbGl0ZXJhbCBieXRlICovXG4gICAgcy5tYXRjaF9sZW5ndGggPSAwO1xuICAgIC8vVHJhY2V2digoc3RkZXJyLFwiJWNcIiwgcy0+d2luZG93W3MtPnN0cnN0YXJ0XSkpO1xuICAgIC8qKiogX3RyX3RhbGx5X2xpdChzLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSwgYmZsdXNoKTsgKioqL1xuICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCAwLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSk7XG4gICAgcy5sb29rYWhlYWQtLTtcbiAgICBzLnN0cnN0YXJ0Kys7XG4gICAgaWYgKGJmbHVzaCkge1xuICAgICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgLyoqKi9cbiAgICB9XG4gIH1cbiAgcy5pbnNlcnQgPSAwO1xuICBpZiAoZmx1c2ggPT09IFpfRklOSVNIKSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAxKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgdHJ1ZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19GSU5JU0hfU1RBUlRFRDtcbiAgICB9XG4gICAgLyoqKi9cbiAgICByZXR1cm4gQlNfRklOSVNIX0RPTkU7XG4gIH1cbiAgaWYgKHMubGFzdF9saXQpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgfVxuICAgIC8qKiovXG4gIH1cbiAgcmV0dXJuIEJTX0JMT0NLX0RPTkU7XG59XG5cbi8qIFZhbHVlcyBmb3IgbWF4X2xhenlfbWF0Y2gsIGdvb2RfbWF0Y2ggYW5kIG1heF9jaGFpbl9sZW5ndGgsIGRlcGVuZGluZyBvblxuICogdGhlIGRlc2lyZWQgcGFjayBsZXZlbCAoMC4uOSkuIFRoZSB2YWx1ZXMgZ2l2ZW4gYmVsb3cgaGF2ZSBiZWVuIHR1bmVkIHRvXG4gKiBleGNsdWRlIHdvcnN0IGNhc2UgcGVyZm9ybWFuY2UgZm9yIHBhdGhvbG9naWNhbCBmaWxlcy4gQmV0dGVyIHZhbHVlcyBtYXkgYmVcbiAqIGZvdW5kIGZvciBzcGVjaWZpYyBmaWxlcy5cbiAqL1xuZnVuY3Rpb24gQ29uZmlnKGdvb2RfbGVuZ3RoLCBtYXhfbGF6eSwgbmljZV9sZW5ndGgsIG1heF9jaGFpbiwgZnVuYykge1xuICB0aGlzLmdvb2RfbGVuZ3RoID0gZ29vZF9sZW5ndGg7XG4gIHRoaXMubWF4X2xhenkgPSBtYXhfbGF6eTtcbiAgdGhpcy5uaWNlX2xlbmd0aCA9IG5pY2VfbGVuZ3RoO1xuICB0aGlzLm1heF9jaGFpbiA9IG1heF9jaGFpbjtcbiAgdGhpcy5mdW5jID0gZnVuYztcbn1cblxudmFyIGNvbmZpZ3VyYXRpb25fdGFibGU7XG5cbmNvbmZpZ3VyYXRpb25fdGFibGUgPSBbXG4gIC8qICAgICAgZ29vZCBsYXp5IG5pY2UgY2hhaW4gKi9cbiAgbmV3IENvbmZpZygwLCAwLCAwLCAwLCBkZWZsYXRlX3N0b3JlZCksICAgICAgICAgIC8qIDAgc3RvcmUgb25seSAqL1xuICBuZXcgQ29uZmlnKDQsIDQsIDgsIDQsIGRlZmxhdGVfZmFzdCksICAgICAgICAgICAgLyogMSBtYXggc3BlZWQsIG5vIGxhenkgbWF0Y2hlcyAqL1xuICBuZXcgQ29uZmlnKDQsIDUsIDE2LCA4LCBkZWZsYXRlX2Zhc3QpLCAgICAgICAgICAgLyogMiAqL1xuICBuZXcgQ29uZmlnKDQsIDYsIDMyLCAzMiwgZGVmbGF0ZV9mYXN0KSwgICAgICAgICAgLyogMyAqL1xuXG4gIG5ldyBDb25maWcoNCwgNCwgMTYsIDE2LCBkZWZsYXRlX3Nsb3cpLCAgICAgICAgICAvKiA0IGxhenkgbWF0Y2hlcyAqL1xuICBuZXcgQ29uZmlnKDgsIDE2LCAzMiwgMzIsIGRlZmxhdGVfc2xvdyksICAgICAgICAgLyogNSAqL1xuICBuZXcgQ29uZmlnKDgsIDE2LCAxMjgsIDEyOCwgZGVmbGF0ZV9zbG93KSwgICAgICAgLyogNiAqL1xuICBuZXcgQ29uZmlnKDgsIDMyLCAxMjgsIDI1NiwgZGVmbGF0ZV9zbG93KSwgICAgICAgLyogNyAqL1xuICBuZXcgQ29uZmlnKDMyLCAxMjgsIDI1OCwgMTAyNCwgZGVmbGF0ZV9zbG93KSwgICAgLyogOCAqL1xuICBuZXcgQ29uZmlnKDMyLCAyNTgsIDI1OCwgNDA5NiwgZGVmbGF0ZV9zbG93KSAgICAgLyogOSBtYXggY29tcHJlc3Npb24gKi9cbl07XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBJbml0aWFsaXplIHRoZSBcImxvbmdlc3QgbWF0Y2hcIiByb3V0aW5lcyBmb3IgYSBuZXcgemxpYiBzdHJlYW1cbiAqL1xuZnVuY3Rpb24gbG1faW5pdChzKSB7XG4gIHMud2luZG93X3NpemUgPSAyICogcy53X3NpemU7XG5cbiAgLyoqKiBDTEVBUl9IQVNIKHMpOyAqKiovXG4gIHplcm8ocy5oZWFkKTsgLy8gRmlsbCB3aXRoIE5JTCAoPSAwKTtcblxuICAvKiBTZXQgdGhlIGRlZmF1bHQgY29uZmlndXJhdGlvbiBwYXJhbWV0ZXJzOlxuICAgKi9cbiAgcy5tYXhfbGF6eV9tYXRjaCA9IGNvbmZpZ3VyYXRpb25fdGFibGVbcy5sZXZlbF0ubWF4X2xhenk7XG4gIHMuZ29vZF9tYXRjaCA9IGNvbmZpZ3VyYXRpb25fdGFibGVbcy5sZXZlbF0uZ29vZF9sZW5ndGg7XG4gIHMubmljZV9tYXRjaCA9IGNvbmZpZ3VyYXRpb25fdGFibGVbcy5sZXZlbF0ubmljZV9sZW5ndGg7XG4gIHMubWF4X2NoYWluX2xlbmd0aCA9IGNvbmZpZ3VyYXRpb25fdGFibGVbcy5sZXZlbF0ubWF4X2NoYWluO1xuXG4gIHMuc3Ryc3RhcnQgPSAwO1xuICBzLmJsb2NrX3N0YXJ0ID0gMDtcbiAgcy5sb29rYWhlYWQgPSAwO1xuICBzLmluc2VydCA9IDA7XG4gIHMubWF0Y2hfbGVuZ3RoID0gcy5wcmV2X2xlbmd0aCA9IE1JTl9NQVRDSCAtIDE7XG4gIHMubWF0Y2hfYXZhaWxhYmxlID0gMDtcbiAgcy5pbnNfaCA9IDA7XG59XG5cblxuZnVuY3Rpb24gRGVmbGF0ZVN0YXRlKCkge1xuICB0aGlzLnN0cm0gPSBudWxsOyAgICAgICAgICAgIC8qIHBvaW50ZXIgYmFjayB0byB0aGlzIHpsaWIgc3RyZWFtICovXG4gIHRoaXMuc3RhdHVzID0gMDsgICAgICAgICAgICAvKiBhcyB0aGUgbmFtZSBpbXBsaWVzICovXG4gIHRoaXMucGVuZGluZ19idWYgPSBudWxsOyAgICAgIC8qIG91dHB1dCBzdGlsbCBwZW5kaW5nICovXG4gIHRoaXMucGVuZGluZ19idWZfc2l6ZSA9IDA7ICAvKiBzaXplIG9mIHBlbmRpbmdfYnVmICovXG4gIHRoaXMucGVuZGluZ19vdXQgPSAwOyAgICAgICAvKiBuZXh0IHBlbmRpbmcgYnl0ZSB0byBvdXRwdXQgdG8gdGhlIHN0cmVhbSAqL1xuICB0aGlzLnBlbmRpbmcgPSAwOyAgICAgICAgICAgLyogbmIgb2YgYnl0ZXMgaW4gdGhlIHBlbmRpbmcgYnVmZmVyICovXG4gIHRoaXMud3JhcCA9IDA7ICAgICAgICAgICAgICAvKiBiaXQgMCB0cnVlIGZvciB6bGliLCBiaXQgMSB0cnVlIGZvciBnemlwICovXG4gIHRoaXMuZ3poZWFkID0gbnVsbDsgICAgICAgICAvKiBnemlwIGhlYWRlciBpbmZvcm1hdGlvbiB0byB3cml0ZSAqL1xuICB0aGlzLmd6aW5kZXggPSAwOyAgICAgICAgICAgLyogd2hlcmUgaW4gZXh0cmEsIG5hbWUsIG9yIGNvbW1lbnQgKi9cbiAgdGhpcy5tZXRob2QgPSBaX0RFRkxBVEVEOyAvKiBjYW4gb25seSBiZSBERUZMQVRFRCAqL1xuICB0aGlzLmxhc3RfZmx1c2ggPSAtMTsgICAvKiB2YWx1ZSBvZiBmbHVzaCBwYXJhbSBmb3IgcHJldmlvdXMgZGVmbGF0ZSBjYWxsICovXG5cbiAgdGhpcy53X3NpemUgPSAwOyAgLyogTFo3NyB3aW5kb3cgc2l6ZSAoMzJLIGJ5IGRlZmF1bHQpICovXG4gIHRoaXMud19iaXRzID0gMDsgIC8qIGxvZzIod19zaXplKSAgKDguLjE2KSAqL1xuICB0aGlzLndfbWFzayA9IDA7ICAvKiB3X3NpemUgLSAxICovXG5cbiAgdGhpcy53aW5kb3cgPSBudWxsO1xuICAvKiBTbGlkaW5nIHdpbmRvdy4gSW5wdXQgYnl0ZXMgYXJlIHJlYWQgaW50byB0aGUgc2Vjb25kIGhhbGYgb2YgdGhlIHdpbmRvdyxcbiAgICogYW5kIG1vdmUgdG8gdGhlIGZpcnN0IGhhbGYgbGF0ZXIgdG8ga2VlcCBhIGRpY3Rpb25hcnkgb2YgYXQgbGVhc3Qgd1NpemVcbiAgICogYnl0ZXMuIFdpdGggdGhpcyBvcmdhbml6YXRpb24sIG1hdGNoZXMgYXJlIGxpbWl0ZWQgdG8gYSBkaXN0YW5jZSBvZlxuICAgKiB3U2l6ZS1NQVhfTUFUQ0ggYnl0ZXMsIGJ1dCB0aGlzIGVuc3VyZXMgdGhhdCBJTyBpcyBhbHdheXNcbiAgICogcGVyZm9ybWVkIHdpdGggYSBsZW5ndGggbXVsdGlwbGUgb2YgdGhlIGJsb2NrIHNpemUuXG4gICAqL1xuXG4gIHRoaXMud2luZG93X3NpemUgPSAwO1xuICAvKiBBY3R1YWwgc2l6ZSBvZiB3aW5kb3c6IDIqd1NpemUsIGV4Y2VwdCB3aGVuIHRoZSB1c2VyIGlucHV0IGJ1ZmZlclxuICAgKiBpcyBkaXJlY3RseSB1c2VkIGFzIHNsaWRpbmcgd2luZG93LlxuICAgKi9cblxuICB0aGlzLnByZXYgPSBudWxsO1xuICAvKiBMaW5rIHRvIG9sZGVyIHN0cmluZyB3aXRoIHNhbWUgaGFzaCBpbmRleC4gVG8gbGltaXQgdGhlIHNpemUgb2YgdGhpc1xuICAgKiBhcnJheSB0byA2NEssIHRoaXMgbGluayBpcyBtYWludGFpbmVkIG9ubHkgZm9yIHRoZSBsYXN0IDMySyBzdHJpbmdzLlxuICAgKiBBbiBpbmRleCBpbiB0aGlzIGFycmF5IGlzIHRodXMgYSB3aW5kb3cgaW5kZXggbW9kdWxvIDMySy5cbiAgICovXG5cbiAgdGhpcy5oZWFkID0gbnVsbDsgICAvKiBIZWFkcyBvZiB0aGUgaGFzaCBjaGFpbnMgb3IgTklMLiAqL1xuXG4gIHRoaXMuaW5zX2ggPSAwOyAgICAgICAvKiBoYXNoIGluZGV4IG9mIHN0cmluZyB0byBiZSBpbnNlcnRlZCAqL1xuICB0aGlzLmhhc2hfc2l6ZSA9IDA7ICAgLyogbnVtYmVyIG9mIGVsZW1lbnRzIGluIGhhc2ggdGFibGUgKi9cbiAgdGhpcy5oYXNoX2JpdHMgPSAwOyAgIC8qIGxvZzIoaGFzaF9zaXplKSAqL1xuICB0aGlzLmhhc2hfbWFzayA9IDA7ICAgLyogaGFzaF9zaXplLTEgKi9cblxuICB0aGlzLmhhc2hfc2hpZnQgPSAwO1xuICAvKiBOdW1iZXIgb2YgYml0cyBieSB3aGljaCBpbnNfaCBtdXN0IGJlIHNoaWZ0ZWQgYXQgZWFjaCBpbnB1dFxuICAgKiBzdGVwLiBJdCBtdXN0IGJlIHN1Y2ggdGhhdCBhZnRlciBNSU5fTUFUQ0ggc3RlcHMsIHRoZSBvbGRlc3RcbiAgICogYnl0ZSBubyBsb25nZXIgdGFrZXMgcGFydCBpbiB0aGUgaGFzaCBrZXksIHRoYXQgaXM6XG4gICAqICAgaGFzaF9zaGlmdCAqIE1JTl9NQVRDSCA+PSBoYXNoX2JpdHNcbiAgICovXG5cbiAgdGhpcy5ibG9ja19zdGFydCA9IDA7XG4gIC8qIFdpbmRvdyBwb3NpdGlvbiBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBjdXJyZW50IG91dHB1dCBibG9jay4gR2V0c1xuICAgKiBuZWdhdGl2ZSB3aGVuIHRoZSB3aW5kb3cgaXMgbW92ZWQgYmFja3dhcmRzLlxuICAgKi9cblxuICB0aGlzLm1hdGNoX2xlbmd0aCA9IDA7ICAgICAgLyogbGVuZ3RoIG9mIGJlc3QgbWF0Y2ggKi9cbiAgdGhpcy5wcmV2X21hdGNoID0gMDsgICAgICAgIC8qIHByZXZpb3VzIG1hdGNoICovXG4gIHRoaXMubWF0Y2hfYXZhaWxhYmxlID0gMDsgICAvKiBzZXQgaWYgcHJldmlvdXMgbWF0Y2ggZXhpc3RzICovXG4gIHRoaXMuc3Ryc3RhcnQgPSAwOyAgICAgICAgICAvKiBzdGFydCBvZiBzdHJpbmcgdG8gaW5zZXJ0ICovXG4gIHRoaXMubWF0Y2hfc3RhcnQgPSAwOyAgICAgICAvKiBzdGFydCBvZiBtYXRjaGluZyBzdHJpbmcgKi9cbiAgdGhpcy5sb29rYWhlYWQgPSAwOyAgICAgICAgIC8qIG51bWJlciBvZiB2YWxpZCBieXRlcyBhaGVhZCBpbiB3aW5kb3cgKi9cblxuICB0aGlzLnByZXZfbGVuZ3RoID0gMDtcbiAgLyogTGVuZ3RoIG9mIHRoZSBiZXN0IG1hdGNoIGF0IHByZXZpb3VzIHN0ZXAuIE1hdGNoZXMgbm90IGdyZWF0ZXIgdGhhbiB0aGlzXG4gICAqIGFyZSBkaXNjYXJkZWQuIFRoaXMgaXMgdXNlZCBpbiB0aGUgbGF6eSBtYXRjaCBldmFsdWF0aW9uLlxuICAgKi9cblxuICB0aGlzLm1heF9jaGFpbl9sZW5ndGggPSAwO1xuICAvKiBUbyBzcGVlZCB1cCBkZWZsYXRpb24sIGhhc2ggY2hhaW5zIGFyZSBuZXZlciBzZWFyY2hlZCBiZXlvbmQgdGhpc1xuICAgKiBsZW5ndGguICBBIGhpZ2hlciBsaW1pdCBpbXByb3ZlcyBjb21wcmVzc2lvbiByYXRpbyBidXQgZGVncmFkZXMgdGhlXG4gICAqIHNwZWVkLlxuICAgKi9cblxuICB0aGlzLm1heF9sYXp5X21hdGNoID0gMDtcbiAgLyogQXR0ZW1wdCB0byBmaW5kIGEgYmV0dGVyIG1hdGNoIG9ubHkgd2hlbiB0aGUgY3VycmVudCBtYXRjaCBpcyBzdHJpY3RseVxuICAgKiBzbWFsbGVyIHRoYW4gdGhpcyB2YWx1ZS4gVGhpcyBtZWNoYW5pc20gaXMgdXNlZCBvbmx5IGZvciBjb21wcmVzc2lvblxuICAgKiBsZXZlbHMgPj0gNC5cbiAgICovXG4gIC8vIFRoYXQncyBhbGlhcyB0byBtYXhfbGF6eV9tYXRjaCwgZG9uJ3QgdXNlIGRpcmVjdGx5XG4gIC8vdGhpcy5tYXhfaW5zZXJ0X2xlbmd0aCA9IDA7XG4gIC8qIEluc2VydCBuZXcgc3RyaW5ncyBpbiB0aGUgaGFzaCB0YWJsZSBvbmx5IGlmIHRoZSBtYXRjaCBsZW5ndGggaXMgbm90XG4gICAqIGdyZWF0ZXIgdGhhbiB0aGlzIGxlbmd0aC4gVGhpcyBzYXZlcyB0aW1lIGJ1dCBkZWdyYWRlcyBjb21wcmVzc2lvbi5cbiAgICogbWF4X2luc2VydF9sZW5ndGggaXMgdXNlZCBvbmx5IGZvciBjb21wcmVzc2lvbiBsZXZlbHMgPD0gMy5cbiAgICovXG5cbiAgdGhpcy5sZXZlbCA9IDA7ICAgICAvKiBjb21wcmVzc2lvbiBsZXZlbCAoMS4uOSkgKi9cbiAgdGhpcy5zdHJhdGVneSA9IDA7ICAvKiBmYXZvciBvciBmb3JjZSBIdWZmbWFuIGNvZGluZyovXG5cbiAgdGhpcy5nb29kX21hdGNoID0gMDtcbiAgLyogVXNlIGEgZmFzdGVyIHNlYXJjaCB3aGVuIHRoZSBwcmV2aW91cyBtYXRjaCBpcyBsb25nZXIgdGhhbiB0aGlzICovXG5cbiAgdGhpcy5uaWNlX21hdGNoID0gMDsgLyogU3RvcCBzZWFyY2hpbmcgd2hlbiBjdXJyZW50IG1hdGNoIGV4Y2VlZHMgdGhpcyAqL1xuXG4gICAgICAgICAgICAgIC8qIHVzZWQgYnkgdHJlZXMuYzogKi9cblxuICAvKiBEaWRuJ3QgdXNlIGN0X2RhdGEgdHlwZWRlZiBiZWxvdyB0byBzdXBwcmVzcyBjb21waWxlciB3YXJuaW5nICovXG5cbiAgLy8gc3RydWN0IGN0X2RhdGFfcyBkeW5fbHRyZWVbSEVBUF9TSVpFXTsgICAvKiBsaXRlcmFsIGFuZCBsZW5ndGggdHJlZSAqL1xuICAvLyBzdHJ1Y3QgY3RfZGF0YV9zIGR5bl9kdHJlZVsyKkRfQ09ERVMrMV07IC8qIGRpc3RhbmNlIHRyZWUgKi9cbiAgLy8gc3RydWN0IGN0X2RhdGFfcyBibF90cmVlWzIqQkxfQ09ERVMrMV07ICAvKiBIdWZmbWFuIHRyZWUgZm9yIGJpdCBsZW5ndGhzICovXG5cbiAgLy8gVXNlIGZsYXQgYXJyYXkgb2YgRE9VQkxFIHNpemUsIHdpdGggaW50ZXJsZWF2ZWQgZmF0YSxcbiAgLy8gYmVjYXVzZSBKUyBkb2VzIG5vdCBzdXBwb3J0IGVmZmVjdGl2ZVxuICB0aGlzLmR5bl9sdHJlZSAgPSBuZXcgdXRpbHMuQnVmMTYoSEVBUF9TSVpFICogMik7XG4gIHRoaXMuZHluX2R0cmVlICA9IG5ldyB1dGlscy5CdWYxNigoMiAqIERfQ09ERVMgKyAxKSAqIDIpO1xuICB0aGlzLmJsX3RyZWUgICAgPSBuZXcgdXRpbHMuQnVmMTYoKDIgKiBCTF9DT0RFUyArIDEpICogMik7XG4gIHplcm8odGhpcy5keW5fbHRyZWUpO1xuICB6ZXJvKHRoaXMuZHluX2R0cmVlKTtcbiAgemVybyh0aGlzLmJsX3RyZWUpO1xuXG4gIHRoaXMubF9kZXNjICAgPSBudWxsOyAgICAgICAgIC8qIGRlc2MuIGZvciBsaXRlcmFsIHRyZWUgKi9cbiAgdGhpcy5kX2Rlc2MgICA9IG51bGw7ICAgICAgICAgLyogZGVzYy4gZm9yIGRpc3RhbmNlIHRyZWUgKi9cbiAgdGhpcy5ibF9kZXNjICA9IG51bGw7ICAgICAgICAgLyogZGVzYy4gZm9yIGJpdCBsZW5ndGggdHJlZSAqL1xuXG4gIC8vdXNoIGJsX2NvdW50W01BWF9CSVRTKzFdO1xuICB0aGlzLmJsX2NvdW50ID0gbmV3IHV0aWxzLkJ1ZjE2KE1BWF9CSVRTICsgMSk7XG4gIC8qIG51bWJlciBvZiBjb2RlcyBhdCBlYWNoIGJpdCBsZW5ndGggZm9yIGFuIG9wdGltYWwgdHJlZSAqL1xuXG4gIC8vaW50IGhlYXBbMipMX0NPREVTKzFdOyAgICAgIC8qIGhlYXAgdXNlZCB0byBidWlsZCB0aGUgSHVmZm1hbiB0cmVlcyAqL1xuICB0aGlzLmhlYXAgPSBuZXcgdXRpbHMuQnVmMTYoMiAqIExfQ09ERVMgKyAxKTsgIC8qIGhlYXAgdXNlZCB0byBidWlsZCB0aGUgSHVmZm1hbiB0cmVlcyAqL1xuICB6ZXJvKHRoaXMuaGVhcCk7XG5cbiAgdGhpcy5oZWFwX2xlbiA9IDA7ICAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSBoZWFwICovXG4gIHRoaXMuaGVhcF9tYXggPSAwOyAgICAgICAgICAgICAgIC8qIGVsZW1lbnQgb2YgbGFyZ2VzdCBmcmVxdWVuY3kgKi9cbiAgLyogVGhlIHNvbnMgb2YgaGVhcFtuXSBhcmUgaGVhcFsyKm5dIGFuZCBoZWFwWzIqbisxXS4gaGVhcFswXSBpcyBub3QgdXNlZC5cbiAgICogVGhlIHNhbWUgaGVhcCBhcnJheSBpcyB1c2VkIHRvIGJ1aWxkIGFsbCB0cmVlcy5cbiAgICovXG5cbiAgdGhpcy5kZXB0aCA9IG5ldyB1dGlscy5CdWYxNigyICogTF9DT0RFUyArIDEpOyAvL3VjaCBkZXB0aFsyKkxfQ09ERVMrMV07XG4gIHplcm8odGhpcy5kZXB0aCk7XG4gIC8qIERlcHRoIG9mIGVhY2ggc3VidHJlZSB1c2VkIGFzIHRpZSBicmVha2VyIGZvciB0cmVlcyBvZiBlcXVhbCBmcmVxdWVuY3lcbiAgICovXG5cbiAgdGhpcy5sX2J1ZiA9IDA7ICAgICAgICAgIC8qIGJ1ZmZlciBpbmRleCBmb3IgbGl0ZXJhbHMgb3IgbGVuZ3RocyAqL1xuXG4gIHRoaXMubGl0X2J1ZnNpemUgPSAwO1xuICAvKiBTaXplIG9mIG1hdGNoIGJ1ZmZlciBmb3IgbGl0ZXJhbHMvbGVuZ3Rocy4gIFRoZXJlIGFyZSA0IHJlYXNvbnMgZm9yXG4gICAqIGxpbWl0aW5nIGxpdF9idWZzaXplIHRvIDY0SzpcbiAgICogICAtIGZyZXF1ZW5jaWVzIGNhbiBiZSBrZXB0IGluIDE2IGJpdCBjb3VudGVyc1xuICAgKiAgIC0gaWYgY29tcHJlc3Npb24gaXMgbm90IHN1Y2Nlc3NmdWwgZm9yIHRoZSBmaXJzdCBibG9jaywgYWxsIGlucHV0XG4gICAqICAgICBkYXRhIGlzIHN0aWxsIGluIHRoZSB3aW5kb3cgc28gd2UgY2FuIHN0aWxsIGVtaXQgYSBzdG9yZWQgYmxvY2sgZXZlblxuICAgKiAgICAgd2hlbiBpbnB1dCBjb21lcyBmcm9tIHN0YW5kYXJkIGlucHV0LiAgKFRoaXMgY2FuIGFsc28gYmUgZG9uZSBmb3JcbiAgICogICAgIGFsbCBibG9ja3MgaWYgbGl0X2J1ZnNpemUgaXMgbm90IGdyZWF0ZXIgdGhhbiAzMksuKVxuICAgKiAgIC0gaWYgY29tcHJlc3Npb24gaXMgbm90IHN1Y2Nlc3NmdWwgZm9yIGEgZmlsZSBzbWFsbGVyIHRoYW4gNjRLLCB3ZSBjYW5cbiAgICogICAgIGV2ZW4gZW1pdCBhIHN0b3JlZCBmaWxlIGluc3RlYWQgb2YgYSBzdG9yZWQgYmxvY2sgKHNhdmluZyA1IGJ5dGVzKS5cbiAgICogICAgIFRoaXMgaXMgYXBwbGljYWJsZSBvbmx5IGZvciB6aXAgKG5vdCBnemlwIG9yIHpsaWIpLlxuICAgKiAgIC0gY3JlYXRpbmcgbmV3IEh1ZmZtYW4gdHJlZXMgbGVzcyBmcmVxdWVudGx5IG1heSBub3QgcHJvdmlkZSBmYXN0XG4gICAqICAgICBhZGFwdGF0aW9uIHRvIGNoYW5nZXMgaW4gdGhlIGlucHV0IGRhdGEgc3RhdGlzdGljcy4gKFRha2UgZm9yXG4gICAqICAgICBleGFtcGxlIGEgYmluYXJ5IGZpbGUgd2l0aCBwb29ybHkgY29tcHJlc3NpYmxlIGNvZGUgZm9sbG93ZWQgYnlcbiAgICogICAgIGEgaGlnaGx5IGNvbXByZXNzaWJsZSBzdHJpbmcgdGFibGUuKSBTbWFsbGVyIGJ1ZmZlciBzaXplcyBnaXZlXG4gICAqICAgICBmYXN0IGFkYXB0YXRpb24gYnV0IGhhdmUgb2YgY291cnNlIHRoZSBvdmVyaGVhZCBvZiB0cmFuc21pdHRpbmdcbiAgICogICAgIHRyZWVzIG1vcmUgZnJlcXVlbnRseS5cbiAgICogICAtIEkgY2FuJ3QgY291bnQgYWJvdmUgNFxuICAgKi9cblxuICB0aGlzLmxhc3RfbGl0ID0gMDsgICAgICAvKiBydW5uaW5nIGluZGV4IGluIGxfYnVmICovXG5cbiAgdGhpcy5kX2J1ZiA9IDA7XG4gIC8qIEJ1ZmZlciBpbmRleCBmb3IgZGlzdGFuY2VzLiBUbyBzaW1wbGlmeSB0aGUgY29kZSwgZF9idWYgYW5kIGxfYnVmIGhhdmVcbiAgICogdGhlIHNhbWUgbnVtYmVyIG9mIGVsZW1lbnRzLiBUbyB1c2UgZGlmZmVyZW50IGxlbmd0aHMsIGFuIGV4dHJhIGZsYWdcbiAgICogYXJyYXkgd291bGQgYmUgbmVjZXNzYXJ5LlxuICAgKi9cblxuICB0aGlzLm9wdF9sZW4gPSAwOyAgICAgICAvKiBiaXQgbGVuZ3RoIG9mIGN1cnJlbnQgYmxvY2sgd2l0aCBvcHRpbWFsIHRyZWVzICovXG4gIHRoaXMuc3RhdGljX2xlbiA9IDA7ICAgIC8qIGJpdCBsZW5ndGggb2YgY3VycmVudCBibG9jayB3aXRoIHN0YXRpYyB0cmVlcyAqL1xuICB0aGlzLm1hdGNoZXMgPSAwOyAgICAgICAvKiBudW1iZXIgb2Ygc3RyaW5nIG1hdGNoZXMgaW4gY3VycmVudCBibG9jayAqL1xuICB0aGlzLmluc2VydCA9IDA7ICAgICAgICAvKiBieXRlcyBhdCBlbmQgb2Ygd2luZG93IGxlZnQgdG8gaW5zZXJ0ICovXG5cblxuICB0aGlzLmJpX2J1ZiA9IDA7XG4gIC8qIE91dHB1dCBidWZmZXIuIGJpdHMgYXJlIGluc2VydGVkIHN0YXJ0aW5nIGF0IHRoZSBib3R0b20gKGxlYXN0XG4gICAqIHNpZ25pZmljYW50IGJpdHMpLlxuICAgKi9cbiAgdGhpcy5iaV92YWxpZCA9IDA7XG4gIC8qIE51bWJlciBvZiB2YWxpZCBiaXRzIGluIGJpX2J1Zi4gIEFsbCBiaXRzIGFib3ZlIHRoZSBsYXN0IHZhbGlkIGJpdFxuICAgKiBhcmUgYWx3YXlzIHplcm8uXG4gICAqL1xuXG4gIC8vIFVzZWQgZm9yIHdpbmRvdyBtZW1vcnkgaW5pdC4gV2Ugc2FmZWx5IGlnbm9yZSBpdCBmb3IgSlMuIFRoYXQgbWFrZXNcbiAgLy8gc2Vuc2Ugb25seSBmb3IgcG9pbnRlcnMgYW5kIG1lbW9yeSBjaGVjayB0b29scy5cbiAgLy90aGlzLmhpZ2hfd2F0ZXIgPSAwO1xuICAvKiBIaWdoIHdhdGVyIG1hcmsgb2Zmc2V0IGluIHdpbmRvdyBmb3IgaW5pdGlhbGl6ZWQgYnl0ZXMgLS0gYnl0ZXMgYWJvdmVcbiAgICogdGhpcyBhcmUgc2V0IHRvIHplcm8gaW4gb3JkZXIgdG8gYXZvaWQgbWVtb3J5IGNoZWNrIHdhcm5pbmdzIHdoZW5cbiAgICogbG9uZ2VzdCBtYXRjaCByb3V0aW5lcyBhY2Nlc3MgYnl0ZXMgcGFzdCB0aGUgaW5wdXQuICBUaGlzIGlzIHRoZW5cbiAgICogdXBkYXRlZCB0byB0aGUgbmV3IGhpZ2ggd2F0ZXIgbWFyay5cbiAgICovXG59XG5cblxuZnVuY3Rpb24gZGVmbGF0ZVJlc2V0S2VlcChzdHJtKSB7XG4gIHZhciBzO1xuXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSkge1xuICAgIHJldHVybiBlcnIoc3RybSwgWl9TVFJFQU1fRVJST1IpO1xuICB9XG5cbiAgc3RybS50b3RhbF9pbiA9IHN0cm0udG90YWxfb3V0ID0gMDtcbiAgc3RybS5kYXRhX3R5cGUgPSBaX1VOS05PV047XG5cbiAgcyA9IHN0cm0uc3RhdGU7XG4gIHMucGVuZGluZyA9IDA7XG4gIHMucGVuZGluZ19vdXQgPSAwO1xuXG4gIGlmIChzLndyYXAgPCAwKSB7XG4gICAgcy53cmFwID0gLXMud3JhcDtcbiAgICAvKiB3YXMgbWFkZSBuZWdhdGl2ZSBieSBkZWZsYXRlKC4uLiwgWl9GSU5JU0gpOyAqL1xuICB9XG4gIHMuc3RhdHVzID0gKHMud3JhcCA/IElOSVRfU1RBVEUgOiBCVVNZX1NUQVRFKTtcbiAgc3RybS5hZGxlciA9IChzLndyYXAgPT09IDIpID9cbiAgICAwICAvLyBjcmMzMigwLCBaX05VTEwsIDApXG4gIDpcbiAgICAxOyAvLyBhZGxlcjMyKDAsIFpfTlVMTCwgMClcbiAgcy5sYXN0X2ZsdXNoID0gWl9OT19GTFVTSDtcbiAgdHJlZXMuX3RyX2luaXQocyk7XG4gIHJldHVybiBaX09LO1xufVxuXG5cbmZ1bmN0aW9uIGRlZmxhdGVSZXNldChzdHJtKSB7XG4gIHZhciByZXQgPSBkZWZsYXRlUmVzZXRLZWVwKHN0cm0pO1xuICBpZiAocmV0ID09PSBaX09LKSB7XG4gICAgbG1faW5pdChzdHJtLnN0YXRlKTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5cbmZ1bmN0aW9uIGRlZmxhdGVTZXRIZWFkZXIoc3RybSwgaGVhZCkge1xuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOyB9XG4gIGlmIChzdHJtLnN0YXRlLndyYXAgIT09IDIpIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOyB9XG4gIHN0cm0uc3RhdGUuZ3poZWFkID0gaGVhZDtcbiAgcmV0dXJuIFpfT0s7XG59XG5cblxuZnVuY3Rpb24gZGVmbGF0ZUluaXQyKHN0cm0sIGxldmVsLCBtZXRob2QsIHdpbmRvd0JpdHMsIG1lbUxldmVsLCBzdHJhdGVneSkge1xuICBpZiAoIXN0cm0pIHsgLy8gPT09IFpfTlVMTFxuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgfVxuICB2YXIgd3JhcCA9IDE7XG5cbiAgaWYgKGxldmVsID09PSBaX0RFRkFVTFRfQ09NUFJFU1NJT04pIHtcbiAgICBsZXZlbCA9IDY7XG4gIH1cblxuICBpZiAod2luZG93Qml0cyA8IDApIHsgLyogc3VwcHJlc3MgemxpYiB3cmFwcGVyICovXG4gICAgd3JhcCA9IDA7XG4gICAgd2luZG93Qml0cyA9IC13aW5kb3dCaXRzO1xuICB9XG5cbiAgZWxzZSBpZiAod2luZG93Qml0cyA+IDE1KSB7XG4gICAgd3JhcCA9IDI7ICAgICAgICAgICAvKiB3cml0ZSBnemlwIHdyYXBwZXIgaW5zdGVhZCAqL1xuICAgIHdpbmRvd0JpdHMgLT0gMTY7XG4gIH1cblxuXG4gIGlmIChtZW1MZXZlbCA8IDEgfHwgbWVtTGV2ZWwgPiBNQVhfTUVNX0xFVkVMIHx8IG1ldGhvZCAhPT0gWl9ERUZMQVRFRCB8fFxuICAgIHdpbmRvd0JpdHMgPCA4IHx8IHdpbmRvd0JpdHMgPiAxNSB8fCBsZXZlbCA8IDAgfHwgbGV2ZWwgPiA5IHx8XG4gICAgc3RyYXRlZ3kgPCAwIHx8IHN0cmF0ZWd5ID4gWl9GSVhFRCkge1xuICAgIHJldHVybiBlcnIoc3RybSwgWl9TVFJFQU1fRVJST1IpO1xuICB9XG5cblxuICBpZiAod2luZG93Qml0cyA9PT0gOCkge1xuICAgIHdpbmRvd0JpdHMgPSA5O1xuICB9XG4gIC8qIHVudGlsIDI1Ni1ieXRlIHdpbmRvdyBidWcgZml4ZWQgKi9cblxuICB2YXIgcyA9IG5ldyBEZWZsYXRlU3RhdGUoKTtcblxuICBzdHJtLnN0YXRlID0gcztcbiAgcy5zdHJtID0gc3RybTtcblxuICBzLndyYXAgPSB3cmFwO1xuICBzLmd6aGVhZCA9IG51bGw7XG4gIHMud19iaXRzID0gd2luZG93Qml0cztcbiAgcy53X3NpemUgPSAxIDw8IHMud19iaXRzO1xuICBzLndfbWFzayA9IHMud19zaXplIC0gMTtcblxuICBzLmhhc2hfYml0cyA9IG1lbUxldmVsICsgNztcbiAgcy5oYXNoX3NpemUgPSAxIDw8IHMuaGFzaF9iaXRzO1xuICBzLmhhc2hfbWFzayA9IHMuaGFzaF9zaXplIC0gMTtcbiAgcy5oYXNoX3NoaWZ0ID0gfn4oKHMuaGFzaF9iaXRzICsgTUlOX01BVENIIC0gMSkgLyBNSU5fTUFUQ0gpO1xuXG4gIHMud2luZG93ID0gbmV3IHV0aWxzLkJ1Zjgocy53X3NpemUgKiAyKTtcbiAgcy5oZWFkID0gbmV3IHV0aWxzLkJ1ZjE2KHMuaGFzaF9zaXplKTtcbiAgcy5wcmV2ID0gbmV3IHV0aWxzLkJ1ZjE2KHMud19zaXplKTtcblxuICAvLyBEb24ndCBuZWVkIG1lbSBpbml0IG1hZ2ljIGZvciBKUy5cbiAgLy9zLmhpZ2hfd2F0ZXIgPSAwOyAgLyogbm90aGluZyB3cml0dGVuIHRvIHMtPndpbmRvdyB5ZXQgKi9cblxuICBzLmxpdF9idWZzaXplID0gMSA8PCAobWVtTGV2ZWwgKyA2KTsgLyogMTZLIGVsZW1lbnRzIGJ5IGRlZmF1bHQgKi9cblxuICBzLnBlbmRpbmdfYnVmX3NpemUgPSBzLmxpdF9idWZzaXplICogNDtcblxuICAvL292ZXJsYXkgPSAodXNoZiAqKSBaQUxMT0Moc3RybSwgcy0+bGl0X2J1ZnNpemUsIHNpemVvZih1c2gpKzIpO1xuICAvL3MtPnBlbmRpbmdfYnVmID0gKHVjaGYgKikgb3ZlcmxheTtcbiAgcy5wZW5kaW5nX2J1ZiA9IG5ldyB1dGlscy5CdWY4KHMucGVuZGluZ19idWZfc2l6ZSk7XG5cbiAgLy8gSXQgaXMgb2Zmc2V0IGZyb20gYHMucGVuZGluZ19idWZgIChzaXplIGlzIGBzLmxpdF9idWZzaXplICogMmApXG4gIC8vcy0+ZF9idWYgPSBvdmVybGF5ICsgcy0+bGl0X2J1ZnNpemUvc2l6ZW9mKHVzaCk7XG4gIHMuZF9idWYgPSAxICogcy5saXRfYnVmc2l6ZTtcblxuICAvL3MtPmxfYnVmID0gcy0+cGVuZGluZ19idWYgKyAoMStzaXplb2YodXNoKSkqcy0+bGl0X2J1ZnNpemU7XG4gIHMubF9idWYgPSAoMSArIDIpICogcy5saXRfYnVmc2l6ZTtcblxuICBzLmxldmVsID0gbGV2ZWw7XG4gIHMuc3RyYXRlZ3kgPSBzdHJhdGVneTtcbiAgcy5tZXRob2QgPSBtZXRob2Q7XG5cbiAgcmV0dXJuIGRlZmxhdGVSZXNldChzdHJtKTtcbn1cblxuZnVuY3Rpb24gZGVmbGF0ZUluaXQoc3RybSwgbGV2ZWwpIHtcbiAgcmV0dXJuIGRlZmxhdGVJbml0MihzdHJtLCBsZXZlbCwgWl9ERUZMQVRFRCwgTUFYX1dCSVRTLCBERUZfTUVNX0xFVkVMLCBaX0RFRkFVTFRfU1RSQVRFR1kpO1xufVxuXG5cbmZ1bmN0aW9uIGRlZmxhdGUoc3RybSwgZmx1c2gpIHtcbiAgdmFyIG9sZF9mbHVzaCwgcztcbiAgdmFyIGJlZywgdmFsOyAvLyBmb3IgZ3ppcCBoZWFkZXIgd3JpdGUgb25seVxuXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSB8fFxuICAgIGZsdXNoID4gWl9CTE9DSyB8fCBmbHVzaCA8IDApIHtcbiAgICByZXR1cm4gc3RybSA/IGVycihzdHJtLCBaX1NUUkVBTV9FUlJPUikgOiBaX1NUUkVBTV9FUlJPUjtcbiAgfVxuXG4gIHMgPSBzdHJtLnN0YXRlO1xuXG4gIGlmICghc3RybS5vdXRwdXQgfHxcbiAgICAgICghc3RybS5pbnB1dCAmJiBzdHJtLmF2YWlsX2luICE9PSAwKSB8fFxuICAgICAgKHMuc3RhdHVzID09PSBGSU5JU0hfU1RBVEUgJiYgZmx1c2ggIT09IFpfRklOSVNIKSkge1xuICAgIHJldHVybiBlcnIoc3RybSwgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSA/IFpfQlVGX0VSUk9SIDogWl9TVFJFQU1fRVJST1IpO1xuICB9XG5cbiAgcy5zdHJtID0gc3RybTsgLyoganVzdCBpbiBjYXNlICovXG4gIG9sZF9mbHVzaCA9IHMubGFzdF9mbHVzaDtcbiAgcy5sYXN0X2ZsdXNoID0gZmx1c2g7XG5cbiAgLyogV3JpdGUgdGhlIGhlYWRlciAqL1xuICBpZiAocy5zdGF0dXMgPT09IElOSVRfU1RBVEUpIHtcblxuICAgIGlmIChzLndyYXAgPT09IDIpIHsgLy8gR1pJUCBoZWFkZXJcbiAgICAgIHN0cm0uYWRsZXIgPSAwOyAgLy9jcmMzMigwTCwgWl9OVUxMLCAwKTtcbiAgICAgIHB1dF9ieXRlKHMsIDMxKTtcbiAgICAgIHB1dF9ieXRlKHMsIDEzOSk7XG4gICAgICBwdXRfYnl0ZShzLCA4KTtcbiAgICAgIGlmICghcy5nemhlYWQpIHsgLy8gcy0+Z3poZWFkID09IFpfTlVMTFxuICAgICAgICBwdXRfYnl0ZShzLCAwKTtcbiAgICAgICAgcHV0X2J5dGUocywgMCk7XG4gICAgICAgIHB1dF9ieXRlKHMsIDApO1xuICAgICAgICBwdXRfYnl0ZShzLCAwKTtcbiAgICAgICAgcHV0X2J5dGUocywgMCk7XG4gICAgICAgIHB1dF9ieXRlKHMsIHMubGV2ZWwgPT09IDkgPyAyIDpcbiAgICAgICAgICAgICAgICAgICAgKHMuc3RyYXRlZ3kgPj0gWl9IVUZGTUFOX09OTFkgfHwgcy5sZXZlbCA8IDIgP1xuICAgICAgICAgICAgICAgICAgICAgNCA6IDApKTtcbiAgICAgICAgcHV0X2J5dGUocywgT1NfQ09ERSk7XG4gICAgICAgIHMuc3RhdHVzID0gQlVTWV9TVEFURTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBwdXRfYnl0ZShzLCAocy5nemhlYWQudGV4dCA/IDEgOiAwKSArXG4gICAgICAgICAgICAgICAgICAgIChzLmd6aGVhZC5oY3JjID8gMiA6IDApICtcbiAgICAgICAgICAgICAgICAgICAgKCFzLmd6aGVhZC5leHRyYSA/IDAgOiA0KSArXG4gICAgICAgICAgICAgICAgICAgICghcy5nemhlYWQubmFtZSA/IDAgOiA4KSArXG4gICAgICAgICAgICAgICAgICAgICghcy5nemhlYWQuY29tbWVudCA/IDAgOiAxNilcbiAgICAgICAgKTtcbiAgICAgICAgcHV0X2J5dGUocywgcy5nemhlYWQudGltZSAmIDB4ZmYpO1xuICAgICAgICBwdXRfYnl0ZShzLCAocy5nemhlYWQudGltZSA+PiA4KSAmIDB4ZmYpO1xuICAgICAgICBwdXRfYnl0ZShzLCAocy5nemhlYWQudGltZSA+PiAxNikgJiAweGZmKTtcbiAgICAgICAgcHV0X2J5dGUocywgKHMuZ3poZWFkLnRpbWUgPj4gMjQpICYgMHhmZik7XG4gICAgICAgIHB1dF9ieXRlKHMsIHMubGV2ZWwgPT09IDkgPyAyIDpcbiAgICAgICAgICAgICAgICAgICAgKHMuc3RyYXRlZ3kgPj0gWl9IVUZGTUFOX09OTFkgfHwgcy5sZXZlbCA8IDIgP1xuICAgICAgICAgICAgICAgICAgICAgNCA6IDApKTtcbiAgICAgICAgcHV0X2J5dGUocywgcy5nemhlYWQub3MgJiAweGZmKTtcbiAgICAgICAgaWYgKHMuZ3poZWFkLmV4dHJhICYmIHMuZ3poZWFkLmV4dHJhLmxlbmd0aCkge1xuICAgICAgICAgIHB1dF9ieXRlKHMsIHMuZ3poZWFkLmV4dHJhLmxlbmd0aCAmIDB4ZmYpO1xuICAgICAgICAgIHB1dF9ieXRlKHMsIChzLmd6aGVhZC5leHRyYS5sZW5ndGggPj4gOCkgJiAweGZmKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocy5nemhlYWQuaGNyYykge1xuICAgICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcsIDApO1xuICAgICAgICB9XG4gICAgICAgIHMuZ3ppbmRleCA9IDA7XG4gICAgICAgIHMuc3RhdHVzID0gRVhUUkFfU1RBVEU7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgLy8gREVGTEFURSBoZWFkZXJcbiAgICB7XG4gICAgICB2YXIgaGVhZGVyID0gKFpfREVGTEFURUQgKyAoKHMud19iaXRzIC0gOCkgPDwgNCkpIDw8IDg7XG4gICAgICB2YXIgbGV2ZWxfZmxhZ3MgPSAtMTtcblxuICAgICAgaWYgKHMuc3RyYXRlZ3kgPj0gWl9IVUZGTUFOX09OTFkgfHwgcy5sZXZlbCA8IDIpIHtcbiAgICAgICAgbGV2ZWxfZmxhZ3MgPSAwO1xuICAgICAgfSBlbHNlIGlmIChzLmxldmVsIDwgNikge1xuICAgICAgICBsZXZlbF9mbGFncyA9IDE7XG4gICAgICB9IGVsc2UgaWYgKHMubGV2ZWwgPT09IDYpIHtcbiAgICAgICAgbGV2ZWxfZmxhZ3MgPSAyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV2ZWxfZmxhZ3MgPSAzO1xuICAgICAgfVxuICAgICAgaGVhZGVyIHw9IChsZXZlbF9mbGFncyA8PCA2KTtcbiAgICAgIGlmIChzLnN0cnN0YXJ0ICE9PSAwKSB7IGhlYWRlciB8PSBQUkVTRVRfRElDVDsgfVxuICAgICAgaGVhZGVyICs9IDMxIC0gKGhlYWRlciAlIDMxKTtcblxuICAgICAgcy5zdGF0dXMgPSBCVVNZX1NUQVRFO1xuICAgICAgcHV0U2hvcnRNU0IocywgaGVhZGVyKTtcblxuICAgICAgLyogU2F2ZSB0aGUgYWRsZXIzMiBvZiB0aGUgcHJlc2V0IGRpY3Rpb25hcnk6ICovXG4gICAgICBpZiAocy5zdHJzdGFydCAhPT0gMCkge1xuICAgICAgICBwdXRTaG9ydE1TQihzLCBzdHJtLmFkbGVyID4+PiAxNik7XG4gICAgICAgIHB1dFNob3J0TVNCKHMsIHN0cm0uYWRsZXIgJiAweGZmZmYpO1xuICAgICAgfVxuICAgICAgc3RybS5hZGxlciA9IDE7IC8vIGFkbGVyMzIoMEwsIFpfTlVMTCwgMCk7XG4gICAgfVxuICB9XG5cbi8vI2lmZGVmIEdaSVBcbiAgaWYgKHMuc3RhdHVzID09PSBFWFRSQV9TVEFURSkge1xuICAgIGlmIChzLmd6aGVhZC5leHRyYS8qICE9IFpfTlVMTCovKSB7XG4gICAgICBiZWcgPSBzLnBlbmRpbmc7ICAvKiBzdGFydCBvZiBieXRlcyB0byB1cGRhdGUgY3JjICovXG5cbiAgICAgIHdoaWxlIChzLmd6aW5kZXggPCAocy5nemhlYWQuZXh0cmEubGVuZ3RoICYgMHhmZmZmKSkge1xuICAgICAgICBpZiAocy5wZW5kaW5nID09PSBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgICBpZiAocy5nemhlYWQuaGNyYyAmJiBzLnBlbmRpbmcgPiBiZWcpIHtcbiAgICAgICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcgLSBiZWcsIGJlZyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7XG4gICAgICAgICAgYmVnID0gcy5wZW5kaW5nO1xuICAgICAgICAgIGlmIChzLnBlbmRpbmcgPT09IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHB1dF9ieXRlKHMsIHMuZ3poZWFkLmV4dHJhW3MuZ3ppbmRleF0gJiAweGZmKTtcbiAgICAgICAgcy5nemluZGV4Kys7XG4gICAgICB9XG4gICAgICBpZiAocy5nemhlYWQuaGNyYyAmJiBzLnBlbmRpbmcgPiBiZWcpIHtcbiAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZyAtIGJlZywgYmVnKTtcbiAgICAgIH1cbiAgICAgIGlmIChzLmd6aW5kZXggPT09IHMuZ3poZWFkLmV4dHJhLmxlbmd0aCkge1xuICAgICAgICBzLmd6aW5kZXggPSAwO1xuICAgICAgICBzLnN0YXR1cyA9IE5BTUVfU1RBVEU7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcy5zdGF0dXMgPSBOQU1FX1NUQVRFO1xuICAgIH1cbiAgfVxuICBpZiAocy5zdGF0dXMgPT09IE5BTUVfU1RBVEUpIHtcbiAgICBpZiAocy5nemhlYWQubmFtZS8qICE9IFpfTlVMTCovKSB7XG4gICAgICBiZWcgPSBzLnBlbmRpbmc7ICAvKiBzdGFydCBvZiBieXRlcyB0byB1cGRhdGUgY3JjICovXG4gICAgICAvL2ludCB2YWw7XG5cbiAgICAgIGRvIHtcbiAgICAgICAgaWYgKHMucGVuZGluZyA9PT0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgICAgaWYgKHMuZ3poZWFkLmhjcmMgJiYgcy5wZW5kaW5nID4gYmVnKSB7XG4gICAgICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nIC0gYmVnLCBiZWcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmbHVzaF9wZW5kaW5nKHN0cm0pO1xuICAgICAgICAgIGJlZyA9IHMucGVuZGluZztcbiAgICAgICAgICBpZiAocy5wZW5kaW5nID09PSBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgICAgIHZhbCA9IDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSlMgc3BlY2lmaWM6IGxpdHRsZSBtYWdpYyB0byBhZGQgemVybyB0ZXJtaW5hdG9yIHRvIGVuZCBvZiBzdHJpbmdcbiAgICAgICAgaWYgKHMuZ3ppbmRleCA8IHMuZ3poZWFkLm5hbWUubGVuZ3RoKSB7XG4gICAgICAgICAgdmFsID0gcy5nemhlYWQubmFtZS5jaGFyQ29kZUF0KHMuZ3ppbmRleCsrKSAmIDB4ZmY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsID0gMDtcbiAgICAgICAgfVxuICAgICAgICBwdXRfYnl0ZShzLCB2YWwpO1xuICAgICAgfSB3aGlsZSAodmFsICE9PSAwKTtcblxuICAgICAgaWYgKHMuZ3poZWFkLmhjcmMgJiYgcy5wZW5kaW5nID4gYmVnKSB7XG4gICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcgLSBiZWcsIGJlZyk7XG4gICAgICB9XG4gICAgICBpZiAodmFsID09PSAwKSB7XG4gICAgICAgIHMuZ3ppbmRleCA9IDA7XG4gICAgICAgIHMuc3RhdHVzID0gQ09NTUVOVF9TVEFURTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBzLnN0YXR1cyA9IENPTU1FTlRfU1RBVEU7XG4gICAgfVxuICB9XG4gIGlmIChzLnN0YXR1cyA9PT0gQ09NTUVOVF9TVEFURSkge1xuICAgIGlmIChzLmd6aGVhZC5jb21tZW50LyogIT0gWl9OVUxMKi8pIHtcbiAgICAgIGJlZyA9IHMucGVuZGluZzsgIC8qIHN0YXJ0IG9mIGJ5dGVzIHRvIHVwZGF0ZSBjcmMgKi9cbiAgICAgIC8vaW50IHZhbDtcblxuICAgICAgZG8ge1xuICAgICAgICBpZiAocy5wZW5kaW5nID09PSBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgICBpZiAocy5nemhlYWQuaGNyYyAmJiBzLnBlbmRpbmcgPiBiZWcpIHtcbiAgICAgICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcgLSBiZWcsIGJlZyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7XG4gICAgICAgICAgYmVnID0gcy5wZW5kaW5nO1xuICAgICAgICAgIGlmIChzLnBlbmRpbmcgPT09IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICAgICAgdmFsID0gMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBKUyBzcGVjaWZpYzogbGl0dGxlIG1hZ2ljIHRvIGFkZCB6ZXJvIHRlcm1pbmF0b3IgdG8gZW5kIG9mIHN0cmluZ1xuICAgICAgICBpZiAocy5nemluZGV4IDwgcy5nemhlYWQuY29tbWVudC5sZW5ndGgpIHtcbiAgICAgICAgICB2YWwgPSBzLmd6aGVhZC5jb21tZW50LmNoYXJDb2RlQXQocy5nemluZGV4KyspICYgMHhmZjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWwgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHB1dF9ieXRlKHMsIHZhbCk7XG4gICAgICB9IHdoaWxlICh2YWwgIT09IDApO1xuXG4gICAgICBpZiAocy5nemhlYWQuaGNyYyAmJiBzLnBlbmRpbmcgPiBiZWcpIHtcbiAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZyAtIGJlZywgYmVnKTtcbiAgICAgIH1cbiAgICAgIGlmICh2YWwgPT09IDApIHtcbiAgICAgICAgcy5zdGF0dXMgPSBIQ1JDX1NUQVRFO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHMuc3RhdHVzID0gSENSQ19TVEFURTtcbiAgICB9XG4gIH1cbiAgaWYgKHMuc3RhdHVzID09PSBIQ1JDX1NUQVRFKSB7XG4gICAgaWYgKHMuZ3poZWFkLmhjcmMpIHtcbiAgICAgIGlmIChzLnBlbmRpbmcgKyAyID4gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7XG4gICAgICB9XG4gICAgICBpZiAocy5wZW5kaW5nICsgMiA8PSBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgcHV0X2J5dGUocywgc3RybS5hZGxlciAmIDB4ZmYpO1xuICAgICAgICBwdXRfYnl0ZShzLCAoc3RybS5hZGxlciA+PiA4KSAmIDB4ZmYpO1xuICAgICAgICBzdHJtLmFkbGVyID0gMDsgLy9jcmMzMigwTCwgWl9OVUxMLCAwKTtcbiAgICAgICAgcy5zdGF0dXMgPSBCVVNZX1NUQVRFO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHMuc3RhdHVzID0gQlVTWV9TVEFURTtcbiAgICB9XG4gIH1cbi8vI2VuZGlmXG5cbiAgLyogRmx1c2ggYXMgbXVjaCBwZW5kaW5nIG91dHB1dCBhcyBwb3NzaWJsZSAqL1xuICBpZiAocy5wZW5kaW5nICE9PSAwKSB7XG4gICAgZmx1c2hfcGVuZGluZyhzdHJtKTtcbiAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIC8qIFNpbmNlIGF2YWlsX291dCBpcyAwLCBkZWZsYXRlIHdpbGwgYmUgY2FsbGVkIGFnYWluIHdpdGhcbiAgICAgICAqIG1vcmUgb3V0cHV0IHNwYWNlLCBidXQgcG9zc2libHkgd2l0aCBib3RoIHBlbmRpbmcgYW5kXG4gICAgICAgKiBhdmFpbF9pbiBlcXVhbCB0byB6ZXJvLiBUaGVyZSB3b24ndCBiZSBhbnl0aGluZyB0byBkbyxcbiAgICAgICAqIGJ1dCB0aGlzIGlzIG5vdCBhbiBlcnJvciBzaXR1YXRpb24gc28gbWFrZSBzdXJlIHdlXG4gICAgICAgKiByZXR1cm4gT0sgaW5zdGVhZCBvZiBCVUZfRVJST1IgYXQgbmV4dCBjYWxsIG9mIGRlZmxhdGU6XG4gICAgICAgKi9cbiAgICAgIHMubGFzdF9mbHVzaCA9IC0xO1xuICAgICAgcmV0dXJuIFpfT0s7XG4gICAgfVxuXG4gICAgLyogTWFrZSBzdXJlIHRoZXJlIGlzIHNvbWV0aGluZyB0byBkbyBhbmQgYXZvaWQgZHVwbGljYXRlIGNvbnNlY3V0aXZlXG4gICAgICogZmx1c2hlcy4gRm9yIHJlcGVhdGVkIGFuZCB1c2VsZXNzIGNhbGxzIHdpdGggWl9GSU5JU0gsIHdlIGtlZXBcbiAgICAgKiByZXR1cm5pbmcgWl9TVFJFQU1fRU5EIGluc3RlYWQgb2YgWl9CVUZfRVJST1IuXG4gICAgICovXG4gIH0gZWxzZSBpZiAoc3RybS5hdmFpbF9pbiA9PT0gMCAmJiByYW5rKGZsdXNoKSA8PSByYW5rKG9sZF9mbHVzaCkgJiZcbiAgICBmbHVzaCAhPT0gWl9GSU5JU0gpIHtcbiAgICByZXR1cm4gZXJyKHN0cm0sIFpfQlVGX0VSUk9SKTtcbiAgfVxuXG4gIC8qIFVzZXIgbXVzdCBub3QgcHJvdmlkZSBtb3JlIGlucHV0IGFmdGVyIHRoZSBmaXJzdCBGSU5JU0g6ICovXG4gIGlmIChzLnN0YXR1cyA9PT0gRklOSVNIX1NUQVRFICYmIHN0cm0uYXZhaWxfaW4gIT09IDApIHtcbiAgICByZXR1cm4gZXJyKHN0cm0sIFpfQlVGX0VSUk9SKTtcbiAgfVxuXG4gIC8qIFN0YXJ0IGEgbmV3IGJsb2NrIG9yIGNvbnRpbnVlIHRoZSBjdXJyZW50IG9uZS5cbiAgICovXG4gIGlmIChzdHJtLmF2YWlsX2luICE9PSAwIHx8IHMubG9va2FoZWFkICE9PSAwIHx8XG4gICAgKGZsdXNoICE9PSBaX05PX0ZMVVNIICYmIHMuc3RhdHVzICE9PSBGSU5JU0hfU1RBVEUpKSB7XG4gICAgdmFyIGJzdGF0ZSA9IChzLnN0cmF0ZWd5ID09PSBaX0hVRkZNQU5fT05MWSkgPyBkZWZsYXRlX2h1ZmYocywgZmx1c2gpIDpcbiAgICAgIChzLnN0cmF0ZWd5ID09PSBaX1JMRSA/IGRlZmxhdGVfcmxlKHMsIGZsdXNoKSA6XG4gICAgICAgIGNvbmZpZ3VyYXRpb25fdGFibGVbcy5sZXZlbF0uZnVuYyhzLCBmbHVzaCkpO1xuXG4gICAgaWYgKGJzdGF0ZSA9PT0gQlNfRklOSVNIX1NUQVJURUQgfHwgYnN0YXRlID09PSBCU19GSU5JU0hfRE9ORSkge1xuICAgICAgcy5zdGF0dXMgPSBGSU5JU0hfU1RBVEU7XG4gICAgfVxuICAgIGlmIChic3RhdGUgPT09IEJTX05FRURfTU9SRSB8fCBic3RhdGUgPT09IEJTX0ZJTklTSF9TVEFSVEVEKSB7XG4gICAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcy5sYXN0X2ZsdXNoID0gLTE7XG4gICAgICAgIC8qIGF2b2lkIEJVRl9FUlJPUiBuZXh0IGNhbGwsIHNlZSBhYm92ZSAqL1xuICAgICAgfVxuICAgICAgcmV0dXJuIFpfT0s7XG4gICAgICAvKiBJZiBmbHVzaCAhPSBaX05PX0ZMVVNIICYmIGF2YWlsX291dCA9PSAwLCB0aGUgbmV4dCBjYWxsXG4gICAgICAgKiBvZiBkZWZsYXRlIHNob3VsZCB1c2UgdGhlIHNhbWUgZmx1c2ggcGFyYW1ldGVyIHRvIG1ha2Ugc3VyZVxuICAgICAgICogdGhhdCB0aGUgZmx1c2ggaXMgY29tcGxldGUuIFNvIHdlIGRvbid0IGhhdmUgdG8gb3V0cHV0IGFuXG4gICAgICAgKiBlbXB0eSBibG9jayBoZXJlLCB0aGlzIHdpbGwgYmUgZG9uZSBhdCBuZXh0IGNhbGwuIFRoaXMgYWxzb1xuICAgICAgICogZW5zdXJlcyB0aGF0IGZvciBhIHZlcnkgc21hbGwgb3V0cHV0IGJ1ZmZlciwgd2UgZW1pdCBhdCBtb3N0XG4gICAgICAgKiBvbmUgZW1wdHkgYmxvY2suXG4gICAgICAgKi9cbiAgICB9XG4gICAgaWYgKGJzdGF0ZSA9PT0gQlNfQkxPQ0tfRE9ORSkge1xuICAgICAgaWYgKGZsdXNoID09PSBaX1BBUlRJQUxfRkxVU0gpIHtcbiAgICAgICAgdHJlZXMuX3RyX2FsaWduKHMpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoZmx1c2ggIT09IFpfQkxPQ0spIHsgLyogRlVMTF9GTFVTSCBvciBTWU5DX0ZMVVNIICovXG5cbiAgICAgICAgdHJlZXMuX3RyX3N0b3JlZF9ibG9jayhzLCAwLCAwLCBmYWxzZSk7XG4gICAgICAgIC8qIEZvciBhIGZ1bGwgZmx1c2gsIHRoaXMgZW1wdHkgYmxvY2sgd2lsbCBiZSByZWNvZ25pemVkXG4gICAgICAgICAqIGFzIGEgc3BlY2lhbCBtYXJrZXIgYnkgaW5mbGF0ZV9zeW5jKCkuXG4gICAgICAgICAqL1xuICAgICAgICBpZiAoZmx1c2ggPT09IFpfRlVMTF9GTFVTSCkge1xuICAgICAgICAgIC8qKiogQ0xFQVJfSEFTSChzKTsgKioqLyAgICAgICAgICAgICAvKiBmb3JnZXQgaGlzdG9yeSAqL1xuICAgICAgICAgIHplcm8ocy5oZWFkKTsgLy8gRmlsbCB3aXRoIE5JTCAoPSAwKTtcblxuICAgICAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkge1xuICAgICAgICAgICAgcy5zdHJzdGFydCA9IDA7XG4gICAgICAgICAgICBzLmJsb2NrX3N0YXJ0ID0gMDtcbiAgICAgICAgICAgIHMuaW5zZXJ0ID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7XG4gICAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcy5sYXN0X2ZsdXNoID0gLTE7IC8qIGF2b2lkIEJVRl9FUlJPUiBhdCBuZXh0IGNhbGwsIHNlZSBhYm92ZSAqL1xuICAgICAgICByZXR1cm4gWl9PSztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLy9Bc3NlcnQoc3RybS0+YXZhaWxfb3V0ID4gMCwgXCJidWcyXCIpO1xuICAvL2lmIChzdHJtLmF2YWlsX291dCA8PSAwKSB7IHRocm93IG5ldyBFcnJvcihcImJ1ZzJcIik7fVxuXG4gIGlmIChmbHVzaCAhPT0gWl9GSU5JU0gpIHsgcmV0dXJuIFpfT0s7IH1cbiAgaWYgKHMud3JhcCA8PSAwKSB7IHJldHVybiBaX1NUUkVBTV9FTkQ7IH1cblxuICAvKiBXcml0ZSB0aGUgdHJhaWxlciAqL1xuICBpZiAocy53cmFwID09PSAyKSB7XG4gICAgcHV0X2J5dGUocywgc3RybS5hZGxlciAmIDB4ZmYpO1xuICAgIHB1dF9ieXRlKHMsIChzdHJtLmFkbGVyID4+IDgpICYgMHhmZik7XG4gICAgcHV0X2J5dGUocywgKHN0cm0uYWRsZXIgPj4gMTYpICYgMHhmZik7XG4gICAgcHV0X2J5dGUocywgKHN0cm0uYWRsZXIgPj4gMjQpICYgMHhmZik7XG4gICAgcHV0X2J5dGUocywgc3RybS50b3RhbF9pbiAmIDB4ZmYpO1xuICAgIHB1dF9ieXRlKHMsIChzdHJtLnRvdGFsX2luID4+IDgpICYgMHhmZik7XG4gICAgcHV0X2J5dGUocywgKHN0cm0udG90YWxfaW4gPj4gMTYpICYgMHhmZik7XG4gICAgcHV0X2J5dGUocywgKHN0cm0udG90YWxfaW4gPj4gMjQpICYgMHhmZik7XG4gIH1cbiAgZWxzZVxuICB7XG4gICAgcHV0U2hvcnRNU0Iocywgc3RybS5hZGxlciA+Pj4gMTYpO1xuICAgIHB1dFNob3J0TVNCKHMsIHN0cm0uYWRsZXIgJiAweGZmZmYpO1xuICB9XG5cbiAgZmx1c2hfcGVuZGluZyhzdHJtKTtcbiAgLyogSWYgYXZhaWxfb3V0IGlzIHplcm8sIHRoZSBhcHBsaWNhdGlvbiB3aWxsIGNhbGwgZGVmbGF0ZSBhZ2FpblxuICAgKiB0byBmbHVzaCB0aGUgcmVzdC5cbiAgICovXG4gIGlmIChzLndyYXAgPiAwKSB7IHMud3JhcCA9IC1zLndyYXA7IH1cbiAgLyogd3JpdGUgdGhlIHRyYWlsZXIgb25seSBvbmNlISAqL1xuICByZXR1cm4gcy5wZW5kaW5nICE9PSAwID8gWl9PSyA6IFpfU1RSRUFNX0VORDtcbn1cblxuZnVuY3Rpb24gZGVmbGF0ZUVuZChzdHJtKSB7XG4gIHZhciBzdGF0dXM7XG5cbiAgaWYgKCFzdHJtLyo9PSBaX05VTEwqLyB8fCAhc3RybS5zdGF0ZS8qPT0gWl9OVUxMKi8pIHtcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gIH1cblxuICBzdGF0dXMgPSBzdHJtLnN0YXRlLnN0YXR1cztcbiAgaWYgKHN0YXR1cyAhPT0gSU5JVF9TVEFURSAmJlxuICAgIHN0YXR1cyAhPT0gRVhUUkFfU1RBVEUgJiZcbiAgICBzdGF0dXMgIT09IE5BTUVfU1RBVEUgJiZcbiAgICBzdGF0dXMgIT09IENPTU1FTlRfU1RBVEUgJiZcbiAgICBzdGF0dXMgIT09IEhDUkNfU1RBVEUgJiZcbiAgICBzdGF0dXMgIT09IEJVU1lfU1RBVEUgJiZcbiAgICBzdGF0dXMgIT09IEZJTklTSF9TVEFURVxuICApIHtcbiAgICByZXR1cm4gZXJyKHN0cm0sIFpfU1RSRUFNX0VSUk9SKTtcbiAgfVxuXG4gIHN0cm0uc3RhdGUgPSBudWxsO1xuXG4gIHJldHVybiBzdGF0dXMgPT09IEJVU1lfU1RBVEUgPyBlcnIoc3RybSwgWl9EQVRBX0VSUk9SKSA6IFpfT0s7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogSW5pdGlhbGl6ZXMgdGhlIGNvbXByZXNzaW9uIGRpY3Rpb25hcnkgZnJvbSB0aGUgZ2l2ZW4gYnl0ZVxuICogc2VxdWVuY2Ugd2l0aG91dCBwcm9kdWNpbmcgYW55IGNvbXByZXNzZWQgb3V0cHV0LlxuICovXG5mdW5jdGlvbiBkZWZsYXRlU2V0RGljdGlvbmFyeShzdHJtLCBkaWN0aW9uYXJ5KSB7XG4gIHZhciBkaWN0TGVuZ3RoID0gZGljdGlvbmFyeS5sZW5ndGg7XG5cbiAgdmFyIHM7XG4gIHZhciBzdHIsIG47XG4gIHZhciB3cmFwO1xuICB2YXIgYXZhaWw7XG4gIHZhciBuZXh0O1xuICB2YXIgaW5wdXQ7XG4gIHZhciB0bXBEaWN0O1xuXG4gIGlmICghc3RybS8qPT0gWl9OVUxMKi8gfHwgIXN0cm0uc3RhdGUvKj09IFpfTlVMTCovKSB7XG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICB9XG5cbiAgcyA9IHN0cm0uc3RhdGU7XG4gIHdyYXAgPSBzLndyYXA7XG5cbiAgaWYgKHdyYXAgPT09IDIgfHwgKHdyYXAgPT09IDEgJiYgcy5zdGF0dXMgIT09IElOSVRfU1RBVEUpIHx8IHMubG9va2FoZWFkKSB7XG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICB9XG5cbiAgLyogd2hlbiB1c2luZyB6bGliIHdyYXBwZXJzLCBjb21wdXRlIEFkbGVyLTMyIGZvciBwcm92aWRlZCBkaWN0aW9uYXJ5ICovXG4gIGlmICh3cmFwID09PSAxKSB7XG4gICAgLyogYWRsZXIzMihzdHJtLT5hZGxlciwgZGljdGlvbmFyeSwgZGljdExlbmd0aCk7ICovXG4gICAgc3RybS5hZGxlciA9IGFkbGVyMzIoc3RybS5hZGxlciwgZGljdGlvbmFyeSwgZGljdExlbmd0aCwgMCk7XG4gIH1cblxuICBzLndyYXAgPSAwOyAgIC8qIGF2b2lkIGNvbXB1dGluZyBBZGxlci0zMiBpbiByZWFkX2J1ZiAqL1xuXG4gIC8qIGlmIGRpY3Rpb25hcnkgd291bGQgZmlsbCB3aW5kb3csIGp1c3QgcmVwbGFjZSB0aGUgaGlzdG9yeSAqL1xuICBpZiAoZGljdExlbmd0aCA+PSBzLndfc2l6ZSkge1xuICAgIGlmICh3cmFwID09PSAwKSB7ICAgICAgICAgICAgLyogYWxyZWFkeSBlbXB0eSBvdGhlcndpc2UgKi9cbiAgICAgIC8qKiogQ0xFQVJfSEFTSChzKTsgKioqL1xuICAgICAgemVybyhzLmhlYWQpOyAvLyBGaWxsIHdpdGggTklMICg9IDApO1xuICAgICAgcy5zdHJzdGFydCA9IDA7XG4gICAgICBzLmJsb2NrX3N0YXJ0ID0gMDtcbiAgICAgIHMuaW5zZXJ0ID0gMDtcbiAgICB9XG4gICAgLyogdXNlIHRoZSB0YWlsICovXG4gICAgLy8gZGljdGlvbmFyeSA9IGRpY3Rpb25hcnkuc2xpY2UoZGljdExlbmd0aCAtIHMud19zaXplKTtcbiAgICB0bXBEaWN0ID0gbmV3IHV0aWxzLkJ1Zjgocy53X3NpemUpO1xuICAgIHV0aWxzLmFycmF5U2V0KHRtcERpY3QsIGRpY3Rpb25hcnksIGRpY3RMZW5ndGggLSBzLndfc2l6ZSwgcy53X3NpemUsIDApO1xuICAgIGRpY3Rpb25hcnkgPSB0bXBEaWN0O1xuICAgIGRpY3RMZW5ndGggPSBzLndfc2l6ZTtcbiAgfVxuICAvKiBpbnNlcnQgZGljdGlvbmFyeSBpbnRvIHdpbmRvdyBhbmQgaGFzaCAqL1xuICBhdmFpbCA9IHN0cm0uYXZhaWxfaW47XG4gIG5leHQgPSBzdHJtLm5leHRfaW47XG4gIGlucHV0ID0gc3RybS5pbnB1dDtcbiAgc3RybS5hdmFpbF9pbiA9IGRpY3RMZW5ndGg7XG4gIHN0cm0ubmV4dF9pbiA9IDA7XG4gIHN0cm0uaW5wdXQgPSBkaWN0aW9uYXJ5O1xuICBmaWxsX3dpbmRvdyhzKTtcbiAgd2hpbGUgKHMubG9va2FoZWFkID49IE1JTl9NQVRDSCkge1xuICAgIHN0ciA9IHMuc3Ryc3RhcnQ7XG4gICAgbiA9IHMubG9va2FoZWFkIC0gKE1JTl9NQVRDSCAtIDEpO1xuICAgIGRvIHtcbiAgICAgIC8qIFVQREFURV9IQVNIKHMsIHMtPmluc19oLCBzLT53aW5kb3dbc3RyICsgTUlOX01BVENILTFdKTsgKi9cbiAgICAgIHMuaW5zX2ggPSAoKHMuaW5zX2ggPDwgcy5oYXNoX3NoaWZ0KSBeIHMud2luZG93W3N0ciArIE1JTl9NQVRDSCAtIDFdKSAmIHMuaGFzaF9tYXNrO1xuXG4gICAgICBzLnByZXZbc3RyICYgcy53X21hc2tdID0gcy5oZWFkW3MuaW5zX2hdO1xuXG4gICAgICBzLmhlYWRbcy5pbnNfaF0gPSBzdHI7XG4gICAgICBzdHIrKztcbiAgICB9IHdoaWxlICgtLW4pO1xuICAgIHMuc3Ryc3RhcnQgPSBzdHI7XG4gICAgcy5sb29rYWhlYWQgPSBNSU5fTUFUQ0ggLSAxO1xuICAgIGZpbGxfd2luZG93KHMpO1xuICB9XG4gIHMuc3Ryc3RhcnQgKz0gcy5sb29rYWhlYWQ7XG4gIHMuYmxvY2tfc3RhcnQgPSBzLnN0cnN0YXJ0O1xuICBzLmluc2VydCA9IHMubG9va2FoZWFkO1xuICBzLmxvb2thaGVhZCA9IDA7XG4gIHMubWF0Y2hfbGVuZ3RoID0gcy5wcmV2X2xlbmd0aCA9IE1JTl9NQVRDSCAtIDE7XG4gIHMubWF0Y2hfYXZhaWxhYmxlID0gMDtcbiAgc3RybS5uZXh0X2luID0gbmV4dDtcbiAgc3RybS5pbnB1dCA9IGlucHV0O1xuICBzdHJtLmF2YWlsX2luID0gYXZhaWw7XG4gIHMud3JhcCA9IHdyYXA7XG4gIHJldHVybiBaX09LO1xufVxuXG5cbmV4cG9ydHMuZGVmbGF0ZUluaXQgPSBkZWZsYXRlSW5pdDtcbmV4cG9ydHMuZGVmbGF0ZUluaXQyID0gZGVmbGF0ZUluaXQyO1xuZXhwb3J0cy5kZWZsYXRlUmVzZXQgPSBkZWZsYXRlUmVzZXQ7XG5leHBvcnRzLmRlZmxhdGVSZXNldEtlZXAgPSBkZWZsYXRlUmVzZXRLZWVwO1xuZXhwb3J0cy5kZWZsYXRlU2V0SGVhZGVyID0gZGVmbGF0ZVNldEhlYWRlcjtcbmV4cG9ydHMuZGVmbGF0ZSA9IGRlZmxhdGU7XG5leHBvcnRzLmRlZmxhdGVFbmQgPSBkZWZsYXRlRW5kO1xuZXhwb3J0cy5kZWZsYXRlU2V0RGljdGlvbmFyeSA9IGRlZmxhdGVTZXREaWN0aW9uYXJ5O1xuZXhwb3J0cy5kZWZsYXRlSW5mbyA9ICdwYWtvIGRlZmxhdGUgKGZyb20gTm9kZWNhIHByb2plY3QpJztcblxuLyogTm90IGltcGxlbWVudGVkXG5leHBvcnRzLmRlZmxhdGVCb3VuZCA9IGRlZmxhdGVCb3VuZDtcbmV4cG9ydHMuZGVmbGF0ZUNvcHkgPSBkZWZsYXRlQ29weTtcbmV4cG9ydHMuZGVmbGF0ZVBhcmFtcyA9IGRlZmxhdGVQYXJhbXM7XG5leHBvcnRzLmRlZmxhdGVQZW5kaW5nID0gZGVmbGF0ZVBlbmRpbmc7XG5leHBvcnRzLmRlZmxhdGVQcmltZSA9IGRlZmxhdGVQcmltZTtcbmV4cG9ydHMuZGVmbGF0ZVR1bmUgPSBkZWZsYXRlVHVuZTtcbiovXG4iLCIvLyBTdHJpbmcgZW5jb2RlL2RlY29kZSBoZWxwZXJzXG4ndXNlIHN0cmljdCc7XG5cblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi9jb21tb24nKTtcblxuXG4vLyBRdWljayBjaGVjayBpZiB3ZSBjYW4gdXNlIGZhc3QgYXJyYXkgdG8gYmluIHN0cmluZyBjb252ZXJzaW9uXG4vL1xuLy8gLSBhcHBseShBcnJheSkgY2FuIGZhaWwgb24gQW5kcm9pZCAyLjJcbi8vIC0gYXBwbHkoVWludDhBcnJheSkgY2FuIGZhaWwgb24gaU9TIDUuMSBTYWZhcmlcbi8vXG52YXIgU1RSX0FQUExZX09LID0gdHJ1ZTtcbnZhciBTVFJfQVBQTFlfVUlBX09LID0gdHJ1ZTtcblxudHJ5IHsgU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBbIDAgXSk7IH0gY2F0Y2ggKF9fKSB7IFNUUl9BUFBMWV9PSyA9IGZhbHNlOyB9XG50cnkgeyBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIG5ldyBVaW50OEFycmF5KDEpKTsgfSBjYXRjaCAoX18pIHsgU1RSX0FQUExZX1VJQV9PSyA9IGZhbHNlOyB9XG5cblxuLy8gVGFibGUgd2l0aCB1dGY4IGxlbmd0aHMgKGNhbGN1bGF0ZWQgYnkgZmlyc3QgYnl0ZSBvZiBzZXF1ZW5jZSlcbi8vIE5vdGUsIHRoYXQgNSAmIDYtYnl0ZSB2YWx1ZXMgYW5kIHNvbWUgNC1ieXRlIHZhbHVlcyBjYW4gbm90IGJlIHJlcHJlc2VudGVkIGluIEpTLFxuLy8gYmVjYXVzZSBtYXggcG9zc2libGUgY29kZXBvaW50IGlzIDB4MTBmZmZmXG52YXIgX3V0ZjhsZW4gPSBuZXcgdXRpbHMuQnVmOCgyNTYpO1xuZm9yICh2YXIgcSA9IDA7IHEgPCAyNTY7IHErKykge1xuICBfdXRmOGxlbltxXSA9IChxID49IDI1MiA/IDYgOiBxID49IDI0OCA/IDUgOiBxID49IDI0MCA/IDQgOiBxID49IDIyNCA/IDMgOiBxID49IDE5MiA/IDIgOiAxKTtcbn1cbl91dGY4bGVuWzI1NF0gPSBfdXRmOGxlblsyNTRdID0gMTsgLy8gSW52YWxpZCBzZXF1ZW5jZSBzdGFydFxuXG5cbi8vIGNvbnZlcnQgc3RyaW5nIHRvIGFycmF5ICh0eXBlZCwgd2hlbiBwb3NzaWJsZSlcbmV4cG9ydHMuc3RyaW5nMmJ1ZiA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgdmFyIGJ1ZiwgYywgYzIsIG1fcG9zLCBpLCBzdHJfbGVuID0gc3RyLmxlbmd0aCwgYnVmX2xlbiA9IDA7XG5cbiAgLy8gY291bnQgYmluYXJ5IHNpemVcbiAgZm9yIChtX3BvcyA9IDA7IG1fcG9zIDwgc3RyX2xlbjsgbV9wb3MrKykge1xuICAgIGMgPSBzdHIuY2hhckNvZGVBdChtX3Bvcyk7XG4gICAgaWYgKChjICYgMHhmYzAwKSA9PT0gMHhkODAwICYmIChtX3BvcyArIDEgPCBzdHJfbGVuKSkge1xuICAgICAgYzIgPSBzdHIuY2hhckNvZGVBdChtX3BvcyArIDEpO1xuICAgICAgaWYgKChjMiAmIDB4ZmMwMCkgPT09IDB4ZGMwMCkge1xuICAgICAgICBjID0gMHgxMDAwMCArICgoYyAtIDB4ZDgwMCkgPDwgMTApICsgKGMyIC0gMHhkYzAwKTtcbiAgICAgICAgbV9wb3MrKztcbiAgICAgIH1cbiAgICB9XG4gICAgYnVmX2xlbiArPSBjIDwgMHg4MCA/IDEgOiBjIDwgMHg4MDAgPyAyIDogYyA8IDB4MTAwMDAgPyAzIDogNDtcbiAgfVxuXG4gIC8vIGFsbG9jYXRlIGJ1ZmZlclxuICBidWYgPSBuZXcgdXRpbHMuQnVmOChidWZfbGVuKTtcblxuICAvLyBjb252ZXJ0XG4gIGZvciAoaSA9IDAsIG1fcG9zID0gMDsgaSA8IGJ1Zl9sZW47IG1fcG9zKyspIHtcbiAgICBjID0gc3RyLmNoYXJDb2RlQXQobV9wb3MpO1xuICAgIGlmICgoYyAmIDB4ZmMwMCkgPT09IDB4ZDgwMCAmJiAobV9wb3MgKyAxIDwgc3RyX2xlbikpIHtcbiAgICAgIGMyID0gc3RyLmNoYXJDb2RlQXQobV9wb3MgKyAxKTtcbiAgICAgIGlmICgoYzIgJiAweGZjMDApID09PSAweGRjMDApIHtcbiAgICAgICAgYyA9IDB4MTAwMDAgKyAoKGMgLSAweGQ4MDApIDw8IDEwKSArIChjMiAtIDB4ZGMwMCk7XG4gICAgICAgIG1fcG9zKys7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjIDwgMHg4MCkge1xuICAgICAgLyogb25lIGJ5dGUgKi9cbiAgICAgIGJ1ZltpKytdID0gYztcbiAgICB9IGVsc2UgaWYgKGMgPCAweDgwMCkge1xuICAgICAgLyogdHdvIGJ5dGVzICovXG4gICAgICBidWZbaSsrXSA9IDB4QzAgfCAoYyA+Pj4gNik7XG4gICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyAmIDB4M2YpO1xuICAgIH0gZWxzZSBpZiAoYyA8IDB4MTAwMDApIHtcbiAgICAgIC8qIHRocmVlIGJ5dGVzICovXG4gICAgICBidWZbaSsrXSA9IDB4RTAgfCAoYyA+Pj4gMTIpO1xuICAgICAgYnVmW2krK10gPSAweDgwIHwgKGMgPj4+IDYgJiAweDNmKTtcbiAgICAgIGJ1ZltpKytdID0gMHg4MCB8IChjICYgMHgzZik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qIGZvdXIgYnl0ZXMgKi9cbiAgICAgIGJ1ZltpKytdID0gMHhmMCB8IChjID4+PiAxOCk7XG4gICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyA+Pj4gMTIgJiAweDNmKTtcbiAgICAgIGJ1ZltpKytdID0gMHg4MCB8IChjID4+PiA2ICYgMHgzZik7XG4gICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyAmIDB4M2YpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBidWY7XG59O1xuXG4vLyBIZWxwZXIgKHVzZWQgaW4gMiBwbGFjZXMpXG5mdW5jdGlvbiBidWYyYmluc3RyaW5nKGJ1ZiwgbGVuKSB7XG4gIC8vIE9uIENocm9tZSwgdGhlIGFyZ3VtZW50cyBpbiBhIGZ1bmN0aW9uIGNhbGwgdGhhdCBhcmUgYWxsb3dlZCBpcyBgNjU1MzRgLlxuICAvLyBJZiB0aGUgbGVuZ3RoIG9mIHRoZSBidWZmZXIgaXMgc21hbGxlciB0aGFuIHRoYXQsIHdlIGNhbiB1c2UgdGhpcyBvcHRpbWl6YXRpb24sXG4gIC8vIG90aGVyd2lzZSB3ZSB3aWxsIHRha2UgYSBzbG93ZXIgcGF0aC5cbiAgaWYgKGxlbiA8IDY1NTM0KSB7XG4gICAgaWYgKChidWYuc3ViYXJyYXkgJiYgU1RSX0FQUExZX1VJQV9PSykgfHwgKCFidWYuc3ViYXJyYXkgJiYgU1RSX0FQUExZX09LKSkge1xuICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgdXRpbHMuc2hyaW5rQnVmKGJ1ZiwgbGVuKSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHJlc3VsdCA9ICcnO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgcmVzdWx0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5cbi8vIENvbnZlcnQgYnl0ZSBhcnJheSB0byBiaW5hcnkgc3RyaW5nXG5leHBvcnRzLmJ1ZjJiaW5zdHJpbmcgPSBmdW5jdGlvbiAoYnVmKSB7XG4gIHJldHVybiBidWYyYmluc3RyaW5nKGJ1ZiwgYnVmLmxlbmd0aCk7XG59O1xuXG5cbi8vIENvbnZlcnQgYmluYXJ5IHN0cmluZyAodHlwZWQsIHdoZW4gcG9zc2libGUpXG5leHBvcnRzLmJpbnN0cmluZzJidWYgPSBmdW5jdGlvbiAoc3RyKSB7XG4gIHZhciBidWYgPSBuZXcgdXRpbHMuQnVmOChzdHIubGVuZ3RoKTtcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGJ1Zi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGJ1ZltpXSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICB9XG4gIHJldHVybiBidWY7XG59O1xuXG5cbi8vIGNvbnZlcnQgYXJyYXkgdG8gc3RyaW5nXG5leHBvcnRzLmJ1ZjJzdHJpbmcgPSBmdW5jdGlvbiAoYnVmLCBtYXgpIHtcbiAgdmFyIGksIG91dCwgYywgY19sZW47XG4gIHZhciBsZW4gPSBtYXggfHwgYnVmLmxlbmd0aDtcblxuICAvLyBSZXNlcnZlIG1heCBwb3NzaWJsZSBsZW5ndGggKDIgd29yZHMgcGVyIGNoYXIpXG4gIC8vIE5COiBieSB1bmtub3duIHJlYXNvbnMsIEFycmF5IGlzIHNpZ25pZmljYW50bHkgZmFzdGVyIGZvclxuICAvLyAgICAgU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseSB0aGFuIFVpbnQxNkFycmF5LlxuICB2YXIgdXRmMTZidWYgPSBuZXcgQXJyYXkobGVuICogMik7XG5cbiAgZm9yIChvdXQgPSAwLCBpID0gMDsgaSA8IGxlbjspIHtcbiAgICBjID0gYnVmW2krK107XG4gICAgLy8gcXVpY2sgcHJvY2VzcyBhc2NpaVxuICAgIGlmIChjIDwgMHg4MCkgeyB1dGYxNmJ1ZltvdXQrK10gPSBjOyBjb250aW51ZTsgfVxuXG4gICAgY19sZW4gPSBfdXRmOGxlbltjXTtcbiAgICAvLyBza2lwIDUgJiA2IGJ5dGUgY29kZXNcbiAgICBpZiAoY19sZW4gPiA0KSB7IHV0ZjE2YnVmW291dCsrXSA9IDB4ZmZmZDsgaSArPSBjX2xlbiAtIDE7IGNvbnRpbnVlOyB9XG5cbiAgICAvLyBhcHBseSBtYXNrIG9uIGZpcnN0IGJ5dGVcbiAgICBjICY9IGNfbGVuID09PSAyID8gMHgxZiA6IGNfbGVuID09PSAzID8gMHgwZiA6IDB4MDc7XG4gICAgLy8gam9pbiB0aGUgcmVzdFxuICAgIHdoaWxlIChjX2xlbiA+IDEgJiYgaSA8IGxlbikge1xuICAgICAgYyA9IChjIDw8IDYpIHwgKGJ1ZltpKytdICYgMHgzZik7XG4gICAgICBjX2xlbi0tO1xuICAgIH1cblxuICAgIC8vIHRlcm1pbmF0ZWQgYnkgZW5kIG9mIHN0cmluZz9cbiAgICBpZiAoY19sZW4gPiAxKSB7IHV0ZjE2YnVmW291dCsrXSA9IDB4ZmZmZDsgY29udGludWU7IH1cblxuICAgIGlmIChjIDwgMHgxMDAwMCkge1xuICAgICAgdXRmMTZidWZbb3V0KytdID0gYztcbiAgICB9IGVsc2Uge1xuICAgICAgYyAtPSAweDEwMDAwO1xuICAgICAgdXRmMTZidWZbb3V0KytdID0gMHhkODAwIHwgKChjID4+IDEwKSAmIDB4M2ZmKTtcbiAgICAgIHV0ZjE2YnVmW291dCsrXSA9IDB4ZGMwMCB8IChjICYgMHgzZmYpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBidWYyYmluc3RyaW5nKHV0ZjE2YnVmLCBvdXQpO1xufTtcblxuXG4vLyBDYWxjdWxhdGUgbWF4IHBvc3NpYmxlIHBvc2l0aW9uIGluIHV0ZjggYnVmZmVyLFxuLy8gdGhhdCB3aWxsIG5vdCBicmVhayBzZXF1ZW5jZS4gSWYgdGhhdCdzIG5vdCBwb3NzaWJsZVxuLy8gLSAodmVyeSBzbWFsbCBsaW1pdHMpIHJldHVybiBtYXggc2l6ZSBhcyBpcy5cbi8vXG4vLyBidWZbXSAtIHV0ZjggYnl0ZXMgYXJyYXlcbi8vIG1heCAgIC0gbGVuZ3RoIGxpbWl0IChtYW5kYXRvcnkpO1xuZXhwb3J0cy51dGY4Ym9yZGVyID0gZnVuY3Rpb24gKGJ1ZiwgbWF4KSB7XG4gIHZhciBwb3M7XG5cbiAgbWF4ID0gbWF4IHx8IGJ1Zi5sZW5ndGg7XG4gIGlmIChtYXggPiBidWYubGVuZ3RoKSB7IG1heCA9IGJ1Zi5sZW5ndGg7IH1cblxuICAvLyBnbyBiYWNrIGZyb20gbGFzdCBwb3NpdGlvbiwgdW50aWwgc3RhcnQgb2Ygc2VxdWVuY2UgZm91bmRcbiAgcG9zID0gbWF4IC0gMTtcbiAgd2hpbGUgKHBvcyA+PSAwICYmIChidWZbcG9zXSAmIDB4QzApID09PSAweDgwKSB7IHBvcy0tOyB9XG5cbiAgLy8gVmVyeSBzbWFsbCBhbmQgYnJva2VuIHNlcXVlbmNlLFxuICAvLyByZXR1cm4gbWF4LCBiZWNhdXNlIHdlIHNob3VsZCByZXR1cm4gc29tZXRoaW5nIGFueXdheS5cbiAgaWYgKHBvcyA8IDApIHsgcmV0dXJuIG1heDsgfVxuXG4gIC8vIElmIHdlIGNhbWUgdG8gc3RhcnQgb2YgYnVmZmVyIC0gdGhhdCBtZWFucyBidWZmZXIgaXMgdG9vIHNtYWxsLFxuICAvLyByZXR1cm4gbWF4IHRvby5cbiAgaWYgKHBvcyA9PT0gMCkgeyByZXR1cm4gbWF4OyB9XG5cbiAgcmV0dXJuIChwb3MgKyBfdXRmOGxlbltidWZbcG9zXV0gPiBtYXgpID8gcG9zIDogbWF4O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG5mdW5jdGlvbiBaU3RyZWFtKCkge1xuICAvKiBuZXh0IGlucHV0IGJ5dGUgKi9cbiAgdGhpcy5pbnB1dCA9IG51bGw7IC8vIEpTIHNwZWNpZmljLCBiZWNhdXNlIHdlIGhhdmUgbm8gcG9pbnRlcnNcbiAgdGhpcy5uZXh0X2luID0gMDtcbiAgLyogbnVtYmVyIG9mIGJ5dGVzIGF2YWlsYWJsZSBhdCBpbnB1dCAqL1xuICB0aGlzLmF2YWlsX2luID0gMDtcbiAgLyogdG90YWwgbnVtYmVyIG9mIGlucHV0IGJ5dGVzIHJlYWQgc28gZmFyICovXG4gIHRoaXMudG90YWxfaW4gPSAwO1xuICAvKiBuZXh0IG91dHB1dCBieXRlIHNob3VsZCBiZSBwdXQgdGhlcmUgKi9cbiAgdGhpcy5vdXRwdXQgPSBudWxsOyAvLyBKUyBzcGVjaWZpYywgYmVjYXVzZSB3ZSBoYXZlIG5vIHBvaW50ZXJzXG4gIHRoaXMubmV4dF9vdXQgPSAwO1xuICAvKiByZW1haW5pbmcgZnJlZSBzcGFjZSBhdCBvdXRwdXQgKi9cbiAgdGhpcy5hdmFpbF9vdXQgPSAwO1xuICAvKiB0b3RhbCBudW1iZXIgb2YgYnl0ZXMgb3V0cHV0IHNvIGZhciAqL1xuICB0aGlzLnRvdGFsX291dCA9IDA7XG4gIC8qIGxhc3QgZXJyb3IgbWVzc2FnZSwgTlVMTCBpZiBubyBlcnJvciAqL1xuICB0aGlzLm1zZyA9ICcnLypaX05VTEwqLztcbiAgLyogbm90IHZpc2libGUgYnkgYXBwbGljYXRpb25zICovXG4gIHRoaXMuc3RhdGUgPSBudWxsO1xuICAvKiBiZXN0IGd1ZXNzIGFib3V0IHRoZSBkYXRhIHR5cGU6IGJpbmFyeSBvciB0ZXh0ICovXG4gIHRoaXMuZGF0YV90eXBlID0gMi8qWl9VTktOT1dOKi87XG4gIC8qIGFkbGVyMzIgdmFsdWUgb2YgdGhlIHVuY29tcHJlc3NlZCBkYXRhICovXG4gIHRoaXMuYWRsZXIgPSAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFpTdHJlYW07XG4iLCIndXNlIHN0cmljdCc7XG5cblxudmFyIHpsaWJfZGVmbGF0ZSA9IHJlcXVpcmUoJy4vemxpYi9kZWZsYXRlJyk7XG52YXIgdXRpbHMgICAgICAgID0gcmVxdWlyZSgnLi91dGlscy9jb21tb24nKTtcbnZhciBzdHJpbmdzICAgICAgPSByZXF1aXJlKCcuL3V0aWxzL3N0cmluZ3MnKTtcbnZhciBtc2cgICAgICAgICAgPSByZXF1aXJlKCcuL3psaWIvbWVzc2FnZXMnKTtcbnZhciBaU3RyZWFtICAgICAgPSByZXF1aXJlKCcuL3psaWIvenN0cmVhbScpO1xuXG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4vKiBQdWJsaWMgY29uc3RhbnRzID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxudmFyIFpfTk9fRkxVU0ggICAgICA9IDA7XG52YXIgWl9GSU5JU0ggICAgICAgID0gNDtcblxudmFyIFpfT0sgICAgICAgICAgICA9IDA7XG52YXIgWl9TVFJFQU1fRU5EICAgID0gMTtcbnZhciBaX1NZTkNfRkxVU0ggICAgPSAyO1xuXG52YXIgWl9ERUZBVUxUX0NPTVBSRVNTSU9OID0gLTE7XG5cbnZhciBaX0RFRkFVTFRfU1RSQVRFR1kgICAgPSAwO1xuXG52YXIgWl9ERUZMQVRFRCAgPSA4O1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5cbi8qKlxuICogY2xhc3MgRGVmbGF0ZVxuICpcbiAqIEdlbmVyaWMgSlMtc3R5bGUgd3JhcHBlciBmb3IgemxpYiBjYWxscy4gSWYgeW91IGRvbid0IG5lZWRcbiAqIHN0cmVhbWluZyBiZWhhdmlvdXIgLSB1c2UgbW9yZSBzaW1wbGUgZnVuY3Rpb25zOiBbW2RlZmxhdGVdXSxcbiAqIFtbZGVmbGF0ZVJhd11dIGFuZCBbW2d6aXBdXS5cbiAqKi9cblxuLyogaW50ZXJuYWxcbiAqIERlZmxhdGUuY2h1bmtzIC0+IEFycmF5XG4gKlxuICogQ2h1bmtzIG9mIG91dHB1dCBkYXRhLCBpZiBbW0RlZmxhdGUjb25EYXRhXV0gbm90IG92ZXJyaWRkZW4uXG4gKiovXG5cbi8qKlxuICogRGVmbGF0ZS5yZXN1bHQgLT4gVWludDhBcnJheXxBcnJheVxuICpcbiAqIENvbXByZXNzZWQgcmVzdWx0LCBnZW5lcmF0ZWQgYnkgZGVmYXVsdCBbW0RlZmxhdGUjb25EYXRhXV1cbiAqIGFuZCBbW0RlZmxhdGUjb25FbmRdXSBoYW5kbGVycy4gRmlsbGVkIGFmdGVyIHlvdSBwdXNoIGxhc3QgY2h1bmtcbiAqIChjYWxsIFtbRGVmbGF0ZSNwdXNoXV0gd2l0aCBgWl9GSU5JU0hgIC8gYHRydWVgIHBhcmFtKSAgb3IgaWYgeW91XG4gKiBwdXNoIGEgY2h1bmsgd2l0aCBleHBsaWNpdCBmbHVzaCAoY2FsbCBbW0RlZmxhdGUjcHVzaF1dIHdpdGhcbiAqIGBaX1NZTkNfRkxVU0hgIHBhcmFtKS5cbiAqKi9cblxuLyoqXG4gKiBEZWZsYXRlLmVyciAtPiBOdW1iZXJcbiAqXG4gKiBFcnJvciBjb2RlIGFmdGVyIGRlZmxhdGUgZmluaXNoZWQuIDAgKFpfT0spIG9uIHN1Y2Nlc3MuXG4gKiBZb3Ugd2lsbCBub3QgbmVlZCBpdCBpbiByZWFsIGxpZmUsIGJlY2F1c2UgZGVmbGF0ZSBlcnJvcnNcbiAqIGFyZSBwb3NzaWJsZSBvbmx5IG9uIHdyb25nIG9wdGlvbnMgb3IgYmFkIGBvbkRhdGFgIC8gYG9uRW5kYFxuICogY3VzdG9tIGhhbmRsZXJzLlxuICoqL1xuXG4vKipcbiAqIERlZmxhdGUubXNnIC0+IFN0cmluZ1xuICpcbiAqIEVycm9yIG1lc3NhZ2UsIGlmIFtbRGVmbGF0ZS5lcnJdXSAhPSAwXG4gKiovXG5cblxuLyoqXG4gKiBuZXcgRGVmbGF0ZShvcHRpb25zKVxuICogLSBvcHRpb25zIChPYmplY3QpOiB6bGliIGRlZmxhdGUgb3B0aW9ucy5cbiAqXG4gKiBDcmVhdGVzIG5ldyBkZWZsYXRvciBpbnN0YW5jZSB3aXRoIHNwZWNpZmllZCBwYXJhbXMuIFRocm93cyBleGNlcHRpb25cbiAqIG9uIGJhZCBwYXJhbXMuIFN1cHBvcnRlZCBvcHRpb25zOlxuICpcbiAqIC0gYGxldmVsYFxuICogLSBgd2luZG93Qml0c2BcbiAqIC0gYG1lbUxldmVsYFxuICogLSBgc3RyYXRlZ3lgXG4gKiAtIGBkaWN0aW9uYXJ5YFxuICpcbiAqIFtodHRwOi8vemxpYi5uZXQvbWFudWFsLmh0bWwjQWR2YW5jZWRdKGh0dHA6Ly96bGliLm5ldC9tYW51YWwuaHRtbCNBZHZhbmNlZClcbiAqIGZvciBtb3JlIGluZm9ybWF0aW9uIG9uIHRoZXNlLlxuICpcbiAqIEFkZGl0aW9uYWwgb3B0aW9ucywgZm9yIGludGVybmFsIG5lZWRzOlxuICpcbiAqIC0gYGNodW5rU2l6ZWAgLSBzaXplIG9mIGdlbmVyYXRlZCBkYXRhIGNodW5rcyAoMTZLIGJ5IGRlZmF1bHQpXG4gKiAtIGByYXdgIChCb29sZWFuKSAtIGRvIHJhdyBkZWZsYXRlXG4gKiAtIGBnemlwYCAoQm9vbGVhbikgLSBjcmVhdGUgZ3ppcCB3cmFwcGVyXG4gKiAtIGB0b2AgKFN0cmluZykgLSBpZiBlcXVhbCB0byAnc3RyaW5nJywgdGhlbiByZXN1bHQgd2lsbCBiZSBcImJpbmFyeSBzdHJpbmdcIlxuICogICAgKGVhY2ggY2hhciBjb2RlIFswLi4yNTVdKVxuICogLSBgaGVhZGVyYCAoT2JqZWN0KSAtIGN1c3RvbSBoZWFkZXIgZm9yIGd6aXBcbiAqICAgLSBgdGV4dGAgKEJvb2xlYW4pIC0gdHJ1ZSBpZiBjb21wcmVzc2VkIGRhdGEgYmVsaWV2ZWQgdG8gYmUgdGV4dFxuICogICAtIGB0aW1lYCAoTnVtYmVyKSAtIG1vZGlmaWNhdGlvbiB0aW1lLCB1bml4IHRpbWVzdGFtcFxuICogICAtIGBvc2AgKE51bWJlcikgLSBvcGVyYXRpb24gc3lzdGVtIGNvZGVcbiAqICAgLSBgZXh0cmFgIChBcnJheSkgLSBhcnJheSBvZiBieXRlcyB3aXRoIGV4dHJhIGRhdGEgKG1heCA2NTUzNilcbiAqICAgLSBgbmFtZWAgKFN0cmluZykgLSBmaWxlIG5hbWUgKGJpbmFyeSBzdHJpbmcpXG4gKiAgIC0gYGNvbW1lbnRgIChTdHJpbmcpIC0gY29tbWVudCAoYmluYXJ5IHN0cmluZylcbiAqICAgLSBgaGNyY2AgKEJvb2xlYW4pIC0gdHJ1ZSBpZiBoZWFkZXIgY3JjIHNob3VsZCBiZSBhZGRlZFxuICpcbiAqICMjIyMjIEV4YW1wbGU6XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogdmFyIHBha28gPSByZXF1aXJlKCdwYWtvJylcbiAqICAgLCBjaHVuazEgPSBVaW50OEFycmF5KFsxLDIsMyw0LDUsNiw3LDgsOV0pXG4gKiAgICwgY2h1bmsyID0gVWludDhBcnJheShbMTAsMTEsMTIsMTMsMTQsMTUsMTYsMTcsMTgsMTldKTtcbiAqXG4gKiB2YXIgZGVmbGF0ZSA9IG5ldyBwYWtvLkRlZmxhdGUoeyBsZXZlbDogM30pO1xuICpcbiAqIGRlZmxhdGUucHVzaChjaHVuazEsIGZhbHNlKTtcbiAqIGRlZmxhdGUucHVzaChjaHVuazIsIHRydWUpOyAgLy8gdHJ1ZSAtPiBsYXN0IGNodW5rXG4gKlxuICogaWYgKGRlZmxhdGUuZXJyKSB7IHRocm93IG5ldyBFcnJvcihkZWZsYXRlLmVycik7IH1cbiAqXG4gKiBjb25zb2xlLmxvZyhkZWZsYXRlLnJlc3VsdCk7XG4gKiBgYGBcbiAqKi9cbmZ1bmN0aW9uIERlZmxhdGUob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRGVmbGF0ZSkpIHJldHVybiBuZXcgRGVmbGF0ZShvcHRpb25zKTtcblxuICB0aGlzLm9wdGlvbnMgPSB1dGlscy5hc3NpZ24oe1xuICAgIGxldmVsOiBaX0RFRkFVTFRfQ09NUFJFU1NJT04sXG4gICAgbWV0aG9kOiBaX0RFRkxBVEVELFxuICAgIGNodW5rU2l6ZTogMTYzODQsXG4gICAgd2luZG93Qml0czogMTUsXG4gICAgbWVtTGV2ZWw6IDgsXG4gICAgc3RyYXRlZ3k6IFpfREVGQVVMVF9TVFJBVEVHWSxcbiAgICB0bzogJydcbiAgfSwgb3B0aW9ucyB8fCB7fSk7XG5cbiAgdmFyIG9wdCA9IHRoaXMub3B0aW9ucztcblxuICBpZiAob3B0LnJhdyAmJiAob3B0LndpbmRvd0JpdHMgPiAwKSkge1xuICAgIG9wdC53aW5kb3dCaXRzID0gLW9wdC53aW5kb3dCaXRzO1xuICB9XG5cbiAgZWxzZSBpZiAob3B0Lmd6aXAgJiYgKG9wdC53aW5kb3dCaXRzID4gMCkgJiYgKG9wdC53aW5kb3dCaXRzIDwgMTYpKSB7XG4gICAgb3B0LndpbmRvd0JpdHMgKz0gMTY7XG4gIH1cblxuICB0aGlzLmVyciAgICA9IDA7ICAgICAgLy8gZXJyb3IgY29kZSwgaWYgaGFwcGVucyAoMCA9IFpfT0spXG4gIHRoaXMubXNnICAgID0gJyc7ICAgICAvLyBlcnJvciBtZXNzYWdlXG4gIHRoaXMuZW5kZWQgID0gZmFsc2U7ICAvLyB1c2VkIHRvIGF2b2lkIG11bHRpcGxlIG9uRW5kKCkgY2FsbHNcbiAgdGhpcy5jaHVua3MgPSBbXTsgICAgIC8vIGNodW5rcyBvZiBjb21wcmVzc2VkIGRhdGFcblxuICB0aGlzLnN0cm0gPSBuZXcgWlN0cmVhbSgpO1xuICB0aGlzLnN0cm0uYXZhaWxfb3V0ID0gMDtcblxuICB2YXIgc3RhdHVzID0gemxpYl9kZWZsYXRlLmRlZmxhdGVJbml0MihcbiAgICB0aGlzLnN0cm0sXG4gICAgb3B0LmxldmVsLFxuICAgIG9wdC5tZXRob2QsXG4gICAgb3B0LndpbmRvd0JpdHMsXG4gICAgb3B0Lm1lbUxldmVsLFxuICAgIG9wdC5zdHJhdGVneVxuICApO1xuXG4gIGlmIChzdGF0dXMgIT09IFpfT0spIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IobXNnW3N0YXR1c10pO1xuICB9XG5cbiAgaWYgKG9wdC5oZWFkZXIpIHtcbiAgICB6bGliX2RlZmxhdGUuZGVmbGF0ZVNldEhlYWRlcih0aGlzLnN0cm0sIG9wdC5oZWFkZXIpO1xuICB9XG5cbiAgaWYgKG9wdC5kaWN0aW9uYXJ5KSB7XG4gICAgdmFyIGRpY3Q7XG4gICAgLy8gQ29udmVydCBkYXRhIGlmIG5lZWRlZFxuICAgIGlmICh0eXBlb2Ygb3B0LmRpY3Rpb25hcnkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBJZiB3ZSBuZWVkIHRvIGNvbXByZXNzIHRleHQsIGNoYW5nZSBlbmNvZGluZyB0byB1dGY4LlxuICAgICAgZGljdCA9IHN0cmluZ3Muc3RyaW5nMmJ1ZihvcHQuZGljdGlvbmFyeSk7XG4gICAgfSBlbHNlIGlmICh0b1N0cmluZy5jYWxsKG9wdC5kaWN0aW9uYXJ5KSA9PT0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJykge1xuICAgICAgZGljdCA9IG5ldyBVaW50OEFycmF5KG9wdC5kaWN0aW9uYXJ5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGljdCA9IG9wdC5kaWN0aW9uYXJ5O1xuICAgIH1cblxuICAgIHN0YXR1cyA9IHpsaWJfZGVmbGF0ZS5kZWZsYXRlU2V0RGljdGlvbmFyeSh0aGlzLnN0cm0sIGRpY3QpO1xuXG4gICAgaWYgKHN0YXR1cyAhPT0gWl9PSykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZ1tzdGF0dXNdKTtcbiAgICB9XG5cbiAgICB0aGlzLl9kaWN0X3NldCA9IHRydWU7XG4gIH1cbn1cblxuLyoqXG4gKiBEZWZsYXRlI3B1c2goZGF0YVssIG1vZGVdKSAtPiBCb29sZWFuXG4gKiAtIGRhdGEgKFVpbnQ4QXJyYXl8QXJyYXl8QXJyYXlCdWZmZXJ8U3RyaW5nKTogaW5wdXQgZGF0YS4gU3RyaW5ncyB3aWxsIGJlXG4gKiAgIGNvbnZlcnRlZCB0byB1dGY4IGJ5dGUgc2VxdWVuY2UuXG4gKiAtIG1vZGUgKE51bWJlcnxCb29sZWFuKTogMC4uNiBmb3IgY29ycmVzcG9uZGluZyBaX05PX0ZMVVNILi5aX1RSRUUgbW9kZXMuXG4gKiAgIFNlZSBjb25zdGFudHMuIFNraXBwZWQgb3IgYGZhbHNlYCBtZWFucyBaX05PX0ZMVVNILCBgdHJ1ZWAgbWVhbnMgWl9GSU5JU0guXG4gKlxuICogU2VuZHMgaW5wdXQgZGF0YSB0byBkZWZsYXRlIHBpcGUsIGdlbmVyYXRpbmcgW1tEZWZsYXRlI29uRGF0YV1dIGNhbGxzIHdpdGhcbiAqIG5ldyBjb21wcmVzc2VkIGNodW5rcy4gUmV0dXJucyBgdHJ1ZWAgb24gc3VjY2Vzcy4gVGhlIGxhc3QgZGF0YSBibG9jayBtdXN0IGhhdmVcbiAqIG1vZGUgWl9GSU5JU0ggKG9yIGB0cnVlYCkuIFRoYXQgd2lsbCBmbHVzaCBpbnRlcm5hbCBwZW5kaW5nIGJ1ZmZlcnMgYW5kIGNhbGxcbiAqIFtbRGVmbGF0ZSNvbkVuZF1dLiBGb3IgaW50ZXJpbSBleHBsaWNpdCBmbHVzaGVzICh3aXRob3V0IGVuZGluZyB0aGUgc3RyZWFtKSB5b3VcbiAqIGNhbiB1c2UgbW9kZSBaX1NZTkNfRkxVU0gsIGtlZXBpbmcgdGhlIGNvbXByZXNzaW9uIGNvbnRleHQuXG4gKlxuICogT24gZmFpbCBjYWxsIFtbRGVmbGF0ZSNvbkVuZF1dIHdpdGggZXJyb3IgY29kZSBhbmQgcmV0dXJuIGZhbHNlLlxuICpcbiAqIFdlIHN0cm9uZ2x5IHJlY29tbWVuZCB0byB1c2UgYFVpbnQ4QXJyYXlgIG9uIGlucHV0IGZvciBiZXN0IHNwZWVkIChvdXRwdXRcbiAqIGFycmF5IGZvcm1hdCBpcyBkZXRlY3RlZCBhdXRvbWF0aWNhbGx5KS4gQWxzbywgZG9uJ3Qgc2tpcCBsYXN0IHBhcmFtIGFuZCBhbHdheXNcbiAqIHVzZSB0aGUgc2FtZSB0eXBlIGluIHlvdXIgY29kZSAoYm9vbGVhbiBvciBudW1iZXIpLiBUaGF0IHdpbGwgaW1wcm92ZSBKUyBzcGVlZC5cbiAqXG4gKiBGb3IgcmVndWxhciBgQXJyYXlgLXMgbWFrZSBzdXJlIGFsbCBlbGVtZW50cyBhcmUgWzAuLjI1NV0uXG4gKlxuICogIyMjIyMgRXhhbXBsZVxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHB1c2goY2h1bmssIGZhbHNlKTsgLy8gcHVzaCBvbmUgb2YgZGF0YSBjaHVua3NcbiAqIC4uLlxuICogcHVzaChjaHVuaywgdHJ1ZSk7ICAvLyBwdXNoIGxhc3QgY2h1bmtcbiAqIGBgYFxuICoqL1xuRGVmbGF0ZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChkYXRhLCBtb2RlKSB7XG4gIHZhciBzdHJtID0gdGhpcy5zdHJtO1xuICB2YXIgY2h1bmtTaXplID0gdGhpcy5vcHRpb25zLmNodW5rU2l6ZTtcbiAgdmFyIHN0YXR1cywgX21vZGU7XG5cbiAgaWYgKHRoaXMuZW5kZWQpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgX21vZGUgPSAobW9kZSA9PT0gfn5tb2RlKSA/IG1vZGUgOiAoKG1vZGUgPT09IHRydWUpID8gWl9GSU5JU0ggOiBaX05PX0ZMVVNIKTtcblxuICAvLyBDb252ZXJ0IGRhdGEgaWYgbmVlZGVkXG4gIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAvLyBJZiB3ZSBuZWVkIHRvIGNvbXByZXNzIHRleHQsIGNoYW5nZSBlbmNvZGluZyB0byB1dGY4LlxuICAgIHN0cm0uaW5wdXQgPSBzdHJpbmdzLnN0cmluZzJidWYoZGF0YSk7XG4gIH0gZWxzZSBpZiAodG9TdHJpbmcuY2FsbChkYXRhKSA9PT0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJykge1xuICAgIHN0cm0uaW5wdXQgPSBuZXcgVWludDhBcnJheShkYXRhKTtcbiAgfSBlbHNlIHtcbiAgICBzdHJtLmlucHV0ID0gZGF0YTtcbiAgfVxuXG4gIHN0cm0ubmV4dF9pbiA9IDA7XG4gIHN0cm0uYXZhaWxfaW4gPSBzdHJtLmlucHV0Lmxlbmd0aDtcblxuICBkbyB7XG4gICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICBzdHJtLm91dHB1dCA9IG5ldyB1dGlscy5CdWY4KGNodW5rU2l6ZSk7XG4gICAgICBzdHJtLm5leHRfb3V0ID0gMDtcbiAgICAgIHN0cm0uYXZhaWxfb3V0ID0gY2h1bmtTaXplO1xuICAgIH1cbiAgICBzdGF0dXMgPSB6bGliX2RlZmxhdGUuZGVmbGF0ZShzdHJtLCBfbW9kZSk7ICAgIC8qIG5vIGJhZCByZXR1cm4gdmFsdWUgKi9cblxuICAgIGlmIChzdGF0dXMgIT09IFpfU1RSRUFNX0VORCAmJiBzdGF0dXMgIT09IFpfT0spIHtcbiAgICAgIHRoaXMub25FbmQoc3RhdHVzKTtcbiAgICAgIHRoaXMuZW5kZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDAgfHwgKHN0cm0uYXZhaWxfaW4gPT09IDAgJiYgKF9tb2RlID09PSBaX0ZJTklTSCB8fCBfbW9kZSA9PT0gWl9TWU5DX0ZMVVNIKSkpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMudG8gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRoaXMub25EYXRhKHN0cmluZ3MuYnVmMmJpbnN0cmluZyh1dGlscy5zaHJpbmtCdWYoc3RybS5vdXRwdXQsIHN0cm0ubmV4dF9vdXQpKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm9uRGF0YSh1dGlscy5zaHJpbmtCdWYoc3RybS5vdXRwdXQsIHN0cm0ubmV4dF9vdXQpKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gd2hpbGUgKChzdHJtLmF2YWlsX2luID4gMCB8fCBzdHJtLmF2YWlsX291dCA9PT0gMCkgJiYgc3RhdHVzICE9PSBaX1NUUkVBTV9FTkQpO1xuXG4gIC8vIEZpbmFsaXplIG9uIHRoZSBsYXN0IGNodW5rLlxuICBpZiAoX21vZGUgPT09IFpfRklOSVNIKSB7XG4gICAgc3RhdHVzID0gemxpYl9kZWZsYXRlLmRlZmxhdGVFbmQodGhpcy5zdHJtKTtcbiAgICB0aGlzLm9uRW5kKHN0YXR1cyk7XG4gICAgdGhpcy5lbmRlZCA9IHRydWU7XG4gICAgcmV0dXJuIHN0YXR1cyA9PT0gWl9PSztcbiAgfVxuXG4gIC8vIGNhbGxiYWNrIGludGVyaW0gcmVzdWx0cyBpZiBaX1NZTkNfRkxVU0guXG4gIGlmIChfbW9kZSA9PT0gWl9TWU5DX0ZMVVNIKSB7XG4gICAgdGhpcy5vbkVuZChaX09LKTtcbiAgICBzdHJtLmF2YWlsX291dCA9IDA7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuLyoqXG4gKiBEZWZsYXRlI29uRGF0YShjaHVuaykgLT4gVm9pZFxuICogLSBjaHVuayAoVWludDhBcnJheXxBcnJheXxTdHJpbmcpOiBvdXRwdXQgZGF0YS4gVHlwZSBvZiBhcnJheSBkZXBlbmRzXG4gKiAgIG9uIGpzIGVuZ2luZSBzdXBwb3J0LiBXaGVuIHN0cmluZyBvdXRwdXQgcmVxdWVzdGVkLCBlYWNoIGNodW5rXG4gKiAgIHdpbGwgYmUgc3RyaW5nLlxuICpcbiAqIEJ5IGRlZmF1bHQsIHN0b3JlcyBkYXRhIGJsb2NrcyBpbiBgY2h1bmtzW11gIHByb3BlcnR5IGFuZCBnbHVlXG4gKiB0aG9zZSBpbiBgb25FbmRgLiBPdmVycmlkZSB0aGlzIGhhbmRsZXIsIGlmIHlvdSBuZWVkIGFub3RoZXIgYmVoYXZpb3VyLlxuICoqL1xuRGVmbGF0ZS5wcm90b3R5cGUub25EYXRhID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gIHRoaXMuY2h1bmtzLnB1c2goY2h1bmspO1xufTtcblxuXG4vKipcbiAqIERlZmxhdGUjb25FbmQoc3RhdHVzKSAtPiBWb2lkXG4gKiAtIHN0YXR1cyAoTnVtYmVyKTogZGVmbGF0ZSBzdGF0dXMuIDAgKFpfT0spIG9uIHN1Y2Nlc3MsXG4gKiAgIG90aGVyIGlmIG5vdC5cbiAqXG4gKiBDYWxsZWQgb25jZSBhZnRlciB5b3UgdGVsbCBkZWZsYXRlIHRoYXQgdGhlIGlucHV0IHN0cmVhbSBpc1xuICogY29tcGxldGUgKFpfRklOSVNIKSBvciBzaG91bGQgYmUgZmx1c2hlZCAoWl9TWU5DX0ZMVVNIKVxuICogb3IgaWYgYW4gZXJyb3IgaGFwcGVuZWQuIEJ5IGRlZmF1bHQgLSBqb2luIGNvbGxlY3RlZCBjaHVua3MsXG4gKiBmcmVlIG1lbW9yeSBhbmQgZmlsbCBgcmVzdWx0c2AgLyBgZXJyYCBwcm9wZXJ0aWVzLlxuICoqL1xuRGVmbGF0ZS5wcm90b3R5cGUub25FbmQgPSBmdW5jdGlvbiAoc3RhdHVzKSB7XG4gIC8vIE9uIHN1Y2Nlc3MgLSBqb2luXG4gIGlmIChzdGF0dXMgPT09IFpfT0spIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLnRvID09PSAnc3RyaW5nJykge1xuICAgICAgdGhpcy5yZXN1bHQgPSB0aGlzLmNodW5rcy5qb2luKCcnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZXN1bHQgPSB1dGlscy5mbGF0dGVuQ2h1bmtzKHRoaXMuY2h1bmtzKTtcbiAgICB9XG4gIH1cbiAgdGhpcy5jaHVua3MgPSBbXTtcbiAgdGhpcy5lcnIgPSBzdGF0dXM7XG4gIHRoaXMubXNnID0gdGhpcy5zdHJtLm1zZztcbn07XG5cblxuLyoqXG4gKiBkZWZsYXRlKGRhdGFbLCBvcHRpb25zXSkgLT4gVWludDhBcnJheXxBcnJheXxTdHJpbmdcbiAqIC0gZGF0YSAoVWludDhBcnJheXxBcnJheXxTdHJpbmcpOiBpbnB1dCBkYXRhIHRvIGNvbXByZXNzLlxuICogLSBvcHRpb25zIChPYmplY3QpOiB6bGliIGRlZmxhdGUgb3B0aW9ucy5cbiAqXG4gKiBDb21wcmVzcyBgZGF0YWAgd2l0aCBkZWZsYXRlIGFsZ29yaXRobSBhbmQgYG9wdGlvbnNgLlxuICpcbiAqIFN1cHBvcnRlZCBvcHRpb25zIGFyZTpcbiAqXG4gKiAtIGxldmVsXG4gKiAtIHdpbmRvd0JpdHNcbiAqIC0gbWVtTGV2ZWxcbiAqIC0gc3RyYXRlZ3lcbiAqIC0gZGljdGlvbmFyeVxuICpcbiAqIFtodHRwOi8vemxpYi5uZXQvbWFudWFsLmh0bWwjQWR2YW5jZWRdKGh0dHA6Ly96bGliLm5ldC9tYW51YWwuaHRtbCNBZHZhbmNlZClcbiAqIGZvciBtb3JlIGluZm9ybWF0aW9uIG9uIHRoZXNlLlxuICpcbiAqIFN1Z2FyIChvcHRpb25zKTpcbiAqXG4gKiAtIGByYXdgIChCb29sZWFuKSAtIHNheSB0aGF0IHdlIHdvcmsgd2l0aCByYXcgc3RyZWFtLCBpZiB5b3UgZG9uJ3Qgd2lzaCB0byBzcGVjaWZ5XG4gKiAgIG5lZ2F0aXZlIHdpbmRvd0JpdHMgaW1wbGljaXRseS5cbiAqIC0gYHRvYCAoU3RyaW5nKSAtIGlmIGVxdWFsIHRvICdzdHJpbmcnLCB0aGVuIHJlc3VsdCB3aWxsIGJlIFwiYmluYXJ5IHN0cmluZ1wiXG4gKiAgICAoZWFjaCBjaGFyIGNvZGUgWzAuLjI1NV0pXG4gKlxuICogIyMjIyMgRXhhbXBsZTpcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiB2YXIgcGFrbyA9IHJlcXVpcmUoJ3Bha28nKVxuICogICAsIGRhdGEgPSBVaW50OEFycmF5KFsxLDIsMyw0LDUsNiw3LDgsOV0pO1xuICpcbiAqIGNvbnNvbGUubG9nKHBha28uZGVmbGF0ZShkYXRhKSk7XG4gKiBgYGBcbiAqKi9cbmZ1bmN0aW9uIGRlZmxhdGUoaW5wdXQsIG9wdGlvbnMpIHtcbiAgdmFyIGRlZmxhdG9yID0gbmV3IERlZmxhdGUob3B0aW9ucyk7XG5cbiAgZGVmbGF0b3IucHVzaChpbnB1dCwgdHJ1ZSk7XG5cbiAgLy8gVGhhdCB3aWxsIG5ldmVyIGhhcHBlbnMsIGlmIHlvdSBkb24ndCBjaGVhdCB3aXRoIG9wdGlvbnMgOilcbiAgaWYgKGRlZmxhdG9yLmVycikgeyB0aHJvdyBkZWZsYXRvci5tc2cgfHwgbXNnW2RlZmxhdG9yLmVycl07IH1cblxuICByZXR1cm4gZGVmbGF0b3IucmVzdWx0O1xufVxuXG5cbi8qKlxuICogZGVmbGF0ZVJhdyhkYXRhWywgb3B0aW9uc10pIC0+IFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nXG4gKiAtIGRhdGEgKFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nKTogaW5wdXQgZGF0YSB0byBjb21wcmVzcy5cbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogemxpYiBkZWZsYXRlIG9wdGlvbnMuXG4gKlxuICogVGhlIHNhbWUgYXMgW1tkZWZsYXRlXV0sIGJ1dCBjcmVhdGVzIHJhdyBkYXRhLCB3aXRob3V0IHdyYXBwZXJcbiAqIChoZWFkZXIgYW5kIGFkbGVyMzIgY3JjKS5cbiAqKi9cbmZ1bmN0aW9uIGRlZmxhdGVSYXcoaW5wdXQsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIG9wdGlvbnMucmF3ID0gdHJ1ZTtcbiAgcmV0dXJuIGRlZmxhdGUoaW5wdXQsIG9wdGlvbnMpO1xufVxuXG5cbi8qKlxuICogZ3ppcChkYXRhWywgb3B0aW9uc10pIC0+IFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nXG4gKiAtIGRhdGEgKFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nKTogaW5wdXQgZGF0YSB0byBjb21wcmVzcy5cbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogemxpYiBkZWZsYXRlIG9wdGlvbnMuXG4gKlxuICogVGhlIHNhbWUgYXMgW1tkZWZsYXRlXV0sIGJ1dCBjcmVhdGUgZ3ppcCB3cmFwcGVyIGluc3RlYWQgb2ZcbiAqIGRlZmxhdGUgb25lLlxuICoqL1xuZnVuY3Rpb24gZ3ppcChpbnB1dCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgb3B0aW9ucy5nemlwID0gdHJ1ZTtcbiAgcmV0dXJuIGRlZmxhdGUoaW5wdXQsIG9wdGlvbnMpO1xufVxuXG5cbmV4cG9ydHMuRGVmbGF0ZSA9IERlZmxhdGU7XG5leHBvcnRzLmRlZmxhdGUgPSBkZWZsYXRlO1xuZXhwb3J0cy5kZWZsYXRlUmF3ID0gZGVmbGF0ZVJhdztcbmV4cG9ydHMuZ3ppcCA9IGd6aXA7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxuLy8gU2VlIHN0YXRlIGRlZnMgZnJvbSBpbmZsYXRlLmpzXG52YXIgQkFEID0gMzA7ICAgICAgIC8qIGdvdCBhIGRhdGEgZXJyb3IgLS0gcmVtYWluIGhlcmUgdW50aWwgcmVzZXQgKi9cbnZhciBUWVBFID0gMTI7ICAgICAgLyogaTogd2FpdGluZyBmb3IgdHlwZSBiaXRzLCBpbmNsdWRpbmcgbGFzdC1mbGFnIGJpdCAqL1xuXG4vKlxuICAgRGVjb2RlIGxpdGVyYWwsIGxlbmd0aCwgYW5kIGRpc3RhbmNlIGNvZGVzIGFuZCB3cml0ZSBvdXQgdGhlIHJlc3VsdGluZ1xuICAgbGl0ZXJhbCBhbmQgbWF0Y2ggYnl0ZXMgdW50aWwgZWl0aGVyIG5vdCBlbm91Z2ggaW5wdXQgb3Igb3V0cHV0IGlzXG4gICBhdmFpbGFibGUsIGFuIGVuZC1vZi1ibG9jayBpcyBlbmNvdW50ZXJlZCwgb3IgYSBkYXRhIGVycm9yIGlzIGVuY291bnRlcmVkLlxuICAgV2hlbiBsYXJnZSBlbm91Z2ggaW5wdXQgYW5kIG91dHB1dCBidWZmZXJzIGFyZSBzdXBwbGllZCB0byBpbmZsYXRlKCksIGZvclxuICAgZXhhbXBsZSwgYSAxNksgaW5wdXQgYnVmZmVyIGFuZCBhIDY0SyBvdXRwdXQgYnVmZmVyLCBtb3JlIHRoYW4gOTUlIG9mIHRoZVxuICAgaW5mbGF0ZSBleGVjdXRpb24gdGltZSBpcyBzcGVudCBpbiB0aGlzIHJvdXRpbmUuXG5cbiAgIEVudHJ5IGFzc3VtcHRpb25zOlxuXG4gICAgICAgIHN0YXRlLm1vZGUgPT09IExFTlxuICAgICAgICBzdHJtLmF2YWlsX2luID49IDZcbiAgICAgICAgc3RybS5hdmFpbF9vdXQgPj0gMjU4XG4gICAgICAgIHN0YXJ0ID49IHN0cm0uYXZhaWxfb3V0XG4gICAgICAgIHN0YXRlLmJpdHMgPCA4XG5cbiAgIE9uIHJldHVybiwgc3RhdGUubW9kZSBpcyBvbmUgb2Y6XG5cbiAgICAgICAgTEVOIC0tIHJhbiBvdXQgb2YgZW5vdWdoIG91dHB1dCBzcGFjZSBvciBlbm91Z2ggYXZhaWxhYmxlIGlucHV0XG4gICAgICAgIFRZUEUgLS0gcmVhY2hlZCBlbmQgb2YgYmxvY2sgY29kZSwgaW5mbGF0ZSgpIHRvIGludGVycHJldCBuZXh0IGJsb2NrXG4gICAgICAgIEJBRCAtLSBlcnJvciBpbiBibG9jayBkYXRhXG5cbiAgIE5vdGVzOlxuXG4gICAgLSBUaGUgbWF4aW11bSBpbnB1dCBiaXRzIHVzZWQgYnkgYSBsZW5ndGgvZGlzdGFuY2UgcGFpciBpcyAxNSBiaXRzIGZvciB0aGVcbiAgICAgIGxlbmd0aCBjb2RlLCA1IGJpdHMgZm9yIHRoZSBsZW5ndGggZXh0cmEsIDE1IGJpdHMgZm9yIHRoZSBkaXN0YW5jZSBjb2RlLFxuICAgICAgYW5kIDEzIGJpdHMgZm9yIHRoZSBkaXN0YW5jZSBleHRyYS4gIFRoaXMgdG90YWxzIDQ4IGJpdHMsIG9yIHNpeCBieXRlcy5cbiAgICAgIFRoZXJlZm9yZSBpZiBzdHJtLmF2YWlsX2luID49IDYsIHRoZW4gdGhlcmUgaXMgZW5vdWdoIGlucHV0IHRvIGF2b2lkXG4gICAgICBjaGVja2luZyBmb3IgYXZhaWxhYmxlIGlucHV0IHdoaWxlIGRlY29kaW5nLlxuXG4gICAgLSBUaGUgbWF4aW11bSBieXRlcyB0aGF0IGEgc2luZ2xlIGxlbmd0aC9kaXN0YW5jZSBwYWlyIGNhbiBvdXRwdXQgaXMgMjU4XG4gICAgICBieXRlcywgd2hpY2ggaXMgdGhlIG1heGltdW0gbGVuZ3RoIHRoYXQgY2FuIGJlIGNvZGVkLiAgaW5mbGF0ZV9mYXN0KClcbiAgICAgIHJlcXVpcmVzIHN0cm0uYXZhaWxfb3V0ID49IDI1OCBmb3IgZWFjaCBsb29wIHRvIGF2b2lkIGNoZWNraW5nIGZvclxuICAgICAgb3V0cHV0IHNwYWNlLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluZmxhdGVfZmFzdChzdHJtLCBzdGFydCkge1xuICB2YXIgc3RhdGU7XG4gIHZhciBfaW47ICAgICAgICAgICAgICAgICAgICAvKiBsb2NhbCBzdHJtLmlucHV0ICovXG4gIHZhciBsYXN0OyAgICAgICAgICAgICAgICAgICAvKiBoYXZlIGVub3VnaCBpbnB1dCB3aGlsZSBpbiA8IGxhc3QgKi9cbiAgdmFyIF9vdXQ7ICAgICAgICAgICAgICAgICAgIC8qIGxvY2FsIHN0cm0ub3V0cHV0ICovXG4gIHZhciBiZWc7ICAgICAgICAgICAgICAgICAgICAvKiBpbmZsYXRlKCkncyBpbml0aWFsIHN0cm0ub3V0cHV0ICovXG4gIHZhciBlbmQ7ICAgICAgICAgICAgICAgICAgICAvKiB3aGlsZSBvdXQgPCBlbmQsIGVub3VnaCBzcGFjZSBhdmFpbGFibGUgKi9cbi8vI2lmZGVmIElORkxBVEVfU1RSSUNUXG4gIHZhciBkbWF4OyAgICAgICAgICAgICAgICAgICAvKiBtYXhpbXVtIGRpc3RhbmNlIGZyb20gemxpYiBoZWFkZXIgKi9cbi8vI2VuZGlmXG4gIHZhciB3c2l6ZTsgICAgICAgICAgICAgICAgICAvKiB3aW5kb3cgc2l6ZSBvciB6ZXJvIGlmIG5vdCB1c2luZyB3aW5kb3cgKi9cbiAgdmFyIHdoYXZlOyAgICAgICAgICAgICAgICAgIC8qIHZhbGlkIGJ5dGVzIGluIHRoZSB3aW5kb3cgKi9cbiAgdmFyIHduZXh0OyAgICAgICAgICAgICAgICAgIC8qIHdpbmRvdyB3cml0ZSBpbmRleCAqL1xuICAvLyBVc2UgYHNfd2luZG93YCBpbnN0ZWFkIGB3aW5kb3dgLCBhdm9pZCBjb25mbGljdCB3aXRoIGluc3RydW1lbnRhdGlvbiB0b29sc1xuICB2YXIgc193aW5kb3c7ICAgICAgICAgICAgICAgLyogYWxsb2NhdGVkIHNsaWRpbmcgd2luZG93LCBpZiB3c2l6ZSAhPSAwICovXG4gIHZhciBob2xkOyAgICAgICAgICAgICAgICAgICAvKiBsb2NhbCBzdHJtLmhvbGQgKi9cbiAgdmFyIGJpdHM7ICAgICAgICAgICAgICAgICAgIC8qIGxvY2FsIHN0cm0uYml0cyAqL1xuICB2YXIgbGNvZGU7ICAgICAgICAgICAgICAgICAgLyogbG9jYWwgc3RybS5sZW5jb2RlICovXG4gIHZhciBkY29kZTsgICAgICAgICAgICAgICAgICAvKiBsb2NhbCBzdHJtLmRpc3Rjb2RlICovXG4gIHZhciBsbWFzazsgICAgICAgICAgICAgICAgICAvKiBtYXNrIGZvciBmaXJzdCBsZXZlbCBvZiBsZW5ndGggY29kZXMgKi9cbiAgdmFyIGRtYXNrOyAgICAgICAgICAgICAgICAgIC8qIG1hc2sgZm9yIGZpcnN0IGxldmVsIG9mIGRpc3RhbmNlIGNvZGVzICovXG4gIHZhciBoZXJlOyAgICAgICAgICAgICAgICAgICAvKiByZXRyaWV2ZWQgdGFibGUgZW50cnkgKi9cbiAgdmFyIG9wOyAgICAgICAgICAgICAgICAgICAgIC8qIGNvZGUgYml0cywgb3BlcmF0aW9uLCBleHRyYSBiaXRzLCBvciAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogIHdpbmRvdyBwb3NpdGlvbiwgd2luZG93IGJ5dGVzIHRvIGNvcHkgKi9cbiAgdmFyIGxlbjsgICAgICAgICAgICAgICAgICAgIC8qIG1hdGNoIGxlbmd0aCwgdW51c2VkIGJ5dGVzICovXG4gIHZhciBkaXN0OyAgICAgICAgICAgICAgICAgICAvKiBtYXRjaCBkaXN0YW5jZSAqL1xuICB2YXIgZnJvbTsgICAgICAgICAgICAgICAgICAgLyogd2hlcmUgdG8gY29weSBtYXRjaCBmcm9tICovXG4gIHZhciBmcm9tX3NvdXJjZTtcblxuXG4gIHZhciBpbnB1dCwgb3V0cHV0OyAvLyBKUyBzcGVjaWZpYywgYmVjYXVzZSB3ZSBoYXZlIG5vIHBvaW50ZXJzXG5cbiAgLyogY29weSBzdGF0ZSB0byBsb2NhbCB2YXJpYWJsZXMgKi9cbiAgc3RhdGUgPSBzdHJtLnN0YXRlO1xuICAvL2hlcmUgPSBzdGF0ZS5oZXJlO1xuICBfaW4gPSBzdHJtLm5leHRfaW47XG4gIGlucHV0ID0gc3RybS5pbnB1dDtcbiAgbGFzdCA9IF9pbiArIChzdHJtLmF2YWlsX2luIC0gNSk7XG4gIF9vdXQgPSBzdHJtLm5leHRfb3V0O1xuICBvdXRwdXQgPSBzdHJtLm91dHB1dDtcbiAgYmVnID0gX291dCAtIChzdGFydCAtIHN0cm0uYXZhaWxfb3V0KTtcbiAgZW5kID0gX291dCArIChzdHJtLmF2YWlsX291dCAtIDI1Nyk7XG4vLyNpZmRlZiBJTkZMQVRFX1NUUklDVFxuICBkbWF4ID0gc3RhdGUuZG1heDtcbi8vI2VuZGlmXG4gIHdzaXplID0gc3RhdGUud3NpemU7XG4gIHdoYXZlID0gc3RhdGUud2hhdmU7XG4gIHduZXh0ID0gc3RhdGUud25leHQ7XG4gIHNfd2luZG93ID0gc3RhdGUud2luZG93O1xuICBob2xkID0gc3RhdGUuaG9sZDtcbiAgYml0cyA9IHN0YXRlLmJpdHM7XG4gIGxjb2RlID0gc3RhdGUubGVuY29kZTtcbiAgZGNvZGUgPSBzdGF0ZS5kaXN0Y29kZTtcbiAgbG1hc2sgPSAoMSA8PCBzdGF0ZS5sZW5iaXRzKSAtIDE7XG4gIGRtYXNrID0gKDEgPDwgc3RhdGUuZGlzdGJpdHMpIC0gMTtcblxuXG4gIC8qIGRlY29kZSBsaXRlcmFscyBhbmQgbGVuZ3RoL2Rpc3RhbmNlcyB1bnRpbCBlbmQtb2YtYmxvY2sgb3Igbm90IGVub3VnaFxuICAgICBpbnB1dCBkYXRhIG9yIG91dHB1dCBzcGFjZSAqL1xuXG4gIHRvcDpcbiAgZG8ge1xuICAgIGlmIChiaXRzIDwgMTUpIHtcbiAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7XG4gICAgICBiaXRzICs9IDg7XG4gICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzO1xuICAgICAgYml0cyArPSA4O1xuICAgIH1cblxuICAgIGhlcmUgPSBsY29kZVtob2xkICYgbG1hc2tdO1xuXG4gICAgZG9sZW46XG4gICAgZm9yICg7OykgeyAvLyBHb3RvIGVtdWxhdGlvblxuICAgICAgb3AgPSBoZXJlID4+PiAyNC8qaGVyZS5iaXRzKi87XG4gICAgICBob2xkID4+Pj0gb3A7XG4gICAgICBiaXRzIC09IG9wO1xuICAgICAgb3AgPSAoaGVyZSA+Pj4gMTYpICYgMHhmZi8qaGVyZS5vcCovO1xuICAgICAgaWYgKG9wID09PSAwKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBsaXRlcmFsICovXG4gICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBoZXJlLnZhbCA+PSAweDIwICYmIGhlcmUudmFsIDwgMHg3ZiA/XG4gICAgICAgIC8vICAgICAgICBcImluZmxhdGU6ICAgICAgICAgbGl0ZXJhbCAnJWMnXFxuXCIgOlxuICAgICAgICAvLyAgICAgICAgXCJpbmZsYXRlOiAgICAgICAgIGxpdGVyYWwgMHglMDJ4XFxuXCIsIGhlcmUudmFsKSk7XG4gICAgICAgIG91dHB1dFtfb3V0KytdID0gaGVyZSAmIDB4ZmZmZi8qaGVyZS52YWwqLztcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKG9wICYgMTYpIHsgICAgICAgICAgICAgICAgICAgICAvKiBsZW5ndGggYmFzZSAqL1xuICAgICAgICBsZW4gPSBoZXJlICYgMHhmZmZmLypoZXJlLnZhbCovO1xuICAgICAgICBvcCAmPSAxNTsgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgZXh0cmEgYml0cyAqL1xuICAgICAgICBpZiAob3ApIHtcbiAgICAgICAgICBpZiAoYml0cyA8IG9wKSB7XG4gICAgICAgICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZW4gKz0gaG9sZCAmICgoMSA8PCBvcCkgLSAxKTtcbiAgICAgICAgICBob2xkID4+Pj0gb3A7XG4gICAgICAgICAgYml0cyAtPSBvcDtcbiAgICAgICAgfVxuICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICAgIGxlbmd0aCAldVxcblwiLCBsZW4pKTtcbiAgICAgICAgaWYgKGJpdHMgPCAxNSkge1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIGhlcmUgPSBkY29kZVtob2xkICYgZG1hc2tdO1xuXG4gICAgICAgIGRvZGlzdDpcbiAgICAgICAgZm9yICg7OykgeyAvLyBnb3RvIGVtdWxhdGlvblxuICAgICAgICAgIG9wID0gaGVyZSA+Pj4gMjQvKmhlcmUuYml0cyovO1xuICAgICAgICAgIGhvbGQgPj4+PSBvcDtcbiAgICAgICAgICBiaXRzIC09IG9wO1xuICAgICAgICAgIG9wID0gKGhlcmUgPj4+IDE2KSAmIDB4ZmYvKmhlcmUub3AqLztcblxuICAgICAgICAgIGlmIChvcCAmIDE2KSB7ICAgICAgICAgICAgICAgICAgICAgIC8qIGRpc3RhbmNlIGJhc2UgKi9cbiAgICAgICAgICAgIGRpc3QgPSBoZXJlICYgMHhmZmZmLypoZXJlLnZhbCovO1xuICAgICAgICAgICAgb3AgJj0gMTU7ICAgICAgICAgICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgZXh0cmEgYml0cyAqL1xuICAgICAgICAgICAgaWYgKGJpdHMgPCBvcCkge1xuICAgICAgICAgICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzO1xuICAgICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgICAgIGlmIChiaXRzIDwgb3ApIHtcbiAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzO1xuICAgICAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGlzdCArPSBob2xkICYgKCgxIDw8IG9wKSAtIDEpO1xuLy8jaWZkZWYgSU5GTEFURV9TVFJJQ1RcbiAgICAgICAgICAgIGlmIChkaXN0ID4gZG1heCkge1xuICAgICAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGRpc3RhbmNlIHRvbyBmYXIgYmFjayc7XG4gICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgICAgIGJyZWFrIHRvcDtcbiAgICAgICAgICAgIH1cbi8vI2VuZGlmXG4gICAgICAgICAgICBob2xkID4+Pj0gb3A7XG4gICAgICAgICAgICBiaXRzIC09IG9wO1xuICAgICAgICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgICBkaXN0YW5jZSAldVxcblwiLCBkaXN0KSk7XG4gICAgICAgICAgICBvcCA9IF9vdXQgLSBiZWc7ICAgICAgICAgICAgICAgIC8qIG1heCBkaXN0YW5jZSBpbiBvdXRwdXQgKi9cbiAgICAgICAgICAgIGlmIChkaXN0ID4gb3ApIHsgICAgICAgICAgICAgICAgLyogc2VlIGlmIGNvcHkgZnJvbSB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgb3AgPSBkaXN0IC0gb3A7ICAgICAgICAgICAgICAgLyogZGlzdGFuY2UgYmFjayBpbiB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgaWYgKG9wID4gd2hhdmUpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuc2FuZSkge1xuICAgICAgICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZSB0b28gZmFyIGJhY2snO1xuICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICAgICAgICAgIGJyZWFrIHRvcDtcbiAgICAgICAgICAgICAgICB9XG5cbi8vICghKSBUaGlzIGJsb2NrIGlzIGRpc2FibGVkIGluIHpsaWIgZGVmYXVsdHMsXG4vLyBkb24ndCBlbmFibGUgaXQgZm9yIGJpbmFyeSBjb21wYXRpYmlsaXR5XG4vLyNpZmRlZiBJTkZMQVRFX0FMTE9XX0lOVkFMSURfRElTVEFOQ0VfVE9PRkFSX0FSUlJcbi8vICAgICAgICAgICAgICAgIGlmIChsZW4gPD0gb3AgLSB3aGF2ZSkge1xuLy8gICAgICAgICAgICAgICAgICBkbyB7XG4vLyAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSAwO1xuLy8gICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLWxlbik7XG4vLyAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIHRvcDtcbi8vICAgICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgICAgIGxlbiAtPSBvcCAtIHdoYXZlO1xuLy8gICAgICAgICAgICAgICAgZG8ge1xuLy8gICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IDA7XG4vLyAgICAgICAgICAgICAgICB9IHdoaWxlICgtLW9wID4gd2hhdmUpO1xuLy8gICAgICAgICAgICAgICAgaWYgKG9wID09PSAwKSB7XG4vLyAgICAgICAgICAgICAgICAgIGZyb20gPSBfb3V0IC0gZGlzdDtcbi8vICAgICAgICAgICAgICAgICAgZG8ge1xuLy8gICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107XG4vLyAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tbGVuKTtcbi8vICAgICAgICAgICAgICAgICAgY29udGludWUgdG9wO1xuLy8gICAgICAgICAgICAgICAgfVxuLy8jZW5kaWZcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBmcm9tID0gMDsgLy8gd2luZG93IGluZGV4XG4gICAgICAgICAgICAgIGZyb21fc291cmNlID0gc193aW5kb3c7XG4gICAgICAgICAgICAgIGlmICh3bmV4dCA9PT0gMCkgeyAgICAgICAgICAgLyogdmVyeSBjb21tb24gY2FzZSAqL1xuICAgICAgICAgICAgICAgIGZyb20gKz0gd3NpemUgLSBvcDtcbiAgICAgICAgICAgICAgICBpZiAob3AgPCBsZW4pIHsgICAgICAgICAvKiBzb21lIGZyb20gd2luZG93ICovXG4gICAgICAgICAgICAgICAgICBsZW4gLT0gb3A7XG4gICAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gc193aW5kb3dbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tb3ApO1xuICAgICAgICAgICAgICAgICAgZnJvbSA9IF9vdXQgLSBkaXN0OyAgLyogcmVzdCBmcm9tIG91dHB1dCAqL1xuICAgICAgICAgICAgICAgICAgZnJvbV9zb3VyY2UgPSBvdXRwdXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2UgaWYgKHduZXh0IDwgb3ApIHsgICAgICAvKiB3cmFwIGFyb3VuZCB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgICBmcm9tICs9IHdzaXplICsgd25leHQgLSBvcDtcbiAgICAgICAgICAgICAgICBvcCAtPSB3bmV4dDtcbiAgICAgICAgICAgICAgICBpZiAob3AgPCBsZW4pIHsgICAgICAgICAvKiBzb21lIGZyb20gZW5kIG9mIHdpbmRvdyAqL1xuICAgICAgICAgICAgICAgICAgbGVuIC09IG9wO1xuICAgICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IHNfd2luZG93W2Zyb20rK107XG4gICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLW9wKTtcbiAgICAgICAgICAgICAgICAgIGZyb20gPSAwO1xuICAgICAgICAgICAgICAgICAgaWYgKHduZXh0IDwgbGVuKSB7ICAvKiBzb21lIGZyb20gc3RhcnQgb2Ygd2luZG93ICovXG4gICAgICAgICAgICAgICAgICAgIG9wID0gd25leHQ7XG4gICAgICAgICAgICAgICAgICAgIGxlbiAtPSBvcDtcbiAgICAgICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gc193aW5kb3dbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1vcCk7XG4gICAgICAgICAgICAgICAgICAgIGZyb20gPSBfb3V0IC0gZGlzdDsgICAgICAvKiByZXN0IGZyb20gb3V0cHV0ICovXG4gICAgICAgICAgICAgICAgICAgIGZyb21fc291cmNlID0gb3V0cHV0O1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIHsgICAgICAgICAgICAgICAgICAgICAgLyogY29udGlndW91cyBpbiB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgICBmcm9tICs9IHduZXh0IC0gb3A7XG4gICAgICAgICAgICAgICAgaWYgKG9wIDwgbGVuKSB7ICAgICAgICAgLyogc29tZSBmcm9tIHdpbmRvdyAqL1xuICAgICAgICAgICAgICAgICAgbGVuIC09IG9wO1xuICAgICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IHNfd2luZG93W2Zyb20rK107XG4gICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLW9wKTtcbiAgICAgICAgICAgICAgICAgIGZyb20gPSBfb3V0IC0gZGlzdDsgIC8qIHJlc3QgZnJvbSBvdXRwdXQgKi9cbiAgICAgICAgICAgICAgICAgIGZyb21fc291cmNlID0gb3V0cHV0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB3aGlsZSAobGVuID4gMikge1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gZnJvbV9zb3VyY2VbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IGZyb21fc291cmNlW2Zyb20rK107XG4gICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBmcm9tX3NvdXJjZVtmcm9tKytdO1xuICAgICAgICAgICAgICAgIGxlbiAtPSAzO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChsZW4pIHtcbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IGZyb21fc291cmNlW2Zyb20rK107XG4gICAgICAgICAgICAgICAgaWYgKGxlbiA+IDEpIHtcbiAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gZnJvbV9zb3VyY2VbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBmcm9tID0gX291dCAtIGRpc3Q7ICAgICAgICAgIC8qIGNvcHkgZGlyZWN0IGZyb20gb3V0cHV0ICovXG4gICAgICAgICAgICAgIGRvIHsgICAgICAgICAgICAgICAgICAgICAgICAvKiBtaW5pbXVtIGxlbmd0aCBpcyB0aHJlZSAqL1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107XG4gICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBvdXRwdXRbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IG91dHB1dFtmcm9tKytdO1xuICAgICAgICAgICAgICAgIGxlbiAtPSAzO1xuICAgICAgICAgICAgICB9IHdoaWxlIChsZW4gPiAyKTtcbiAgICAgICAgICAgICAgaWYgKGxlbikge1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107XG4gICAgICAgICAgICAgICAgaWYgKGxlbiA+IDEpIHtcbiAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKChvcCAmIDY0KSA9PT0gMCkgeyAgICAgICAgICAvKiAybmQgbGV2ZWwgZGlzdGFuY2UgY29kZSAqL1xuICAgICAgICAgICAgaGVyZSA9IGRjb2RlWyhoZXJlICYgMHhmZmZmKS8qaGVyZS52YWwqLyArIChob2xkICYgKCgxIDw8IG9wKSAtIDEpKV07XG4gICAgICAgICAgICBjb250aW51ZSBkb2Rpc3Q7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZSBjb2RlJztcbiAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgICBicmVhayB0b3A7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7IC8vIG5lZWQgdG8gZW11bGF0ZSBnb3RvIHZpYSBcImNvbnRpbnVlXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSBpZiAoKG9wICYgNjQpID09PSAwKSB7ICAgICAgICAgICAgICAvKiAybmQgbGV2ZWwgbGVuZ3RoIGNvZGUgKi9cbiAgICAgICAgaGVyZSA9IGxjb2RlWyhoZXJlICYgMHhmZmZmKS8qaGVyZS52YWwqLyArIChob2xkICYgKCgxIDw8IG9wKSAtIDEpKV07XG4gICAgICAgIGNvbnRpbnVlIGRvbGVuO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAob3AgJiAzMikgeyAgICAgICAgICAgICAgICAgICAgIC8qIGVuZC1vZi1ibG9jayAqL1xuICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICAgIGVuZCBvZiBibG9ja1xcblwiKSk7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBUWVBFO1xuICAgICAgICBicmVhayB0b3A7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBsaXRlcmFsL2xlbmd0aCBjb2RlJztcbiAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgYnJlYWsgdG9wO1xuICAgICAgfVxuXG4gICAgICBicmVhazsgLy8gbmVlZCB0byBlbXVsYXRlIGdvdG8gdmlhIFwiY29udGludWVcIlxuICAgIH1cbiAgfSB3aGlsZSAoX2luIDwgbGFzdCAmJiBfb3V0IDwgZW5kKTtcblxuICAvKiByZXR1cm4gdW51c2VkIGJ5dGVzIChvbiBlbnRyeSwgYml0cyA8IDgsIHNvIGluIHdvbid0IGdvIHRvbyBmYXIgYmFjaykgKi9cbiAgbGVuID0gYml0cyA+PiAzO1xuICBfaW4gLT0gbGVuO1xuICBiaXRzIC09IGxlbiA8PCAzO1xuICBob2xkICY9ICgxIDw8IGJpdHMpIC0gMTtcblxuICAvKiB1cGRhdGUgc3RhdGUgYW5kIHJldHVybiAqL1xuICBzdHJtLm5leHRfaW4gPSBfaW47XG4gIHN0cm0ubmV4dF9vdXQgPSBfb3V0O1xuICBzdHJtLmF2YWlsX2luID0gKF9pbiA8IGxhc3QgPyA1ICsgKGxhc3QgLSBfaW4pIDogNSAtIChfaW4gLSBsYXN0KSk7XG4gIHN0cm0uYXZhaWxfb3V0ID0gKF9vdXQgPCBlbmQgPyAyNTcgKyAoZW5kIC0gX291dCkgOiAyNTcgLSAoX291dCAtIGVuZCkpO1xuICBzdGF0ZS5ob2xkID0gaG9sZDtcbiAgc3RhdGUuYml0cyA9IGJpdHM7XG4gIHJldHVybjtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvY29tbW9uJyk7XG5cbnZhciBNQVhCSVRTID0gMTU7XG52YXIgRU5PVUdIX0xFTlMgPSA4NTI7XG52YXIgRU5PVUdIX0RJU1RTID0gNTkyO1xuLy92YXIgRU5PVUdIID0gKEVOT1VHSF9MRU5TK0VOT1VHSF9ESVNUUyk7XG5cbnZhciBDT0RFUyA9IDA7XG52YXIgTEVOUyA9IDE7XG52YXIgRElTVFMgPSAyO1xuXG52YXIgbGJhc2UgPSBbIC8qIExlbmd0aCBjb2RlcyAyNTcuLjI4NSBiYXNlICovXG4gIDMsIDQsIDUsIDYsIDcsIDgsIDksIDEwLCAxMSwgMTMsIDE1LCAxNywgMTksIDIzLCAyNywgMzEsXG4gIDM1LCA0MywgNTEsIDU5LCA2NywgODMsIDk5LCAxMTUsIDEzMSwgMTYzLCAxOTUsIDIyNywgMjU4LCAwLCAwXG5dO1xuXG52YXIgbGV4dCA9IFsgLyogTGVuZ3RoIGNvZGVzIDI1Ny4uMjg1IGV4dHJhICovXG4gIDE2LCAxNiwgMTYsIDE2LCAxNiwgMTYsIDE2LCAxNiwgMTcsIDE3LCAxNywgMTcsIDE4LCAxOCwgMTgsIDE4LFxuICAxOSwgMTksIDE5LCAxOSwgMjAsIDIwLCAyMCwgMjAsIDIxLCAyMSwgMjEsIDIxLCAxNiwgNzIsIDc4XG5dO1xuXG52YXIgZGJhc2UgPSBbIC8qIERpc3RhbmNlIGNvZGVzIDAuLjI5IGJhc2UgKi9cbiAgMSwgMiwgMywgNCwgNSwgNywgOSwgMTMsIDE3LCAyNSwgMzMsIDQ5LCA2NSwgOTcsIDEyOSwgMTkzLFxuICAyNTcsIDM4NSwgNTEzLCA3NjksIDEwMjUsIDE1MzcsIDIwNDksIDMwNzMsIDQwOTcsIDYxNDUsXG4gIDgxOTMsIDEyMjg5LCAxNjM4NSwgMjQ1NzcsIDAsIDBcbl07XG5cbnZhciBkZXh0ID0gWyAvKiBEaXN0YW5jZSBjb2RlcyAwLi4yOSBleHRyYSAqL1xuICAxNiwgMTYsIDE2LCAxNiwgMTcsIDE3LCAxOCwgMTgsIDE5LCAxOSwgMjAsIDIwLCAyMSwgMjEsIDIyLCAyMixcbiAgMjMsIDIzLCAyNCwgMjQsIDI1LCAyNSwgMjYsIDI2LCAyNywgMjcsXG4gIDI4LCAyOCwgMjksIDI5LCA2NCwgNjRcbl07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5mbGF0ZV90YWJsZSh0eXBlLCBsZW5zLCBsZW5zX2luZGV4LCBjb2RlcywgdGFibGUsIHRhYmxlX2luZGV4LCB3b3JrLCBvcHRzKVxue1xuICB2YXIgYml0cyA9IG9wdHMuYml0cztcbiAgICAgIC8vaGVyZSA9IG9wdHMuaGVyZTsgLyogdGFibGUgZW50cnkgZm9yIGR1cGxpY2F0aW9uICovXG5cbiAgdmFyIGxlbiA9IDA7ICAgICAgICAgICAgICAgLyogYSBjb2RlJ3MgbGVuZ3RoIGluIGJpdHMgKi9cbiAgdmFyIHN5bSA9IDA7ICAgICAgICAgICAgICAgLyogaW5kZXggb2YgY29kZSBzeW1ib2xzICovXG4gIHZhciBtaW4gPSAwLCBtYXggPSAwOyAgICAgICAgICAvKiBtaW5pbXVtIGFuZCBtYXhpbXVtIGNvZGUgbGVuZ3RocyAqL1xuICB2YXIgcm9vdCA9IDA7ICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgaW5kZXggYml0cyBmb3Igcm9vdCB0YWJsZSAqL1xuICB2YXIgY3VyciA9IDA7ICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgaW5kZXggYml0cyBmb3IgY3VycmVudCB0YWJsZSAqL1xuICB2YXIgZHJvcCA9IDA7ICAgICAgICAgICAgICAvKiBjb2RlIGJpdHMgdG8gZHJvcCBmb3Igc3ViLXRhYmxlICovXG4gIHZhciBsZWZ0ID0gMDsgICAgICAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIHByZWZpeCBjb2RlcyBhdmFpbGFibGUgKi9cbiAgdmFyIHVzZWQgPSAwOyAgICAgICAgICAgICAgLyogY29kZSBlbnRyaWVzIGluIHRhYmxlIHVzZWQgKi9cbiAgdmFyIGh1ZmYgPSAwOyAgICAgICAgICAgICAgLyogSHVmZm1hbiBjb2RlICovXG4gIHZhciBpbmNyOyAgICAgICAgICAgICAgLyogZm9yIGluY3JlbWVudGluZyBjb2RlLCBpbmRleCAqL1xuICB2YXIgZmlsbDsgICAgICAgICAgICAgIC8qIGluZGV4IGZvciByZXBsaWNhdGluZyBlbnRyaWVzICovXG4gIHZhciBsb3c7ICAgICAgICAgICAgICAgLyogbG93IGJpdHMgZm9yIGN1cnJlbnQgcm9vdCBlbnRyeSAqL1xuICB2YXIgbWFzazsgICAgICAgICAgICAgIC8qIG1hc2sgZm9yIGxvdyByb290IGJpdHMgKi9cbiAgdmFyIG5leHQ7ICAgICAgICAgICAgIC8qIG5leHQgYXZhaWxhYmxlIHNwYWNlIGluIHRhYmxlICovXG4gIHZhciBiYXNlID0gbnVsbDsgICAgIC8qIGJhc2UgdmFsdWUgdGFibGUgdG8gdXNlICovXG4gIHZhciBiYXNlX2luZGV4ID0gMDtcbi8vICB2YXIgc2hvZXh0cmE7ICAgIC8qIGV4dHJhIGJpdHMgdGFibGUgdG8gdXNlICovXG4gIHZhciBlbmQ7ICAgICAgICAgICAgICAgICAgICAvKiB1c2UgYmFzZSBhbmQgZXh0cmEgZm9yIHN5bWJvbCA+IGVuZCAqL1xuICB2YXIgY291bnQgPSBuZXcgdXRpbHMuQnVmMTYoTUFYQklUUyArIDEpOyAvL1tNQVhCSVRTKzFdOyAgICAvKiBudW1iZXIgb2YgY29kZXMgb2YgZWFjaCBsZW5ndGggKi9cbiAgdmFyIG9mZnMgPSBuZXcgdXRpbHMuQnVmMTYoTUFYQklUUyArIDEpOyAvL1tNQVhCSVRTKzFdOyAgICAgLyogb2Zmc2V0cyBpbiB0YWJsZSBmb3IgZWFjaCBsZW5ndGggKi9cbiAgdmFyIGV4dHJhID0gbnVsbDtcbiAgdmFyIGV4dHJhX2luZGV4ID0gMDtcblxuICB2YXIgaGVyZV9iaXRzLCBoZXJlX29wLCBoZXJlX3ZhbDtcblxuICAvKlxuICAgUHJvY2VzcyBhIHNldCBvZiBjb2RlIGxlbmd0aHMgdG8gY3JlYXRlIGEgY2Fub25pY2FsIEh1ZmZtYW4gY29kZS4gIFRoZVxuICAgY29kZSBsZW5ndGhzIGFyZSBsZW5zWzAuLmNvZGVzLTFdLiAgRWFjaCBsZW5ndGggY29ycmVzcG9uZHMgdG8gdGhlXG4gICBzeW1ib2xzIDAuLmNvZGVzLTEuICBUaGUgSHVmZm1hbiBjb2RlIGlzIGdlbmVyYXRlZCBieSBmaXJzdCBzb3J0aW5nIHRoZVxuICAgc3ltYm9scyBieSBsZW5ndGggZnJvbSBzaG9ydCB0byBsb25nLCBhbmQgcmV0YWluaW5nIHRoZSBzeW1ib2wgb3JkZXJcbiAgIGZvciBjb2RlcyB3aXRoIGVxdWFsIGxlbmd0aHMuICBUaGVuIHRoZSBjb2RlIHN0YXJ0cyB3aXRoIGFsbCB6ZXJvIGJpdHNcbiAgIGZvciB0aGUgZmlyc3QgY29kZSBvZiB0aGUgc2hvcnRlc3QgbGVuZ3RoLCBhbmQgdGhlIGNvZGVzIGFyZSBpbnRlZ2VyXG4gICBpbmNyZW1lbnRzIGZvciB0aGUgc2FtZSBsZW5ndGgsIGFuZCB6ZXJvcyBhcmUgYXBwZW5kZWQgYXMgdGhlIGxlbmd0aFxuICAgaW5jcmVhc2VzLiAgRm9yIHRoZSBkZWZsYXRlIGZvcm1hdCwgdGhlc2UgYml0cyBhcmUgc3RvcmVkIGJhY2t3YXJkc1xuICAgZnJvbSB0aGVpciBtb3JlIG5hdHVyYWwgaW50ZWdlciBpbmNyZW1lbnQgb3JkZXJpbmcsIGFuZCBzbyB3aGVuIHRoZVxuICAgZGVjb2RpbmcgdGFibGVzIGFyZSBidWlsdCBpbiB0aGUgbGFyZ2UgbG9vcCBiZWxvdywgdGhlIGludGVnZXIgY29kZXNcbiAgIGFyZSBpbmNyZW1lbnRlZCBiYWNrd2FyZHMuXG5cbiAgIFRoaXMgcm91dGluZSBhc3N1bWVzLCBidXQgZG9lcyBub3QgY2hlY2ssIHRoYXQgYWxsIG9mIHRoZSBlbnRyaWVzIGluXG4gICBsZW5zW10gYXJlIGluIHRoZSByYW5nZSAwLi5NQVhCSVRTLiAgVGhlIGNhbGxlciBtdXN0IGFzc3VyZSB0aGlzLlxuICAgMS4uTUFYQklUUyBpcyBpbnRlcnByZXRlZCBhcyB0aGF0IGNvZGUgbGVuZ3RoLiAgemVybyBtZWFucyB0aGF0IHRoYXRcbiAgIHN5bWJvbCBkb2VzIG5vdCBvY2N1ciBpbiB0aGlzIGNvZGUuXG5cbiAgIFRoZSBjb2RlcyBhcmUgc29ydGVkIGJ5IGNvbXB1dGluZyBhIGNvdW50IG9mIGNvZGVzIGZvciBlYWNoIGxlbmd0aCxcbiAgIGNyZWF0aW5nIGZyb20gdGhhdCBhIHRhYmxlIG9mIHN0YXJ0aW5nIGluZGljZXMgZm9yIGVhY2ggbGVuZ3RoIGluIHRoZVxuICAgc29ydGVkIHRhYmxlLCBhbmQgdGhlbiBlbnRlcmluZyB0aGUgc3ltYm9scyBpbiBvcmRlciBpbiB0aGUgc29ydGVkXG4gICB0YWJsZS4gIFRoZSBzb3J0ZWQgdGFibGUgaXMgd29ya1tdLCB3aXRoIHRoYXQgc3BhY2UgYmVpbmcgcHJvdmlkZWQgYnlcbiAgIHRoZSBjYWxsZXIuXG5cbiAgIFRoZSBsZW5ndGggY291bnRzIGFyZSB1c2VkIGZvciBvdGhlciBwdXJwb3NlcyBhcyB3ZWxsLCBpLmUuIGZpbmRpbmdcbiAgIHRoZSBtaW5pbXVtIGFuZCBtYXhpbXVtIGxlbmd0aCBjb2RlcywgZGV0ZXJtaW5pbmcgaWYgdGhlcmUgYXJlIGFueVxuICAgY29kZXMgYXQgYWxsLCBjaGVja2luZyBmb3IgYSB2YWxpZCBzZXQgb2YgbGVuZ3RocywgYW5kIGxvb2tpbmcgYWhlYWRcbiAgIGF0IGxlbmd0aCBjb3VudHMgdG8gZGV0ZXJtaW5lIHN1Yi10YWJsZSBzaXplcyB3aGVuIGJ1aWxkaW5nIHRoZVxuICAgZGVjb2RpbmcgdGFibGVzLlxuICAgKi9cblxuICAvKiBhY2N1bXVsYXRlIGxlbmd0aHMgZm9yIGNvZGVzIChhc3N1bWVzIGxlbnNbXSBhbGwgaW4gMC4uTUFYQklUUykgKi9cbiAgZm9yIChsZW4gPSAwOyBsZW4gPD0gTUFYQklUUzsgbGVuKyspIHtcbiAgICBjb3VudFtsZW5dID0gMDtcbiAgfVxuICBmb3IgKHN5bSA9IDA7IHN5bSA8IGNvZGVzOyBzeW0rKykge1xuICAgIGNvdW50W2xlbnNbbGVuc19pbmRleCArIHN5bV1dKys7XG4gIH1cblxuICAvKiBib3VuZCBjb2RlIGxlbmd0aHMsIGZvcmNlIHJvb3QgdG8gYmUgd2l0aGluIGNvZGUgbGVuZ3RocyAqL1xuICByb290ID0gYml0cztcbiAgZm9yIChtYXggPSBNQVhCSVRTOyBtYXggPj0gMTsgbWF4LS0pIHtcbiAgICBpZiAoY291bnRbbWF4XSAhPT0gMCkgeyBicmVhazsgfVxuICB9XG4gIGlmIChyb290ID4gbWF4KSB7XG4gICAgcm9vdCA9IG1heDtcbiAgfVxuICBpZiAobWF4ID09PSAwKSB7ICAgICAgICAgICAgICAgICAgICAgLyogbm8gc3ltYm9scyB0byBjb2RlIGF0IGFsbCAqL1xuICAgIC8vdGFibGUub3Bbb3B0cy50YWJsZV9pbmRleF0gPSA2NDsgIC8vaGVyZS5vcCA9ICh2YXIgY2hhcik2NDsgICAgLyogaW52YWxpZCBjb2RlIG1hcmtlciAqL1xuICAgIC8vdGFibGUuYml0c1tvcHRzLnRhYmxlX2luZGV4XSA9IDE7ICAgLy9oZXJlLmJpdHMgPSAodmFyIGNoYXIpMTtcbiAgICAvL3RhYmxlLnZhbFtvcHRzLnRhYmxlX2luZGV4KytdID0gMDsgICAvL2hlcmUudmFsID0gKHZhciBzaG9ydCkwO1xuICAgIHRhYmxlW3RhYmxlX2luZGV4KytdID0gKDEgPDwgMjQpIHwgKDY0IDw8IDE2KSB8IDA7XG5cblxuICAgIC8vdGFibGUub3Bbb3B0cy50YWJsZV9pbmRleF0gPSA2NDtcbiAgICAvL3RhYmxlLmJpdHNbb3B0cy50YWJsZV9pbmRleF0gPSAxO1xuICAgIC8vdGFibGUudmFsW29wdHMudGFibGVfaW5kZXgrK10gPSAwO1xuICAgIHRhYmxlW3RhYmxlX2luZGV4KytdID0gKDEgPDwgMjQpIHwgKDY0IDw8IDE2KSB8IDA7XG5cbiAgICBvcHRzLmJpdHMgPSAxO1xuICAgIHJldHVybiAwOyAgICAgLyogbm8gc3ltYm9scywgYnV0IHdhaXQgZm9yIGRlY29kaW5nIHRvIHJlcG9ydCBlcnJvciAqL1xuICB9XG4gIGZvciAobWluID0gMTsgbWluIDwgbWF4OyBtaW4rKykge1xuICAgIGlmIChjb3VudFttaW5dICE9PSAwKSB7IGJyZWFrOyB9XG4gIH1cbiAgaWYgKHJvb3QgPCBtaW4pIHtcbiAgICByb290ID0gbWluO1xuICB9XG5cbiAgLyogY2hlY2sgZm9yIGFuIG92ZXItc3Vic2NyaWJlZCBvciBpbmNvbXBsZXRlIHNldCBvZiBsZW5ndGhzICovXG4gIGxlZnQgPSAxO1xuICBmb3IgKGxlbiA9IDE7IGxlbiA8PSBNQVhCSVRTOyBsZW4rKykge1xuICAgIGxlZnQgPDw9IDE7XG4gICAgbGVmdCAtPSBjb3VudFtsZW5dO1xuICAgIGlmIChsZWZ0IDwgMCkge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH0gICAgICAgIC8qIG92ZXItc3Vic2NyaWJlZCAqL1xuICB9XG4gIGlmIChsZWZ0ID4gMCAmJiAodHlwZSA9PT0gQ09ERVMgfHwgbWF4ICE9PSAxKSkge1xuICAgIHJldHVybiAtMTsgICAgICAgICAgICAgICAgICAgICAgLyogaW5jb21wbGV0ZSBzZXQgKi9cbiAgfVxuXG4gIC8qIGdlbmVyYXRlIG9mZnNldHMgaW50byBzeW1ib2wgdGFibGUgZm9yIGVhY2ggbGVuZ3RoIGZvciBzb3J0aW5nICovXG4gIG9mZnNbMV0gPSAwO1xuICBmb3IgKGxlbiA9IDE7IGxlbiA8IE1BWEJJVFM7IGxlbisrKSB7XG4gICAgb2Zmc1tsZW4gKyAxXSA9IG9mZnNbbGVuXSArIGNvdW50W2xlbl07XG4gIH1cblxuICAvKiBzb3J0IHN5bWJvbHMgYnkgbGVuZ3RoLCBieSBzeW1ib2wgb3JkZXIgd2l0aGluIGVhY2ggbGVuZ3RoICovXG4gIGZvciAoc3ltID0gMDsgc3ltIDwgY29kZXM7IHN5bSsrKSB7XG4gICAgaWYgKGxlbnNbbGVuc19pbmRleCArIHN5bV0gIT09IDApIHtcbiAgICAgIHdvcmtbb2Zmc1tsZW5zW2xlbnNfaW5kZXggKyBzeW1dXSsrXSA9IHN5bTtcbiAgICB9XG4gIH1cblxuICAvKlxuICAgQ3JlYXRlIGFuZCBmaWxsIGluIGRlY29kaW5nIHRhYmxlcy4gIEluIHRoaXMgbG9vcCwgdGhlIHRhYmxlIGJlaW5nXG4gICBmaWxsZWQgaXMgYXQgbmV4dCBhbmQgaGFzIGN1cnIgaW5kZXggYml0cy4gIFRoZSBjb2RlIGJlaW5nIHVzZWQgaXMgaHVmZlxuICAgd2l0aCBsZW5ndGggbGVuLiAgVGhhdCBjb2RlIGlzIGNvbnZlcnRlZCB0byBhbiBpbmRleCBieSBkcm9wcGluZyBkcm9wXG4gICBiaXRzIG9mZiBvZiB0aGUgYm90dG9tLiAgRm9yIGNvZGVzIHdoZXJlIGxlbiBpcyBsZXNzIHRoYW4gZHJvcCArIGN1cnIsXG4gICB0aG9zZSB0b3AgZHJvcCArIGN1cnIgLSBsZW4gYml0cyBhcmUgaW5jcmVtZW50ZWQgdGhyb3VnaCBhbGwgdmFsdWVzIHRvXG4gICBmaWxsIHRoZSB0YWJsZSB3aXRoIHJlcGxpY2F0ZWQgZW50cmllcy5cblxuICAgcm9vdCBpcyB0aGUgbnVtYmVyIG9mIGluZGV4IGJpdHMgZm9yIHRoZSByb290IHRhYmxlLiAgV2hlbiBsZW4gZXhjZWVkc1xuICAgcm9vdCwgc3ViLXRhYmxlcyBhcmUgY3JlYXRlZCBwb2ludGVkIHRvIGJ5IHRoZSByb290IGVudHJ5IHdpdGggYW4gaW5kZXhcbiAgIG9mIHRoZSBsb3cgcm9vdCBiaXRzIG9mIGh1ZmYuICBUaGlzIGlzIHNhdmVkIGluIGxvdyB0byBjaGVjayBmb3Igd2hlbiBhXG4gICBuZXcgc3ViLXRhYmxlIHNob3VsZCBiZSBzdGFydGVkLiAgZHJvcCBpcyB6ZXJvIHdoZW4gdGhlIHJvb3QgdGFibGUgaXNcbiAgIGJlaW5nIGZpbGxlZCwgYW5kIGRyb3AgaXMgcm9vdCB3aGVuIHN1Yi10YWJsZXMgYXJlIGJlaW5nIGZpbGxlZC5cblxuICAgV2hlbiBhIG5ldyBzdWItdGFibGUgaXMgbmVlZGVkLCBpdCBpcyBuZWNlc3NhcnkgdG8gbG9vayBhaGVhZCBpbiB0aGVcbiAgIGNvZGUgbGVuZ3RocyB0byBkZXRlcm1pbmUgd2hhdCBzaXplIHN1Yi10YWJsZSBpcyBuZWVkZWQuICBUaGUgbGVuZ3RoXG4gICBjb3VudHMgYXJlIHVzZWQgZm9yIHRoaXMsIGFuZCBzbyBjb3VudFtdIGlzIGRlY3JlbWVudGVkIGFzIGNvZGVzIGFyZVxuICAgZW50ZXJlZCBpbiB0aGUgdGFibGVzLlxuXG4gICB1c2VkIGtlZXBzIHRyYWNrIG9mIGhvdyBtYW55IHRhYmxlIGVudHJpZXMgaGF2ZSBiZWVuIGFsbG9jYXRlZCBmcm9tIHRoZVxuICAgcHJvdmlkZWQgKnRhYmxlIHNwYWNlLiAgSXQgaXMgY2hlY2tlZCBmb3IgTEVOUyBhbmQgRElTVCB0YWJsZXMgYWdhaW5zdFxuICAgdGhlIGNvbnN0YW50cyBFTk9VR0hfTEVOUyBhbmQgRU5PVUdIX0RJU1RTIHRvIGd1YXJkIGFnYWluc3QgY2hhbmdlcyBpblxuICAgdGhlIGluaXRpYWwgcm9vdCB0YWJsZSBzaXplIGNvbnN0YW50cy4gIFNlZSB0aGUgY29tbWVudHMgaW4gaW5mdHJlZXMuaFxuICAgZm9yIG1vcmUgaW5mb3JtYXRpb24uXG5cbiAgIHN5bSBpbmNyZW1lbnRzIHRocm91Z2ggYWxsIHN5bWJvbHMsIGFuZCB0aGUgbG9vcCB0ZXJtaW5hdGVzIHdoZW5cbiAgIGFsbCBjb2RlcyBvZiBsZW5ndGggbWF4LCBpLmUuIGFsbCBjb2RlcywgaGF2ZSBiZWVuIHByb2Nlc3NlZC4gIFRoaXNcbiAgIHJvdXRpbmUgcGVybWl0cyBpbmNvbXBsZXRlIGNvZGVzLCBzbyBhbm90aGVyIGxvb3AgYWZ0ZXIgdGhpcyBvbmUgZmlsbHNcbiAgIGluIHRoZSByZXN0IG9mIHRoZSBkZWNvZGluZyB0YWJsZXMgd2l0aCBpbnZhbGlkIGNvZGUgbWFya2Vycy5cbiAgICovXG5cbiAgLyogc2V0IHVwIGZvciBjb2RlIHR5cGUgKi9cbiAgLy8gcG9vciBtYW4gb3B0aW1pemF0aW9uIC0gdXNlIGlmLWVsc2UgaW5zdGVhZCBvZiBzd2l0Y2gsXG4gIC8vIHRvIGF2b2lkIGRlb3B0cyBpbiBvbGQgdjhcbiAgaWYgKHR5cGUgPT09IENPREVTKSB7XG4gICAgYmFzZSA9IGV4dHJhID0gd29yazsgICAgLyogZHVtbXkgdmFsdWUtLW5vdCB1c2VkICovXG4gICAgZW5kID0gMTk7XG5cbiAgfSBlbHNlIGlmICh0eXBlID09PSBMRU5TKSB7XG4gICAgYmFzZSA9IGxiYXNlO1xuICAgIGJhc2VfaW5kZXggLT0gMjU3O1xuICAgIGV4dHJhID0gbGV4dDtcbiAgICBleHRyYV9pbmRleCAtPSAyNTc7XG4gICAgZW5kID0gMjU2O1xuXG4gIH0gZWxzZSB7ICAgICAgICAgICAgICAgICAgICAvKiBESVNUUyAqL1xuICAgIGJhc2UgPSBkYmFzZTtcbiAgICBleHRyYSA9IGRleHQ7XG4gICAgZW5kID0gLTE7XG4gIH1cblxuICAvKiBpbml0aWFsaXplIG9wdHMgZm9yIGxvb3AgKi9cbiAgaHVmZiA9IDA7ICAgICAgICAgICAgICAgICAgIC8qIHN0YXJ0aW5nIGNvZGUgKi9cbiAgc3ltID0gMDsgICAgICAgICAgICAgICAgICAgIC8qIHN0YXJ0aW5nIGNvZGUgc3ltYm9sICovXG4gIGxlbiA9IG1pbjsgICAgICAgICAgICAgICAgICAvKiBzdGFydGluZyBjb2RlIGxlbmd0aCAqL1xuICBuZXh0ID0gdGFibGVfaW5kZXg7ICAgICAgICAgICAgICAvKiBjdXJyZW50IHRhYmxlIHRvIGZpbGwgaW4gKi9cbiAgY3VyciA9IHJvb3Q7ICAgICAgICAgICAgICAgIC8qIGN1cnJlbnQgdGFibGUgaW5kZXggYml0cyAqL1xuICBkcm9wID0gMDsgICAgICAgICAgICAgICAgICAgLyogY3VycmVudCBiaXRzIHRvIGRyb3AgZnJvbSBjb2RlIGZvciBpbmRleCAqL1xuICBsb3cgPSAtMTsgICAgICAgICAgICAgICAgICAgLyogdHJpZ2dlciBuZXcgc3ViLXRhYmxlIHdoZW4gbGVuID4gcm9vdCAqL1xuICB1c2VkID0gMSA8PCByb290OyAgICAgICAgICAvKiB1c2Ugcm9vdCB0YWJsZSBlbnRyaWVzICovXG4gIG1hc2sgPSB1c2VkIC0gMTsgICAgICAgICAgICAvKiBtYXNrIGZvciBjb21wYXJpbmcgbG93ICovXG5cbiAgLyogY2hlY2sgYXZhaWxhYmxlIHRhYmxlIHNwYWNlICovXG4gIGlmICgodHlwZSA9PT0gTEVOUyAmJiB1c2VkID4gRU5PVUdIX0xFTlMpIHx8XG4gICAgKHR5cGUgPT09IERJU1RTICYmIHVzZWQgPiBFTk9VR0hfRElTVFMpKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cblxuICAvKiBwcm9jZXNzIGFsbCBjb2RlcyBhbmQgbWFrZSB0YWJsZSBlbnRyaWVzICovXG4gIGZvciAoOzspIHtcbiAgICAvKiBjcmVhdGUgdGFibGUgZW50cnkgKi9cbiAgICBoZXJlX2JpdHMgPSBsZW4gLSBkcm9wO1xuICAgIGlmICh3b3JrW3N5bV0gPCBlbmQpIHtcbiAgICAgIGhlcmVfb3AgPSAwO1xuICAgICAgaGVyZV92YWwgPSB3b3JrW3N5bV07XG4gICAgfVxuICAgIGVsc2UgaWYgKHdvcmtbc3ltXSA+IGVuZCkge1xuICAgICAgaGVyZV9vcCA9IGV4dHJhW2V4dHJhX2luZGV4ICsgd29ya1tzeW1dXTtcbiAgICAgIGhlcmVfdmFsID0gYmFzZVtiYXNlX2luZGV4ICsgd29ya1tzeW1dXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBoZXJlX29wID0gMzIgKyA2NDsgICAgICAgICAvKiBlbmQgb2YgYmxvY2sgKi9cbiAgICAgIGhlcmVfdmFsID0gMDtcbiAgICB9XG5cbiAgICAvKiByZXBsaWNhdGUgZm9yIHRob3NlIGluZGljZXMgd2l0aCBsb3cgbGVuIGJpdHMgZXF1YWwgdG8gaHVmZiAqL1xuICAgIGluY3IgPSAxIDw8IChsZW4gLSBkcm9wKTtcbiAgICBmaWxsID0gMSA8PCBjdXJyO1xuICAgIG1pbiA9IGZpbGw7ICAgICAgICAgICAgICAgICAvKiBzYXZlIG9mZnNldCB0byBuZXh0IHRhYmxlICovXG4gICAgZG8ge1xuICAgICAgZmlsbCAtPSBpbmNyO1xuICAgICAgdGFibGVbbmV4dCArIChodWZmID4+IGRyb3ApICsgZmlsbF0gPSAoaGVyZV9iaXRzIDw8IDI0KSB8IChoZXJlX29wIDw8IDE2KSB8IGhlcmVfdmFsIHwwO1xuICAgIH0gd2hpbGUgKGZpbGwgIT09IDApO1xuXG4gICAgLyogYmFja3dhcmRzIGluY3JlbWVudCB0aGUgbGVuLWJpdCBjb2RlIGh1ZmYgKi9cbiAgICBpbmNyID0gMSA8PCAobGVuIC0gMSk7XG4gICAgd2hpbGUgKGh1ZmYgJiBpbmNyKSB7XG4gICAgICBpbmNyID4+PSAxO1xuICAgIH1cbiAgICBpZiAoaW5jciAhPT0gMCkge1xuICAgICAgaHVmZiAmPSBpbmNyIC0gMTtcbiAgICAgIGh1ZmYgKz0gaW5jcjtcbiAgICB9IGVsc2Uge1xuICAgICAgaHVmZiA9IDA7XG4gICAgfVxuXG4gICAgLyogZ28gdG8gbmV4dCBzeW1ib2wsIHVwZGF0ZSBjb3VudCwgbGVuICovXG4gICAgc3ltKys7XG4gICAgaWYgKC0tY291bnRbbGVuXSA9PT0gMCkge1xuICAgICAgaWYgKGxlbiA9PT0gbWF4KSB7IGJyZWFrOyB9XG4gICAgICBsZW4gPSBsZW5zW2xlbnNfaW5kZXggKyB3b3JrW3N5bV1dO1xuICAgIH1cblxuICAgIC8qIGNyZWF0ZSBuZXcgc3ViLXRhYmxlIGlmIG5lZWRlZCAqL1xuICAgIGlmIChsZW4gPiByb290ICYmIChodWZmICYgbWFzaykgIT09IGxvdykge1xuICAgICAgLyogaWYgZmlyc3QgdGltZSwgdHJhbnNpdGlvbiB0byBzdWItdGFibGVzICovXG4gICAgICBpZiAoZHJvcCA9PT0gMCkge1xuICAgICAgICBkcm9wID0gcm9vdDtcbiAgICAgIH1cblxuICAgICAgLyogaW5jcmVtZW50IHBhc3QgbGFzdCB0YWJsZSAqL1xuICAgICAgbmV4dCArPSBtaW47ICAgICAgICAgICAgLyogaGVyZSBtaW4gaXMgMSA8PCBjdXJyICovXG5cbiAgICAgIC8qIGRldGVybWluZSBsZW5ndGggb2YgbmV4dCB0YWJsZSAqL1xuICAgICAgY3VyciA9IGxlbiAtIGRyb3A7XG4gICAgICBsZWZ0ID0gMSA8PCBjdXJyO1xuICAgICAgd2hpbGUgKGN1cnIgKyBkcm9wIDwgbWF4KSB7XG4gICAgICAgIGxlZnQgLT0gY291bnRbY3VyciArIGRyb3BdO1xuICAgICAgICBpZiAobGVmdCA8PSAwKSB7IGJyZWFrOyB9XG4gICAgICAgIGN1cnIrKztcbiAgICAgICAgbGVmdCA8PD0gMTtcbiAgICAgIH1cblxuICAgICAgLyogY2hlY2sgZm9yIGVub3VnaCBzcGFjZSAqL1xuICAgICAgdXNlZCArPSAxIDw8IGN1cnI7XG4gICAgICBpZiAoKHR5cGUgPT09IExFTlMgJiYgdXNlZCA+IEVOT1VHSF9MRU5TKSB8fFxuICAgICAgICAodHlwZSA9PT0gRElTVFMgJiYgdXNlZCA+IEVOT1VHSF9ESVNUUykpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9XG5cbiAgICAgIC8qIHBvaW50IGVudHJ5IGluIHJvb3QgdGFibGUgdG8gc3ViLXRhYmxlICovXG4gICAgICBsb3cgPSBodWZmICYgbWFzaztcbiAgICAgIC8qdGFibGUub3BbbG93XSA9IGN1cnI7XG4gICAgICB0YWJsZS5iaXRzW2xvd10gPSByb290O1xuICAgICAgdGFibGUudmFsW2xvd10gPSBuZXh0IC0gb3B0cy50YWJsZV9pbmRleDsqL1xuICAgICAgdGFibGVbbG93XSA9IChyb290IDw8IDI0KSB8IChjdXJyIDw8IDE2KSB8IChuZXh0IC0gdGFibGVfaW5kZXgpIHwwO1xuICAgIH1cbiAgfVxuXG4gIC8qIGZpbGwgaW4gcmVtYWluaW5nIHRhYmxlIGVudHJ5IGlmIGNvZGUgaXMgaW5jb21wbGV0ZSAoZ3VhcmFudGVlZCB0byBoYXZlXG4gICBhdCBtb3N0IG9uZSByZW1haW5pbmcgZW50cnksIHNpbmNlIGlmIHRoZSBjb2RlIGlzIGluY29tcGxldGUsIHRoZVxuICAgbWF4aW11bSBjb2RlIGxlbmd0aCB0aGF0IHdhcyBhbGxvd2VkIHRvIGdldCB0aGlzIGZhciBpcyBvbmUgYml0KSAqL1xuICBpZiAoaHVmZiAhPT0gMCkge1xuICAgIC8vdGFibGUub3BbbmV4dCArIGh1ZmZdID0gNjQ7ICAgICAgICAgICAgLyogaW52YWxpZCBjb2RlIG1hcmtlciAqL1xuICAgIC8vdGFibGUuYml0c1tuZXh0ICsgaHVmZl0gPSBsZW4gLSBkcm9wO1xuICAgIC8vdGFibGUudmFsW25leHQgKyBodWZmXSA9IDA7XG4gICAgdGFibGVbbmV4dCArIGh1ZmZdID0gKChsZW4gLSBkcm9wKSA8PCAyNCkgfCAoNjQgPDwgMTYpIHwwO1xuICB9XG5cbiAgLyogc2V0IHJldHVybiBwYXJhbWV0ZXJzICovXG4gIC8vb3B0cy50YWJsZV9pbmRleCArPSB1c2VkO1xuICBvcHRzLmJpdHMgPSByb290O1xuICByZXR1cm4gMDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxudmFyIHV0aWxzICAgICAgICAgPSByZXF1aXJlKCcuLi91dGlscy9jb21tb24nKTtcbnZhciBhZGxlcjMyICAgICAgID0gcmVxdWlyZSgnLi9hZGxlcjMyJyk7XG52YXIgY3JjMzIgICAgICAgICA9IHJlcXVpcmUoJy4vY3JjMzInKTtcbnZhciBpbmZsYXRlX2Zhc3QgID0gcmVxdWlyZSgnLi9pbmZmYXN0Jyk7XG52YXIgaW5mbGF0ZV90YWJsZSA9IHJlcXVpcmUoJy4vaW5mdHJlZXMnKTtcblxudmFyIENPREVTID0gMDtcbnZhciBMRU5TID0gMTtcbnZhciBESVNUUyA9IDI7XG5cbi8qIFB1YmxpYyBjb25zdGFudHMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5cbi8qIEFsbG93ZWQgZmx1c2ggdmFsdWVzOyBzZWUgZGVmbGF0ZSgpIGFuZCBpbmZsYXRlKCkgYmVsb3cgZm9yIGRldGFpbHMgKi9cbi8vdmFyIFpfTk9fRkxVU0ggICAgICA9IDA7XG4vL3ZhciBaX1BBUlRJQUxfRkxVU0ggPSAxO1xuLy92YXIgWl9TWU5DX0ZMVVNIICAgID0gMjtcbi8vdmFyIFpfRlVMTF9GTFVTSCAgICA9IDM7XG52YXIgWl9GSU5JU0ggICAgICAgID0gNDtcbnZhciBaX0JMT0NLICAgICAgICAgPSA1O1xudmFyIFpfVFJFRVMgICAgICAgICA9IDY7XG5cblxuLyogUmV0dXJuIGNvZGVzIGZvciB0aGUgY29tcHJlc3Npb24vZGVjb21wcmVzc2lvbiBmdW5jdGlvbnMuIE5lZ2F0aXZlIHZhbHVlc1xuICogYXJlIGVycm9ycywgcG9zaXRpdmUgdmFsdWVzIGFyZSB1c2VkIGZvciBzcGVjaWFsIGJ1dCBub3JtYWwgZXZlbnRzLlxuICovXG52YXIgWl9PSyAgICAgICAgICAgID0gMDtcbnZhciBaX1NUUkVBTV9FTkQgICAgPSAxO1xudmFyIFpfTkVFRF9ESUNUICAgICA9IDI7XG4vL3ZhciBaX0VSUk5PICAgICAgICAgPSAtMTtcbnZhciBaX1NUUkVBTV9FUlJPUiAgPSAtMjtcbnZhciBaX0RBVEFfRVJST1IgICAgPSAtMztcbnZhciBaX01FTV9FUlJPUiAgICAgPSAtNDtcbnZhciBaX0JVRl9FUlJPUiAgICAgPSAtNTtcbi8vdmFyIFpfVkVSU0lPTl9FUlJPUiA9IC02O1xuXG4vKiBUaGUgZGVmbGF0ZSBjb21wcmVzc2lvbiBtZXRob2QgKi9cbnZhciBaX0RFRkxBVEVEICA9IDg7XG5cblxuLyogU1RBVEVTID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cblxudmFyICAgIEhFQUQgPSAxOyAgICAgICAvKiBpOiB3YWl0aW5nIGZvciBtYWdpYyBoZWFkZXIgKi9cbnZhciAgICBGTEFHUyA9IDI7ICAgICAgLyogaTogd2FpdGluZyBmb3IgbWV0aG9kIGFuZCBmbGFncyAoZ3ppcCkgKi9cbnZhciAgICBUSU1FID0gMzsgICAgICAgLyogaTogd2FpdGluZyBmb3IgbW9kaWZpY2F0aW9uIHRpbWUgKGd6aXApICovXG52YXIgICAgT1MgPSA0OyAgICAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGV4dHJhIGZsYWdzIGFuZCBvcGVyYXRpbmcgc3lzdGVtIChnemlwKSAqL1xudmFyICAgIEVYTEVOID0gNTsgICAgICAvKiBpOiB3YWl0aW5nIGZvciBleHRyYSBsZW5ndGggKGd6aXApICovXG52YXIgICAgRVhUUkEgPSA2OyAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGV4dHJhIGJ5dGVzIChnemlwKSAqL1xudmFyICAgIE5BTUUgPSA3OyAgICAgICAvKiBpOiB3YWl0aW5nIGZvciBlbmQgb2YgZmlsZSBuYW1lIChnemlwKSAqL1xudmFyICAgIENPTU1FTlQgPSA4OyAgICAvKiBpOiB3YWl0aW5nIGZvciBlbmQgb2YgY29tbWVudCAoZ3ppcCkgKi9cbnZhciAgICBIQ1JDID0gOTsgICAgICAgLyogaTogd2FpdGluZyBmb3IgaGVhZGVyIGNyYyAoZ3ppcCkgKi9cbnZhciAgICBESUNUSUQgPSAxMDsgICAgLyogaTogd2FpdGluZyBmb3IgZGljdGlvbmFyeSBjaGVjayB2YWx1ZSAqL1xudmFyICAgIERJQ1QgPSAxMTsgICAgICAvKiB3YWl0aW5nIGZvciBpbmZsYXRlU2V0RGljdGlvbmFyeSgpIGNhbGwgKi9cbnZhciAgICAgICAgVFlQRSA9IDEyOyAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIHR5cGUgYml0cywgaW5jbHVkaW5nIGxhc3QtZmxhZyBiaXQgKi9cbnZhciAgICAgICAgVFlQRURPID0gMTM7ICAgIC8qIGk6IHNhbWUsIGJ1dCBza2lwIGNoZWNrIHRvIGV4aXQgaW5mbGF0ZSBvbiBuZXcgYmxvY2sgKi9cbnZhciAgICAgICAgU1RPUkVEID0gMTQ7ICAgIC8qIGk6IHdhaXRpbmcgZm9yIHN0b3JlZCBzaXplIChsZW5ndGggYW5kIGNvbXBsZW1lbnQpICovXG52YXIgICAgICAgIENPUFlfID0gMTU7ICAgICAvKiBpL286IHNhbWUgYXMgQ09QWSBiZWxvdywgYnV0IG9ubHkgZmlyc3QgdGltZSBpbiAqL1xudmFyICAgICAgICBDT1BZID0gMTY7ICAgICAgLyogaS9vOiB3YWl0aW5nIGZvciBpbnB1dCBvciBvdXRwdXQgdG8gY29weSBzdG9yZWQgYmxvY2sgKi9cbnZhciAgICAgICAgVEFCTEUgPSAxNzsgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGR5bmFtaWMgYmxvY2sgdGFibGUgbGVuZ3RocyAqL1xudmFyICAgICAgICBMRU5MRU5TID0gMTg7ICAgLyogaTogd2FpdGluZyBmb3IgY29kZSBsZW5ndGggY29kZSBsZW5ndGhzICovXG52YXIgICAgICAgIENPREVMRU5TID0gMTk7ICAvKiBpOiB3YWl0aW5nIGZvciBsZW5ndGgvbGl0IGFuZCBkaXN0YW5jZSBjb2RlIGxlbmd0aHMgKi9cbnZhciAgICAgICAgICAgIExFTl8gPSAyMDsgICAgICAvKiBpOiBzYW1lIGFzIExFTiBiZWxvdywgYnV0IG9ubHkgZmlyc3QgdGltZSBpbiAqL1xudmFyICAgICAgICAgICAgTEVOID0gMjE7ICAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGxlbmd0aC9saXQvZW9iIGNvZGUgKi9cbnZhciAgICAgICAgICAgIExFTkVYVCA9IDIyOyAgICAvKiBpOiB3YWl0aW5nIGZvciBsZW5ndGggZXh0cmEgYml0cyAqL1xudmFyICAgICAgICAgICAgRElTVCA9IDIzOyAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGRpc3RhbmNlIGNvZGUgKi9cbnZhciAgICAgICAgICAgIERJU1RFWFQgPSAyNDsgICAvKiBpOiB3YWl0aW5nIGZvciBkaXN0YW5jZSBleHRyYSBiaXRzICovXG52YXIgICAgICAgICAgICBNQVRDSCA9IDI1OyAgICAgLyogbzogd2FpdGluZyBmb3Igb3V0cHV0IHNwYWNlIHRvIGNvcHkgc3RyaW5nICovXG52YXIgICAgICAgICAgICBMSVQgPSAyNjsgICAgICAgLyogbzogd2FpdGluZyBmb3Igb3V0cHV0IHNwYWNlIHRvIHdyaXRlIGxpdGVyYWwgKi9cbnZhciAgICBDSEVDSyA9IDI3OyAgICAgLyogaTogd2FpdGluZyBmb3IgMzItYml0IGNoZWNrIHZhbHVlICovXG52YXIgICAgTEVOR1RIID0gMjg7ICAgIC8qIGk6IHdhaXRpbmcgZm9yIDMyLWJpdCBsZW5ndGggKGd6aXApICovXG52YXIgICAgRE9ORSA9IDI5OyAgICAgIC8qIGZpbmlzaGVkIGNoZWNrLCBkb25lIC0tIHJlbWFpbiBoZXJlIHVudGlsIHJlc2V0ICovXG52YXIgICAgQkFEID0gMzA7ICAgICAgIC8qIGdvdCBhIGRhdGEgZXJyb3IgLS0gcmVtYWluIGhlcmUgdW50aWwgcmVzZXQgKi9cbnZhciAgICBNRU0gPSAzMTsgICAgICAgLyogZ290IGFuIGluZmxhdGUoKSBtZW1vcnkgZXJyb3IgLS0gcmVtYWluIGhlcmUgdW50aWwgcmVzZXQgKi9cbnZhciAgICBTWU5DID0gMzI7ICAgICAgLyogbG9va2luZyBmb3Igc3luY2hyb25pemF0aW9uIGJ5dGVzIHRvIHJlc3RhcnQgaW5mbGF0ZSgpICovXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cblxuXG52YXIgRU5PVUdIX0xFTlMgPSA4NTI7XG52YXIgRU5PVUdIX0RJU1RTID0gNTkyO1xuLy92YXIgRU5PVUdIID0gIChFTk9VR0hfTEVOUytFTk9VR0hfRElTVFMpO1xuXG52YXIgTUFYX1dCSVRTID0gMTU7XG4vKiAzMksgTFo3NyB3aW5kb3cgKi9cbnZhciBERUZfV0JJVFMgPSBNQVhfV0JJVFM7XG5cblxuZnVuY3Rpb24genN3YXAzMihxKSB7XG4gIHJldHVybiAgKCgocSA+Pj4gMjQpICYgMHhmZikgK1xuICAgICAgICAgICgocSA+Pj4gOCkgJiAweGZmMDApICtcbiAgICAgICAgICAoKHEgJiAweGZmMDApIDw8IDgpICtcbiAgICAgICAgICAoKHEgJiAweGZmKSA8PCAyNCkpO1xufVxuXG5cbmZ1bmN0aW9uIEluZmxhdGVTdGF0ZSgpIHtcbiAgdGhpcy5tb2RlID0gMDsgICAgICAgICAgICAgLyogY3VycmVudCBpbmZsYXRlIG1vZGUgKi9cbiAgdGhpcy5sYXN0ID0gZmFsc2U7ICAgICAgICAgIC8qIHRydWUgaWYgcHJvY2Vzc2luZyBsYXN0IGJsb2NrICovXG4gIHRoaXMud3JhcCA9IDA7ICAgICAgICAgICAgICAvKiBiaXQgMCB0cnVlIGZvciB6bGliLCBiaXQgMSB0cnVlIGZvciBnemlwICovXG4gIHRoaXMuaGF2ZWRpY3QgPSBmYWxzZTsgICAgICAvKiB0cnVlIGlmIGRpY3Rpb25hcnkgcHJvdmlkZWQgKi9cbiAgdGhpcy5mbGFncyA9IDA7ICAgICAgICAgICAgIC8qIGd6aXAgaGVhZGVyIG1ldGhvZCBhbmQgZmxhZ3MgKDAgaWYgemxpYikgKi9cbiAgdGhpcy5kbWF4ID0gMDsgICAgICAgICAgICAgIC8qIHpsaWIgaGVhZGVyIG1heCBkaXN0YW5jZSAoSU5GTEFURV9TVFJJQ1QpICovXG4gIHRoaXMuY2hlY2sgPSAwOyAgICAgICAgICAgICAvKiBwcm90ZWN0ZWQgY29weSBvZiBjaGVjayB2YWx1ZSAqL1xuICB0aGlzLnRvdGFsID0gMDsgICAgICAgICAgICAgLyogcHJvdGVjdGVkIGNvcHkgb2Ygb3V0cHV0IGNvdW50ICovXG4gIC8vIFRPRE86IG1heSBiZSB7fVxuICB0aGlzLmhlYWQgPSBudWxsOyAgICAgICAgICAgLyogd2hlcmUgdG8gc2F2ZSBnemlwIGhlYWRlciBpbmZvcm1hdGlvbiAqL1xuXG4gIC8qIHNsaWRpbmcgd2luZG93ICovXG4gIHRoaXMud2JpdHMgPSAwOyAgICAgICAgICAgICAvKiBsb2cgYmFzZSAyIG9mIHJlcXVlc3RlZCB3aW5kb3cgc2l6ZSAqL1xuICB0aGlzLndzaXplID0gMDsgICAgICAgICAgICAgLyogd2luZG93IHNpemUgb3IgemVybyBpZiBub3QgdXNpbmcgd2luZG93ICovXG4gIHRoaXMud2hhdmUgPSAwOyAgICAgICAgICAgICAvKiB2YWxpZCBieXRlcyBpbiB0aGUgd2luZG93ICovXG4gIHRoaXMud25leHQgPSAwOyAgICAgICAgICAgICAvKiB3aW5kb3cgd3JpdGUgaW5kZXggKi9cbiAgdGhpcy53aW5kb3cgPSBudWxsOyAgICAgICAgIC8qIGFsbG9jYXRlZCBzbGlkaW5nIHdpbmRvdywgaWYgbmVlZGVkICovXG5cbiAgLyogYml0IGFjY3VtdWxhdG9yICovXG4gIHRoaXMuaG9sZCA9IDA7ICAgICAgICAgICAgICAvKiBpbnB1dCBiaXQgYWNjdW11bGF0b3IgKi9cbiAgdGhpcy5iaXRzID0gMDsgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBiaXRzIGluIFwiaW5cIiAqL1xuXG4gIC8qIGZvciBzdHJpbmcgYW5kIHN0b3JlZCBibG9jayBjb3B5aW5nICovXG4gIHRoaXMubGVuZ3RoID0gMDsgICAgICAgICAgICAvKiBsaXRlcmFsIG9yIGxlbmd0aCBvZiBkYXRhIHRvIGNvcHkgKi9cbiAgdGhpcy5vZmZzZXQgPSAwOyAgICAgICAgICAgIC8qIGRpc3RhbmNlIGJhY2sgdG8gY29weSBzdHJpbmcgZnJvbSAqL1xuXG4gIC8qIGZvciB0YWJsZSBhbmQgY29kZSBkZWNvZGluZyAqL1xuICB0aGlzLmV4dHJhID0gMDsgICAgICAgICAgICAgLyogZXh0cmEgYml0cyBuZWVkZWQgKi9cblxuICAvKiBmaXhlZCBhbmQgZHluYW1pYyBjb2RlIHRhYmxlcyAqL1xuICB0aGlzLmxlbmNvZGUgPSBudWxsOyAgICAgICAgICAvKiBzdGFydGluZyB0YWJsZSBmb3IgbGVuZ3RoL2xpdGVyYWwgY29kZXMgKi9cbiAgdGhpcy5kaXN0Y29kZSA9IG51bGw7ICAgICAgICAgLyogc3RhcnRpbmcgdGFibGUgZm9yIGRpc3RhbmNlIGNvZGVzICovXG4gIHRoaXMubGVuYml0cyA9IDA7ICAgICAgICAgICAvKiBpbmRleCBiaXRzIGZvciBsZW5jb2RlICovXG4gIHRoaXMuZGlzdGJpdHMgPSAwOyAgICAgICAgICAvKiBpbmRleCBiaXRzIGZvciBkaXN0Y29kZSAqL1xuXG4gIC8qIGR5bmFtaWMgdGFibGUgYnVpbGRpbmcgKi9cbiAgdGhpcy5uY29kZSA9IDA7ICAgICAgICAgICAgIC8qIG51bWJlciBvZiBjb2RlIGxlbmd0aCBjb2RlIGxlbmd0aHMgKi9cbiAgdGhpcy5ubGVuID0gMDsgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBsZW5ndGggY29kZSBsZW5ndGhzICovXG4gIHRoaXMubmRpc3QgPSAwOyAgICAgICAgICAgICAvKiBudW1iZXIgb2YgZGlzdGFuY2UgY29kZSBsZW5ndGhzICovXG4gIHRoaXMuaGF2ZSA9IDA7ICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgY29kZSBsZW5ndGhzIGluIGxlbnNbXSAqL1xuICB0aGlzLm5leHQgPSBudWxsOyAgICAgICAgICAgICAgLyogbmV4dCBhdmFpbGFibGUgc3BhY2UgaW4gY29kZXNbXSAqL1xuXG4gIHRoaXMubGVucyA9IG5ldyB1dGlscy5CdWYxNigzMjApOyAvKiB0ZW1wb3Jhcnkgc3RvcmFnZSBmb3IgY29kZSBsZW5ndGhzICovXG4gIHRoaXMud29yayA9IG5ldyB1dGlscy5CdWYxNigyODgpOyAvKiB3b3JrIGFyZWEgZm9yIGNvZGUgdGFibGUgYnVpbGRpbmcgKi9cblxuICAvKlxuICAgYmVjYXVzZSB3ZSBkb24ndCBoYXZlIHBvaW50ZXJzIGluIGpzLCB3ZSB1c2UgbGVuY29kZSBhbmQgZGlzdGNvZGUgZGlyZWN0bHlcbiAgIGFzIGJ1ZmZlcnMgc28gd2UgZG9uJ3QgbmVlZCBjb2Rlc1xuICAqL1xuICAvL3RoaXMuY29kZXMgPSBuZXcgdXRpbHMuQnVmMzIoRU5PVUdIKTsgICAgICAgLyogc3BhY2UgZm9yIGNvZGUgdGFibGVzICovXG4gIHRoaXMubGVuZHluID0gbnVsbDsgICAgICAgICAgICAgIC8qIGR5bmFtaWMgdGFibGUgZm9yIGxlbmd0aC9saXRlcmFsIGNvZGVzIChKUyBzcGVjaWZpYykgKi9cbiAgdGhpcy5kaXN0ZHluID0gbnVsbDsgICAgICAgICAgICAgLyogZHluYW1pYyB0YWJsZSBmb3IgZGlzdGFuY2UgY29kZXMgKEpTIHNwZWNpZmljKSAqL1xuICB0aGlzLnNhbmUgPSAwOyAgICAgICAgICAgICAgICAgICAvKiBpZiBmYWxzZSwgYWxsb3cgaW52YWxpZCBkaXN0YW5jZSB0b28gZmFyICovXG4gIHRoaXMuYmFjayA9IDA7ICAgICAgICAgICAgICAgICAgIC8qIGJpdHMgYmFjayBvZiBsYXN0IHVucHJvY2Vzc2VkIGxlbmd0aC9saXQgKi9cbiAgdGhpcy53YXMgPSAwOyAgICAgICAgICAgICAgICAgICAgLyogaW5pdGlhbCBsZW5ndGggb2YgbWF0Y2ggKi9cbn1cblxuZnVuY3Rpb24gaW5mbGF0ZVJlc2V0S2VlcChzdHJtKSB7XG4gIHZhciBzdGF0ZTtcblxuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOyB9XG4gIHN0YXRlID0gc3RybS5zdGF0ZTtcbiAgc3RybS50b3RhbF9pbiA9IHN0cm0udG90YWxfb3V0ID0gc3RhdGUudG90YWwgPSAwO1xuICBzdHJtLm1zZyA9ICcnOyAvKlpfTlVMTCovXG4gIGlmIChzdGF0ZS53cmFwKSB7ICAgICAgIC8qIHRvIHN1cHBvcnQgaWxsLWNvbmNlaXZlZCBKYXZhIHRlc3Qgc3VpdGUgKi9cbiAgICBzdHJtLmFkbGVyID0gc3RhdGUud3JhcCAmIDE7XG4gIH1cbiAgc3RhdGUubW9kZSA9IEhFQUQ7XG4gIHN0YXRlLmxhc3QgPSAwO1xuICBzdGF0ZS5oYXZlZGljdCA9IDA7XG4gIHN0YXRlLmRtYXggPSAzMjc2ODtcbiAgc3RhdGUuaGVhZCA9IG51bGwvKlpfTlVMTCovO1xuICBzdGF0ZS5ob2xkID0gMDtcbiAgc3RhdGUuYml0cyA9IDA7XG4gIC8vc3RhdGUubGVuY29kZSA9IHN0YXRlLmRpc3Rjb2RlID0gc3RhdGUubmV4dCA9IHN0YXRlLmNvZGVzO1xuICBzdGF0ZS5sZW5jb2RlID0gc3RhdGUubGVuZHluID0gbmV3IHV0aWxzLkJ1ZjMyKEVOT1VHSF9MRU5TKTtcbiAgc3RhdGUuZGlzdGNvZGUgPSBzdGF0ZS5kaXN0ZHluID0gbmV3IHV0aWxzLkJ1ZjMyKEVOT1VHSF9ESVNUUyk7XG5cbiAgc3RhdGUuc2FuZSA9IDE7XG4gIHN0YXRlLmJhY2sgPSAtMTtcbiAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiByZXNldFxcblwiKSk7XG4gIHJldHVybiBaX09LO1xufVxuXG5mdW5jdGlvbiBpbmZsYXRlUmVzZXQoc3RybSkge1xuICB2YXIgc3RhdGU7XG5cbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuICBzdGF0ZSA9IHN0cm0uc3RhdGU7XG4gIHN0YXRlLndzaXplID0gMDtcbiAgc3RhdGUud2hhdmUgPSAwO1xuICBzdGF0ZS53bmV4dCA9IDA7XG4gIHJldHVybiBpbmZsYXRlUmVzZXRLZWVwKHN0cm0pO1xuXG59XG5cbmZ1bmN0aW9uIGluZmxhdGVSZXNldDIoc3RybSwgd2luZG93Qml0cykge1xuICB2YXIgd3JhcDtcbiAgdmFyIHN0YXRlO1xuXG4gIC8qIGdldCB0aGUgc3RhdGUgKi9cbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuICBzdGF0ZSA9IHN0cm0uc3RhdGU7XG5cbiAgLyogZXh0cmFjdCB3cmFwIHJlcXVlc3QgZnJvbSB3aW5kb3dCaXRzIHBhcmFtZXRlciAqL1xuICBpZiAod2luZG93Qml0cyA8IDApIHtcbiAgICB3cmFwID0gMDtcbiAgICB3aW5kb3dCaXRzID0gLXdpbmRvd0JpdHM7XG4gIH1cbiAgZWxzZSB7XG4gICAgd3JhcCA9ICh3aW5kb3dCaXRzID4+IDQpICsgMTtcbiAgICBpZiAod2luZG93Qml0cyA8IDQ4KSB7XG4gICAgICB3aW5kb3dCaXRzICY9IDE1O1xuICAgIH1cbiAgfVxuXG4gIC8qIHNldCBudW1iZXIgb2Ygd2luZG93IGJpdHMsIGZyZWUgd2luZG93IGlmIGRpZmZlcmVudCAqL1xuICBpZiAod2luZG93Qml0cyAmJiAod2luZG93Qml0cyA8IDggfHwgd2luZG93Qml0cyA+IDE1KSkge1xuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgfVxuICBpZiAoc3RhdGUud2luZG93ICE9PSBudWxsICYmIHN0YXRlLndiaXRzICE9PSB3aW5kb3dCaXRzKSB7XG4gICAgc3RhdGUud2luZG93ID0gbnVsbDtcbiAgfVxuXG4gIC8qIHVwZGF0ZSBzdGF0ZSBhbmQgcmVzZXQgdGhlIHJlc3Qgb2YgaXQgKi9cbiAgc3RhdGUud3JhcCA9IHdyYXA7XG4gIHN0YXRlLndiaXRzID0gd2luZG93Qml0cztcbiAgcmV0dXJuIGluZmxhdGVSZXNldChzdHJtKTtcbn1cblxuZnVuY3Rpb24gaW5mbGF0ZUluaXQyKHN0cm0sIHdpbmRvd0JpdHMpIHtcbiAgdmFyIHJldDtcbiAgdmFyIHN0YXRlO1xuXG4gIGlmICghc3RybSkgeyByZXR1cm4gWl9TVFJFQU1fRVJST1I7IH1cbiAgLy9zdHJtLm1zZyA9IFpfTlVMTDsgICAgICAgICAgICAgICAgIC8qIGluIGNhc2Ugd2UgcmV0dXJuIGFuIGVycm9yICovXG5cbiAgc3RhdGUgPSBuZXcgSW5mbGF0ZVN0YXRlKCk7XG5cbiAgLy9pZiAoc3RhdGUgPT09IFpfTlVMTCkgcmV0dXJuIFpfTUVNX0VSUk9SO1xuICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6IGFsbG9jYXRlZFxcblwiKSk7XG4gIHN0cm0uc3RhdGUgPSBzdGF0ZTtcbiAgc3RhdGUud2luZG93ID0gbnVsbC8qWl9OVUxMKi87XG4gIHJldCA9IGluZmxhdGVSZXNldDIoc3RybSwgd2luZG93Qml0cyk7XG4gIGlmIChyZXQgIT09IFpfT0spIHtcbiAgICBzdHJtLnN0YXRlID0gbnVsbC8qWl9OVUxMKi87XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gaW5mbGF0ZUluaXQoc3RybSkge1xuICByZXR1cm4gaW5mbGF0ZUluaXQyKHN0cm0sIERFRl9XQklUUyk7XG59XG5cblxuLypcbiBSZXR1cm4gc3RhdGUgd2l0aCBsZW5ndGggYW5kIGRpc3RhbmNlIGRlY29kaW5nIHRhYmxlcyBhbmQgaW5kZXggc2l6ZXMgc2V0IHRvXG4gZml4ZWQgY29kZSBkZWNvZGluZy4gIE5vcm1hbGx5IHRoaXMgcmV0dXJucyBmaXhlZCB0YWJsZXMgZnJvbSBpbmZmaXhlZC5oLlxuIElmIEJVSUxERklYRUQgaXMgZGVmaW5lZCwgdGhlbiBpbnN0ZWFkIHRoaXMgcm91dGluZSBidWlsZHMgdGhlIHRhYmxlcyB0aGVcbiBmaXJzdCB0aW1lIGl0J3MgY2FsbGVkLCBhbmQgcmV0dXJucyB0aG9zZSB0YWJsZXMgdGhlIGZpcnN0IHRpbWUgYW5kXG4gdGhlcmVhZnRlci4gIFRoaXMgcmVkdWNlcyB0aGUgc2l6ZSBvZiB0aGUgY29kZSBieSBhYm91dCAySyBieXRlcywgaW5cbiBleGNoYW5nZSBmb3IgYSBsaXR0bGUgZXhlY3V0aW9uIHRpbWUuICBIb3dldmVyLCBCVUlMREZJWEVEIHNob3VsZCBub3QgYmVcbiB1c2VkIGZvciB0aHJlYWRlZCBhcHBsaWNhdGlvbnMsIHNpbmNlIHRoZSByZXdyaXRpbmcgb2YgdGhlIHRhYmxlcyBhbmQgdmlyZ2luXG4gbWF5IG5vdCBiZSB0aHJlYWQtc2FmZS5cbiAqL1xudmFyIHZpcmdpbiA9IHRydWU7XG5cbnZhciBsZW5maXgsIGRpc3RmaXg7IC8vIFdlIGhhdmUgbm8gcG9pbnRlcnMgaW4gSlMsIHNvIGtlZXAgdGFibGVzIHNlcGFyYXRlXG5cbmZ1bmN0aW9uIGZpeGVkdGFibGVzKHN0YXRlKSB7XG4gIC8qIGJ1aWxkIGZpeGVkIGh1ZmZtYW4gdGFibGVzIGlmIGZpcnN0IGNhbGwgKG1heSBub3QgYmUgdGhyZWFkIHNhZmUpICovXG4gIGlmICh2aXJnaW4pIHtcbiAgICB2YXIgc3ltO1xuXG4gICAgbGVuZml4ID0gbmV3IHV0aWxzLkJ1ZjMyKDUxMik7XG4gICAgZGlzdGZpeCA9IG5ldyB1dGlscy5CdWYzMigzMik7XG5cbiAgICAvKiBsaXRlcmFsL2xlbmd0aCB0YWJsZSAqL1xuICAgIHN5bSA9IDA7XG4gICAgd2hpbGUgKHN5bSA8IDE0NCkgeyBzdGF0ZS5sZW5zW3N5bSsrXSA9IDg7IH1cbiAgICB3aGlsZSAoc3ltIDwgMjU2KSB7IHN0YXRlLmxlbnNbc3ltKytdID0gOTsgfVxuICAgIHdoaWxlIChzeW0gPCAyODApIHsgc3RhdGUubGVuc1tzeW0rK10gPSA3OyB9XG4gICAgd2hpbGUgKHN5bSA8IDI4OCkgeyBzdGF0ZS5sZW5zW3N5bSsrXSA9IDg7IH1cblxuICAgIGluZmxhdGVfdGFibGUoTEVOUywgIHN0YXRlLmxlbnMsIDAsIDI4OCwgbGVuZml4LCAgIDAsIHN0YXRlLndvcmssIHsgYml0czogOSB9KTtcblxuICAgIC8qIGRpc3RhbmNlIHRhYmxlICovXG4gICAgc3ltID0gMDtcbiAgICB3aGlsZSAoc3ltIDwgMzIpIHsgc3RhdGUubGVuc1tzeW0rK10gPSA1OyB9XG5cbiAgICBpbmZsYXRlX3RhYmxlKERJU1RTLCBzdGF0ZS5sZW5zLCAwLCAzMiwgICBkaXN0Zml4LCAwLCBzdGF0ZS53b3JrLCB7IGJpdHM6IDUgfSk7XG5cbiAgICAvKiBkbyB0aGlzIGp1c3Qgb25jZSAqL1xuICAgIHZpcmdpbiA9IGZhbHNlO1xuICB9XG5cbiAgc3RhdGUubGVuY29kZSA9IGxlbmZpeDtcbiAgc3RhdGUubGVuYml0cyA9IDk7XG4gIHN0YXRlLmRpc3Rjb2RlID0gZGlzdGZpeDtcbiAgc3RhdGUuZGlzdGJpdHMgPSA1O1xufVxuXG5cbi8qXG4gVXBkYXRlIHRoZSB3aW5kb3cgd2l0aCB0aGUgbGFzdCB3c2l6ZSAobm9ybWFsbHkgMzJLKSBieXRlcyB3cml0dGVuIGJlZm9yZVxuIHJldHVybmluZy4gIElmIHdpbmRvdyBkb2VzIG5vdCBleGlzdCB5ZXQsIGNyZWF0ZSBpdC4gIFRoaXMgaXMgb25seSBjYWxsZWRcbiB3aGVuIGEgd2luZG93IGlzIGFscmVhZHkgaW4gdXNlLCBvciB3aGVuIG91dHB1dCBoYXMgYmVlbiB3cml0dGVuIGR1cmluZyB0aGlzXG4gaW5mbGF0ZSBjYWxsLCBidXQgdGhlIGVuZCBvZiB0aGUgZGVmbGF0ZSBzdHJlYW0gaGFzIG5vdCBiZWVuIHJlYWNoZWQgeWV0LlxuIEl0IGlzIGFsc28gY2FsbGVkIHRvIGNyZWF0ZSBhIHdpbmRvdyBmb3IgZGljdGlvbmFyeSBkYXRhIHdoZW4gYSBkaWN0aW9uYXJ5XG4gaXMgbG9hZGVkLlxuXG4gUHJvdmlkaW5nIG91dHB1dCBidWZmZXJzIGxhcmdlciB0aGFuIDMySyB0byBpbmZsYXRlKCkgc2hvdWxkIHByb3ZpZGUgYSBzcGVlZFxuIGFkdmFudGFnZSwgc2luY2Ugb25seSB0aGUgbGFzdCAzMksgb2Ygb3V0cHV0IGlzIGNvcGllZCB0byB0aGUgc2xpZGluZyB3aW5kb3dcbiB1cG9uIHJldHVybiBmcm9tIGluZmxhdGUoKSwgYW5kIHNpbmNlIGFsbCBkaXN0YW5jZXMgYWZ0ZXIgdGhlIGZpcnN0IDMySyBvZlxuIG91dHB1dCB3aWxsIGZhbGwgaW4gdGhlIG91dHB1dCBkYXRhLCBtYWtpbmcgbWF0Y2ggY29waWVzIHNpbXBsZXIgYW5kIGZhc3Rlci5cbiBUaGUgYWR2YW50YWdlIG1heSBiZSBkZXBlbmRlbnQgb24gdGhlIHNpemUgb2YgdGhlIHByb2Nlc3NvcidzIGRhdGEgY2FjaGVzLlxuICovXG5mdW5jdGlvbiB1cGRhdGV3aW5kb3coc3RybSwgc3JjLCBlbmQsIGNvcHkpIHtcbiAgdmFyIGRpc3Q7XG4gIHZhciBzdGF0ZSA9IHN0cm0uc3RhdGU7XG5cbiAgLyogaWYgaXQgaGFzbid0IGJlZW4gZG9uZSBhbHJlYWR5LCBhbGxvY2F0ZSBzcGFjZSBmb3IgdGhlIHdpbmRvdyAqL1xuICBpZiAoc3RhdGUud2luZG93ID09PSBudWxsKSB7XG4gICAgc3RhdGUud3NpemUgPSAxIDw8IHN0YXRlLndiaXRzO1xuICAgIHN0YXRlLnduZXh0ID0gMDtcbiAgICBzdGF0ZS53aGF2ZSA9IDA7XG5cbiAgICBzdGF0ZS53aW5kb3cgPSBuZXcgdXRpbHMuQnVmOChzdGF0ZS53c2l6ZSk7XG4gIH1cblxuICAvKiBjb3B5IHN0YXRlLT53c2l6ZSBvciBsZXNzIG91dHB1dCBieXRlcyBpbnRvIHRoZSBjaXJjdWxhciB3aW5kb3cgKi9cbiAgaWYgKGNvcHkgPj0gc3RhdGUud3NpemUpIHtcbiAgICB1dGlscy5hcnJheVNldChzdGF0ZS53aW5kb3csIHNyYywgZW5kIC0gc3RhdGUud3NpemUsIHN0YXRlLndzaXplLCAwKTtcbiAgICBzdGF0ZS53bmV4dCA9IDA7XG4gICAgc3RhdGUud2hhdmUgPSBzdGF0ZS53c2l6ZTtcbiAgfVxuICBlbHNlIHtcbiAgICBkaXN0ID0gc3RhdGUud3NpemUgLSBzdGF0ZS53bmV4dDtcbiAgICBpZiAoZGlzdCA+IGNvcHkpIHtcbiAgICAgIGRpc3QgPSBjb3B5O1xuICAgIH1cbiAgICAvL3ptZW1jcHkoc3RhdGUtPndpbmRvdyArIHN0YXRlLT53bmV4dCwgZW5kIC0gY29weSwgZGlzdCk7XG4gICAgdXRpbHMuYXJyYXlTZXQoc3RhdGUud2luZG93LCBzcmMsIGVuZCAtIGNvcHksIGRpc3QsIHN0YXRlLnduZXh0KTtcbiAgICBjb3B5IC09IGRpc3Q7XG4gICAgaWYgKGNvcHkpIHtcbiAgICAgIC8vem1lbWNweShzdGF0ZS0+d2luZG93LCBlbmQgLSBjb3B5LCBjb3B5KTtcbiAgICAgIHV0aWxzLmFycmF5U2V0KHN0YXRlLndpbmRvdywgc3JjLCBlbmQgLSBjb3B5LCBjb3B5LCAwKTtcbiAgICAgIHN0YXRlLnduZXh0ID0gY29weTtcbiAgICAgIHN0YXRlLndoYXZlID0gc3RhdGUud3NpemU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgc3RhdGUud25leHQgKz0gZGlzdDtcbiAgICAgIGlmIChzdGF0ZS53bmV4dCA9PT0gc3RhdGUud3NpemUpIHsgc3RhdGUud25leHQgPSAwOyB9XG4gICAgICBpZiAoc3RhdGUud2hhdmUgPCBzdGF0ZS53c2l6ZSkgeyBzdGF0ZS53aGF2ZSArPSBkaXN0OyB9XG4gICAgfVxuICB9XG4gIHJldHVybiAwO1xufVxuXG5mdW5jdGlvbiBpbmZsYXRlKHN0cm0sIGZsdXNoKSB7XG4gIHZhciBzdGF0ZTtcbiAgdmFyIGlucHV0LCBvdXRwdXQ7ICAgICAgICAgIC8vIGlucHV0L291dHB1dCBidWZmZXJzXG4gIHZhciBuZXh0OyAgICAgICAgICAgICAgICAgICAvKiBuZXh0IGlucHV0IElOREVYICovXG4gIHZhciBwdXQ7ICAgICAgICAgICAgICAgICAgICAvKiBuZXh0IG91dHB1dCBJTkRFWCAqL1xuICB2YXIgaGF2ZSwgbGVmdDsgICAgICAgICAgICAgLyogYXZhaWxhYmxlIGlucHV0IGFuZCBvdXRwdXQgKi9cbiAgdmFyIGhvbGQ7ICAgICAgICAgICAgICAgICAgIC8qIGJpdCBidWZmZXIgKi9cbiAgdmFyIGJpdHM7ICAgICAgICAgICAgICAgICAgIC8qIGJpdHMgaW4gYml0IGJ1ZmZlciAqL1xuICB2YXIgX2luLCBfb3V0OyAgICAgICAgICAgICAgLyogc2F2ZSBzdGFydGluZyBhdmFpbGFibGUgaW5wdXQgYW5kIG91dHB1dCAqL1xuICB2YXIgY29weTsgICAgICAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIHN0b3JlZCBvciBtYXRjaCBieXRlcyB0byBjb3B5ICovXG4gIHZhciBmcm9tOyAgICAgICAgICAgICAgICAgICAvKiB3aGVyZSB0byBjb3B5IG1hdGNoIGJ5dGVzIGZyb20gKi9cbiAgdmFyIGZyb21fc291cmNlO1xuICB2YXIgaGVyZSA9IDA7ICAgICAgICAgICAgICAgLyogY3VycmVudCBkZWNvZGluZyB0YWJsZSBlbnRyeSAqL1xuICB2YXIgaGVyZV9iaXRzLCBoZXJlX29wLCBoZXJlX3ZhbDsgLy8gcGFrZWQgXCJoZXJlXCIgZGVub3JtYWxpemVkIChKUyBzcGVjaWZpYylcbiAgLy92YXIgbGFzdDsgICAgICAgICAgICAgICAgICAgLyogcGFyZW50IHRhYmxlIGVudHJ5ICovXG4gIHZhciBsYXN0X2JpdHMsIGxhc3Rfb3AsIGxhc3RfdmFsOyAvLyBwYWtlZCBcImxhc3RcIiBkZW5vcm1hbGl6ZWQgKEpTIHNwZWNpZmljKVxuICB2YXIgbGVuOyAgICAgICAgICAgICAgICAgICAgLyogbGVuZ3RoIHRvIGNvcHkgZm9yIHJlcGVhdHMsIGJpdHMgdG8gZHJvcCAqL1xuICB2YXIgcmV0OyAgICAgICAgICAgICAgICAgICAgLyogcmV0dXJuIGNvZGUgKi9cbiAgdmFyIGhidWYgPSBuZXcgdXRpbHMuQnVmOCg0KTsgICAgLyogYnVmZmVyIGZvciBnemlwIGhlYWRlciBjcmMgY2FsY3VsYXRpb24gKi9cbiAgdmFyIG9wdHM7XG5cbiAgdmFyIG47IC8vIHRlbXBvcmFyeSB2YXIgZm9yIE5FRURfQklUU1xuXG4gIHZhciBvcmRlciA9IC8qIHBlcm11dGF0aW9uIG9mIGNvZGUgbGVuZ3RocyAqL1xuICAgIFsgMTYsIDE3LCAxOCwgMCwgOCwgNywgOSwgNiwgMTAsIDUsIDExLCA0LCAxMiwgMywgMTMsIDIsIDE0LCAxLCAxNSBdO1xuXG5cbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlIHx8ICFzdHJtLm91dHB1dCB8fFxuICAgICAgKCFzdHJtLmlucHV0ICYmIHN0cm0uYXZhaWxfaW4gIT09IDApKSB7XG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICB9XG5cbiAgc3RhdGUgPSBzdHJtLnN0YXRlO1xuICBpZiAoc3RhdGUubW9kZSA9PT0gVFlQRSkgeyBzdGF0ZS5tb2RlID0gVFlQRURPOyB9ICAgIC8qIHNraXAgY2hlY2sgKi9cblxuXG4gIC8vLS0tIExPQUQoKSAtLS1cbiAgcHV0ID0gc3RybS5uZXh0X291dDtcbiAgb3V0cHV0ID0gc3RybS5vdXRwdXQ7XG4gIGxlZnQgPSBzdHJtLmF2YWlsX291dDtcbiAgbmV4dCA9IHN0cm0ubmV4dF9pbjtcbiAgaW5wdXQgPSBzdHJtLmlucHV0O1xuICBoYXZlID0gc3RybS5hdmFpbF9pbjtcbiAgaG9sZCA9IHN0YXRlLmhvbGQ7XG4gIGJpdHMgPSBzdGF0ZS5iaXRzO1xuICAvLy0tLVxuXG4gIF9pbiA9IGhhdmU7XG4gIF9vdXQgPSBsZWZ0O1xuICByZXQgPSBaX09LO1xuXG4gIGluZl9sZWF2ZTogLy8gZ290byBlbXVsYXRpb25cbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoc3RhdGUubW9kZSkge1xuICAgICAgY2FzZSBIRUFEOlxuICAgICAgICBpZiAoc3RhdGUud3JhcCA9PT0gMCkge1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBUWVBFRE87XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0gTkVFREJJVFMoMTYpO1xuICAgICAgICB3aGlsZSAoYml0cyA8IDE2KSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIGlmICgoc3RhdGUud3JhcCAmIDIpICYmIGhvbGQgPT09IDB4OGIxZikgeyAgLyogZ3ppcCBoZWFkZXIgKi9cbiAgICAgICAgICBzdGF0ZS5jaGVjayA9IDAvKmNyYzMyKDBMLCBaX05VTEwsIDApKi87XG4gICAgICAgICAgLy89PT0gQ1JDMihzdGF0ZS5jaGVjaywgaG9sZCk7XG4gICAgICAgICAgaGJ1ZlswXSA9IGhvbGQgJiAweGZmO1xuICAgICAgICAgIGhidWZbMV0gPSAoaG9sZCA+Pj4gOCkgJiAweGZmO1xuICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGhidWYsIDIsIDApO1xuICAgICAgICAgIC8vPT09Ly9cblxuICAgICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgICAgYml0cyA9IDA7XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBGTEFHUztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5mbGFncyA9IDA7ICAgICAgICAgICAvKiBleHBlY3QgemxpYiBoZWFkZXIgKi9cbiAgICAgICAgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgICBzdGF0ZS5oZWFkLmRvbmUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShzdGF0ZS53cmFwICYgMSkgfHwgICAvKiBjaGVjayBpZiB6bGliIGhlYWRlciBhbGxvd2VkICovXG4gICAgICAgICAgKCgoaG9sZCAmIDB4ZmYpLypCSVRTKDgpKi8gPDwgOCkgKyAoaG9sZCA+PiA4KSkgJSAzMSkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2luY29ycmVjdCBoZWFkZXIgY2hlY2snO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChob2xkICYgMHgwZikvKkJJVFMoNCkqLyAhPT0gWl9ERUZMQVRFRCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ3Vua25vd24gY29tcHJlc3Npb24gbWV0aG9kJztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vLS0tIERST1BCSVRTKDQpIC0tLS8vXG4gICAgICAgIGhvbGQgPj4+PSA0O1xuICAgICAgICBiaXRzIC09IDQ7XG4gICAgICAgIC8vLS0tLy9cbiAgICAgICAgbGVuID0gKGhvbGQgJiAweDBmKS8qQklUUyg0KSovICsgODtcbiAgICAgICAgaWYgKHN0YXRlLndiaXRzID09PSAwKSB7XG4gICAgICAgICAgc3RhdGUud2JpdHMgPSBsZW47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobGVuID4gc3RhdGUud2JpdHMpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIHdpbmRvdyBzaXplJztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLmRtYXggPSAxIDw8IGxlbjtcbiAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgIHpsaWIgaGVhZGVyIG9rXFxuXCIpKTtcbiAgICAgICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID0gMS8qYWRsZXIzMigwTCwgWl9OVUxMLCAwKSovO1xuICAgICAgICBzdGF0ZS5tb2RlID0gaG9sZCAmIDB4MjAwID8gRElDVElEIDogVFlQRTtcbiAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAvLz09PS8vXG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBGTEFHUzpcbiAgICAgICAgLy89PT0gTkVFREJJVFMoMTYpOyAqL1xuICAgICAgICB3aGlsZSAoYml0cyA8IDE2KSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0YXRlLmZsYWdzID0gaG9sZDtcbiAgICAgICAgaWYgKChzdGF0ZS5mbGFncyAmIDB4ZmYpICE9PSBaX0RFRkxBVEVEKSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAndW5rbm93biBjb21wcmVzc2lvbiBtZXRob2QnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHhlMDAwKSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAndW5rbm93biBoZWFkZXIgZmxhZ3Mgc2V0JztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgc3RhdGUuaGVhZC50ZXh0ID0gKChob2xkID4+IDgpICYgMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwMjAwKSB7XG4gICAgICAgICAgLy89PT0gQ1JDMihzdGF0ZS5jaGVjaywgaG9sZCk7XG4gICAgICAgICAgaGJ1ZlswXSA9IGhvbGQgJiAweGZmO1xuICAgICAgICAgIGhidWZbMV0gPSAoaG9sZCA+Pj4gOCkgJiAweGZmO1xuICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGhidWYsIDIsIDApO1xuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgfVxuICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICBob2xkID0gMDtcbiAgICAgICAgYml0cyA9IDA7XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RhdGUubW9kZSA9IFRJTUU7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgVElNRTpcbiAgICAgICAgLy89PT0gTkVFREJJVFMoMzIpOyAqL1xuICAgICAgICB3aGlsZSAoYml0cyA8IDMyKSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgc3RhdGUuaGVhZC50aW1lID0gaG9sZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHtcbiAgICAgICAgICAvLz09PSBDUkM0KHN0YXRlLmNoZWNrLCBob2xkKVxuICAgICAgICAgIGhidWZbMF0gPSBob2xkICYgMHhmZjtcbiAgICAgICAgICBoYnVmWzFdID0gKGhvbGQgPj4+IDgpICYgMHhmZjtcbiAgICAgICAgICBoYnVmWzJdID0gKGhvbGQgPj4+IDE2KSAmIDB4ZmY7XG4gICAgICAgICAgaGJ1ZlszXSA9IChob2xkID4+PiAyNCkgJiAweGZmO1xuICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGhidWYsIDQsIDApO1xuICAgICAgICAgIC8vPT09XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0YXRlLm1vZGUgPSBPUztcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBPUzpcbiAgICAgICAgLy89PT0gTkVFREJJVFMoMTYpOyAqL1xuICAgICAgICB3aGlsZSAoYml0cyA8IDE2KSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgc3RhdGUuaGVhZC54ZmxhZ3MgPSAoaG9sZCAmIDB4ZmYpO1xuICAgICAgICAgIHN0YXRlLmhlYWQub3MgPSAoaG9sZCA+PiA4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHtcbiAgICAgICAgICAvLz09PSBDUkMyKHN0YXRlLmNoZWNrLCBob2xkKTtcbiAgICAgICAgICBoYnVmWzBdID0gaG9sZCAmIDB4ZmY7XG4gICAgICAgICAgaGJ1ZlsxXSA9IChob2xkID4+PiA4KSAmIDB4ZmY7XG4gICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaGJ1ZiwgMiwgMCk7XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICB9XG4gICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgIGhvbGQgPSAwO1xuICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgLy89PT0vL1xuICAgICAgICBzdGF0ZS5tb2RlID0gRVhMRU47XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgRVhMRU46XG4gICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDQwMCkge1xuICAgICAgICAgIC8vPT09IE5FRURCSVRTKDE2KTsgKi9cbiAgICAgICAgICB3aGlsZSAoYml0cyA8IDE2KSB7XG4gICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgc3RhdGUubGVuZ3RoID0gaG9sZDtcbiAgICAgICAgICBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgICAgc3RhdGUuaGVhZC5leHRyYV9sZW4gPSBob2xkO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHtcbiAgICAgICAgICAgIC8vPT09IENSQzIoc3RhdGUuY2hlY2ssIGhvbGQpO1xuICAgICAgICAgICAgaGJ1ZlswXSA9IGhvbGQgJiAweGZmO1xuICAgICAgICAgICAgaGJ1ZlsxXSA9IChob2xkID4+PiA4KSAmIDB4ZmY7XG4gICAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyKHN0YXRlLmNoZWNrLCBoYnVmLCAyLCAwKTtcbiAgICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICB9XG4gICAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgICBob2xkID0gMDtcbiAgICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgIHN0YXRlLmhlYWQuZXh0cmEgPSBudWxsLypaX05VTEwqLztcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5tb2RlID0gRVhUUkE7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgRVhUUkE6XG4gICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDQwMCkge1xuICAgICAgICAgIGNvcHkgPSBzdGF0ZS5sZW5ndGg7XG4gICAgICAgICAgaWYgKGNvcHkgPiBoYXZlKSB7IGNvcHkgPSBoYXZlOyB9XG4gICAgICAgICAgaWYgKGNvcHkpIHtcbiAgICAgICAgICAgIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgICAgIGxlbiA9IHN0YXRlLmhlYWQuZXh0cmFfbGVuIC0gc3RhdGUubGVuZ3RoO1xuICAgICAgICAgICAgICBpZiAoIXN0YXRlLmhlYWQuZXh0cmEpIHtcbiAgICAgICAgICAgICAgICAvLyBVc2UgdW50eXBlZCBhcnJheSBmb3IgbW9yZSBjb252ZW5pZW50IHByb2Nlc3NpbmcgbGF0ZXJcbiAgICAgICAgICAgICAgICBzdGF0ZS5oZWFkLmV4dHJhID0gbmV3IEFycmF5KHN0YXRlLmhlYWQuZXh0cmFfbGVuKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB1dGlscy5hcnJheVNldChcbiAgICAgICAgICAgICAgICBzdGF0ZS5oZWFkLmV4dHJhLFxuICAgICAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgICAgIG5leHQsXG4gICAgICAgICAgICAgICAgLy8gZXh0cmEgZmllbGQgaXMgbGltaXRlZCB0byA2NTUzNiBieXRlc1xuICAgICAgICAgICAgICAgIC8vIC0gbm8gbmVlZCBmb3IgYWRkaXRpb25hbCBzaXplIGNoZWNrXG4gICAgICAgICAgICAgICAgY29weSxcbiAgICAgICAgICAgICAgICAvKmxlbiArIGNvcHkgPiBzdGF0ZS5oZWFkLmV4dHJhX21heCAtIGxlbiA/IHN0YXRlLmhlYWQuZXh0cmFfbWF4IDogY29weSwqL1xuICAgICAgICAgICAgICAgIGxlblxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAvL3ptZW1jcHkoc3RhdGUuaGVhZC5leHRyYSArIGxlbiwgbmV4dCxcbiAgICAgICAgICAgICAgLy8gICAgICAgIGxlbiArIGNvcHkgPiBzdGF0ZS5oZWFkLmV4dHJhX21heCA/XG4gICAgICAgICAgICAgIC8vICAgICAgICBzdGF0ZS5oZWFkLmV4dHJhX21heCAtIGxlbiA6IGNvcHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwMjAwKSB7XG4gICAgICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGlucHV0LCBjb3B5LCBuZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGhhdmUgLT0gY29weTtcbiAgICAgICAgICAgIG5leHQgKz0gY29weTtcbiAgICAgICAgICAgIHN0YXRlLmxlbmd0aCAtPSBjb3B5O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3RhdGUubGVuZ3RoKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICB9XG4gICAgICAgIHN0YXRlLmxlbmd0aCA9IDA7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBOQU1FO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIE5BTUU6XG4gICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDgwMCkge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGNvcHkgPSAwO1xuICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgIC8vIFRPRE86IDIgb3IgMSBieXRlcz9cbiAgICAgICAgICAgIGxlbiA9IGlucHV0W25leHQgKyBjb3B5KytdO1xuICAgICAgICAgICAgLyogdXNlIGNvbnN0YW50IGxpbWl0IGJlY2F1c2UgaW4ganMgd2Ugc2hvdWxkIG5vdCBwcmVhbGxvY2F0ZSBtZW1vcnkgKi9cbiAgICAgICAgICAgIGlmIChzdGF0ZS5oZWFkICYmIGxlbiAmJlxuICAgICAgICAgICAgICAgIChzdGF0ZS5sZW5ndGggPCA2NTUzNiAvKnN0YXRlLmhlYWQubmFtZV9tYXgqLykpIHtcbiAgICAgICAgICAgICAgc3RhdGUuaGVhZC5uYW1lICs9IFN0cmluZy5mcm9tQ2hhckNvZGUobGVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IHdoaWxlIChsZW4gJiYgY29weSA8IGhhdmUpO1xuXG4gICAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwMjAwKSB7XG4gICAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyKHN0YXRlLmNoZWNrLCBpbnB1dCwgY29weSwgbmV4dCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGhhdmUgLT0gY29weTtcbiAgICAgICAgICBuZXh0ICs9IGNvcHk7XG4gICAgICAgICAgaWYgKGxlbikgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgc3RhdGUuaGVhZC5uYW1lID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5sZW5ndGggPSAwO1xuICAgICAgICBzdGF0ZS5tb2RlID0gQ09NTUVOVDtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBDT01NRU5UOlxuICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDEwMDApIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBjb3B5ID0gMDtcbiAgICAgICAgICBkbyB7XG4gICAgICAgICAgICBsZW4gPSBpbnB1dFtuZXh0ICsgY29weSsrXTtcbiAgICAgICAgICAgIC8qIHVzZSBjb25zdGFudCBsaW1pdCBiZWNhdXNlIGluIGpzIHdlIHNob3VsZCBub3QgcHJlYWxsb2NhdGUgbWVtb3J5ICovXG4gICAgICAgICAgICBpZiAoc3RhdGUuaGVhZCAmJiBsZW4gJiZcbiAgICAgICAgICAgICAgICAoc3RhdGUubGVuZ3RoIDwgNjU1MzYgLypzdGF0ZS5oZWFkLmNvbW1fbWF4Ki8pKSB7XG4gICAgICAgICAgICAgIHN0YXRlLmhlYWQuY29tbWVudCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGxlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSB3aGlsZSAobGVuICYmIGNvcHkgPCBoYXZlKTtcbiAgICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHtcbiAgICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGlucHV0LCBjb3B5LCBuZXh0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaGF2ZSAtPSBjb3B5O1xuICAgICAgICAgIG5leHQgKz0gY29weTtcbiAgICAgICAgICBpZiAobGVuKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgICBzdGF0ZS5oZWFkLmNvbW1lbnQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLm1vZGUgPSBIQ1JDO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIEhDUkM6XG4gICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkge1xuICAgICAgICAgIC8vPT09IE5FRURCSVRTKDE2KTsgKi9cbiAgICAgICAgICB3aGlsZSAoYml0cyA8IDE2KSB7XG4gICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgaWYgKGhvbGQgIT09IChzdGF0ZS5jaGVjayAmIDB4ZmZmZikpIHtcbiAgICAgICAgICAgIHN0cm0ubXNnID0gJ2hlYWRlciBjcmMgbWlzbWF0Y2gnO1xuICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICAgIGhvbGQgPSAwO1xuICAgICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgIHN0YXRlLmhlYWQuaGNyYyA9ICgoc3RhdGUuZmxhZ3MgPj4gOSkgJiAxKTtcbiAgICAgICAgICBzdGF0ZS5oZWFkLmRvbmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS5jaGVjayA9IDA7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBUWVBFO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRElDVElEOlxuICAgICAgICAvLz09PSBORUVEQklUUygzMik7ICovXG4gICAgICAgIHdoaWxlIChiaXRzIDwgMzIpIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID0genN3YXAzMihob2xkKTtcbiAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0YXRlLm1vZGUgPSBESUNUO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIERJQ1Q6XG4gICAgICAgIGlmIChzdGF0ZS5oYXZlZGljdCA9PT0gMCkge1xuICAgICAgICAgIC8vLS0tIFJFU1RPUkUoKSAtLS1cbiAgICAgICAgICBzdHJtLm5leHRfb3V0ID0gcHV0O1xuICAgICAgICAgIHN0cm0uYXZhaWxfb3V0ID0gbGVmdDtcbiAgICAgICAgICBzdHJtLm5leHRfaW4gPSBuZXh0O1xuICAgICAgICAgIHN0cm0uYXZhaWxfaW4gPSBoYXZlO1xuICAgICAgICAgIHN0YXRlLmhvbGQgPSBob2xkO1xuICAgICAgICAgIHN0YXRlLmJpdHMgPSBiaXRzO1xuICAgICAgICAgIC8vLS0tXG4gICAgICAgICAgcmV0dXJuIFpfTkVFRF9ESUNUO1xuICAgICAgICB9XG4gICAgICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS5jaGVjayA9IDEvKmFkbGVyMzIoMEwsIFpfTlVMTCwgMCkqLztcbiAgICAgICAgc3RhdGUubW9kZSA9IFRZUEU7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgVFlQRTpcbiAgICAgICAgaWYgKGZsdXNoID09PSBaX0JMT0NLIHx8IGZsdXNoID09PSBaX1RSRUVTKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIFRZUEVETzpcbiAgICAgICAgaWYgKHN0YXRlLmxhc3QpIHtcbiAgICAgICAgICAvLy0tLSBCWVRFQklUUygpIC0tLS8vXG4gICAgICAgICAgaG9sZCA+Pj49IGJpdHMgJiA3O1xuICAgICAgICAgIGJpdHMgLT0gYml0cyAmIDc7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBDSEVDSztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvLz09PSBORUVEQklUUygzKTsgKi9cbiAgICAgICAgd2hpbGUgKGJpdHMgPCAzKSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0YXRlLmxhc3QgPSAoaG9sZCAmIDB4MDEpLypCSVRTKDEpKi87XG4gICAgICAgIC8vLS0tIERST1BCSVRTKDEpIC0tLS8vXG4gICAgICAgIGhvbGQgPj4+PSAxO1xuICAgICAgICBiaXRzIC09IDE7XG4gICAgICAgIC8vLS0tLy9cblxuICAgICAgICBzd2l0Y2ggKChob2xkICYgMHgwMykvKkJJVFMoMikqLykge1xuICAgICAgICAgIGNhc2UgMDogICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIHN0b3JlZCBibG9jayAqL1xuICAgICAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgc3RvcmVkIGJsb2NrJXNcXG5cIixcbiAgICAgICAgICAgIC8vICAgICAgICBzdGF0ZS5sYXN0ID8gXCIgKGxhc3QpXCIgOiBcIlwiKSk7XG4gICAgICAgICAgICBzdGF0ZS5tb2RlID0gU1RPUkVEO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAxOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogZml4ZWQgYmxvY2sgKi9cbiAgICAgICAgICAgIGZpeGVkdGFibGVzKHN0YXRlKTtcbiAgICAgICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgIGZpeGVkIGNvZGVzIGJsb2NrJXNcXG5cIixcbiAgICAgICAgICAgIC8vICAgICAgICBzdGF0ZS5sYXN0ID8gXCIgKGxhc3QpXCIgOiBcIlwiKSk7XG4gICAgICAgICAgICBzdGF0ZS5tb2RlID0gTEVOXzsgICAgICAgICAgICAgLyogZGVjb2RlIGNvZGVzICovXG4gICAgICAgICAgICBpZiAoZmx1c2ggPT09IFpfVFJFRVMpIHtcbiAgICAgICAgICAgICAgLy8tLS0gRFJPUEJJVFMoMikgLS0tLy9cbiAgICAgICAgICAgICAgaG9sZCA+Pj49IDI7XG4gICAgICAgICAgICAgIGJpdHMgLT0gMjtcbiAgICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgICAgICBicmVhayBpbmZfbGVhdmU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDI6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBkeW5hbWljIGJsb2NrICovXG4gICAgICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgICBkeW5hbWljIGNvZGVzIGJsb2NrJXNcXG5cIixcbiAgICAgICAgICAgIC8vICAgICAgICBzdGF0ZS5sYXN0ID8gXCIgKGxhc3QpXCIgOiBcIlwiKSk7XG4gICAgICAgICAgICBzdGF0ZS5tb2RlID0gVEFCTEU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGJsb2NrIHR5cGUnO1xuICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgfVxuICAgICAgICAvLy0tLSBEUk9QQklUUygyKSAtLS0vL1xuICAgICAgICBob2xkID4+Pj0gMjtcbiAgICAgICAgYml0cyAtPSAyO1xuICAgICAgICAvLy0tLS8vXG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBTVE9SRUQ6XG4gICAgICAgIC8vLS0tIEJZVEVCSVRTKCkgLS0tLy8gLyogZ28gdG8gYnl0ZSBib3VuZGFyeSAqL1xuICAgICAgICBob2xkID4+Pj0gYml0cyAmIDc7XG4gICAgICAgIGJpdHMgLT0gYml0cyAmIDc7XG4gICAgICAgIC8vLS0tLy9cbiAgICAgICAgLy89PT0gTkVFREJJVFMoMzIpOyAqL1xuICAgICAgICB3aGlsZSAoYml0cyA8IDMyKSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIGlmICgoaG9sZCAmIDB4ZmZmZikgIT09ICgoaG9sZCA+Pj4gMTYpIF4gMHhmZmZmKSkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgc3RvcmVkIGJsb2NrIGxlbmd0aHMnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUubGVuZ3RoID0gaG9sZCAmIDB4ZmZmZjtcbiAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICBzdG9yZWQgbGVuZ3RoICV1XFxuXCIsXG4gICAgICAgIC8vICAgICAgICBzdGF0ZS5sZW5ndGgpKTtcbiAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0YXRlLm1vZGUgPSBDT1BZXztcbiAgICAgICAgaWYgKGZsdXNoID09PSBaX1RSRUVTKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIENPUFlfOlxuICAgICAgICBzdGF0ZS5tb2RlID0gQ09QWTtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBDT1BZOlxuICAgICAgICBjb3B5ID0gc3RhdGUubGVuZ3RoO1xuICAgICAgICBpZiAoY29weSkge1xuICAgICAgICAgIGlmIChjb3B5ID4gaGF2ZSkgeyBjb3B5ID0gaGF2ZTsgfVxuICAgICAgICAgIGlmIChjb3B5ID4gbGVmdCkgeyBjb3B5ID0gbGVmdDsgfVxuICAgICAgICAgIGlmIChjb3B5ID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIC8vLS0tIHptZW1jcHkocHV0LCBuZXh0LCBjb3B5KTsgLS0tXG4gICAgICAgICAgdXRpbHMuYXJyYXlTZXQob3V0cHV0LCBpbnB1dCwgbmV4dCwgY29weSwgcHV0KTtcbiAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgaGF2ZSAtPSBjb3B5O1xuICAgICAgICAgIG5leHQgKz0gY29weTtcbiAgICAgICAgICBsZWZ0IC09IGNvcHk7XG4gICAgICAgICAgcHV0ICs9IGNvcHk7XG4gICAgICAgICAgc3RhdGUubGVuZ3RoIC09IGNvcHk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICBzdG9yZWQgZW5kXFxuXCIpKTtcbiAgICAgICAgc3RhdGUubW9kZSA9IFRZUEU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBUQUJMRTpcbiAgICAgICAgLy89PT0gTkVFREJJVFMoMTQpOyAqL1xuICAgICAgICB3aGlsZSAoYml0cyA8IDE0KSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0YXRlLm5sZW4gPSAoaG9sZCAmIDB4MWYpLypCSVRTKDUpKi8gKyAyNTc7XG4gICAgICAgIC8vLS0tIERST1BCSVRTKDUpIC0tLS8vXG4gICAgICAgIGhvbGQgPj4+PSA1O1xuICAgICAgICBiaXRzIC09IDU7XG4gICAgICAgIC8vLS0tLy9cbiAgICAgICAgc3RhdGUubmRpc3QgPSAoaG9sZCAmIDB4MWYpLypCSVRTKDUpKi8gKyAxO1xuICAgICAgICAvLy0tLSBEUk9QQklUUyg1KSAtLS0vL1xuICAgICAgICBob2xkID4+Pj0gNTtcbiAgICAgICAgYml0cyAtPSA1O1xuICAgICAgICAvLy0tLS8vXG4gICAgICAgIHN0YXRlLm5jb2RlID0gKGhvbGQgJiAweDBmKS8qQklUUyg0KSovICsgNDtcbiAgICAgICAgLy8tLS0gRFJPUEJJVFMoNCkgLS0tLy9cbiAgICAgICAgaG9sZCA+Pj49IDQ7XG4gICAgICAgIGJpdHMgLT0gNDtcbiAgICAgICAgLy8tLS0vL1xuLy8jaWZuZGVmIFBLWklQX0JVR19XT1JLQVJPVU5EXG4gICAgICAgIGlmIChzdGF0ZS5ubGVuID4gMjg2IHx8IHN0YXRlLm5kaXN0ID4gMzApIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICd0b28gbWFueSBsZW5ndGggb3IgZGlzdGFuY2Ugc3ltYm9scyc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuLy8jZW5kaWZcbiAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICB0YWJsZSBzaXplcyBva1xcblwiKSk7XG4gICAgICAgIHN0YXRlLmhhdmUgPSAwO1xuICAgICAgICBzdGF0ZS5tb2RlID0gTEVOTEVOUztcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBMRU5MRU5TOlxuICAgICAgICB3aGlsZSAoc3RhdGUuaGF2ZSA8IHN0YXRlLm5jb2RlKSB7XG4gICAgICAgICAgLy89PT0gTkVFREJJVFMoMyk7XG4gICAgICAgICAgd2hpbGUgKGJpdHMgPCAzKSB7XG4gICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgc3RhdGUubGVuc1tvcmRlcltzdGF0ZS5oYXZlKytdXSA9IChob2xkICYgMHgwNyk7Ly9CSVRTKDMpO1xuICAgICAgICAgIC8vLS0tIERST1BCSVRTKDMpIC0tLS8vXG4gICAgICAgICAgaG9sZCA+Pj49IDM7XG4gICAgICAgICAgYml0cyAtPSAzO1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoc3RhdGUuaGF2ZSA8IDE5KSB7XG4gICAgICAgICAgc3RhdGUubGVuc1tvcmRlcltzdGF0ZS5oYXZlKytdXSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2UgaGF2ZSBzZXBhcmF0ZSB0YWJsZXMgJiBubyBwb2ludGVycy4gMiBjb21tZW50ZWQgbGluZXMgYmVsb3cgbm90IG5lZWRlZC5cbiAgICAgICAgLy9zdGF0ZS5uZXh0ID0gc3RhdGUuY29kZXM7XG4gICAgICAgIC8vc3RhdGUubGVuY29kZSA9IHN0YXRlLm5leHQ7XG4gICAgICAgIC8vIFN3aXRjaCB0byB1c2UgZHluYW1pYyB0YWJsZVxuICAgICAgICBzdGF0ZS5sZW5jb2RlID0gc3RhdGUubGVuZHluO1xuICAgICAgICBzdGF0ZS5sZW5iaXRzID0gNztcblxuICAgICAgICBvcHRzID0geyBiaXRzOiBzdGF0ZS5sZW5iaXRzIH07XG4gICAgICAgIHJldCA9IGluZmxhdGVfdGFibGUoQ09ERVMsIHN0YXRlLmxlbnMsIDAsIDE5LCBzdGF0ZS5sZW5jb2RlLCAwLCBzdGF0ZS53b3JrLCBvcHRzKTtcbiAgICAgICAgc3RhdGUubGVuYml0cyA9IG9wdHMuYml0cztcblxuICAgICAgICBpZiAocmV0KSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBjb2RlIGxlbmd0aHMgc2V0JztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgY29kZSBsZW5ndGhzIG9rXFxuXCIpKTtcbiAgICAgICAgc3RhdGUuaGF2ZSA9IDA7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBDT0RFTEVOUztcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBDT0RFTEVOUzpcbiAgICAgICAgd2hpbGUgKHN0YXRlLmhhdmUgPCBzdGF0ZS5ubGVuICsgc3RhdGUubmRpc3QpIHtcbiAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBoZXJlID0gc3RhdGUubGVuY29kZVtob2xkICYgKCgxIDw8IHN0YXRlLmxlbmJpdHMpIC0gMSldOy8qQklUUyhzdGF0ZS5sZW5iaXRzKSovXG4gICAgICAgICAgICBoZXJlX2JpdHMgPSBoZXJlID4+PiAyNDtcbiAgICAgICAgICAgIGhlcmVfb3AgPSAoaGVyZSA+Pj4gMTYpICYgMHhmZjtcbiAgICAgICAgICAgIGhlcmVfdmFsID0gaGVyZSAmIDB4ZmZmZjtcblxuICAgICAgICAgICAgaWYgKChoZXJlX2JpdHMpIDw9IGJpdHMpIHsgYnJlYWs7IH1cbiAgICAgICAgICAgIC8vLS0tIFBVTExCWVRFKCkgLS0tLy9cbiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChoZXJlX3ZhbCA8IDE2KSB7XG4gICAgICAgICAgICAvLy0tLSBEUk9QQklUUyhoZXJlLmJpdHMpIC0tLS8vXG4gICAgICAgICAgICBob2xkID4+Pj0gaGVyZV9iaXRzO1xuICAgICAgICAgICAgYml0cyAtPSBoZXJlX2JpdHM7XG4gICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgICBzdGF0ZS5sZW5zW3N0YXRlLmhhdmUrK10gPSBoZXJlX3ZhbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoaGVyZV92YWwgPT09IDE2KSB7XG4gICAgICAgICAgICAgIC8vPT09IE5FRURCSVRTKGhlcmUuYml0cyArIDIpO1xuICAgICAgICAgICAgICBuID0gaGVyZV9iaXRzICsgMjtcbiAgICAgICAgICAgICAgd2hpbGUgKGJpdHMgPCBuKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKGhlcmUuYml0cykgLS0tLy9cbiAgICAgICAgICAgICAgaG9sZCA+Pj49IGhlcmVfYml0cztcbiAgICAgICAgICAgICAgYml0cyAtPSBoZXJlX2JpdHM7XG4gICAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICAgICAgaWYgKHN0YXRlLmhhdmUgPT09IDApIHtcbiAgICAgICAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGJpdCBsZW5ndGggcmVwZWF0JztcbiAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGxlbiA9IHN0YXRlLmxlbnNbc3RhdGUuaGF2ZSAtIDFdO1xuICAgICAgICAgICAgICBjb3B5ID0gMyArIChob2xkICYgMHgwMyk7Ly9CSVRTKDIpO1xuICAgICAgICAgICAgICAvLy0tLSBEUk9QQklUUygyKSAtLS0vL1xuICAgICAgICAgICAgICBob2xkID4+Pj0gMjtcbiAgICAgICAgICAgICAgYml0cyAtPSAyO1xuICAgICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChoZXJlX3ZhbCA9PT0gMTcpIHtcbiAgICAgICAgICAgICAgLy89PT0gTkVFREJJVFMoaGVyZS5iaXRzICsgMyk7XG4gICAgICAgICAgICAgIG4gPSBoZXJlX2JpdHMgKyAzO1xuICAgICAgICAgICAgICB3aGlsZSAoYml0cyA8IG4pIHtcbiAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICAgICAgLy8tLS0gRFJPUEJJVFMoaGVyZS5iaXRzKSAtLS0vL1xuICAgICAgICAgICAgICBob2xkID4+Pj0gaGVyZV9iaXRzO1xuICAgICAgICAgICAgICBiaXRzIC09IGhlcmVfYml0cztcbiAgICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgICAgICBsZW4gPSAwO1xuICAgICAgICAgICAgICBjb3B5ID0gMyArIChob2xkICYgMHgwNyk7Ly9CSVRTKDMpO1xuICAgICAgICAgICAgICAvLy0tLSBEUk9QQklUUygzKSAtLS0vL1xuICAgICAgICAgICAgICBob2xkID4+Pj0gMztcbiAgICAgICAgICAgICAgYml0cyAtPSAzO1xuICAgICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgLy89PT0gTkVFREJJVFMoaGVyZS5iaXRzICsgNyk7XG4gICAgICAgICAgICAgIG4gPSBoZXJlX2JpdHMgKyA3O1xuICAgICAgICAgICAgICB3aGlsZSAoYml0cyA8IG4pIHtcbiAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICAgICAgLy8tLS0gRFJPUEJJVFMoaGVyZS5iaXRzKSAtLS0vL1xuICAgICAgICAgICAgICBob2xkID4+Pj0gaGVyZV9iaXRzO1xuICAgICAgICAgICAgICBiaXRzIC09IGhlcmVfYml0cztcbiAgICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgICAgICBsZW4gPSAwO1xuICAgICAgICAgICAgICBjb3B5ID0gMTEgKyAoaG9sZCAmIDB4N2YpOy8vQklUUyg3KTtcbiAgICAgICAgICAgICAgLy8tLS0gRFJPUEJJVFMoNykgLS0tLy9cbiAgICAgICAgICAgICAgaG9sZCA+Pj49IDc7XG4gICAgICAgICAgICAgIGJpdHMgLT0gNztcbiAgICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0YXRlLmhhdmUgKyBjb3B5ID4gc3RhdGUubmxlbiArIHN0YXRlLm5kaXN0KSB7XG4gICAgICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgYml0IGxlbmd0aCByZXBlYXQnO1xuICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChjb3B5LS0pIHtcbiAgICAgICAgICAgICAgc3RhdGUubGVuc1tzdGF0ZS5oYXZlKytdID0gbGVuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qIGhhbmRsZSBlcnJvciBicmVha3MgaW4gd2hpbGUgKi9cbiAgICAgICAgaWYgKHN0YXRlLm1vZGUgPT09IEJBRCkgeyBicmVhazsgfVxuXG4gICAgICAgIC8qIGNoZWNrIGZvciBlbmQtb2YtYmxvY2sgY29kZSAoYmV0dGVyIGhhdmUgb25lKSAqL1xuICAgICAgICBpZiAoc3RhdGUubGVuc1syNTZdID09PSAwKSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBjb2RlIC0tIG1pc3NpbmcgZW5kLW9mLWJsb2NrJztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgLyogYnVpbGQgY29kZSB0YWJsZXMgLS0gbm90ZTogZG8gbm90IGNoYW5nZSB0aGUgbGVuYml0cyBvciBkaXN0Yml0c1xuICAgICAgICAgICB2YWx1ZXMgaGVyZSAoOSBhbmQgNikgd2l0aG91dCByZWFkaW5nIHRoZSBjb21tZW50cyBpbiBpbmZ0cmVlcy5oXG4gICAgICAgICAgIGNvbmNlcm5pbmcgdGhlIEVOT1VHSCBjb25zdGFudHMsIHdoaWNoIGRlcGVuZCBvbiB0aG9zZSB2YWx1ZXMgKi9cbiAgICAgICAgc3RhdGUubGVuYml0cyA9IDk7XG5cbiAgICAgICAgb3B0cyA9IHsgYml0czogc3RhdGUubGVuYml0cyB9O1xuICAgICAgICByZXQgPSBpbmZsYXRlX3RhYmxlKExFTlMsIHN0YXRlLmxlbnMsIDAsIHN0YXRlLm5sZW4sIHN0YXRlLmxlbmNvZGUsIDAsIHN0YXRlLndvcmssIG9wdHMpO1xuICAgICAgICAvLyBXZSBoYXZlIHNlcGFyYXRlIHRhYmxlcyAmIG5vIHBvaW50ZXJzLiAyIGNvbW1lbnRlZCBsaW5lcyBiZWxvdyBub3QgbmVlZGVkLlxuICAgICAgICAvLyBzdGF0ZS5uZXh0X2luZGV4ID0gb3B0cy50YWJsZV9pbmRleDtcbiAgICAgICAgc3RhdGUubGVuYml0cyA9IG9wdHMuYml0cztcbiAgICAgICAgLy8gc3RhdGUubGVuY29kZSA9IHN0YXRlLm5leHQ7XG5cbiAgICAgICAgaWYgKHJldCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgbGl0ZXJhbC9sZW5ndGhzIHNldCc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlLmRpc3RiaXRzID0gNjtcbiAgICAgICAgLy9zdGF0ZS5kaXN0Y29kZS5jb3B5KHN0YXRlLmNvZGVzKTtcbiAgICAgICAgLy8gU3dpdGNoIHRvIHVzZSBkeW5hbWljIHRhYmxlXG4gICAgICAgIHN0YXRlLmRpc3Rjb2RlID0gc3RhdGUuZGlzdGR5bjtcbiAgICAgICAgb3B0cyA9IHsgYml0czogc3RhdGUuZGlzdGJpdHMgfTtcbiAgICAgICAgcmV0ID0gaW5mbGF0ZV90YWJsZShESVNUUywgc3RhdGUubGVucywgc3RhdGUubmxlbiwgc3RhdGUubmRpc3QsIHN0YXRlLmRpc3Rjb2RlLCAwLCBzdGF0ZS53b3JrLCBvcHRzKTtcbiAgICAgICAgLy8gV2UgaGF2ZSBzZXBhcmF0ZSB0YWJsZXMgJiBubyBwb2ludGVycy4gMiBjb21tZW50ZWQgbGluZXMgYmVsb3cgbm90IG5lZWRlZC5cbiAgICAgICAgLy8gc3RhdGUubmV4dF9pbmRleCA9IG9wdHMudGFibGVfaW5kZXg7XG4gICAgICAgIHN0YXRlLmRpc3RiaXRzID0gb3B0cy5iaXRzO1xuICAgICAgICAvLyBzdGF0ZS5kaXN0Y29kZSA9IHN0YXRlLm5leHQ7XG5cbiAgICAgICAgaWYgKHJldCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgZGlzdGFuY2VzIHNldCc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvL1RyYWNldigoc3RkZXJyLCAnaW5mbGF0ZTogICAgICAgY29kZXMgb2tcXG4nKSk7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBMRU5fO1xuICAgICAgICBpZiAoZmx1c2ggPT09IFpfVFJFRVMpIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgTEVOXzpcbiAgICAgICAgc3RhdGUubW9kZSA9IExFTjtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBMRU46XG4gICAgICAgIGlmIChoYXZlID49IDYgJiYgbGVmdCA+PSAyNTgpIHtcbiAgICAgICAgICAvLy0tLSBSRVNUT1JFKCkgLS0tXG4gICAgICAgICAgc3RybS5uZXh0X291dCA9IHB1dDtcbiAgICAgICAgICBzdHJtLmF2YWlsX291dCA9IGxlZnQ7XG4gICAgICAgICAgc3RybS5uZXh0X2luID0gbmV4dDtcbiAgICAgICAgICBzdHJtLmF2YWlsX2luID0gaGF2ZTtcbiAgICAgICAgICBzdGF0ZS5ob2xkID0gaG9sZDtcbiAgICAgICAgICBzdGF0ZS5iaXRzID0gYml0cztcbiAgICAgICAgICAvLy0tLVxuICAgICAgICAgIGluZmxhdGVfZmFzdChzdHJtLCBfb3V0KTtcbiAgICAgICAgICAvLy0tLSBMT0FEKCkgLS0tXG4gICAgICAgICAgcHV0ID0gc3RybS5uZXh0X291dDtcbiAgICAgICAgICBvdXRwdXQgPSBzdHJtLm91dHB1dDtcbiAgICAgICAgICBsZWZ0ID0gc3RybS5hdmFpbF9vdXQ7XG4gICAgICAgICAgbmV4dCA9IHN0cm0ubmV4dF9pbjtcbiAgICAgICAgICBpbnB1dCA9IHN0cm0uaW5wdXQ7XG4gICAgICAgICAgaGF2ZSA9IHN0cm0uYXZhaWxfaW47XG4gICAgICAgICAgaG9sZCA9IHN0YXRlLmhvbGQ7XG4gICAgICAgICAgYml0cyA9IHN0YXRlLmJpdHM7XG4gICAgICAgICAgLy8tLS1cblxuICAgICAgICAgIGlmIChzdGF0ZS5tb2RlID09PSBUWVBFKSB7XG4gICAgICAgICAgICBzdGF0ZS5iYWNrID0gLTE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLmJhY2sgPSAwO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgaGVyZSA9IHN0YXRlLmxlbmNvZGVbaG9sZCAmICgoMSA8PCBzdGF0ZS5sZW5iaXRzKSAtIDEpXTsgIC8qQklUUyhzdGF0ZS5sZW5iaXRzKSovXG4gICAgICAgICAgaGVyZV9iaXRzID0gaGVyZSA+Pj4gMjQ7XG4gICAgICAgICAgaGVyZV9vcCA9IChoZXJlID4+PiAxNikgJiAweGZmO1xuICAgICAgICAgIGhlcmVfdmFsID0gaGVyZSAmIDB4ZmZmZjtcblxuICAgICAgICAgIGlmIChoZXJlX2JpdHMgPD0gYml0cykgeyBicmVhazsgfVxuICAgICAgICAgIC8vLS0tIFBVTExCWVRFKCkgLS0tLy9cbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgfVxuICAgICAgICBpZiAoaGVyZV9vcCAmJiAoaGVyZV9vcCAmIDB4ZjApID09PSAwKSB7XG4gICAgICAgICAgbGFzdF9iaXRzID0gaGVyZV9iaXRzO1xuICAgICAgICAgIGxhc3Rfb3AgPSBoZXJlX29wO1xuICAgICAgICAgIGxhc3RfdmFsID0gaGVyZV92YWw7XG4gICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgaGVyZSA9IHN0YXRlLmxlbmNvZGVbbGFzdF92YWwgK1xuICAgICAgICAgICAgICAgICAgICAoKGhvbGQgJiAoKDEgPDwgKGxhc3RfYml0cyArIGxhc3Rfb3ApKSAtIDEpKS8qQklUUyhsYXN0LmJpdHMgKyBsYXN0Lm9wKSovID4+IGxhc3RfYml0cyldO1xuICAgICAgICAgICAgaGVyZV9iaXRzID0gaGVyZSA+Pj4gMjQ7XG4gICAgICAgICAgICBoZXJlX29wID0gKGhlcmUgPj4+IDE2KSAmIDB4ZmY7XG4gICAgICAgICAgICBoZXJlX3ZhbCA9IGhlcmUgJiAweGZmZmY7XG5cbiAgICAgICAgICAgIGlmICgobGFzdF9iaXRzICsgaGVyZV9iaXRzKSA8PSBiaXRzKSB7IGJyZWFrOyB9XG4gICAgICAgICAgICAvLy0tLSBQVUxMQllURSgpIC0tLS8vXG4gICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLy0tLSBEUk9QQklUUyhsYXN0LmJpdHMpIC0tLS8vXG4gICAgICAgICAgaG9sZCA+Pj49IGxhc3RfYml0cztcbiAgICAgICAgICBiaXRzIC09IGxhc3RfYml0cztcbiAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgc3RhdGUuYmFjayArPSBsYXN0X2JpdHM7XG4gICAgICAgIH1cbiAgICAgICAgLy8tLS0gRFJPUEJJVFMoaGVyZS5iaXRzKSAtLS0vL1xuICAgICAgICBob2xkID4+Pj0gaGVyZV9iaXRzO1xuICAgICAgICBiaXRzIC09IGhlcmVfYml0cztcbiAgICAgICAgLy8tLS0vL1xuICAgICAgICBzdGF0ZS5iYWNrICs9IGhlcmVfYml0cztcbiAgICAgICAgc3RhdGUubGVuZ3RoID0gaGVyZV92YWw7XG4gICAgICAgIGlmIChoZXJlX29wID09PSAwKSB7XG4gICAgICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIGhlcmUudmFsID49IDB4MjAgJiYgaGVyZS52YWwgPCAweDdmID9cbiAgICAgICAgICAvLyAgICAgICAgXCJpbmZsYXRlOiAgICAgICAgIGxpdGVyYWwgJyVjJ1xcblwiIDpcbiAgICAgICAgICAvLyAgICAgICAgXCJpbmZsYXRlOiAgICAgICAgIGxpdGVyYWwgMHglMDJ4XFxuXCIsIGhlcmUudmFsKSk7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IExJVDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGVyZV9vcCAmIDMyKSB7XG4gICAgICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgICBlbmQgb2YgYmxvY2tcXG5cIikpO1xuICAgICAgICAgIHN0YXRlLmJhY2sgPSAtMTtcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gVFlQRTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGVyZV9vcCAmIDY0KSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBsaXRlcmFsL2xlbmd0aCBjb2RlJztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLmV4dHJhID0gaGVyZV9vcCAmIDE1O1xuICAgICAgICBzdGF0ZS5tb2RlID0gTEVORVhUO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIExFTkVYVDpcbiAgICAgICAgaWYgKHN0YXRlLmV4dHJhKSB7XG4gICAgICAgICAgLy89PT0gTkVFREJJVFMoc3RhdGUuZXh0cmEpO1xuICAgICAgICAgIG4gPSBzdGF0ZS5leHRyYTtcbiAgICAgICAgICB3aGlsZSAoYml0cyA8IG4pIHtcbiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICBzdGF0ZS5sZW5ndGggKz0gaG9sZCAmICgoMSA8PCBzdGF0ZS5leHRyYSkgLSAxKS8qQklUUyhzdGF0ZS5leHRyYSkqLztcbiAgICAgICAgICAvLy0tLSBEUk9QQklUUyhzdGF0ZS5leHRyYSkgLS0tLy9cbiAgICAgICAgICBob2xkID4+Pj0gc3RhdGUuZXh0cmE7XG4gICAgICAgICAgYml0cyAtPSBzdGF0ZS5leHRyYTtcbiAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgc3RhdGUuYmFjayArPSBzdGF0ZS5leHRyYTtcbiAgICAgICAgfVxuICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICAgIGxlbmd0aCAldVxcblwiLCBzdGF0ZS5sZW5ndGgpKTtcbiAgICAgICAgc3RhdGUud2FzID0gc3RhdGUubGVuZ3RoO1xuICAgICAgICBzdGF0ZS5tb2RlID0gRElTVDtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBESVNUOlxuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgaGVyZSA9IHN0YXRlLmRpc3Rjb2RlW2hvbGQgJiAoKDEgPDwgc3RhdGUuZGlzdGJpdHMpIC0gMSldOy8qQklUUyhzdGF0ZS5kaXN0Yml0cykqL1xuICAgICAgICAgIGhlcmVfYml0cyA9IGhlcmUgPj4+IDI0O1xuICAgICAgICAgIGhlcmVfb3AgPSAoaGVyZSA+Pj4gMTYpICYgMHhmZjtcbiAgICAgICAgICBoZXJlX3ZhbCA9IGhlcmUgJiAweGZmZmY7XG5cbiAgICAgICAgICBpZiAoKGhlcmVfYml0cykgPD0gYml0cykgeyBicmVhazsgfVxuICAgICAgICAgIC8vLS0tIFBVTExCWVRFKCkgLS0tLy9cbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgfVxuICAgICAgICBpZiAoKGhlcmVfb3AgJiAweGYwKSA9PT0gMCkge1xuICAgICAgICAgIGxhc3RfYml0cyA9IGhlcmVfYml0cztcbiAgICAgICAgICBsYXN0X29wID0gaGVyZV9vcDtcbiAgICAgICAgICBsYXN0X3ZhbCA9IGhlcmVfdmFsO1xuICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGhlcmUgPSBzdGF0ZS5kaXN0Y29kZVtsYXN0X3ZhbCArXG4gICAgICAgICAgICAgICAgICAgICgoaG9sZCAmICgoMSA8PCAobGFzdF9iaXRzICsgbGFzdF9vcCkpIC0gMSkpLypCSVRTKGxhc3QuYml0cyArIGxhc3Qub3ApKi8gPj4gbGFzdF9iaXRzKV07XG4gICAgICAgICAgICBoZXJlX2JpdHMgPSBoZXJlID4+PiAyNDtcbiAgICAgICAgICAgIGhlcmVfb3AgPSAoaGVyZSA+Pj4gMTYpICYgMHhmZjtcbiAgICAgICAgICAgIGhlcmVfdmFsID0gaGVyZSAmIDB4ZmZmZjtcblxuICAgICAgICAgICAgaWYgKChsYXN0X2JpdHMgKyBoZXJlX2JpdHMpIDw9IGJpdHMpIHsgYnJlYWs7IH1cbiAgICAgICAgICAgIC8vLS0tIFBVTExCWVRFKCkgLS0tLy9cbiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgfVxuICAgICAgICAgIC8vLS0tIERST1BCSVRTKGxhc3QuYml0cykgLS0tLy9cbiAgICAgICAgICBob2xkID4+Pj0gbGFzdF9iaXRzO1xuICAgICAgICAgIGJpdHMgLT0gbGFzdF9iaXRzO1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICBzdGF0ZS5iYWNrICs9IGxhc3RfYml0cztcbiAgICAgICAgfVxuICAgICAgICAvLy0tLSBEUk9QQklUUyhoZXJlLmJpdHMpIC0tLS8vXG4gICAgICAgIGhvbGQgPj4+PSBoZXJlX2JpdHM7XG4gICAgICAgIGJpdHMgLT0gaGVyZV9iaXRzO1xuICAgICAgICAvLy0tLS8vXG4gICAgICAgIHN0YXRlLmJhY2sgKz0gaGVyZV9iaXRzO1xuICAgICAgICBpZiAoaGVyZV9vcCAmIDY0KSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZSBjb2RlJztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLm9mZnNldCA9IGhlcmVfdmFsO1xuICAgICAgICBzdGF0ZS5leHRyYSA9IChoZXJlX29wKSAmIDE1O1xuICAgICAgICBzdGF0ZS5tb2RlID0gRElTVEVYVDtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBESVNURVhUOlxuICAgICAgICBpZiAoc3RhdGUuZXh0cmEpIHtcbiAgICAgICAgICAvLz09PSBORUVEQklUUyhzdGF0ZS5leHRyYSk7XG4gICAgICAgICAgbiA9IHN0YXRlLmV4dHJhO1xuICAgICAgICAgIHdoaWxlIChiaXRzIDwgbikge1xuICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIHN0YXRlLm9mZnNldCArPSBob2xkICYgKCgxIDw8IHN0YXRlLmV4dHJhKSAtIDEpLypCSVRTKHN0YXRlLmV4dHJhKSovO1xuICAgICAgICAgIC8vLS0tIERST1BCSVRTKHN0YXRlLmV4dHJhKSAtLS0vL1xuICAgICAgICAgIGhvbGQgPj4+PSBzdGF0ZS5leHRyYTtcbiAgICAgICAgICBiaXRzIC09IHN0YXRlLmV4dHJhO1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICBzdGF0ZS5iYWNrICs9IHN0YXRlLmV4dHJhO1xuICAgICAgICB9XG4vLyNpZmRlZiBJTkZMQVRFX1NUUklDVFxuICAgICAgICBpZiAoc3RhdGUub2Zmc2V0ID4gc3RhdGUuZG1heCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgZGlzdGFuY2UgdG9vIGZhciBiYWNrJztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4vLyNlbmRpZlxuICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICAgIGRpc3RhbmNlICV1XFxuXCIsIHN0YXRlLm9mZnNldCkpO1xuICAgICAgICBzdGF0ZS5tb2RlID0gTUFUQ0g7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgTUFUQ0g6XG4gICAgICAgIGlmIChsZWZ0ID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICBjb3B5ID0gX291dCAtIGxlZnQ7XG4gICAgICAgIGlmIChzdGF0ZS5vZmZzZXQgPiBjb3B5KSB7ICAgICAgICAgLyogY29weSBmcm9tIHdpbmRvdyAqL1xuICAgICAgICAgIGNvcHkgPSBzdGF0ZS5vZmZzZXQgLSBjb3B5O1xuICAgICAgICAgIGlmIChjb3B5ID4gc3RhdGUud2hhdmUpIHtcbiAgICAgICAgICAgIGlmIChzdGF0ZS5zYW5lKSB7XG4gICAgICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgZGlzdGFuY2UgdG9vIGZhciBiYWNrJztcbiAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4vLyAoISkgVGhpcyBibG9jayBpcyBkaXNhYmxlZCBpbiB6bGliIGRlZmF1bHRzLFxuLy8gZG9uJ3QgZW5hYmxlIGl0IGZvciBiaW5hcnkgY29tcGF0aWJpbGl0eVxuLy8jaWZkZWYgSU5GTEFURV9BTExPV19JTlZBTElEX0RJU1RBTkNFX1RPT0ZBUl9BUlJSXG4vLyAgICAgICAgICBUcmFjZSgoc3RkZXJyLCBcImluZmxhdGUuYyB0b28gZmFyXFxuXCIpKTtcbi8vICAgICAgICAgIGNvcHkgLT0gc3RhdGUud2hhdmU7XG4vLyAgICAgICAgICBpZiAoY29weSA+IHN0YXRlLmxlbmd0aCkgeyBjb3B5ID0gc3RhdGUubGVuZ3RoOyB9XG4vLyAgICAgICAgICBpZiAoY29weSA+IGxlZnQpIHsgY29weSA9IGxlZnQ7IH1cbi8vICAgICAgICAgIGxlZnQgLT0gY29weTtcbi8vICAgICAgICAgIHN0YXRlLmxlbmd0aCAtPSBjb3B5O1xuLy8gICAgICAgICAgZG8ge1xuLy8gICAgICAgICAgICBvdXRwdXRbcHV0KytdID0gMDtcbi8vICAgICAgICAgIH0gd2hpbGUgKC0tY29weSk7XG4vLyAgICAgICAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSB7IHN0YXRlLm1vZGUgPSBMRU47IH1cbi8vICAgICAgICAgIGJyZWFrO1xuLy8jZW5kaWZcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNvcHkgPiBzdGF0ZS53bmV4dCkge1xuICAgICAgICAgICAgY29weSAtPSBzdGF0ZS53bmV4dDtcbiAgICAgICAgICAgIGZyb20gPSBzdGF0ZS53c2l6ZSAtIGNvcHk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZnJvbSA9IHN0YXRlLnduZXh0IC0gY29weTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNvcHkgPiBzdGF0ZS5sZW5ndGgpIHsgY29weSA9IHN0YXRlLmxlbmd0aDsgfVxuICAgICAgICAgIGZyb21fc291cmNlID0gc3RhdGUud2luZG93O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIGNvcHkgZnJvbSBvdXRwdXQgKi9cbiAgICAgICAgICBmcm9tX3NvdXJjZSA9IG91dHB1dDtcbiAgICAgICAgICBmcm9tID0gcHV0IC0gc3RhdGUub2Zmc2V0O1xuICAgICAgICAgIGNvcHkgPSBzdGF0ZS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvcHkgPiBsZWZ0KSB7IGNvcHkgPSBsZWZ0OyB9XG4gICAgICAgIGxlZnQgLT0gY29weTtcbiAgICAgICAgc3RhdGUubGVuZ3RoIC09IGNvcHk7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICBvdXRwdXRbcHV0KytdID0gZnJvbV9zb3VyY2VbZnJvbSsrXTtcbiAgICAgICAgfSB3aGlsZSAoLS1jb3B5KTtcbiAgICAgICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgeyBzdGF0ZS5tb2RlID0gTEVOOyB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBMSVQ6XG4gICAgICAgIGlmIChsZWZ0ID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICBvdXRwdXRbcHV0KytdID0gc3RhdGUubGVuZ3RoO1xuICAgICAgICBsZWZ0LS07XG4gICAgICAgIHN0YXRlLm1vZGUgPSBMRU47XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBDSEVDSzpcbiAgICAgICAgaWYgKHN0YXRlLndyYXApIHtcbiAgICAgICAgICAvLz09PSBORUVEQklUUygzMik7XG4gICAgICAgICAgd2hpbGUgKGJpdHMgPCAzMikge1xuICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICAvLyBVc2UgJ3wnIGluc3RlYWQgb2YgJysnIHRvIG1ha2Ugc3VyZSB0aGF0IHJlc3VsdCBpcyBzaWduZWRcbiAgICAgICAgICAgIGhvbGQgfD0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgX291dCAtPSBsZWZ0O1xuICAgICAgICAgIHN0cm0udG90YWxfb3V0ICs9IF9vdXQ7XG4gICAgICAgICAgc3RhdGUudG90YWwgKz0gX291dDtcbiAgICAgICAgICBpZiAoX291dCkge1xuICAgICAgICAgICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID1cbiAgICAgICAgICAgICAgICAvKlVQREFURShzdGF0ZS5jaGVjaywgcHV0IC0gX291dCwgX291dCk7Ki9cbiAgICAgICAgICAgICAgICAoc3RhdGUuZmxhZ3MgPyBjcmMzMihzdGF0ZS5jaGVjaywgb3V0cHV0LCBfb3V0LCBwdXQgLSBfb3V0KSA6IGFkbGVyMzIoc3RhdGUuY2hlY2ssIG91dHB1dCwgX291dCwgcHV0IC0gX291dCkpO1xuXG4gICAgICAgICAgfVxuICAgICAgICAgIF9vdXQgPSBsZWZ0O1xuICAgICAgICAgIC8vIE5COiBjcmMzMiBzdG9yZWQgYXMgc2lnbmVkIDMyLWJpdCBpbnQsIHpzd2FwMzIgcmV0dXJucyBzaWduZWQgdG9vXG4gICAgICAgICAgaWYgKChzdGF0ZS5mbGFncyA/IGhvbGQgOiB6c3dhcDMyKGhvbGQpKSAhPT0gc3RhdGUuY2hlY2spIHtcbiAgICAgICAgICAgIHN0cm0ubXNnID0gJ2luY29ycmVjdCBkYXRhIGNoZWNrJztcbiAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgICBob2xkID0gMDtcbiAgICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgIGNoZWNrIG1hdGNoZXMgdHJhaWxlclxcblwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUubW9kZSA9IExFTkdUSDtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBMRU5HVEg6XG4gICAgICAgIGlmIChzdGF0ZS53cmFwICYmIHN0YXRlLmZsYWdzKSB7XG4gICAgICAgICAgLy89PT0gTkVFREJJVFMoMzIpO1xuICAgICAgICAgIHdoaWxlIChiaXRzIDwgMzIpIHtcbiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICBpZiAoaG9sZCAhPT0gKHN0YXRlLnRvdGFsICYgMHhmZmZmZmZmZikpIHtcbiAgICAgICAgICAgIHN0cm0ubXNnID0gJ2luY29ycmVjdCBsZW5ndGggY2hlY2snO1xuICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICAgIGhvbGQgPSAwO1xuICAgICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgbGVuZ3RoIG1hdGNoZXMgdHJhaWxlclxcblwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUubW9kZSA9IERPTkU7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgRE9ORTpcbiAgICAgICAgcmV0ID0gWl9TVFJFQU1fRU5EO1xuICAgICAgICBicmVhayBpbmZfbGVhdmU7XG4gICAgICBjYXNlIEJBRDpcbiAgICAgICAgcmV0ID0gWl9EQVRBX0VSUk9SO1xuICAgICAgICBicmVhayBpbmZfbGVhdmU7XG4gICAgICBjYXNlIE1FTTpcbiAgICAgICAgcmV0dXJuIFpfTUVNX0VSUk9SO1xuICAgICAgY2FzZSBTWU5DOlxuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gICAgfVxuICB9XG5cbiAgLy8gaW5mX2xlYXZlIDwtIGhlcmUgaXMgcmVhbCBwbGFjZSBmb3IgXCJnb3RvIGluZl9sZWF2ZVwiLCBlbXVsYXRlZCB2aWEgXCJicmVhayBpbmZfbGVhdmVcIlxuXG4gIC8qXG4gICAgIFJldHVybiBmcm9tIGluZmxhdGUoKSwgdXBkYXRpbmcgdGhlIHRvdGFsIGNvdW50cyBhbmQgdGhlIGNoZWNrIHZhbHVlLlxuICAgICBJZiB0aGVyZSB3YXMgbm8gcHJvZ3Jlc3MgZHVyaW5nIHRoZSBpbmZsYXRlKCkgY2FsbCwgcmV0dXJuIGEgYnVmZmVyXG4gICAgIGVycm9yLiAgQ2FsbCB1cGRhdGV3aW5kb3coKSB0byBjcmVhdGUgYW5kL29yIHVwZGF0ZSB0aGUgd2luZG93IHN0YXRlLlxuICAgICBOb3RlOiBhIG1lbW9yeSBlcnJvciBmcm9tIGluZmxhdGUoKSBpcyBub24tcmVjb3ZlcmFibGUuXG4gICAqL1xuXG4gIC8vLS0tIFJFU1RPUkUoKSAtLS1cbiAgc3RybS5uZXh0X291dCA9IHB1dDtcbiAgc3RybS5hdmFpbF9vdXQgPSBsZWZ0O1xuICBzdHJtLm5leHRfaW4gPSBuZXh0O1xuICBzdHJtLmF2YWlsX2luID0gaGF2ZTtcbiAgc3RhdGUuaG9sZCA9IGhvbGQ7XG4gIHN0YXRlLmJpdHMgPSBiaXRzO1xuICAvLy0tLVxuXG4gIGlmIChzdGF0ZS53c2l6ZSB8fCAoX291dCAhPT0gc3RybS5hdmFpbF9vdXQgJiYgc3RhdGUubW9kZSA8IEJBRCAmJlxuICAgICAgICAgICAgICAgICAgICAgIChzdGF0ZS5tb2RlIDwgQ0hFQ0sgfHwgZmx1c2ggIT09IFpfRklOSVNIKSkpIHtcbiAgICBpZiAodXBkYXRld2luZG93KHN0cm0sIHN0cm0ub3V0cHV0LCBzdHJtLm5leHRfb3V0LCBfb3V0IC0gc3RybS5hdmFpbF9vdXQpKSB7XG4gICAgICBzdGF0ZS5tb2RlID0gTUVNO1xuICAgICAgcmV0dXJuIFpfTUVNX0VSUk9SO1xuICAgIH1cbiAgfVxuICBfaW4gLT0gc3RybS5hdmFpbF9pbjtcbiAgX291dCAtPSBzdHJtLmF2YWlsX291dDtcbiAgc3RybS50b3RhbF9pbiArPSBfaW47XG4gIHN0cm0udG90YWxfb3V0ICs9IF9vdXQ7XG4gIHN0YXRlLnRvdGFsICs9IF9vdXQ7XG4gIGlmIChzdGF0ZS53cmFwICYmIF9vdXQpIHtcbiAgICBzdHJtLmFkbGVyID0gc3RhdGUuY2hlY2sgPSAvKlVQREFURShzdGF0ZS5jaGVjaywgc3RybS5uZXh0X291dCAtIF9vdXQsIF9vdXQpOyovXG4gICAgICAoc3RhdGUuZmxhZ3MgPyBjcmMzMihzdGF0ZS5jaGVjaywgb3V0cHV0LCBfb3V0LCBzdHJtLm5leHRfb3V0IC0gX291dCkgOiBhZGxlcjMyKHN0YXRlLmNoZWNrLCBvdXRwdXQsIF9vdXQsIHN0cm0ubmV4dF9vdXQgLSBfb3V0KSk7XG4gIH1cbiAgc3RybS5kYXRhX3R5cGUgPSBzdGF0ZS5iaXRzICsgKHN0YXRlLmxhc3QgPyA2NCA6IDApICtcbiAgICAgICAgICAgICAgICAgICAgKHN0YXRlLm1vZGUgPT09IFRZUEUgPyAxMjggOiAwKSArXG4gICAgICAgICAgICAgICAgICAgIChzdGF0ZS5tb2RlID09PSBMRU5fIHx8IHN0YXRlLm1vZGUgPT09IENPUFlfID8gMjU2IDogMCk7XG4gIGlmICgoKF9pbiA9PT0gMCAmJiBfb3V0ID09PSAwKSB8fCBmbHVzaCA9PT0gWl9GSU5JU0gpICYmIHJldCA9PT0gWl9PSykge1xuICAgIHJldCA9IFpfQlVGX0VSUk9SO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGluZmxhdGVFbmQoc3RybSkge1xuXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSAvKnx8IHN0cm0tPnpmcmVlID09IChmcmVlX2Z1bmMpMCovKSB7XG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICB9XG5cbiAgdmFyIHN0YXRlID0gc3RybS5zdGF0ZTtcbiAgaWYgKHN0YXRlLndpbmRvdykge1xuICAgIHN0YXRlLndpbmRvdyA9IG51bGw7XG4gIH1cbiAgc3RybS5zdGF0ZSA9IG51bGw7XG4gIHJldHVybiBaX09LO1xufVxuXG5mdW5jdGlvbiBpbmZsYXRlR2V0SGVhZGVyKHN0cm0sIGhlYWQpIHtcbiAgdmFyIHN0YXRlO1xuXG4gIC8qIGNoZWNrIHN0YXRlICovXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSkgeyByZXR1cm4gWl9TVFJFQU1fRVJST1I7IH1cbiAgc3RhdGUgPSBzdHJtLnN0YXRlO1xuICBpZiAoKHN0YXRlLndyYXAgJiAyKSA9PT0gMCkgeyByZXR1cm4gWl9TVFJFQU1fRVJST1I7IH1cblxuICAvKiBzYXZlIGhlYWRlciBzdHJ1Y3R1cmUgKi9cbiAgc3RhdGUuaGVhZCA9IGhlYWQ7XG4gIGhlYWQuZG9uZSA9IGZhbHNlO1xuICByZXR1cm4gWl9PSztcbn1cblxuZnVuY3Rpb24gaW5mbGF0ZVNldERpY3Rpb25hcnkoc3RybSwgZGljdGlvbmFyeSkge1xuICB2YXIgZGljdExlbmd0aCA9IGRpY3Rpb25hcnkubGVuZ3RoO1xuXG4gIHZhciBzdGF0ZTtcbiAgdmFyIGRpY3RpZDtcbiAgdmFyIHJldDtcblxuICAvKiBjaGVjayBzdGF0ZSAqL1xuICBpZiAoIXN0cm0gLyogPT0gWl9OVUxMICovIHx8ICFzdHJtLnN0YXRlIC8qID09IFpfTlVMTCAqLykgeyByZXR1cm4gWl9TVFJFQU1fRVJST1I7IH1cbiAgc3RhdGUgPSBzdHJtLnN0YXRlO1xuXG4gIGlmIChzdGF0ZS53cmFwICE9PSAwICYmIHN0YXRlLm1vZGUgIT09IERJQ1QpIHtcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gIH1cblxuICAvKiBjaGVjayBmb3IgY29ycmVjdCBkaWN0aW9uYXJ5IGlkZW50aWZpZXIgKi9cbiAgaWYgKHN0YXRlLm1vZGUgPT09IERJQ1QpIHtcbiAgICBkaWN0aWQgPSAxOyAvKiBhZGxlcjMyKDAsIG51bGwsIDApKi9cbiAgICAvKiBkaWN0aWQgPSBhZGxlcjMyKGRpY3RpZCwgZGljdGlvbmFyeSwgZGljdExlbmd0aCk7ICovXG4gICAgZGljdGlkID0gYWRsZXIzMihkaWN0aWQsIGRpY3Rpb25hcnksIGRpY3RMZW5ndGgsIDApO1xuICAgIGlmIChkaWN0aWQgIT09IHN0YXRlLmNoZWNrKSB7XG4gICAgICByZXR1cm4gWl9EQVRBX0VSUk9SO1xuICAgIH1cbiAgfVxuICAvKiBjb3B5IGRpY3Rpb25hcnkgdG8gd2luZG93IHVzaW5nIHVwZGF0ZXdpbmRvdygpLCB3aGljaCB3aWxsIGFtZW5kIHRoZVxuICAgZXhpc3RpbmcgZGljdGlvbmFyeSBpZiBhcHByb3ByaWF0ZSAqL1xuICByZXQgPSB1cGRhdGV3aW5kb3coc3RybSwgZGljdGlvbmFyeSwgZGljdExlbmd0aCwgZGljdExlbmd0aCk7XG4gIGlmIChyZXQpIHtcbiAgICBzdGF0ZS5tb2RlID0gTUVNO1xuICAgIHJldHVybiBaX01FTV9FUlJPUjtcbiAgfVxuICBzdGF0ZS5oYXZlZGljdCA9IDE7XG4gIC8vIFRyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgZGljdGlvbmFyeSBzZXRcXG5cIikpO1xuICByZXR1cm4gWl9PSztcbn1cblxuZXhwb3J0cy5pbmZsYXRlUmVzZXQgPSBpbmZsYXRlUmVzZXQ7XG5leHBvcnRzLmluZmxhdGVSZXNldDIgPSBpbmZsYXRlUmVzZXQyO1xuZXhwb3J0cy5pbmZsYXRlUmVzZXRLZWVwID0gaW5mbGF0ZVJlc2V0S2VlcDtcbmV4cG9ydHMuaW5mbGF0ZUluaXQgPSBpbmZsYXRlSW5pdDtcbmV4cG9ydHMuaW5mbGF0ZUluaXQyID0gaW5mbGF0ZUluaXQyO1xuZXhwb3J0cy5pbmZsYXRlID0gaW5mbGF0ZTtcbmV4cG9ydHMuaW5mbGF0ZUVuZCA9IGluZmxhdGVFbmQ7XG5leHBvcnRzLmluZmxhdGVHZXRIZWFkZXIgPSBpbmZsYXRlR2V0SGVhZGVyO1xuZXhwb3J0cy5pbmZsYXRlU2V0RGljdGlvbmFyeSA9IGluZmxhdGVTZXREaWN0aW9uYXJ5O1xuZXhwb3J0cy5pbmZsYXRlSW5mbyA9ICdwYWtvIGluZmxhdGUgKGZyb20gTm9kZWNhIHByb2plY3QpJztcblxuLyogTm90IGltcGxlbWVudGVkXG5leHBvcnRzLmluZmxhdGVDb3B5ID0gaW5mbGF0ZUNvcHk7XG5leHBvcnRzLmluZmxhdGVHZXREaWN0aW9uYXJ5ID0gaW5mbGF0ZUdldERpY3Rpb25hcnk7XG5leHBvcnRzLmluZmxhdGVNYXJrID0gaW5mbGF0ZU1hcms7XG5leHBvcnRzLmluZmxhdGVQcmltZSA9IGluZmxhdGVQcmltZTtcbmV4cG9ydHMuaW5mbGF0ZVN5bmMgPSBpbmZsYXRlU3luYztcbmV4cG9ydHMuaW5mbGF0ZVN5bmNQb2ludCA9IGluZmxhdGVTeW5jUG9pbnQ7XG5leHBvcnRzLmluZmxhdGVVbmRlcm1pbmUgPSBpbmZsYXRlVW5kZXJtaW5lO1xuKi9cbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblxuICAvKiBBbGxvd2VkIGZsdXNoIHZhbHVlczsgc2VlIGRlZmxhdGUoKSBhbmQgaW5mbGF0ZSgpIGJlbG93IGZvciBkZXRhaWxzICovXG4gIFpfTk9fRkxVU0g6ICAgICAgICAgMCxcbiAgWl9QQVJUSUFMX0ZMVVNIOiAgICAxLFxuICBaX1NZTkNfRkxVU0g6ICAgICAgIDIsXG4gIFpfRlVMTF9GTFVTSDogICAgICAgMyxcbiAgWl9GSU5JU0g6ICAgICAgICAgICA0LFxuICBaX0JMT0NLOiAgICAgICAgICAgIDUsXG4gIFpfVFJFRVM6ICAgICAgICAgICAgNixcblxuICAvKiBSZXR1cm4gY29kZXMgZm9yIHRoZSBjb21wcmVzc2lvbi9kZWNvbXByZXNzaW9uIGZ1bmN0aW9ucy4gTmVnYXRpdmUgdmFsdWVzXG4gICogYXJlIGVycm9ycywgcG9zaXRpdmUgdmFsdWVzIGFyZSB1c2VkIGZvciBzcGVjaWFsIGJ1dCBub3JtYWwgZXZlbnRzLlxuICAqL1xuICBaX09LOiAgICAgICAgICAgICAgIDAsXG4gIFpfU1RSRUFNX0VORDogICAgICAgMSxcbiAgWl9ORUVEX0RJQ1Q6ICAgICAgICAyLFxuICBaX0VSUk5POiAgICAgICAgICAgLTEsXG4gIFpfU1RSRUFNX0VSUk9SOiAgICAtMixcbiAgWl9EQVRBX0VSUk9SOiAgICAgIC0zLFxuICAvL1pfTUVNX0VSUk9SOiAgICAgLTQsXG4gIFpfQlVGX0VSUk9SOiAgICAgICAtNSxcbiAgLy9aX1ZFUlNJT05fRVJST1I6IC02LFxuXG4gIC8qIGNvbXByZXNzaW9uIGxldmVscyAqL1xuICBaX05PX0NPTVBSRVNTSU9OOiAgICAgICAgIDAsXG4gIFpfQkVTVF9TUEVFRDogICAgICAgICAgICAgMSxcbiAgWl9CRVNUX0NPTVBSRVNTSU9OOiAgICAgICA5LFxuICBaX0RFRkFVTFRfQ09NUFJFU1NJT046ICAgLTEsXG5cblxuICBaX0ZJTFRFUkVEOiAgICAgICAgICAgICAgIDEsXG4gIFpfSFVGRk1BTl9PTkxZOiAgICAgICAgICAgMixcbiAgWl9STEU6ICAgICAgICAgICAgICAgICAgICAzLFxuICBaX0ZJWEVEOiAgICAgICAgICAgICAgICAgIDQsXG4gIFpfREVGQVVMVF9TVFJBVEVHWTogICAgICAgMCxcblxuICAvKiBQb3NzaWJsZSB2YWx1ZXMgb2YgdGhlIGRhdGFfdHlwZSBmaWVsZCAodGhvdWdoIHNlZSBpbmZsYXRlKCkpICovXG4gIFpfQklOQVJZOiAgICAgICAgICAgICAgICAgMCxcbiAgWl9URVhUOiAgICAgICAgICAgICAgICAgICAxLFxuICAvL1pfQVNDSUk6ICAgICAgICAgICAgICAgIDEsIC8vID0gWl9URVhUIChkZXByZWNhdGVkKVxuICBaX1VOS05PV046ICAgICAgICAgICAgICAgIDIsXG5cbiAgLyogVGhlIGRlZmxhdGUgY29tcHJlc3Npb24gbWV0aG9kICovXG4gIFpfREVGTEFURUQ6ICAgICAgICAgICAgICAgOFxuICAvL1pfTlVMTDogICAgICAgICAgICAgICAgIG51bGwgLy8gVXNlIC0xIG9yIG51bGwgaW5saW5lLCBkZXBlbmRpbmcgb24gdmFyIHR5cGVcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxuZnVuY3Rpb24gR1poZWFkZXIoKSB7XG4gIC8qIHRydWUgaWYgY29tcHJlc3NlZCBkYXRhIGJlbGlldmVkIHRvIGJlIHRleHQgKi9cbiAgdGhpcy50ZXh0ICAgICAgID0gMDtcbiAgLyogbW9kaWZpY2F0aW9uIHRpbWUgKi9cbiAgdGhpcy50aW1lICAgICAgID0gMDtcbiAgLyogZXh0cmEgZmxhZ3MgKG5vdCB1c2VkIHdoZW4gd3JpdGluZyBhIGd6aXAgZmlsZSkgKi9cbiAgdGhpcy54ZmxhZ3MgICAgID0gMDtcbiAgLyogb3BlcmF0aW5nIHN5c3RlbSAqL1xuICB0aGlzLm9zICAgICAgICAgPSAwO1xuICAvKiBwb2ludGVyIHRvIGV4dHJhIGZpZWxkIG9yIFpfTlVMTCBpZiBub25lICovXG4gIHRoaXMuZXh0cmEgICAgICA9IG51bGw7XG4gIC8qIGV4dHJhIGZpZWxkIGxlbmd0aCAodmFsaWQgaWYgZXh0cmEgIT0gWl9OVUxMKSAqL1xuICB0aGlzLmV4dHJhX2xlbiAgPSAwOyAvLyBBY3R1YWxseSwgd2UgZG9uJ3QgbmVlZCBpdCBpbiBKUyxcbiAgICAgICAgICAgICAgICAgICAgICAgLy8gYnV0IGxlYXZlIGZvciBmZXcgY29kZSBtb2RpZmljYXRpb25zXG5cbiAgLy9cbiAgLy8gU2V0dXAgbGltaXRzIGlzIG5vdCBuZWNlc3NhcnkgYmVjYXVzZSBpbiBqcyB3ZSBzaG91bGQgbm90IHByZWFsbG9jYXRlIG1lbW9yeVxuICAvLyBmb3IgaW5mbGF0ZSB1c2UgY29uc3RhbnQgbGltaXQgaW4gNjU1MzYgYnl0ZXNcbiAgLy9cblxuICAvKiBzcGFjZSBhdCBleHRyYSAob25seSB3aGVuIHJlYWRpbmcgaGVhZGVyKSAqL1xuICAvLyB0aGlzLmV4dHJhX21heCAgPSAwO1xuICAvKiBwb2ludGVyIHRvIHplcm8tdGVybWluYXRlZCBmaWxlIG5hbWUgb3IgWl9OVUxMICovXG4gIHRoaXMubmFtZSAgICAgICA9ICcnO1xuICAvKiBzcGFjZSBhdCBuYW1lIChvbmx5IHdoZW4gcmVhZGluZyBoZWFkZXIpICovXG4gIC8vIHRoaXMubmFtZV9tYXggICA9IDA7XG4gIC8qIHBvaW50ZXIgdG8gemVyby10ZXJtaW5hdGVkIGNvbW1lbnQgb3IgWl9OVUxMICovXG4gIHRoaXMuY29tbWVudCAgICA9ICcnO1xuICAvKiBzcGFjZSBhdCBjb21tZW50IChvbmx5IHdoZW4gcmVhZGluZyBoZWFkZXIpICovXG4gIC8vIHRoaXMuY29tbV9tYXggICA9IDA7XG4gIC8qIHRydWUgaWYgdGhlcmUgd2FzIG9yIHdpbGwgYmUgYSBoZWFkZXIgY3JjICovXG4gIHRoaXMuaGNyYyAgICAgICA9IDA7XG4gIC8qIHRydWUgd2hlbiBkb25lIHJlYWRpbmcgZ3ppcCBoZWFkZXIgKG5vdCB1c2VkIHdoZW4gd3JpdGluZyBhIGd6aXAgZmlsZSkgKi9cbiAgdGhpcy5kb25lICAgICAgID0gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gR1poZWFkZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cblxudmFyIHpsaWJfaW5mbGF0ZSA9IHJlcXVpcmUoJy4vemxpYi9pbmZsYXRlJyk7XG52YXIgdXRpbHMgICAgICAgID0gcmVxdWlyZSgnLi91dGlscy9jb21tb24nKTtcbnZhciBzdHJpbmdzICAgICAgPSByZXF1aXJlKCcuL3V0aWxzL3N0cmluZ3MnKTtcbnZhciBjICAgICAgICAgICAgPSByZXF1aXJlKCcuL3psaWIvY29uc3RhbnRzJyk7XG52YXIgbXNnICAgICAgICAgID0gcmVxdWlyZSgnLi96bGliL21lc3NhZ2VzJyk7XG52YXIgWlN0cmVhbSAgICAgID0gcmVxdWlyZSgnLi96bGliL3pzdHJlYW0nKTtcbnZhciBHWmhlYWRlciAgICAgPSByZXF1aXJlKCcuL3psaWIvZ3poZWFkZXInKTtcblxudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuLyoqXG4gKiBjbGFzcyBJbmZsYXRlXG4gKlxuICogR2VuZXJpYyBKUy1zdHlsZSB3cmFwcGVyIGZvciB6bGliIGNhbGxzLiBJZiB5b3UgZG9uJ3QgbmVlZFxuICogc3RyZWFtaW5nIGJlaGF2aW91ciAtIHVzZSBtb3JlIHNpbXBsZSBmdW5jdGlvbnM6IFtbaW5mbGF0ZV1dXG4gKiBhbmQgW1tpbmZsYXRlUmF3XV0uXG4gKiovXG5cbi8qIGludGVybmFsXG4gKiBpbmZsYXRlLmNodW5rcyAtPiBBcnJheVxuICpcbiAqIENodW5rcyBvZiBvdXRwdXQgZGF0YSwgaWYgW1tJbmZsYXRlI29uRGF0YV1dIG5vdCBvdmVycmlkZGVuLlxuICoqL1xuXG4vKipcbiAqIEluZmxhdGUucmVzdWx0IC0+IFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nXG4gKlxuICogVW5jb21wcmVzc2VkIHJlc3VsdCwgZ2VuZXJhdGVkIGJ5IGRlZmF1bHQgW1tJbmZsYXRlI29uRGF0YV1dXG4gKiBhbmQgW1tJbmZsYXRlI29uRW5kXV0gaGFuZGxlcnMuIEZpbGxlZCBhZnRlciB5b3UgcHVzaCBsYXN0IGNodW5rXG4gKiAoY2FsbCBbW0luZmxhdGUjcHVzaF1dIHdpdGggYFpfRklOSVNIYCAvIGB0cnVlYCBwYXJhbSkgb3IgaWYgeW91XG4gKiBwdXNoIGEgY2h1bmsgd2l0aCBleHBsaWNpdCBmbHVzaCAoY2FsbCBbW0luZmxhdGUjcHVzaF1dIHdpdGhcbiAqIGBaX1NZTkNfRkxVU0hgIHBhcmFtKS5cbiAqKi9cblxuLyoqXG4gKiBJbmZsYXRlLmVyciAtPiBOdW1iZXJcbiAqXG4gKiBFcnJvciBjb2RlIGFmdGVyIGluZmxhdGUgZmluaXNoZWQuIDAgKFpfT0spIG9uIHN1Y2Nlc3MuXG4gKiBTaG91bGQgYmUgY2hlY2tlZCBpZiBicm9rZW4gZGF0YSBwb3NzaWJsZS5cbiAqKi9cblxuLyoqXG4gKiBJbmZsYXRlLm1zZyAtPiBTdHJpbmdcbiAqXG4gKiBFcnJvciBtZXNzYWdlLCBpZiBbW0luZmxhdGUuZXJyXV0gIT0gMFxuICoqL1xuXG5cbi8qKlxuICogbmV3IEluZmxhdGUob3B0aW9ucylcbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogemxpYiBpbmZsYXRlIG9wdGlvbnMuXG4gKlxuICogQ3JlYXRlcyBuZXcgaW5mbGF0b3IgaW5zdGFuY2Ugd2l0aCBzcGVjaWZpZWQgcGFyYW1zLiBUaHJvd3MgZXhjZXB0aW9uXG4gKiBvbiBiYWQgcGFyYW1zLiBTdXBwb3J0ZWQgb3B0aW9uczpcbiAqXG4gKiAtIGB3aW5kb3dCaXRzYFxuICogLSBgZGljdGlvbmFyeWBcbiAqXG4gKiBbaHR0cDovL3psaWIubmV0L21hbnVhbC5odG1sI0FkdmFuY2VkXShodHRwOi8vemxpYi5uZXQvbWFudWFsLmh0bWwjQWR2YW5jZWQpXG4gKiBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiB0aGVzZS5cbiAqXG4gKiBBZGRpdGlvbmFsIG9wdGlvbnMsIGZvciBpbnRlcm5hbCBuZWVkczpcbiAqXG4gKiAtIGBjaHVua1NpemVgIC0gc2l6ZSBvZiBnZW5lcmF0ZWQgZGF0YSBjaHVua3MgKDE2SyBieSBkZWZhdWx0KVxuICogLSBgcmF3YCAoQm9vbGVhbikgLSBkbyByYXcgaW5mbGF0ZVxuICogLSBgdG9gIChTdHJpbmcpIC0gaWYgZXF1YWwgdG8gJ3N0cmluZycsIHRoZW4gcmVzdWx0IHdpbGwgYmUgY29udmVydGVkXG4gKiAgIGZyb20gdXRmOCB0byB1dGYxNiAoamF2YXNjcmlwdCkgc3RyaW5nLiBXaGVuIHN0cmluZyBvdXRwdXQgcmVxdWVzdGVkLFxuICogICBjaHVuayBsZW5ndGggY2FuIGRpZmZlciBmcm9tIGBjaHVua1NpemVgLCBkZXBlbmRpbmcgb24gY29udGVudC5cbiAqXG4gKiBCeSBkZWZhdWx0LCB3aGVuIG5vIG9wdGlvbnMgc2V0LCBhdXRvZGV0ZWN0IGRlZmxhdGUvZ3ppcCBkYXRhIGZvcm1hdCB2aWFcbiAqIHdyYXBwZXIgaGVhZGVyLlxuICpcbiAqICMjIyMjIEV4YW1wbGU6XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogdmFyIHBha28gPSByZXF1aXJlKCdwYWtvJylcbiAqICAgLCBjaHVuazEgPSBVaW50OEFycmF5KFsxLDIsMyw0LDUsNiw3LDgsOV0pXG4gKiAgICwgY2h1bmsyID0gVWludDhBcnJheShbMTAsMTEsMTIsMTMsMTQsMTUsMTYsMTcsMTgsMTldKTtcbiAqXG4gKiB2YXIgaW5mbGF0ZSA9IG5ldyBwYWtvLkluZmxhdGUoeyBsZXZlbDogM30pO1xuICpcbiAqIGluZmxhdGUucHVzaChjaHVuazEsIGZhbHNlKTtcbiAqIGluZmxhdGUucHVzaChjaHVuazIsIHRydWUpOyAgLy8gdHJ1ZSAtPiBsYXN0IGNodW5rXG4gKlxuICogaWYgKGluZmxhdGUuZXJyKSB7IHRocm93IG5ldyBFcnJvcihpbmZsYXRlLmVycik7IH1cbiAqXG4gKiBjb25zb2xlLmxvZyhpbmZsYXRlLnJlc3VsdCk7XG4gKiBgYGBcbiAqKi9cbmZ1bmN0aW9uIEluZmxhdGUob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgSW5mbGF0ZSkpIHJldHVybiBuZXcgSW5mbGF0ZShvcHRpb25zKTtcblxuICB0aGlzLm9wdGlvbnMgPSB1dGlscy5hc3NpZ24oe1xuICAgIGNodW5rU2l6ZTogMTYzODQsXG4gICAgd2luZG93Qml0czogMCxcbiAgICB0bzogJydcbiAgfSwgb3B0aW9ucyB8fCB7fSk7XG5cbiAgdmFyIG9wdCA9IHRoaXMub3B0aW9ucztcblxuICAvLyBGb3JjZSB3aW5kb3cgc2l6ZSBmb3IgYHJhd2AgZGF0YSwgaWYgbm90IHNldCBkaXJlY3RseSxcbiAgLy8gYmVjYXVzZSB3ZSBoYXZlIG5vIGhlYWRlciBmb3IgYXV0b2RldGVjdC5cbiAgaWYgKG9wdC5yYXcgJiYgKG9wdC53aW5kb3dCaXRzID49IDApICYmIChvcHQud2luZG93Qml0cyA8IDE2KSkge1xuICAgIG9wdC53aW5kb3dCaXRzID0gLW9wdC53aW5kb3dCaXRzO1xuICAgIGlmIChvcHQud2luZG93Qml0cyA9PT0gMCkgeyBvcHQud2luZG93Qml0cyA9IC0xNTsgfVxuICB9XG5cbiAgLy8gSWYgYHdpbmRvd0JpdHNgIG5vdCBkZWZpbmVkIChhbmQgbW9kZSBub3QgcmF3KSAtIHNldCBhdXRvZGV0ZWN0IGZsYWcgZm9yIGd6aXAvZGVmbGF0ZVxuICBpZiAoKG9wdC53aW5kb3dCaXRzID49IDApICYmIChvcHQud2luZG93Qml0cyA8IDE2KSAmJlxuICAgICAgIShvcHRpb25zICYmIG9wdGlvbnMud2luZG93Qml0cykpIHtcbiAgICBvcHQud2luZG93Qml0cyArPSAzMjtcbiAgfVxuXG4gIC8vIEd6aXAgaGVhZGVyIGhhcyBubyBpbmZvIGFib3V0IHdpbmRvd3Mgc2l6ZSwgd2UgY2FuIGRvIGF1dG9kZXRlY3Qgb25seVxuICAvLyBmb3IgZGVmbGF0ZS4gU28sIGlmIHdpbmRvdyBzaXplIG5vdCBzZXQsIGZvcmNlIGl0IHRvIG1heCB3aGVuIGd6aXAgcG9zc2libGVcbiAgaWYgKChvcHQud2luZG93Qml0cyA+IDE1KSAmJiAob3B0LndpbmRvd0JpdHMgPCA0OCkpIHtcbiAgICAvLyBiaXQgMyAoMTYpIC0+IGd6aXBwZWQgZGF0YVxuICAgIC8vIGJpdCA0ICgzMikgLT4gYXV0b2RldGVjdCBnemlwL2RlZmxhdGVcbiAgICBpZiAoKG9wdC53aW5kb3dCaXRzICYgMTUpID09PSAwKSB7XG4gICAgICBvcHQud2luZG93Qml0cyB8PSAxNTtcbiAgICB9XG4gIH1cblxuICB0aGlzLmVyciAgICA9IDA7ICAgICAgLy8gZXJyb3IgY29kZSwgaWYgaGFwcGVucyAoMCA9IFpfT0spXG4gIHRoaXMubXNnICAgID0gJyc7ICAgICAvLyBlcnJvciBtZXNzYWdlXG4gIHRoaXMuZW5kZWQgID0gZmFsc2U7ICAvLyB1c2VkIHRvIGF2b2lkIG11bHRpcGxlIG9uRW5kKCkgY2FsbHNcbiAgdGhpcy5jaHVua3MgPSBbXTsgICAgIC8vIGNodW5rcyBvZiBjb21wcmVzc2VkIGRhdGFcblxuICB0aGlzLnN0cm0gICA9IG5ldyBaU3RyZWFtKCk7XG4gIHRoaXMuc3RybS5hdmFpbF9vdXQgPSAwO1xuXG4gIHZhciBzdGF0dXMgID0gemxpYl9pbmZsYXRlLmluZmxhdGVJbml0MihcbiAgICB0aGlzLnN0cm0sXG4gICAgb3B0LndpbmRvd0JpdHNcbiAgKTtcblxuICBpZiAoc3RhdHVzICE9PSBjLlpfT0spIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IobXNnW3N0YXR1c10pO1xuICB9XG5cbiAgdGhpcy5oZWFkZXIgPSBuZXcgR1poZWFkZXIoKTtcblxuICB6bGliX2luZmxhdGUuaW5mbGF0ZUdldEhlYWRlcih0aGlzLnN0cm0sIHRoaXMuaGVhZGVyKTtcblxuICAvLyBTZXR1cCBkaWN0aW9uYXJ5XG4gIGlmIChvcHQuZGljdGlvbmFyeSkge1xuICAgIC8vIENvbnZlcnQgZGF0YSBpZiBuZWVkZWRcbiAgICBpZiAodHlwZW9mIG9wdC5kaWN0aW9uYXJ5ID09PSAnc3RyaW5nJykge1xuICAgICAgb3B0LmRpY3Rpb25hcnkgPSBzdHJpbmdzLnN0cmluZzJidWYob3B0LmRpY3Rpb25hcnkpO1xuICAgIH0gZWxzZSBpZiAodG9TdHJpbmcuY2FsbChvcHQuZGljdGlvbmFyeSkgPT09ICdbb2JqZWN0IEFycmF5QnVmZmVyXScpIHtcbiAgICAgIG9wdC5kaWN0aW9uYXJ5ID0gbmV3IFVpbnQ4QXJyYXkob3B0LmRpY3Rpb25hcnkpO1xuICAgIH1cbiAgICBpZiAob3B0LnJhdykgeyAvL0luIHJhdyBtb2RlIHdlIG5lZWQgdG8gc2V0IHRoZSBkaWN0aW9uYXJ5IGVhcmx5XG4gICAgICBzdGF0dXMgPSB6bGliX2luZmxhdGUuaW5mbGF0ZVNldERpY3Rpb25hcnkodGhpcy5zdHJtLCBvcHQuZGljdGlvbmFyeSk7XG4gICAgICBpZiAoc3RhdHVzICE9PSBjLlpfT0spIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZ1tzdGF0dXNdKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBJbmZsYXRlI3B1c2goZGF0YVssIG1vZGVdKSAtPiBCb29sZWFuXG4gKiAtIGRhdGEgKFVpbnQ4QXJyYXl8QXJyYXl8QXJyYXlCdWZmZXJ8U3RyaW5nKTogaW5wdXQgZGF0YVxuICogLSBtb2RlIChOdW1iZXJ8Qm9vbGVhbik6IDAuLjYgZm9yIGNvcnJlc3BvbmRpbmcgWl9OT19GTFVTSC4uWl9UUkVFIG1vZGVzLlxuICogICBTZWUgY29uc3RhbnRzLiBTa2lwcGVkIG9yIGBmYWxzZWAgbWVhbnMgWl9OT19GTFVTSCwgYHRydWVgIG1lYW5zIFpfRklOSVNILlxuICpcbiAqIFNlbmRzIGlucHV0IGRhdGEgdG8gaW5mbGF0ZSBwaXBlLCBnZW5lcmF0aW5nIFtbSW5mbGF0ZSNvbkRhdGFdXSBjYWxscyB3aXRoXG4gKiBuZXcgb3V0cHV0IGNodW5rcy4gUmV0dXJucyBgdHJ1ZWAgb24gc3VjY2Vzcy4gVGhlIGxhc3QgZGF0YSBibG9jayBtdXN0IGhhdmVcbiAqIG1vZGUgWl9GSU5JU0ggKG9yIGB0cnVlYCkuIFRoYXQgd2lsbCBmbHVzaCBpbnRlcm5hbCBwZW5kaW5nIGJ1ZmZlcnMgYW5kIGNhbGxcbiAqIFtbSW5mbGF0ZSNvbkVuZF1dLiBGb3IgaW50ZXJpbSBleHBsaWNpdCBmbHVzaGVzICh3aXRob3V0IGVuZGluZyB0aGUgc3RyZWFtKSB5b3VcbiAqIGNhbiB1c2UgbW9kZSBaX1NZTkNfRkxVU0gsIGtlZXBpbmcgdGhlIGRlY29tcHJlc3Npb24gY29udGV4dC5cbiAqXG4gKiBPbiBmYWlsIGNhbGwgW1tJbmZsYXRlI29uRW5kXV0gd2l0aCBlcnJvciBjb2RlIGFuZCByZXR1cm4gZmFsc2UuXG4gKlxuICogV2Ugc3Ryb25nbHkgcmVjb21tZW5kIHRvIHVzZSBgVWludDhBcnJheWAgb24gaW5wdXQgZm9yIGJlc3Qgc3BlZWQgKG91dHB1dFxuICogZm9ybWF0IGlzIGRldGVjdGVkIGF1dG9tYXRpY2FsbHkpLiBBbHNvLCBkb24ndCBza2lwIGxhc3QgcGFyYW0gYW5kIGFsd2F5c1xuICogdXNlIHRoZSBzYW1lIHR5cGUgaW4geW91ciBjb2RlIChib29sZWFuIG9yIG51bWJlcikuIFRoYXQgd2lsbCBpbXByb3ZlIEpTIHNwZWVkLlxuICpcbiAqIEZvciByZWd1bGFyIGBBcnJheWAtcyBtYWtlIHN1cmUgYWxsIGVsZW1lbnRzIGFyZSBbMC4uMjU1XS5cbiAqXG4gKiAjIyMjIyBFeGFtcGxlXG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogcHVzaChjaHVuaywgZmFsc2UpOyAvLyBwdXNoIG9uZSBvZiBkYXRhIGNodW5rc1xuICogLi4uXG4gKiBwdXNoKGNodW5rLCB0cnVlKTsgIC8vIHB1c2ggbGFzdCBjaHVua1xuICogYGBgXG4gKiovXG5JbmZsYXRlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGRhdGEsIG1vZGUpIHtcbiAgdmFyIHN0cm0gPSB0aGlzLnN0cm07XG4gIHZhciBjaHVua1NpemUgPSB0aGlzLm9wdGlvbnMuY2h1bmtTaXplO1xuICB2YXIgZGljdGlvbmFyeSA9IHRoaXMub3B0aW9ucy5kaWN0aW9uYXJ5O1xuICB2YXIgc3RhdHVzLCBfbW9kZTtcbiAgdmFyIG5leHRfb3V0X3V0ZjgsIHRhaWwsIHV0ZjhzdHI7XG5cbiAgLy8gRmxhZyB0byBwcm9wZXJseSBwcm9jZXNzIFpfQlVGX0VSUk9SIG9uIHRlc3RpbmcgaW5mbGF0ZSBjYWxsXG4gIC8vIHdoZW4gd2UgY2hlY2sgdGhhdCBhbGwgb3V0cHV0IGRhdGEgd2FzIGZsdXNoZWQuXG4gIHZhciBhbGxvd0J1ZkVycm9yID0gZmFsc2U7XG5cbiAgaWYgKHRoaXMuZW5kZWQpIHsgcmV0dXJuIGZhbHNlOyB9XG4gIF9tb2RlID0gKG1vZGUgPT09IH5+bW9kZSkgPyBtb2RlIDogKChtb2RlID09PSB0cnVlKSA/IGMuWl9GSU5JU0ggOiBjLlpfTk9fRkxVU0gpO1xuXG4gIC8vIENvbnZlcnQgZGF0YSBpZiBuZWVkZWRcbiAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgIC8vIE9ubHkgYmluYXJ5IHN0cmluZ3MgY2FuIGJlIGRlY29tcHJlc3NlZCBvbiBwcmFjdGljZVxuICAgIHN0cm0uaW5wdXQgPSBzdHJpbmdzLmJpbnN0cmluZzJidWYoZGF0YSk7XG4gIH0gZWxzZSBpZiAodG9TdHJpbmcuY2FsbChkYXRhKSA9PT0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJykge1xuICAgIHN0cm0uaW5wdXQgPSBuZXcgVWludDhBcnJheShkYXRhKTtcbiAgfSBlbHNlIHtcbiAgICBzdHJtLmlucHV0ID0gZGF0YTtcbiAgfVxuXG4gIHN0cm0ubmV4dF9pbiA9IDA7XG4gIHN0cm0uYXZhaWxfaW4gPSBzdHJtLmlucHV0Lmxlbmd0aDtcblxuICBkbyB7XG4gICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICBzdHJtLm91dHB1dCA9IG5ldyB1dGlscy5CdWY4KGNodW5rU2l6ZSk7XG4gICAgICBzdHJtLm5leHRfb3V0ID0gMDtcbiAgICAgIHN0cm0uYXZhaWxfb3V0ID0gY2h1bmtTaXplO1xuICAgIH1cblxuICAgIHN0YXR1cyA9IHpsaWJfaW5mbGF0ZS5pbmZsYXRlKHN0cm0sIGMuWl9OT19GTFVTSCk7ICAgIC8qIG5vIGJhZCByZXR1cm4gdmFsdWUgKi9cblxuICAgIGlmIChzdGF0dXMgPT09IGMuWl9ORUVEX0RJQ1QgJiYgZGljdGlvbmFyeSkge1xuICAgICAgc3RhdHVzID0gemxpYl9pbmZsYXRlLmluZmxhdGVTZXREaWN0aW9uYXJ5KHRoaXMuc3RybSwgZGljdGlvbmFyeSk7XG4gICAgfVxuXG4gICAgaWYgKHN0YXR1cyA9PT0gYy5aX0JVRl9FUlJPUiAmJiBhbGxvd0J1ZkVycm9yID09PSB0cnVlKSB7XG4gICAgICBzdGF0dXMgPSBjLlpfT0s7XG4gICAgICBhbGxvd0J1ZkVycm9yID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHN0YXR1cyAhPT0gYy5aX1NUUkVBTV9FTkQgJiYgc3RhdHVzICE9PSBjLlpfT0spIHtcbiAgICAgIHRoaXMub25FbmQoc3RhdHVzKTtcbiAgICAgIHRoaXMuZW5kZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChzdHJtLm5leHRfb3V0KSB7XG4gICAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDAgfHwgc3RhdHVzID09PSBjLlpfU1RSRUFNX0VORCB8fCAoc3RybS5hdmFpbF9pbiA9PT0gMCAmJiAoX21vZGUgPT09IGMuWl9GSU5JU0ggfHwgX21vZGUgPT09IGMuWl9TWU5DX0ZMVVNIKSkpIHtcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnRvID09PSAnc3RyaW5nJykge1xuXG4gICAgICAgICAgbmV4dF9vdXRfdXRmOCA9IHN0cmluZ3MudXRmOGJvcmRlcihzdHJtLm91dHB1dCwgc3RybS5uZXh0X291dCk7XG5cbiAgICAgICAgICB0YWlsID0gc3RybS5uZXh0X291dCAtIG5leHRfb3V0X3V0Zjg7XG4gICAgICAgICAgdXRmOHN0ciA9IHN0cmluZ3MuYnVmMnN0cmluZyhzdHJtLm91dHB1dCwgbmV4dF9vdXRfdXRmOCk7XG5cbiAgICAgICAgICAvLyBtb3ZlIHRhaWxcbiAgICAgICAgICBzdHJtLm5leHRfb3V0ID0gdGFpbDtcbiAgICAgICAgICBzdHJtLmF2YWlsX291dCA9IGNodW5rU2l6ZSAtIHRhaWw7XG4gICAgICAgICAgaWYgKHRhaWwpIHsgdXRpbHMuYXJyYXlTZXQoc3RybS5vdXRwdXQsIHN0cm0ub3V0cHV0LCBuZXh0X291dF91dGY4LCB0YWlsLCAwKTsgfVxuXG4gICAgICAgICAgdGhpcy5vbkRhdGEodXRmOHN0cik7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLm9uRGF0YSh1dGlscy5zaHJpbmtCdWYoc3RybS5vdXRwdXQsIHN0cm0ubmV4dF9vdXQpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFdoZW4gbm8gbW9yZSBpbnB1dCBkYXRhLCB3ZSBzaG91bGQgY2hlY2sgdGhhdCBpbnRlcm5hbCBpbmZsYXRlIGJ1ZmZlcnNcbiAgICAvLyBhcmUgZmx1c2hlZC4gVGhlIG9ubHkgd2F5IHRvIGRvIGl0IHdoZW4gYXZhaWxfb3V0ID0gMCAtIHJ1biBvbmUgbW9yZVxuICAgIC8vIGluZmxhdGUgcGFzcy4gQnV0IGlmIG91dHB1dCBkYXRhIG5vdCBleGlzdHMsIGluZmxhdGUgcmV0dXJuIFpfQlVGX0VSUk9SLlxuICAgIC8vIEhlcmUgd2Ugc2V0IGZsYWcgdG8gcHJvY2VzcyB0aGlzIGVycm9yIHByb3Blcmx5LlxuICAgIC8vXG4gICAgLy8gTk9URS4gRGVmbGF0ZSBkb2VzIG5vdCByZXR1cm4gZXJyb3IgaW4gdGhpcyBjYXNlIGFuZCBkb2VzIG5vdCBuZWVkcyBzdWNoXG4gICAgLy8gbG9naWMuXG4gICAgaWYgKHN0cm0uYXZhaWxfaW4gPT09IDAgJiYgc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIGFsbG93QnVmRXJyb3IgPSB0cnVlO1xuICAgIH1cblxuICB9IHdoaWxlICgoc3RybS5hdmFpbF9pbiA+IDAgfHwgc3RybS5hdmFpbF9vdXQgPT09IDApICYmIHN0YXR1cyAhPT0gYy5aX1NUUkVBTV9FTkQpO1xuXG4gIGlmIChzdGF0dXMgPT09IGMuWl9TVFJFQU1fRU5EKSB7XG4gICAgX21vZGUgPSBjLlpfRklOSVNIO1xuICB9XG5cbiAgLy8gRmluYWxpemUgb24gdGhlIGxhc3QgY2h1bmsuXG4gIGlmIChfbW9kZSA9PT0gYy5aX0ZJTklTSCkge1xuICAgIHN0YXR1cyA9IHpsaWJfaW5mbGF0ZS5pbmZsYXRlRW5kKHRoaXMuc3RybSk7XG4gICAgdGhpcy5vbkVuZChzdGF0dXMpO1xuICAgIHRoaXMuZW5kZWQgPSB0cnVlO1xuICAgIHJldHVybiBzdGF0dXMgPT09IGMuWl9PSztcbiAgfVxuXG4gIC8vIGNhbGxiYWNrIGludGVyaW0gcmVzdWx0cyBpZiBaX1NZTkNfRkxVU0guXG4gIGlmIChfbW9kZSA9PT0gYy5aX1NZTkNfRkxVU0gpIHtcbiAgICB0aGlzLm9uRW5kKGMuWl9PSyk7XG4gICAgc3RybS5hdmFpbF9vdXQgPSAwO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cbi8qKlxuICogSW5mbGF0ZSNvbkRhdGEoY2h1bmspIC0+IFZvaWRcbiAqIC0gY2h1bmsgKFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nKTogb3V0cHV0IGRhdGEuIFR5cGUgb2YgYXJyYXkgZGVwZW5kc1xuICogICBvbiBqcyBlbmdpbmUgc3VwcG9ydC4gV2hlbiBzdHJpbmcgb3V0cHV0IHJlcXVlc3RlZCwgZWFjaCBjaHVua1xuICogICB3aWxsIGJlIHN0cmluZy5cbiAqXG4gKiBCeSBkZWZhdWx0LCBzdG9yZXMgZGF0YSBibG9ja3MgaW4gYGNodW5rc1tdYCBwcm9wZXJ0eSBhbmQgZ2x1ZVxuICogdGhvc2UgaW4gYG9uRW5kYC4gT3ZlcnJpZGUgdGhpcyBoYW5kbGVyLCBpZiB5b3UgbmVlZCBhbm90aGVyIGJlaGF2aW91ci5cbiAqKi9cbkluZmxhdGUucHJvdG90eXBlLm9uRGF0YSA9IGZ1bmN0aW9uIChjaHVuaykge1xuICB0aGlzLmNodW5rcy5wdXNoKGNodW5rKTtcbn07XG5cblxuLyoqXG4gKiBJbmZsYXRlI29uRW5kKHN0YXR1cykgLT4gVm9pZFxuICogLSBzdGF0dXMgKE51bWJlcik6IGluZmxhdGUgc3RhdHVzLiAwIChaX09LKSBvbiBzdWNjZXNzLFxuICogICBvdGhlciBpZiBub3QuXG4gKlxuICogQ2FsbGVkIGVpdGhlciBhZnRlciB5b3UgdGVsbCBpbmZsYXRlIHRoYXQgdGhlIGlucHV0IHN0cmVhbSBpc1xuICogY29tcGxldGUgKFpfRklOSVNIKSBvciBzaG91bGQgYmUgZmx1c2hlZCAoWl9TWU5DX0ZMVVNIKVxuICogb3IgaWYgYW4gZXJyb3IgaGFwcGVuZWQuIEJ5IGRlZmF1bHQgLSBqb2luIGNvbGxlY3RlZCBjaHVua3MsXG4gKiBmcmVlIG1lbW9yeSBhbmQgZmlsbCBgcmVzdWx0c2AgLyBgZXJyYCBwcm9wZXJ0aWVzLlxuICoqL1xuSW5mbGF0ZS5wcm90b3R5cGUub25FbmQgPSBmdW5jdGlvbiAoc3RhdHVzKSB7XG4gIC8vIE9uIHN1Y2Nlc3MgLSBqb2luXG4gIGlmIChzdGF0dXMgPT09IGMuWl9PSykge1xuICAgIGlmICh0aGlzLm9wdGlvbnMudG8gPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBHbHVlICYgY29udmVydCBoZXJlLCB1bnRpbCB3ZSB0ZWFjaCBwYWtvIHRvIHNlbmRcbiAgICAgIC8vIHV0ZjggYWxpZ25lZCBzdHJpbmdzIHRvIG9uRGF0YVxuICAgICAgdGhpcy5yZXN1bHQgPSB0aGlzLmNodW5rcy5qb2luKCcnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZXN1bHQgPSB1dGlscy5mbGF0dGVuQ2h1bmtzKHRoaXMuY2h1bmtzKTtcbiAgICB9XG4gIH1cbiAgdGhpcy5jaHVua3MgPSBbXTtcbiAgdGhpcy5lcnIgPSBzdGF0dXM7XG4gIHRoaXMubXNnID0gdGhpcy5zdHJtLm1zZztcbn07XG5cblxuLyoqXG4gKiBpbmZsYXRlKGRhdGFbLCBvcHRpb25zXSkgLT4gVWludDhBcnJheXxBcnJheXxTdHJpbmdcbiAqIC0gZGF0YSAoVWludDhBcnJheXxBcnJheXxTdHJpbmcpOiBpbnB1dCBkYXRhIHRvIGRlY29tcHJlc3MuXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHpsaWIgaW5mbGF0ZSBvcHRpb25zLlxuICpcbiAqIERlY29tcHJlc3MgYGRhdGFgIHdpdGggaW5mbGF0ZS91bmd6aXAgYW5kIGBvcHRpb25zYC4gQXV0b2RldGVjdFxuICogZm9ybWF0IHZpYSB3cmFwcGVyIGhlYWRlciBieSBkZWZhdWx0LiBUaGF0J3Mgd2h5IHdlIGRvbid0IHByb3ZpZGVcbiAqIHNlcGFyYXRlIGB1bmd6aXBgIG1ldGhvZC5cbiAqXG4gKiBTdXBwb3J0ZWQgb3B0aW9ucyBhcmU6XG4gKlxuICogLSB3aW5kb3dCaXRzXG4gKlxuICogW2h0dHA6Ly96bGliLm5ldC9tYW51YWwuaHRtbCNBZHZhbmNlZF0oaHR0cDovL3psaWIubmV0L21hbnVhbC5odG1sI0FkdmFuY2VkKVxuICogZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gKlxuICogU3VnYXIgKG9wdGlvbnMpOlxuICpcbiAqIC0gYHJhd2AgKEJvb2xlYW4pIC0gc2F5IHRoYXQgd2Ugd29yayB3aXRoIHJhdyBzdHJlYW0sIGlmIHlvdSBkb24ndCB3aXNoIHRvIHNwZWNpZnlcbiAqICAgbmVnYXRpdmUgd2luZG93Qml0cyBpbXBsaWNpdGx5LlxuICogLSBgdG9gIChTdHJpbmcpIC0gaWYgZXF1YWwgdG8gJ3N0cmluZycsIHRoZW4gcmVzdWx0IHdpbGwgYmUgY29udmVydGVkXG4gKiAgIGZyb20gdXRmOCB0byB1dGYxNiAoamF2YXNjcmlwdCkgc3RyaW5nLiBXaGVuIHN0cmluZyBvdXRwdXQgcmVxdWVzdGVkLFxuICogICBjaHVuayBsZW5ndGggY2FuIGRpZmZlciBmcm9tIGBjaHVua1NpemVgLCBkZXBlbmRpbmcgb24gY29udGVudC5cbiAqXG4gKlxuICogIyMjIyMgRXhhbXBsZTpcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiB2YXIgcGFrbyA9IHJlcXVpcmUoJ3Bha28nKVxuICogICAsIGlucHV0ID0gcGFrby5kZWZsYXRlKFsxLDIsMyw0LDUsNiw3LDgsOV0pXG4gKiAgICwgb3V0cHV0O1xuICpcbiAqIHRyeSB7XG4gKiAgIG91dHB1dCA9IHBha28uaW5mbGF0ZShpbnB1dCk7XG4gKiB9IGNhdGNoIChlcnIpXG4gKiAgIGNvbnNvbGUubG9nKGVycik7XG4gKiB9XG4gKiBgYGBcbiAqKi9cbmZ1bmN0aW9uIGluZmxhdGUoaW5wdXQsIG9wdGlvbnMpIHtcbiAgdmFyIGluZmxhdG9yID0gbmV3IEluZmxhdGUob3B0aW9ucyk7XG5cbiAgaW5mbGF0b3IucHVzaChpbnB1dCwgdHJ1ZSk7XG5cbiAgLy8gVGhhdCB3aWxsIG5ldmVyIGhhcHBlbnMsIGlmIHlvdSBkb24ndCBjaGVhdCB3aXRoIG9wdGlvbnMgOilcbiAgaWYgKGluZmxhdG9yLmVycikgeyB0aHJvdyBpbmZsYXRvci5tc2cgfHwgbXNnW2luZmxhdG9yLmVycl07IH1cblxuICByZXR1cm4gaW5mbGF0b3IucmVzdWx0O1xufVxuXG5cbi8qKlxuICogaW5mbGF0ZVJhdyhkYXRhWywgb3B0aW9uc10pIC0+IFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nXG4gKiAtIGRhdGEgKFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nKTogaW5wdXQgZGF0YSB0byBkZWNvbXByZXNzLlxuICogLSBvcHRpb25zIChPYmplY3QpOiB6bGliIGluZmxhdGUgb3B0aW9ucy5cbiAqXG4gKiBUaGUgc2FtZSBhcyBbW2luZmxhdGVdXSwgYnV0IGNyZWF0ZXMgcmF3IGRhdGEsIHdpdGhvdXQgd3JhcHBlclxuICogKGhlYWRlciBhbmQgYWRsZXIzMiBjcmMpLlxuICoqL1xuZnVuY3Rpb24gaW5mbGF0ZVJhdyhpbnB1dCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgb3B0aW9ucy5yYXcgPSB0cnVlO1xuICByZXR1cm4gaW5mbGF0ZShpbnB1dCwgb3B0aW9ucyk7XG59XG5cblxuLyoqXG4gKiB1bmd6aXAoZGF0YVssIG9wdGlvbnNdKSAtPiBVaW50OEFycmF5fEFycmF5fFN0cmluZ1xuICogLSBkYXRhIChVaW50OEFycmF5fEFycmF5fFN0cmluZyk6IGlucHV0IGRhdGEgdG8gZGVjb21wcmVzcy5cbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogemxpYiBpbmZsYXRlIG9wdGlvbnMuXG4gKlxuICogSnVzdCBzaG9ydGN1dCB0byBbW2luZmxhdGVdXSwgYmVjYXVzZSBpdCBhdXRvZGV0ZWN0cyBmb3JtYXRcbiAqIGJ5IGhlYWRlci5jb250ZW50LiBEb25lIGZvciBjb252ZW5pZW5jZS5cbiAqKi9cblxuXG5leHBvcnRzLkluZmxhdGUgPSBJbmZsYXRlO1xuZXhwb3J0cy5pbmZsYXRlID0gaW5mbGF0ZTtcbmV4cG9ydHMuaW5mbGF0ZVJhdyA9IGluZmxhdGVSYXc7XG5leHBvcnRzLnVuZ3ppcCAgPSBpbmZsYXRlO1xuIiwiLy8gVG9wIGxldmVsIGZpbGUgaXMganVzdCBhIG1peGluIG9mIHN1Ym1vZHVsZXMgJiBjb25zdGFudHNcbid1c2Ugc3RyaWN0JztcblxudmFyIGFzc2lnbiAgICA9IHJlcXVpcmUoJy4vbGliL3V0aWxzL2NvbW1vbicpLmFzc2lnbjtcblxudmFyIGRlZmxhdGUgICA9IHJlcXVpcmUoJy4vbGliL2RlZmxhdGUnKTtcbnZhciBpbmZsYXRlICAgPSByZXF1aXJlKCcuL2xpYi9pbmZsYXRlJyk7XG52YXIgY29uc3RhbnRzID0gcmVxdWlyZSgnLi9saWIvemxpYi9jb25zdGFudHMnKTtcblxudmFyIHBha28gPSB7fTtcblxuYXNzaWduKHBha28sIGRlZmxhdGUsIGluZmxhdGUsIGNvbnN0YW50cyk7XG5cbm1vZHVsZS5leHBvcnRzID0gcGFrbztcbiIsIi8vIEEgc2ltcGxlIGltcGxlbWVudGF0aW9uIG9mIG1ha2UtYXJyYXlcbmZ1bmN0aW9uIG1ha2VBcnJheSAoc3ViamVjdCkge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShzdWJqZWN0KVxuICAgID8gc3ViamVjdFxuICAgIDogW3N1YmplY3RdXG59XG5cbmNvbnN0IEVNUFRZID0gJydcbmNvbnN0IFNQQUNFID0gJyAnXG5jb25zdCBFU0NBUEUgPSAnXFxcXCdcbmNvbnN0IFJFR0VYX1RFU1RfQkxBTktfTElORSA9IC9eXFxzKyQvXG5jb25zdCBSRUdFWF9SRVBMQUNFX0xFQURJTkdfRVhDQVBFRF9FWENMQU1BVElPTiA9IC9eXFxcXCEvXG5jb25zdCBSRUdFWF9SRVBMQUNFX0xFQURJTkdfRVhDQVBFRF9IQVNIID0gL15cXFxcIy9cbmNvbnN0IFJFR0VYX1NQTElUQUxMX0NSTEYgPSAvXFxyP1xcbi9nXG4vLyAvZm9vLFxuLy8gLi9mb28sXG4vLyAuLi9mb28sXG4vLyAuXG4vLyAuLlxuY29uc3QgUkVHRVhfVEVTVF9JTlZBTElEX1BBVEggPSAvXlxcLipcXC98XlxcLiskL1xuXG5jb25zdCBTTEFTSCA9ICcvJ1xuY29uc3QgS0VZX0lHTk9SRSA9IHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnXG4gID8gU3ltYm9sLmZvcignbm9kZS1pZ25vcmUnKVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICA6ICdub2RlLWlnbm9yZSdcblxuY29uc3QgZGVmaW5lID0gKG9iamVjdCwga2V5LCB2YWx1ZSkgPT5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iamVjdCwga2V5LCB7dmFsdWV9KVxuXG5jb25zdCBSRUdFWF9SRUdFWFBfUkFOR0UgPSAvKFswLXpdKS0oWzAtel0pL2dcblxuLy8gU2FuaXRpemUgdGhlIHJhbmdlIG9mIGEgcmVndWxhciBleHByZXNzaW9uXG4vLyBUaGUgY2FzZXMgYXJlIGNvbXBsaWNhdGVkLCBzZWUgdGVzdCBjYXNlcyBmb3IgZGV0YWlsc1xuY29uc3Qgc2FuaXRpemVSYW5nZSA9IHJhbmdlID0+IHJhbmdlLnJlcGxhY2UoXG4gIFJFR0VYX1JFR0VYUF9SQU5HRSxcbiAgKG1hdGNoLCBmcm9tLCB0bykgPT4gZnJvbS5jaGFyQ29kZUF0KDApIDw9IHRvLmNoYXJDb2RlQXQoMClcbiAgICA/IG1hdGNoXG4gICAgLy8gSW52YWxpZCByYW5nZSAob3V0IG9mIG9yZGVyKSB3aGljaCBpcyBvayBmb3IgZ2l0aWdub3JlIHJ1bGVzIGJ1dFxuICAgIC8vICAgZmF0YWwgZm9yIEphdmFTY3JpcHQgcmVndWxhciBleHByZXNzaW9uLCBzbyBlbGltaW5hdGUgaXQuXG4gICAgOiBFTVBUWVxuKVxuXG4vLyBTZWUgZml4dHVyZXMgIzU5XG5jb25zdCBjbGVhblJhbmdlQmFja1NsYXNoID0gc2xhc2hlcyA9PiB7XG4gIGNvbnN0IHtsZW5ndGh9ID0gc2xhc2hlc1xuICByZXR1cm4gc2xhc2hlcy5zbGljZSgwLCBsZW5ndGggLSBsZW5ndGggJSAyKVxufVxuXG4vLyA+IElmIHRoZSBwYXR0ZXJuIGVuZHMgd2l0aCBhIHNsYXNoLFxuLy8gPiBpdCBpcyByZW1vdmVkIGZvciB0aGUgcHVycG9zZSBvZiB0aGUgZm9sbG93aW5nIGRlc2NyaXB0aW9uLFxuLy8gPiBidXQgaXQgd291bGQgb25seSBmaW5kIGEgbWF0Y2ggd2l0aCBhIGRpcmVjdG9yeS5cbi8vID4gSW4gb3RoZXIgd29yZHMsIGZvby8gd2lsbCBtYXRjaCBhIGRpcmVjdG9yeSBmb28gYW5kIHBhdGhzIHVuZGVybmVhdGggaXQsXG4vLyA+IGJ1dCB3aWxsIG5vdCBtYXRjaCBhIHJlZ3VsYXIgZmlsZSBvciBhIHN5bWJvbGljIGxpbmsgZm9vXG4vLyA+ICAodGhpcyBpcyBjb25zaXN0ZW50IHdpdGggdGhlIHdheSBob3cgcGF0aHNwZWMgd29ya3MgaW4gZ2VuZXJhbCBpbiBHaXQpLlxuLy8gJ2Bmb28vYCcgd2lsbCBub3QgbWF0Y2ggcmVndWxhciBmaWxlICdgZm9vYCcgb3Igc3ltYm9saWMgbGluayAnYGZvb2AnXG4vLyAtPiBpZ25vcmUtcnVsZXMgd2lsbCBub3QgZGVhbCB3aXRoIGl0LCBiZWNhdXNlIGl0IGNvc3RzIGV4dHJhIGBmcy5zdGF0YCBjYWxsXG4vLyAgICAgIHlvdSBjb3VsZCB1c2Ugb3B0aW9uIGBtYXJrOiB0cnVlYCB3aXRoIGBnbG9iYFxuXG4vLyAnYGZvby9gJyBzaG91bGQgbm90IGNvbnRpbnVlIHdpdGggdGhlICdgLi5gJ1xuY29uc3QgUkVQTEFDRVJTID0gW1xuXG4gIC8vID4gVHJhaWxpbmcgc3BhY2VzIGFyZSBpZ25vcmVkIHVubGVzcyB0aGV5IGFyZSBxdW90ZWQgd2l0aCBiYWNrc2xhc2ggKFwiXFxcIilcbiAgW1xuICAgIC8vIChhXFwgKSAtPiAoYSApXG4gICAgLy8gKGEgICkgLT4gKGEpXG4gICAgLy8gKGEgXFwgKSAtPiAoYSAgKVxuICAgIC9cXFxcP1xccyskLyxcbiAgICBtYXRjaCA9PiBtYXRjaC5pbmRleE9mKCdcXFxcJykgPT09IDBcbiAgICAgID8gU1BBQ0VcbiAgICAgIDogRU1QVFlcbiAgXSxcblxuICAvLyByZXBsYWNlIChcXCApIHdpdGggJyAnXG4gIFtcbiAgICAvXFxcXFxccy9nLFxuICAgICgpID0+IFNQQUNFXG4gIF0sXG5cbiAgLy8gRXNjYXBlIG1ldGFjaGFyYWN0ZXJzXG4gIC8vIHdoaWNoIGlzIHdyaXR0ZW4gZG93biBieSB1c2VycyBidXQgbWVhbnMgc3BlY2lhbCBmb3IgcmVndWxhciBleHByZXNzaW9ucy5cblxuICAvLyA+IFRoZXJlIGFyZSAxMiBjaGFyYWN0ZXJzIHdpdGggc3BlY2lhbCBtZWFuaW5nczpcbiAgLy8gPiAtIHRoZSBiYWNrc2xhc2ggXFwsXG4gIC8vID4gLSB0aGUgY2FyZXQgXixcbiAgLy8gPiAtIHRoZSBkb2xsYXIgc2lnbiAkLFxuICAvLyA+IC0gdGhlIHBlcmlvZCBvciBkb3QgLixcbiAgLy8gPiAtIHRoZSB2ZXJ0aWNhbCBiYXIgb3IgcGlwZSBzeW1ib2wgfCxcbiAgLy8gPiAtIHRoZSBxdWVzdGlvbiBtYXJrID8sXG4gIC8vID4gLSB0aGUgYXN0ZXJpc2sgb3Igc3RhciAqLFxuICAvLyA+IC0gdGhlIHBsdXMgc2lnbiArLFxuICAvLyA+IC0gdGhlIG9wZW5pbmcgcGFyZW50aGVzaXMgKCxcbiAgLy8gPiAtIHRoZSBjbG9zaW5nIHBhcmVudGhlc2lzICksXG4gIC8vID4gLSBhbmQgdGhlIG9wZW5pbmcgc3F1YXJlIGJyYWNrZXQgWyxcbiAgLy8gPiAtIHRoZSBvcGVuaW5nIGN1cmx5IGJyYWNlIHssXG4gIC8vID4gVGhlc2Ugc3BlY2lhbCBjaGFyYWN0ZXJzIGFyZSBvZnRlbiBjYWxsZWQgXCJtZXRhY2hhcmFjdGVyc1wiLlxuICBbXG4gICAgL1tcXFxcJC58KisoKXteXS9nLFxuICAgIG1hdGNoID0+IGBcXFxcJHttYXRjaH1gXG4gIF0sXG5cbiAgW1xuICAgIC8vID4gYSBxdWVzdGlvbiBtYXJrICg/KSBtYXRjaGVzIGEgc2luZ2xlIGNoYXJhY3RlclxuICAgIC8oPyFcXFxcKVxcPy9nLFxuICAgICgpID0+ICdbXi9dJ1xuICBdLFxuXG4gIC8vIGxlYWRpbmcgc2xhc2hcbiAgW1xuXG4gICAgLy8gPiBBIGxlYWRpbmcgc2xhc2ggbWF0Y2hlcyB0aGUgYmVnaW5uaW5nIG9mIHRoZSBwYXRobmFtZS5cbiAgICAvLyA+IEZvciBleGFtcGxlLCBcIi8qLmNcIiBtYXRjaGVzIFwiY2F0LWZpbGUuY1wiIGJ1dCBub3QgXCJtb3ppbGxhLXNoYTEvc2hhMS5jXCIuXG4gICAgLy8gQSBsZWFkaW5nIHNsYXNoIG1hdGNoZXMgdGhlIGJlZ2lubmluZyBvZiB0aGUgcGF0aG5hbWVcbiAgICAvXlxcLy8sXG4gICAgKCkgPT4gJ14nXG4gIF0sXG5cbiAgLy8gcmVwbGFjZSBzcGVjaWFsIG1ldGFjaGFyYWN0ZXIgc2xhc2ggYWZ0ZXIgdGhlIGxlYWRpbmcgc2xhc2hcbiAgW1xuICAgIC9cXC8vZyxcbiAgICAoKSA9PiAnXFxcXC8nXG4gIF0sXG5cbiAgW1xuICAgIC8vID4gQSBsZWFkaW5nIFwiKipcIiBmb2xsb3dlZCBieSBhIHNsYXNoIG1lYW5zIG1hdGNoIGluIGFsbCBkaXJlY3Rvcmllcy5cbiAgICAvLyA+IEZvciBleGFtcGxlLCBcIioqL2Zvb1wiIG1hdGNoZXMgZmlsZSBvciBkaXJlY3RvcnkgXCJmb29cIiBhbnl3aGVyZSxcbiAgICAvLyA+IHRoZSBzYW1lIGFzIHBhdHRlcm4gXCJmb29cIi5cbiAgICAvLyA+IFwiKiovZm9vL2JhclwiIG1hdGNoZXMgZmlsZSBvciBkaXJlY3RvcnkgXCJiYXJcIiBhbnl3aGVyZSB0aGF0IGlzIGRpcmVjdGx5XG4gICAgLy8gPiAgIHVuZGVyIGRpcmVjdG9yeSBcImZvb1wiLlxuICAgIC8vIE5vdGljZSB0aGF0IHRoZSAnKidzIGhhdmUgYmVlbiByZXBsYWNlZCBhcyAnXFxcXConXG4gICAgL15cXF4qXFxcXFxcKlxcXFxcXCpcXFxcXFwvLyxcblxuICAgIC8vICcqKi9mb28nIDwtPiAnZm9vJ1xuICAgICgpID0+ICdeKD86LipcXFxcLyk/J1xuICBdLFxuXG4gIC8vIHN0YXJ0aW5nXG4gIFtcbiAgICAvLyB0aGVyZSB3aWxsIGJlIG5vIGxlYWRpbmcgJy8nXG4gICAgLy8gICAod2hpY2ggaGFzIGJlZW4gcmVwbGFjZWQgYnkgc2VjdGlvbiBcImxlYWRpbmcgc2xhc2hcIilcbiAgICAvLyBJZiBzdGFydHMgd2l0aCAnKionLCBhZGRpbmcgYSAnXicgdG8gdGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiBhbHNvIHdvcmtzXG4gICAgL14oPz1bXl5dKS8sXG4gICAgZnVuY3Rpb24gc3RhcnRpbmdSZXBsYWNlciAoKSB7XG4gICAgICAvLyBJZiBoYXMgYSBzbGFzaCBgL2AgYXQgdGhlIGJlZ2lubmluZyBvciBtaWRkbGVcbiAgICAgIHJldHVybiAhL1xcLyg/ISQpLy50ZXN0KHRoaXMpXG4gICAgICAgIC8vID4gUHJpb3IgdG8gMi4yMi4xXG4gICAgICAgIC8vID4gSWYgdGhlIHBhdHRlcm4gZG9lcyBub3QgY29udGFpbiBhIHNsYXNoIC8sXG4gICAgICAgIC8vID4gICBHaXQgdHJlYXRzIGl0IGFzIGEgc2hlbGwgZ2xvYiBwYXR0ZXJuXG4gICAgICAgIC8vIEFjdHVhbGx5LCBpZiB0aGVyZSBpcyBvbmx5IGEgdHJhaWxpbmcgc2xhc2gsXG4gICAgICAgIC8vICAgZ2l0IGFsc28gdHJlYXRzIGl0IGFzIGEgc2hlbGwgZ2xvYiBwYXR0ZXJuXG5cbiAgICAgICAgLy8gQWZ0ZXIgMi4yMi4xIChjb21wYXRpYmxlIGJ1dCBjbGVhcmVyKVxuICAgICAgICAvLyA+IElmIHRoZXJlIGlzIGEgc2VwYXJhdG9yIGF0IHRoZSBiZWdpbm5pbmcgb3IgbWlkZGxlIChvciBib3RoKVxuICAgICAgICAvLyA+IG9mIHRoZSBwYXR0ZXJuLCB0aGVuIHRoZSBwYXR0ZXJuIGlzIHJlbGF0aXZlIHRvIHRoZSBkaXJlY3RvcnlcbiAgICAgICAgLy8gPiBsZXZlbCBvZiB0aGUgcGFydGljdWxhciAuZ2l0aWdub3JlIGZpbGUgaXRzZWxmLlxuICAgICAgICAvLyA+IE90aGVyd2lzZSB0aGUgcGF0dGVybiBtYXkgYWxzbyBtYXRjaCBhdCBhbnkgbGV2ZWwgYmVsb3dcbiAgICAgICAgLy8gPiB0aGUgLmdpdGlnbm9yZSBsZXZlbC5cbiAgICAgICAgPyAnKD86XnxcXFxcLyknXG5cbiAgICAgICAgLy8gPiBPdGhlcndpc2UsIEdpdCB0cmVhdHMgdGhlIHBhdHRlcm4gYXMgYSBzaGVsbCBnbG9iIHN1aXRhYmxlIGZvclxuICAgICAgICAvLyA+ICAgY29uc3VtcHRpb24gYnkgZm5tYXRjaCgzKVxuICAgICAgICA6ICdeJ1xuICAgIH1cbiAgXSxcblxuICAvLyB0d28gZ2xvYnN0YXJzXG4gIFtcbiAgICAvLyBVc2UgbG9va2FoZWFkIGFzc2VydGlvbnMgc28gdGhhdCB3ZSBjb3VsZCBtYXRjaCBtb3JlIHRoYW4gb25lIGAnLyoqJ2BcbiAgICAvXFxcXFxcL1xcXFxcXCpcXFxcXFwqKD89XFxcXFxcL3wkKS9nLFxuXG4gICAgLy8gWmVybywgb25lIG9yIHNldmVyYWwgZGlyZWN0b3JpZXNcbiAgICAvLyBzaG91bGQgbm90IHVzZSAnKicsIG9yIGl0IHdpbGwgYmUgcmVwbGFjZWQgYnkgdGhlIG5leHQgcmVwbGFjZXJcblxuICAgIC8vIENoZWNrIGlmIGl0IGlzIG5vdCB0aGUgbGFzdCBgJy8qKidgXG4gICAgKF8sIGluZGV4LCBzdHIpID0+IGluZGV4ICsgNiA8IHN0ci5sZW5ndGhcblxuICAgICAgLy8gY2FzZTogLyoqL1xuICAgICAgLy8gPiBBIHNsYXNoIGZvbGxvd2VkIGJ5IHR3byBjb25zZWN1dGl2ZSBhc3Rlcmlza3MgdGhlbiBhIHNsYXNoIG1hdGNoZXNcbiAgICAgIC8vID4gICB6ZXJvIG9yIG1vcmUgZGlyZWN0b3JpZXMuXG4gICAgICAvLyA+IEZvciBleGFtcGxlLCBcImEvKiovYlwiIG1hdGNoZXMgXCJhL2JcIiwgXCJhL3gvYlwiLCBcImEveC95L2JcIiBhbmQgc28gb24uXG4gICAgICAvLyAnLyoqLydcbiAgICAgID8gJyg/OlxcXFwvW15cXFxcL10rKSonXG5cbiAgICAgIC8vIGNhc2U6IC8qKlxuICAgICAgLy8gPiBBIHRyYWlsaW5nIGBcIi8qKlwiYCBtYXRjaGVzIGV2ZXJ5dGhpbmcgaW5zaWRlLlxuXG4gICAgICAvLyAjMjE6IGV2ZXJ5dGhpbmcgaW5zaWRlIGJ1dCBpdCBzaG91bGQgbm90IGluY2x1ZGUgdGhlIGN1cnJlbnQgZm9sZGVyXG4gICAgICA6ICdcXFxcLy4rJ1xuICBdLFxuXG4gIC8vIGludGVybWVkaWF0ZSB3aWxkY2FyZHNcbiAgW1xuICAgIC8vIE5ldmVyIHJlcGxhY2UgZXNjYXBlZCAnKidcbiAgICAvLyBpZ25vcmUgcnVsZSAnXFwqJyB3aWxsIG1hdGNoIHRoZSBwYXRoICcqJ1xuXG4gICAgLy8gJ2FiYy4qLycgLT4gZ29cbiAgICAvLyAnYWJjLionICAtPiBza2lwIHRoaXMgcnVsZVxuICAgIC8oXnxbXlxcXFxdKylcXFxcXFwqKD89LispL2csXG5cbiAgICAvLyAnKi5qcycgbWF0Y2hlcyAnLmpzJ1xuICAgIC8vICcqLmpzJyBkb2Vzbid0IG1hdGNoICdhYmMnXG4gICAgKF8sIHAxKSA9PiBgJHtwMX1bXlxcXFwvXSpgXG4gIF0sXG5cbiAgW1xuICAgIC8vIHVuZXNjYXBlLCByZXZlcnQgc3RlcCAzIGV4Y2VwdCBmb3IgYmFjayBzbGFzaFxuICAgIC8vIEZvciBleGFtcGxlLCBpZiBhIHVzZXIgZXNjYXBlIGEgJ1xcXFwqJyxcbiAgICAvLyBhZnRlciBzdGVwIDMsIHRoZSByZXN1bHQgd2lsbCBiZSAnXFxcXFxcXFxcXFxcKidcbiAgICAvXFxcXFxcXFxcXFxcKD89WyQufCorKCl7Xl0pL2csXG4gICAgKCkgPT4gRVNDQVBFXG4gIF0sXG5cbiAgW1xuICAgIC8vICdcXFxcXFxcXCcgLT4gJ1xcXFwnXG4gICAgL1xcXFxcXFxcL2csXG4gICAgKCkgPT4gRVNDQVBFXG4gIF0sXG5cbiAgW1xuICAgIC8vID4gVGhlIHJhbmdlIG5vdGF0aW9uLCBlLmcuIFthLXpBLVpdLFxuICAgIC8vID4gY2FuIGJlIHVzZWQgdG8gbWF0Y2ggb25lIG9mIHRoZSBjaGFyYWN0ZXJzIGluIGEgcmFuZ2UuXG5cbiAgICAvLyBgXFxgIGlzIGVzY2FwZWQgYnkgc3RlcCAzXG4gICAgLyhcXFxcKT9cXFsoW15cXF0vXSo/KShcXFxcKikoJHxcXF0pL2csXG4gICAgKG1hdGNoLCBsZWFkRXNjYXBlLCByYW5nZSwgZW5kRXNjYXBlLCBjbG9zZSkgPT4gbGVhZEVzY2FwZSA9PT0gRVNDQVBFXG4gICAgICAvLyAnXFxcXFtiYXJdJyAtPiAnXFxcXFxcXFxbYmFyXFxcXF0nXG4gICAgICA/IGBcXFxcWyR7cmFuZ2V9JHtjbGVhblJhbmdlQmFja1NsYXNoKGVuZEVzY2FwZSl9JHtjbG9zZX1gXG4gICAgICA6IGNsb3NlID09PSAnXSdcbiAgICAgICAgPyBlbmRFc2NhcGUubGVuZ3RoICUgMiA9PT0gMFxuICAgICAgICAgIC8vIEEgbm9ybWFsIGNhc2UsIGFuZCBpdCBpcyBhIHJhbmdlIG5vdGF0aW9uXG4gICAgICAgICAgLy8gJ1tiYXJdJ1xuICAgICAgICAgIC8vICdbYmFyXFxcXFxcXFxdJ1xuICAgICAgICAgID8gYFske3Nhbml0aXplUmFuZ2UocmFuZ2UpfSR7ZW5kRXNjYXBlfV1gXG4gICAgICAgICAgLy8gSW52YWxpZCByYW5nZSBub3RhdG9uXG4gICAgICAgICAgLy8gJ1tiYXJcXFxcXScgLT4gJ1tiYXJcXFxcXFxcXF0nXG4gICAgICAgICAgOiAnW10nXG4gICAgICAgIDogJ1tdJ1xuICBdLFxuXG4gIC8vIGVuZGluZ1xuICBbXG4gICAgLy8gJ2pzJyB3aWxsIG5vdCBtYXRjaCAnanMuJ1xuICAgIC8vICdhYicgd2lsbCBub3QgbWF0Y2ggJ2FiYydcbiAgICAvKD86W14qXSkkLyxcblxuICAgIC8vIFdURiFcbiAgICAvLyBodHRwczovL2dpdC1zY20uY29tL2RvY3MvZ2l0aWdub3JlXG4gICAgLy8gY2hhbmdlcyBpbiBbMi4yMi4xXShodHRwczovL2dpdC1zY20uY29tL2RvY3MvZ2l0aWdub3JlLzIuMjIuMSlcbiAgICAvLyB3aGljaCByZS1maXhlcyAjMjQsICMzOFxuXG4gICAgLy8gPiBJZiB0aGVyZSBpcyBhIHNlcGFyYXRvciBhdCB0aGUgZW5kIG9mIHRoZSBwYXR0ZXJuIHRoZW4gdGhlIHBhdHRlcm5cbiAgICAvLyA+IHdpbGwgb25seSBtYXRjaCBkaXJlY3Rvcmllcywgb3RoZXJ3aXNlIHRoZSBwYXR0ZXJuIGNhbiBtYXRjaCBib3RoXG4gICAgLy8gPiBmaWxlcyBhbmQgZGlyZWN0b3JpZXMuXG5cbiAgICAvLyAnanMqJyB3aWxsIG5vdCBtYXRjaCAnYS5qcydcbiAgICAvLyAnanMvJyB3aWxsIG5vdCBtYXRjaCAnYS5qcydcbiAgICAvLyAnanMnIHdpbGwgbWF0Y2ggJ2EuanMnIGFuZCAnYS5qcy8nXG4gICAgbWF0Y2ggPT4gL1xcLyQvLnRlc3QobWF0Y2gpXG4gICAgICAvLyBmb28vIHdpbGwgbm90IG1hdGNoICdmb28nXG4gICAgICA/IGAke21hdGNofSRgXG4gICAgICAvLyBmb28gbWF0Y2hlcyAnZm9vJyBhbmQgJ2Zvby8nXG4gICAgICA6IGAke21hdGNofSg/PSR8XFxcXC8kKWBcbiAgXSxcblxuICAvLyB0cmFpbGluZyB3aWxkY2FyZFxuICBbXG4gICAgLyhcXF58XFxcXFxcLyk/XFxcXFxcKiQvLFxuICAgIChfLCBwMSkgPT4ge1xuICAgICAgY29uc3QgcHJlZml4ID0gcDFcbiAgICAgICAgLy8gJ1xcXic6XG4gICAgICAgIC8vICcvKicgZG9lcyBub3QgbWF0Y2ggRU1QVFlcbiAgICAgICAgLy8gJy8qJyBkb2VzIG5vdCBtYXRjaCBldmVyeXRoaW5nXG5cbiAgICAgICAgLy8gJ1xcXFxcXC8nOlxuICAgICAgICAvLyAnYWJjLyonIGRvZXMgbm90IG1hdGNoICdhYmMvJ1xuICAgICAgICA/IGAke3AxfVteL10rYFxuXG4gICAgICAgIC8vICdhKicgbWF0Y2hlcyAnYSdcbiAgICAgICAgLy8gJ2EqJyBtYXRjaGVzICdhYSdcbiAgICAgICAgOiAnW14vXSonXG5cbiAgICAgIHJldHVybiBgJHtwcmVmaXh9KD89JHxcXFxcLyQpYFxuICAgIH1cbiAgXSxcbl1cblxuLy8gQSBzaW1wbGUgY2FjaGUsIGJlY2F1c2UgYW4gaWdub3JlIHJ1bGUgb25seSBoYXMgb25seSBvbmUgY2VydGFpbiBtZWFuaW5nXG5jb25zdCByZWdleENhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKVxuXG4vLyBAcGFyYW0ge3BhdHRlcm59XG5jb25zdCBtYWtlUmVnZXggPSAocGF0dGVybiwgbmVnYXRpdmUsIGlnbm9yZWNhc2UpID0+IHtcbiAgY29uc3QgciA9IHJlZ2V4Q2FjaGVbcGF0dGVybl1cbiAgaWYgKHIpIHtcbiAgICByZXR1cm4gclxuICB9XG5cbiAgLy8gY29uc3QgcmVwbGFjZXJzID0gbmVnYXRpdmVcbiAgLy8gICA/IE5FR0FUSVZFX1JFUExBQ0VSU1xuICAvLyAgIDogUE9TSVRJVkVfUkVQTEFDRVJTXG5cbiAgY29uc3Qgc291cmNlID0gUkVQTEFDRVJTLnJlZHVjZShcbiAgICAocHJldiwgY3VycmVudCkgPT4gcHJldi5yZXBsYWNlKGN1cnJlbnRbMF0sIGN1cnJlbnRbMV0uYmluZChwYXR0ZXJuKSksXG4gICAgcGF0dGVyblxuICApXG5cbiAgcmV0dXJuIHJlZ2V4Q2FjaGVbcGF0dGVybl0gPSBpZ25vcmVjYXNlXG4gICAgPyBuZXcgUmVnRXhwKHNvdXJjZSwgJ2knKVxuICAgIDogbmV3IFJlZ0V4cChzb3VyY2UpXG59XG5cbmNvbnN0IGlzU3RyaW5nID0gc3ViamVjdCA9PiB0eXBlb2Ygc3ViamVjdCA9PT0gJ3N0cmluZydcblxuLy8gPiBBIGJsYW5rIGxpbmUgbWF0Y2hlcyBubyBmaWxlcywgc28gaXQgY2FuIHNlcnZlIGFzIGEgc2VwYXJhdG9yIGZvciByZWFkYWJpbGl0eS5cbmNvbnN0IGNoZWNrUGF0dGVybiA9IHBhdHRlcm4gPT4gcGF0dGVyblxuICAmJiBpc1N0cmluZyhwYXR0ZXJuKVxuICAmJiAhUkVHRVhfVEVTVF9CTEFOS19MSU5FLnRlc3QocGF0dGVybilcblxuICAvLyA+IEEgbGluZSBzdGFydGluZyB3aXRoICMgc2VydmVzIGFzIGEgY29tbWVudC5cbiAgJiYgcGF0dGVybi5pbmRleE9mKCcjJykgIT09IDBcblxuY29uc3Qgc3BsaXRQYXR0ZXJuID0gcGF0dGVybiA9PiBwYXR0ZXJuLnNwbGl0KFJFR0VYX1NQTElUQUxMX0NSTEYpXG5cbmNsYXNzIElnbm9yZVJ1bGUge1xuICBjb25zdHJ1Y3RvciAoXG4gICAgb3JpZ2luLFxuICAgIHBhdHRlcm4sXG4gICAgbmVnYXRpdmUsXG4gICAgcmVnZXhcbiAgKSB7XG4gICAgdGhpcy5vcmlnaW4gPSBvcmlnaW5cbiAgICB0aGlzLnBhdHRlcm4gPSBwYXR0ZXJuXG4gICAgdGhpcy5uZWdhdGl2ZSA9IG5lZ2F0aXZlXG4gICAgdGhpcy5yZWdleCA9IHJlZ2V4XG4gIH1cbn1cblxuY29uc3QgY3JlYXRlUnVsZSA9IChwYXR0ZXJuLCBpZ25vcmVjYXNlKSA9PiB7XG4gIGNvbnN0IG9yaWdpbiA9IHBhdHRlcm5cbiAgbGV0IG5lZ2F0aXZlID0gZmFsc2VcblxuICAvLyA+IEFuIG9wdGlvbmFsIHByZWZpeCBcIiFcIiB3aGljaCBuZWdhdGVzIHRoZSBwYXR0ZXJuO1xuICBpZiAocGF0dGVybi5pbmRleE9mKCchJykgPT09IDApIHtcbiAgICBuZWdhdGl2ZSA9IHRydWVcbiAgICBwYXR0ZXJuID0gcGF0dGVybi5zdWJzdHIoMSlcbiAgfVxuXG4gIHBhdHRlcm4gPSBwYXR0ZXJuXG4gIC8vID4gUHV0IGEgYmFja3NsYXNoIChcIlxcXCIpIGluIGZyb250IG9mIHRoZSBmaXJzdCBcIiFcIiBmb3IgcGF0dGVybnMgdGhhdFxuICAvLyA+ICAgYmVnaW4gd2l0aCBhIGxpdGVyYWwgXCIhXCIsIGZvciBleGFtcGxlLCBgXCJcXCFpbXBvcnRhbnQhLnR4dFwiYC5cbiAgLnJlcGxhY2UoUkVHRVhfUkVQTEFDRV9MRUFESU5HX0VYQ0FQRURfRVhDTEFNQVRJT04sICchJylcbiAgLy8gPiBQdXQgYSBiYWNrc2xhc2ggKFwiXFxcIikgaW4gZnJvbnQgb2YgdGhlIGZpcnN0IGhhc2ggZm9yIHBhdHRlcm5zIHRoYXRcbiAgLy8gPiAgIGJlZ2luIHdpdGggYSBoYXNoLlxuICAucmVwbGFjZShSRUdFWF9SRVBMQUNFX0xFQURJTkdfRVhDQVBFRF9IQVNILCAnIycpXG5cbiAgY29uc3QgcmVnZXggPSBtYWtlUmVnZXgocGF0dGVybiwgbmVnYXRpdmUsIGlnbm9yZWNhc2UpXG5cbiAgcmV0dXJuIG5ldyBJZ25vcmVSdWxlKFxuICAgIG9yaWdpbixcbiAgICBwYXR0ZXJuLFxuICAgIG5lZ2F0aXZlLFxuICAgIHJlZ2V4XG4gIClcbn1cblxuY29uc3QgdGhyb3dFcnJvciA9IChtZXNzYWdlLCBDdG9yKSA9PiB7XG4gIHRocm93IG5ldyBDdG9yKG1lc3NhZ2UpXG59XG5cbmNvbnN0IGNoZWNrUGF0aCA9IChwYXRoLCBvcmlnaW5hbFBhdGgsIGRvVGhyb3cpID0+IHtcbiAgaWYgKCFpc1N0cmluZyhwYXRoKSkge1xuICAgIHJldHVybiBkb1Rocm93KFxuICAgICAgYHBhdGggbXVzdCBiZSBhIHN0cmluZywgYnV0IGdvdCBcXGAke29yaWdpbmFsUGF0aH1cXGBgLFxuICAgICAgVHlwZUVycm9yXG4gICAgKVxuICB9XG5cbiAgLy8gV2UgZG9uJ3Qga25vdyBpZiB3ZSBzaG91bGQgaWdub3JlIEVNUFRZLCBzbyB0aHJvd1xuICBpZiAoIXBhdGgpIHtcbiAgICByZXR1cm4gZG9UaHJvdyhgcGF0aCBtdXN0IG5vdCBiZSBlbXB0eWAsIFR5cGVFcnJvcilcbiAgfVxuXG4gIC8vIENoZWNrIGlmIGl0IGlzIGEgcmVsYXRpdmUgcGF0aFxuICBpZiAoY2hlY2tQYXRoLmlzTm90UmVsYXRpdmUocGF0aCkpIHtcbiAgICBjb25zdCByID0gJ2BwYXRoLnJlbGF0aXZlKClgZCdcbiAgICByZXR1cm4gZG9UaHJvdyhcbiAgICAgIGBwYXRoIHNob3VsZCBiZSBhICR7cn0gc3RyaW5nLCBidXQgZ290IFwiJHtvcmlnaW5hbFBhdGh9XCJgLFxuICAgICAgUmFuZ2VFcnJvclxuICAgIClcbiAgfVxuXG4gIHJldHVybiB0cnVlXG59XG5cbmNvbnN0IGlzTm90UmVsYXRpdmUgPSBwYXRoID0+IFJFR0VYX1RFU1RfSU5WQUxJRF9QQVRILnRlc3QocGF0aClcblxuY2hlY2tQYXRoLmlzTm90UmVsYXRpdmUgPSBpc05vdFJlbGF0aXZlXG5jaGVja1BhdGguY29udmVydCA9IHAgPT4gcFxuXG5jbGFzcyBJZ25vcmUge1xuICBjb25zdHJ1Y3RvciAoe1xuICAgIGlnbm9yZWNhc2UgPSB0cnVlXG4gIH0gPSB7fSkge1xuICAgIHRoaXMuX3J1bGVzID0gW11cbiAgICB0aGlzLl9pZ25vcmVjYXNlID0gaWdub3JlY2FzZVxuICAgIGRlZmluZSh0aGlzLCBLRVlfSUdOT1JFLCB0cnVlKVxuICAgIHRoaXMuX2luaXRDYWNoZSgpXG4gIH1cblxuICBfaW5pdENhY2hlICgpIHtcbiAgICB0aGlzLl9pZ25vcmVDYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbClcbiAgICB0aGlzLl90ZXN0Q2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpXG4gIH1cblxuICBfYWRkUGF0dGVybiAocGF0dGVybikge1xuICAgIC8vICMzMlxuICAgIGlmIChwYXR0ZXJuICYmIHBhdHRlcm5bS0VZX0lHTk9SRV0pIHtcbiAgICAgIHRoaXMuX3J1bGVzID0gdGhpcy5fcnVsZXMuY29uY2F0KHBhdHRlcm4uX3J1bGVzKVxuICAgICAgdGhpcy5fYWRkZWQgPSB0cnVlXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoY2hlY2tQYXR0ZXJuKHBhdHRlcm4pKSB7XG4gICAgICBjb25zdCBydWxlID0gY3JlYXRlUnVsZShwYXR0ZXJuLCB0aGlzLl9pZ25vcmVjYXNlKVxuICAgICAgdGhpcy5fYWRkZWQgPSB0cnVlXG4gICAgICB0aGlzLl9ydWxlcy5wdXNoKHJ1bGUpXG4gICAgfVxuICB9XG5cbiAgLy8gQHBhcmFtIHtBcnJheTxzdHJpbmc+IHwgc3RyaW5nIHwgSWdub3JlfSBwYXR0ZXJuXG4gIGFkZCAocGF0dGVybikge1xuICAgIHRoaXMuX2FkZGVkID0gZmFsc2VcblxuICAgIG1ha2VBcnJheShcbiAgICAgIGlzU3RyaW5nKHBhdHRlcm4pXG4gICAgICAgID8gc3BsaXRQYXR0ZXJuKHBhdHRlcm4pXG4gICAgICAgIDogcGF0dGVyblxuICAgICkuZm9yRWFjaCh0aGlzLl9hZGRQYXR0ZXJuLCB0aGlzKVxuXG4gICAgLy8gU29tZSBydWxlcyBoYXZlIGp1c3QgYWRkZWQgdG8gdGhlIGlnbm9yZSxcbiAgICAvLyBtYWtpbmcgdGhlIGJlaGF2aW9yIGNoYW5nZWQuXG4gICAgaWYgKHRoaXMuX2FkZGVkKSB7XG4gICAgICB0aGlzLl9pbml0Q2FjaGUoKVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvLyBsZWdhY3lcbiAgYWRkUGF0dGVybiAocGF0dGVybikge1xuICAgIHJldHVybiB0aGlzLmFkZChwYXR0ZXJuKVxuICB9XG5cbiAgLy8gICAgICAgICAgfCAgICAgICAgICAgaWdub3JlZCA6IHVuaWdub3JlZFxuICAvLyBuZWdhdGl2ZSB8ICAgMDowICAgfCAgIDA6MSAgIHwgICAxOjAgICB8ICAgMToxXG4gIC8vIC0tLS0tLS0tIHwgLS0tLS0tLSB8IC0tLS0tLS0gfCAtLS0tLS0tIHwgLS0tLS0tLS1cbiAgLy8gICAgIDAgICAgfCAgVEVTVCAgIHwgIFRFU1QgICB8ICBTS0lQICAgfCAgICBYXG4gIC8vICAgICAxICAgIHwgIFRFU1RJRiB8ICBTS0lQICAgfCAgVEVTVCAgIHwgICAgWFxuXG4gIC8vIC0gU0tJUDogYWx3YXlzIHNraXBcbiAgLy8gLSBURVNUOiBhbHdheXMgdGVzdFxuICAvLyAtIFRFU1RJRjogb25seSB0ZXN0IGlmIGNoZWNrVW5pZ25vcmVkXG4gIC8vIC0gWDogdGhhdCBuZXZlciBoYXBwZW5cblxuICAvLyBAcGFyYW0ge2Jvb2xlYW59IHdoZXRoZXIgc2hvdWxkIGNoZWNrIGlmIHRoZSBwYXRoIGlzIHVuaWdub3JlZCxcbiAgLy8gICBzZXR0aW5nIGBjaGVja1VuaWdub3JlZGAgdG8gYGZhbHNlYCBjb3VsZCByZWR1Y2UgYWRkaXRpb25hbFxuICAvLyAgIHBhdGggbWF0Y2hpbmcuXG5cbiAgLy8gQHJldHVybnMge1Rlc3RSZXN1bHR9IHRydWUgaWYgYSBmaWxlIGlzIGlnbm9yZWRcbiAgX3Rlc3RPbmUgKHBhdGgsIGNoZWNrVW5pZ25vcmVkKSB7XG4gICAgbGV0IGlnbm9yZWQgPSBmYWxzZVxuICAgIGxldCB1bmlnbm9yZWQgPSBmYWxzZVxuXG4gICAgdGhpcy5fcnVsZXMuZm9yRWFjaChydWxlID0+IHtcbiAgICAgIGNvbnN0IHtuZWdhdGl2ZX0gPSBydWxlXG4gICAgICBpZiAoXG4gICAgICAgIHVuaWdub3JlZCA9PT0gbmVnYXRpdmUgJiYgaWdub3JlZCAhPT0gdW5pZ25vcmVkXG4gICAgICAgIHx8IG5lZ2F0aXZlICYmICFpZ25vcmVkICYmICF1bmlnbm9yZWQgJiYgIWNoZWNrVW5pZ25vcmVkXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG1hdGNoZWQgPSBydWxlLnJlZ2V4LnRlc3QocGF0aClcblxuICAgICAgaWYgKG1hdGNoZWQpIHtcbiAgICAgICAgaWdub3JlZCA9ICFuZWdhdGl2ZVxuICAgICAgICB1bmlnbm9yZWQgPSBuZWdhdGl2ZVxuICAgICAgfVxuICAgIH0pXG5cbiAgICByZXR1cm4ge1xuICAgICAgaWdub3JlZCxcbiAgICAgIHVuaWdub3JlZFxuICAgIH1cbiAgfVxuXG4gIC8vIEByZXR1cm5zIHtUZXN0UmVzdWx0fVxuICBfdGVzdCAob3JpZ2luYWxQYXRoLCBjYWNoZSwgY2hlY2tVbmlnbm9yZWQsIHNsaWNlcykge1xuICAgIGNvbnN0IHBhdGggPSBvcmlnaW5hbFBhdGhcbiAgICAgIC8vIFN1cHBvcnRzIG51bGxhYmxlIHBhdGhcbiAgICAgICYmIGNoZWNrUGF0aC5jb252ZXJ0KG9yaWdpbmFsUGF0aClcblxuICAgIGNoZWNrUGF0aChwYXRoLCBvcmlnaW5hbFBhdGgsIHRocm93RXJyb3IpXG5cbiAgICByZXR1cm4gdGhpcy5fdChwYXRoLCBjYWNoZSwgY2hlY2tVbmlnbm9yZWQsIHNsaWNlcylcbiAgfVxuXG4gIF90IChwYXRoLCBjYWNoZSwgY2hlY2tVbmlnbm9yZWQsIHNsaWNlcykge1xuICAgIGlmIChwYXRoIGluIGNhY2hlKSB7XG4gICAgICByZXR1cm4gY2FjaGVbcGF0aF1cbiAgICB9XG5cbiAgICBpZiAoIXNsaWNlcykge1xuICAgICAgLy8gcGF0aC90by9hLmpzXG4gICAgICAvLyBbJ3BhdGgnLCAndG8nLCAnYS5qcyddXG4gICAgICBzbGljZXMgPSBwYXRoLnNwbGl0KFNMQVNIKVxuICAgIH1cblxuICAgIHNsaWNlcy5wb3AoKVxuXG4gICAgLy8gSWYgdGhlIHBhdGggaGFzIG5vIHBhcmVudCBkaXJlY3RvcnksIGp1c3QgdGVzdCBpdFxuICAgIGlmICghc2xpY2VzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGNhY2hlW3BhdGhdID0gdGhpcy5fdGVzdE9uZShwYXRoLCBjaGVja1VuaWdub3JlZClcbiAgICB9XG5cbiAgICBjb25zdCBwYXJlbnQgPSB0aGlzLl90KFxuICAgICAgc2xpY2VzLmpvaW4oU0xBU0gpICsgU0xBU0gsXG4gICAgICBjYWNoZSxcbiAgICAgIGNoZWNrVW5pZ25vcmVkLFxuICAgICAgc2xpY2VzXG4gICAgKVxuXG4gICAgLy8gSWYgdGhlIHBhdGggY29udGFpbnMgYSBwYXJlbnQgZGlyZWN0b3J5LCBjaGVjayB0aGUgcGFyZW50IGZpcnN0XG4gICAgcmV0dXJuIGNhY2hlW3BhdGhdID0gcGFyZW50Lmlnbm9yZWRcbiAgICAgIC8vID4gSXQgaXMgbm90IHBvc3NpYmxlIHRvIHJlLWluY2x1ZGUgYSBmaWxlIGlmIGEgcGFyZW50IGRpcmVjdG9yeSBvZlxuICAgICAgLy8gPiAgIHRoYXQgZmlsZSBpcyBleGNsdWRlZC5cbiAgICAgID8gcGFyZW50XG4gICAgICA6IHRoaXMuX3Rlc3RPbmUocGF0aCwgY2hlY2tVbmlnbm9yZWQpXG4gIH1cblxuICBpZ25vcmVzIChwYXRoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Rlc3QocGF0aCwgdGhpcy5faWdub3JlQ2FjaGUsIGZhbHNlKS5pZ25vcmVkXG4gIH1cblxuICBjcmVhdGVGaWx0ZXIgKCkge1xuICAgIHJldHVybiBwYXRoID0+ICF0aGlzLmlnbm9yZXMocGF0aClcbiAgfVxuXG4gIGZpbHRlciAocGF0aHMpIHtcbiAgICByZXR1cm4gbWFrZUFycmF5KHBhdGhzKS5maWx0ZXIodGhpcy5jcmVhdGVGaWx0ZXIoKSlcbiAgfVxuXG4gIC8vIEByZXR1cm5zIHtUZXN0UmVzdWx0fVxuICB0ZXN0IChwYXRoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Rlc3QocGF0aCwgdGhpcy5fdGVzdENhY2hlLCB0cnVlKVxuICB9XG59XG5cbmNvbnN0IGZhY3RvcnkgPSBvcHRpb25zID0+IG5ldyBJZ25vcmUob3B0aW9ucylcblxuY29uc3QgcmV0dXJuRmFsc2UgPSAoKSA9PiBmYWxzZVxuXG5jb25zdCBpc1BhdGhWYWxpZCA9IHBhdGggPT5cbiAgY2hlY2tQYXRoKHBhdGggJiYgY2hlY2tQYXRoLmNvbnZlcnQocGF0aCksIHBhdGgsIHJldHVybkZhbHNlKVxuXG5mYWN0b3J5LmlzUGF0aFZhbGlkID0gaXNQYXRoVmFsaWRcblxuLy8gRml4ZXMgdHlwZXNjcmlwdFxuZmFjdG9yeS5kZWZhdWx0ID0gZmFjdG9yeVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnlcblxuLy8gV2luZG93c1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8qIGlzdGFuYnVsIGlnbm9yZSBpZiAgKi9cbmlmIChcbiAgLy8gRGV0ZWN0IGBwcm9jZXNzYCBzbyB0aGF0IGl0IGNhbiBydW4gaW4gYnJvd3NlcnMuXG4gIHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJ1xuICAmJiAoXG4gICAgcHJvY2Vzcy5lbnYgJiYgcHJvY2Vzcy5lbnYuSUdOT1JFX1RFU1RfV0lOMzJcbiAgICB8fCBwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInXG4gIClcbikge1xuICAvKiBlc2xpbnQgbm8tY29udHJvbC1yZWdleDogXCJvZmZcIiAqL1xuICBjb25zdCBtYWtlUG9zaXggPSBzdHIgPT4gL15cXFxcXFxcXFxcP1xcXFwvLnRlc3Qoc3RyKVxuICB8fCAvW1wiPD58XFx1MDAwMC1cXHUwMDFGXSsvdS50ZXN0KHN0cilcbiAgICA/IHN0clxuICAgIDogc3RyLnJlcGxhY2UoL1xcXFwvZywgJy8nKVxuXG4gIGNoZWNrUGF0aC5jb252ZXJ0ID0gbWFrZVBvc2l4XG5cbiAgLy8gJ0M6XFxcXGZvbycgICAgIDwtICdDOlxcXFxmb28nIGhhcyBiZWVuIGNvbnZlcnRlZCB0byAnQzovJ1xuICAvLyAnZDpcXFxcZm9vJ1xuICBjb25zdCBSRUdJWF9JU19XSU5ET1dTX1BBVEhfQUJTT0xVVEUgPSAvXlthLXpdOlxcLy9pXG4gIGNoZWNrUGF0aC5pc05vdFJlbGF0aXZlID0gcGF0aCA9PlxuICAgIFJFR0lYX0lTX1dJTkRPV1NfUEFUSF9BQlNPTFVURS50ZXN0KHBhdGgpXG4gICAgfHwgaXNOb3RSZWxhdGl2ZShwYXRoKVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBwcm9jZXNzRm4gPSAoZm4sIG9wdGlvbnMpID0+IGZ1bmN0aW9uICguLi5hcmdzKSB7XG5cdGNvbnN0IFAgPSBvcHRpb25zLnByb21pc2VNb2R1bGU7XG5cblx0cmV0dXJuIG5ldyBQKChyZXNvbHZlLCByZWplY3QpID0+IHtcblx0XHRpZiAob3B0aW9ucy5tdWx0aUFyZ3MpIHtcblx0XHRcdGFyZ3MucHVzaCgoLi4ucmVzdWx0KSA9PiB7XG5cdFx0XHRcdGlmIChvcHRpb25zLmVycm9yRmlyc3QpIHtcblx0XHRcdFx0XHRpZiAocmVzdWx0WzBdKSB7XG5cdFx0XHRcdFx0XHRyZWplY3QocmVzdWx0KTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cmVzdWx0LnNoaWZ0KCk7XG5cdFx0XHRcdFx0XHRyZXNvbHZlKHJlc3VsdCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJlc29sdmUocmVzdWx0KTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fSBlbHNlIGlmIChvcHRpb25zLmVycm9yRmlyc3QpIHtcblx0XHRcdGFyZ3MucHVzaCgoZXJyb3IsIHJlc3VsdCkgPT4ge1xuXHRcdFx0XHRpZiAoZXJyb3IpIHtcblx0XHRcdFx0XHRyZWplY3QoZXJyb3IpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJlc29sdmUocmVzdWx0KTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGFyZ3MucHVzaChyZXNvbHZlKTtcblx0XHR9XG5cblx0XHRmbi5hcHBseSh0aGlzLCBhcmdzKTtcblx0fSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IChpbnB1dCwgb3B0aW9ucykgPT4ge1xuXHRvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7XG5cdFx0ZXhjbHVkZTogWy8uKyhTeW5jfFN0cmVhbSkkL10sXG5cdFx0ZXJyb3JGaXJzdDogdHJ1ZSxcblx0XHRwcm9taXNlTW9kdWxlOiBQcm9taXNlXG5cdH0sIG9wdGlvbnMpO1xuXG5cdGNvbnN0IG9ialR5cGUgPSB0eXBlb2YgaW5wdXQ7XG5cdGlmICghKGlucHV0ICE9PSBudWxsICYmIChvYmpUeXBlID09PSAnb2JqZWN0JyB8fCBvYmpUeXBlID09PSAnZnVuY3Rpb24nKSkpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKGBFeHBlY3RlZCBcXGBpbnB1dFxcYCB0byBiZSBhIFxcYEZ1bmN0aW9uXFxgIG9yIFxcYE9iamVjdFxcYCwgZ290IFxcYCR7aW5wdXQgPT09IG51bGwgPyAnbnVsbCcgOiBvYmpUeXBlfVxcYGApO1xuXHR9XG5cblx0Y29uc3QgZmlsdGVyID0ga2V5ID0+IHtcblx0XHRjb25zdCBtYXRjaCA9IHBhdHRlcm4gPT4gdHlwZW9mIHBhdHRlcm4gPT09ICdzdHJpbmcnID8ga2V5ID09PSBwYXR0ZXJuIDogcGF0dGVybi50ZXN0KGtleSk7XG5cdFx0cmV0dXJuIG9wdGlvbnMuaW5jbHVkZSA/IG9wdGlvbnMuaW5jbHVkZS5zb21lKG1hdGNoKSA6ICFvcHRpb25zLmV4Y2x1ZGUuc29tZShtYXRjaCk7XG5cdH07XG5cblx0bGV0IHJldDtcblx0aWYgKG9ialR5cGUgPT09ICdmdW5jdGlvbicpIHtcblx0XHRyZXQgPSBmdW5jdGlvbiAoLi4uYXJncykge1xuXHRcdFx0cmV0dXJuIG9wdGlvbnMuZXhjbHVkZU1haW4gPyBpbnB1dCguLi5hcmdzKSA6IHByb2Nlc3NGbihpbnB1dCwgb3B0aW9ucykuYXBwbHkodGhpcywgYXJncyk7XG5cdFx0fTtcblx0fSBlbHNlIHtcblx0XHRyZXQgPSBPYmplY3QuY3JlYXRlKE9iamVjdC5nZXRQcm90b3R5cGVPZihpbnB1dCkpO1xuXHR9XG5cblx0Zm9yIChjb25zdCBrZXkgaW4gaW5wdXQpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBndWFyZC1mb3ItaW5cblx0XHRjb25zdCBwcm9wZXJ0eSA9IGlucHV0W2tleV07XG5cdFx0cmV0W2tleV0gPSB0eXBlb2YgcHJvcGVydHkgPT09ICdmdW5jdGlvbicgJiYgZmlsdGVyKGtleSkgPyBwcm9jZXNzRm4ocHJvcGVydHksIG9wdGlvbnMpIDogcHJvcGVydHk7XG5cdH1cblxuXHRyZXR1cm4gcmV0O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gZXNjYXBlUmVnRXhwKHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoL1suKis/XiR7fSgpfFtcXF1cXFxcXS9nLCAnXFxcXCQmJyk7IC8vICQmIG1lYW5zIHRoZSB3aG9sZSBtYXRjaGVkIHN0cmluZ1xufVxuXG5mdW5jdGlvbiByZXBsYWNlQWxsKHN0ciwgc2VhcmNoLCByZXBsYWNlbWVudCkge1xuICBzZWFyY2ggPSBzZWFyY2ggaW5zdGFuY2VvZiBSZWdFeHAgPyBzZWFyY2ggOiBuZXcgUmVnRXhwKGVzY2FwZVJlZ0V4cChzZWFyY2gpLCAnZycpO1xuXG4gIHJldHVybiBzdHIucmVwbGFjZShzZWFyY2gsIHJlcGxhY2VtZW50KTtcbn1cblxudmFyIENsZWFuR2l0UmVmID0ge1xuICBjbGVhbjogZnVuY3Rpb24gY2xlYW4odmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBhIHN0cmluZywgcmVjZWl2ZWQ6ICcgKyB2YWx1ZSk7XG4gICAgfVxuXG4gICAgdmFsdWUgPSByZXBsYWNlQWxsKHZhbHVlLCAnLi8nLCAnLycpO1xuICAgIHZhbHVlID0gcmVwbGFjZUFsbCh2YWx1ZSwgJy4uJywgJy4nKTtcbiAgICB2YWx1ZSA9IHJlcGxhY2VBbGwodmFsdWUsICcgJywgJy0nKTtcbiAgICB2YWx1ZSA9IHJlcGxhY2VBbGwodmFsdWUsIC9eW35eOj8qXFxcXFxcLV0vZywgJycpO1xuICAgIHZhbHVlID0gcmVwbGFjZUFsbCh2YWx1ZSwgL1t+Xjo/KlxcXFxdL2csICctJyk7XG4gICAgdmFsdWUgPSByZXBsYWNlQWxsKHZhbHVlLCAvW35eOj8qXFxcXFxcLV0kL2csICcnKTtcbiAgICB2YWx1ZSA9IHJlcGxhY2VBbGwodmFsdWUsICdAeycsICctJyk7XG4gICAgdmFsdWUgPSByZXBsYWNlQWxsKHZhbHVlLCAvXFwuJC9nLCAnJyk7XG4gICAgdmFsdWUgPSByZXBsYWNlQWxsKHZhbHVlLCAvXFwvJC9nLCAnJyk7XG4gICAgdmFsdWUgPSByZXBsYWNlQWxsKHZhbHVlLCAvXFwubG9jayQvZywgJycpO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDbGVhbkdpdFJlZjsiLCIvKlxuICogVVJMOiBodHRwczovL2dpdGh1Yi5jb20vY3ViaWNkYWl5YS9vbnBcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMgVGF0c3VoaWtvIEt1Ym8gPGN1YmljZGFpeWFAZ21haWwuY29tPlxuICpcbiAqICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiAgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqICB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiAgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiAgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqICBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqICBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqICBUSEUgU09GVFdBUkUuXG4gKi9cblxuLyoqXG4gKiBUaGUgYWxnb3JpdGhtIGltcGxlbWVudGVkIGhlcmUgaXMgYmFzZWQgb24gXCJBbiBPKE5QKSBTZXF1ZW5jZSBDb21wYXJpc29uIEFsZ29yaXRobVwiXG4gKiBieSBkZXNjcmliZWQgYnkgU3VuIFd1LCBVZGkgTWFuYmVyIGFuZCBHZW5lIE15ZXJzXG4qL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYV8sIGJfKSB7XG4gICAgdmFyIGEgICAgICAgICAgPSBhXyxcbiAgICAgICAgYiAgICAgICAgICA9IGJfLFxuICAgICAgICBtICAgICAgICAgID0gYS5sZW5ndGgsXG4gICAgICAgIG4gICAgICAgICAgPSBiLmxlbmd0aCxcbiAgICAgICAgcmV2ZXJzZSAgICA9IGZhbHNlLFxuICAgICAgICBlZCAgICAgICAgID0gbnVsbCxcbiAgICAgICAgb2Zmc2V0ICAgICA9IG0gKyAxLFxuICAgICAgICBwYXRoICAgICAgID0gW10sXG4gICAgICAgIHBhdGhwb3NpICAgPSBbXSxcbiAgICAgICAgc2VzICAgICAgICA9IFtdLFxuICAgICAgICBsY3MgICAgICAgID0gXCJcIixcbiAgICAgICAgU0VTX0RFTEVURSA9IC0xLFxuICAgICAgICBTRVNfQ09NTU9OID0gMCxcbiAgICAgICAgU0VTX0FERCAgICA9IDE7XG5cbiAgICB2YXIgdG1wMSxcbiAgICAgICAgdG1wMjtcblxuICAgIHZhciBpbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAobSA+PSBuKSB7XG4gICAgICAgICAgICB0bXAxICAgID0gYTtcbiAgICAgICAgICAgIHRtcDIgICAgPSBtO1xuICAgICAgICAgICAgYSAgICAgICA9IGI7XG4gICAgICAgICAgICBiICAgICAgID0gdG1wMTtcbiAgICAgICAgICAgIG0gICAgICAgPSBuO1xuICAgICAgICAgICAgbiAgICAgICA9IHRtcDI7XG4gICAgICAgICAgICByZXZlcnNlID0gdHJ1ZTtcbiAgICAgICAgICAgIG9mZnNldCA9IG0gKyAxO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBQID0gZnVuY3Rpb24gKHgsIHksIGspIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICd4JyA6IHgsXG4gICAgICAgICAgICAneScgOiB5LFxuICAgICAgICAgICAgJ2snIDogayxcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIHNlc2VsZW0gPSBmdW5jdGlvbiAoZWxlbSwgdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2VsZW0nIDogZWxlbSxcbiAgICAgICAgICAgICd0JyAgICA6IHQsXG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBzbmFrZSA9IGZ1bmN0aW9uIChrLCBwLCBwcCkge1xuICAgICAgICB2YXIgciwgeCwgeTtcbiAgICAgICAgaWYgKHAgPiBwcCkge1xuICAgICAgICAgICAgciA9IHBhdGhbay0xK29mZnNldF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByID0gcGF0aFtrKzErb2Zmc2V0XTtcbiAgICAgICAgfVxuXG4gICAgICAgIHkgPSBNYXRoLm1heChwLCBwcCk7XG4gICAgICAgIHggPSB5IC0gaztcbiAgICAgICAgd2hpbGUgKHggPCBtICYmIHkgPCBuICYmIGFbeF0gPT09IGJbeV0pIHtcbiAgICAgICAgICAgICsreDtcbiAgICAgICAgICAgICsreTtcbiAgICAgICAgfVxuXG4gICAgICAgIHBhdGhbaytvZmZzZXRdID0gcGF0aHBvc2kubGVuZ3RoO1xuICAgICAgICBwYXRocG9zaVtwYXRocG9zaS5sZW5ndGhdID0gbmV3IFAoeCwgeSwgcik7XG4gICAgICAgIHJldHVybiB5O1xuICAgIH07XG5cbiAgICB2YXIgcmVjb3Jkc2VxID0gZnVuY3Rpb24gKGVwYykge1xuICAgICAgICB2YXIgeF9pZHgsIHlfaWR4LCBweF9pZHgsIHB5X2lkeCwgaTtcbiAgICAgICAgeF9pZHggID0geV9pZHggID0gMTtcbiAgICAgICAgcHhfaWR4ID0gcHlfaWR4ID0gMDtcbiAgICAgICAgZm9yIChpPWVwYy5sZW5ndGgtMTtpPj0wOy0taSkge1xuICAgICAgICAgICAgd2hpbGUocHhfaWR4IDwgZXBjW2ldLnggfHwgcHlfaWR4IDwgZXBjW2ldLnkpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXBjW2ldLnkgLSBlcGNbaV0ueCA+IHB5X2lkeCAtIHB4X2lkeCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmV2ZXJzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VzW3Nlcy5sZW5ndGhdID0gbmV3IHNlc2VsZW0oYltweV9pZHhdLCBTRVNfREVMRVRFKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlc1tzZXMubGVuZ3RoXSA9IG5ldyBzZXNlbGVtKGJbcHlfaWR4XSwgU0VTX0FERCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgKyt5X2lkeDtcbiAgICAgICAgICAgICAgICAgICAgKytweV9pZHg7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChlcGNbaV0ueSAtIGVwY1tpXS54IDwgcHlfaWR4IC0gcHhfaWR4KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXZlcnNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXNbc2VzLmxlbmd0aF0gPSBuZXcgc2VzZWxlbShhW3B4X2lkeF0sIFNFU19BREQpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VzW3Nlcy5sZW5ndGhdID0gbmV3IHNlc2VsZW0oYVtweF9pZHhdLCBTRVNfREVMRVRFKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICArK3hfaWR4O1xuICAgICAgICAgICAgICAgICAgICArK3B4X2lkeDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzZXNbc2VzLmxlbmd0aF0gPSBuZXcgc2VzZWxlbShhW3B4X2lkeF0sIFNFU19DT01NT04pO1xuICAgICAgICAgICAgICAgICAgICBsY3MgKz0gYVtweF9pZHhdO1xuICAgICAgICAgICAgICAgICAgICArK3hfaWR4O1xuICAgICAgICAgICAgICAgICAgICArK3lfaWR4O1xuICAgICAgICAgICAgICAgICAgICArK3B4X2lkeDtcbiAgICAgICAgICAgICAgICAgICAgKytweV9pZHg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIGluaXQoKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIFNFU19ERUxFVEUgOiAtMSxcbiAgICAgICAgU0VTX0NPTU1PTiA6ICAwLFxuICAgICAgICBTRVNfQUREICAgIDogIDEsXG4gICAgICAgIGVkaXRkaXN0YW5jZSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBlZDtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0bGNzIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGxjcztcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0c2VzIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHNlcztcbiAgICAgICAgfSxcbiAgICAgICAgY29tcG9zZSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBkZWx0YSwgc2l6ZSwgZnAsIHAsIHIsIGVwYywgaSwgaztcbiAgICAgICAgICAgIGRlbHRhICA9IG4gLSBtO1xuICAgICAgICAgICAgc2l6ZSAgID0gbSArIG4gKyAzO1xuICAgICAgICAgICAgZnAgICAgID0ge307XG4gICAgICAgICAgICBmb3IgKGk9MDtpPHNpemU7KytpKSB7XG4gICAgICAgICAgICAgICAgZnBbaV0gPSAtMTtcbiAgICAgICAgICAgICAgICBwYXRoW2ldID0gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwID0gLTE7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgKytwO1xuICAgICAgICAgICAgICAgIGZvciAoaz0tcDtrPD1kZWx0YS0xOysraykge1xuICAgICAgICAgICAgICAgICAgICBmcFtrK29mZnNldF0gPSBzbmFrZShrLCBmcFtrLTErb2Zmc2V0XSsxLCBmcFtrKzErb2Zmc2V0XSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAoaz1kZWx0YStwO2s+PWRlbHRhKzE7LS1rKSB7XG4gICAgICAgICAgICAgICAgICAgIGZwW2srb2Zmc2V0XSA9IHNuYWtlKGssIGZwW2stMStvZmZzZXRdKzEsIGZwW2srMStvZmZzZXRdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZnBbZGVsdGErb2Zmc2V0XSA9IHNuYWtlKGRlbHRhLCBmcFtkZWx0YS0xK29mZnNldF0rMSwgZnBbZGVsdGErMStvZmZzZXRdKTtcbiAgICAgICAgICAgIH0gd2hpbGUgKGZwW2RlbHRhK29mZnNldF0gIT09IG4pO1xuXG4gICAgICAgICAgICBlZCA9IGRlbHRhICsgMiAqIHA7XG5cbiAgICAgICAgICAgIHIgPSBwYXRoW2RlbHRhK29mZnNldF07XG5cbiAgICAgICAgICAgIGVwYyAgPSBbXTtcbiAgICAgICAgICAgIHdoaWxlIChyICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIGVwY1tlcGMubGVuZ3RoXSA9IG5ldyBQKHBhdGhwb3NpW3JdLngsIHBhdGhwb3NpW3JdLnksIG51bGwpO1xuICAgICAgICAgICAgICAgIHIgPSBwYXRocG9zaVtyXS5rO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVjb3Jkc2VxKGVwYyk7XG4gICAgICAgIH1cbiAgICB9O1xufTtcbiIsIi8vIENvcHlyaWdodCAoYykgMjAwNiwgMjAwOCBUb255IEdhcm5vY2stSm9uZXMgPHRvbnlnQGxzaGlmdC5uZXQ+XG4vLyBDb3B5cmlnaHQgKGMpIDIwMDYsIDIwMDggTFNoaWZ0IEx0ZC4gPHF1ZXJ5QGxzaGlmdC5uZXQ+XG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbi8vIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzXG4vLyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sXG4vLyBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLFxuLy8gcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSxcbi8vIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sXG4vLyBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuLy8gaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbi8vIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbi8vIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlNcbi8vIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuLy8gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU5cbi8vIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbi8vIFNPRlRXQVJFLlxuXG52YXIgb25wID0gcmVxdWlyZSgnLi9vbnAnKTtcblxuZnVuY3Rpb24gbG9uZ2VzdENvbW1vblN1YnNlcXVlbmNlKGZpbGUxLCBmaWxlMikge1xuICB2YXIgZGlmZiA9IG5ldyBvbnAoZmlsZTEsIGZpbGUyKTtcbiAgZGlmZi5jb21wb3NlKCk7XG4gIHZhciBzZXMgPSBkaWZmLmdldHNlcygpO1xuXG4gIHZhciByb290O1xuICB2YXIgcHJldjtcbiAgdmFyIGZpbGUxUmV2SWR4ID0gZmlsZTEubGVuZ3RoIC0gMSxcbiAgICAgIGZpbGUyUmV2SWR4ID0gZmlsZTIubGVuZ3RoIC0gMTtcbiAgZm9yICh2YXIgaSA9IHNlcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgaWYgKHNlc1tpXS50ID09PSBkaWZmLlNFU19DT01NT04pIHtcbiAgICAgICAgaWYgKHByZXYpIHtcbiAgICAgICAgICBwcmV2LmNoYWluID0ge1xuICAgICAgICAgICAgZmlsZTFpbmRleDogZmlsZTFSZXZJZHgsXG4gICAgICAgICAgICBmaWxlMmluZGV4OiBmaWxlMlJldklkeCxcbiAgICAgICAgICAgIGNoYWluOiBudWxsXG4gICAgICAgICAgfTtcbiAgICAgICAgICBwcmV2ID0gcHJldi5jaGFpbjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByb290ID0ge1xuICAgICAgICAgICAgZmlsZTFpbmRleDogZmlsZTFSZXZJZHgsXG4gICAgICAgICAgICBmaWxlMmluZGV4OiBmaWxlMlJldklkeCxcbiAgICAgICAgICAgIGNoYWluOiBudWxsXG4gICAgICAgICAgfTtcbiAgICAgICAgICBwcmV2ID0gcm9vdDtcbiAgICAgICAgfVxuICAgICAgICBmaWxlMVJldklkeC0tO1xuICAgICAgICBmaWxlMlJldklkeC0tO1xuICAgICAgfSBlbHNlIGlmIChzZXNbaV0udCA9PT0gZGlmZi5TRVNfREVMRVRFKSB7XG4gICAgICAgIGZpbGUxUmV2SWR4LS07XG4gICAgICB9IGVsc2UgaWYgKHNlc1tpXS50ID09PSBkaWZmLlNFU19BREQpIHtcbiAgICAgICAgZmlsZTJSZXZJZHgtLTtcbiAgICAgIH1cbiAgfVxuXG4gIHZhciB0YWlsID0ge1xuICAgIGZpbGUxaW5kZXg6IC0xLFxuICAgIGZpbGUyaW5kZXg6IC0xLFxuICAgIGNoYWluOiBudWxsXG4gIH07XG5cbiAgaWYgKCFwcmV2KSB7XG4gICAgcmV0dXJuIHRhaWw7XG4gIH1cblxuICBwcmV2LmNoYWluID0gdGFpbDtcblxuICByZXR1cm4gcm9vdDtcbn1cblxuZnVuY3Rpb24gZGlmZkluZGljZXMoZmlsZTEsIGZpbGUyKSB7XG4gIC8vIFdlIGFwcGx5IHRoZSBMQ1MgdG8gZ2l2ZSBhIHNpbXBsZSByZXByZXNlbnRhdGlvbiBvZiB0aGVcbiAgLy8gb2Zmc2V0cyBhbmQgbGVuZ3RocyBvZiBtaXNtYXRjaGVkIGNodW5rcyBpbiB0aGUgaW5wdXRcbiAgLy8gZmlsZXMuIFRoaXMgaXMgdXNlZCBieSBkaWZmM19tZXJnZV9pbmRpY2VzIGJlbG93LlxuXG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIHRhaWwxID0gZmlsZTEubGVuZ3RoO1xuICB2YXIgdGFpbDIgPSBmaWxlMi5sZW5ndGg7XG5cbiAgZm9yICh2YXIgY2FuZGlkYXRlID0gbG9uZ2VzdENvbW1vblN1YnNlcXVlbmNlKGZpbGUxLCBmaWxlMik7IGNhbmRpZGF0ZSAhPT0gbnVsbDsgY2FuZGlkYXRlID0gY2FuZGlkYXRlLmNoYWluKSB7XG4gICAgdmFyIG1pc21hdGNoTGVuZ3RoMSA9IHRhaWwxIC0gY2FuZGlkYXRlLmZpbGUxaW5kZXggLSAxO1xuICAgIHZhciBtaXNtYXRjaExlbmd0aDIgPSB0YWlsMiAtIGNhbmRpZGF0ZS5maWxlMmluZGV4IC0gMTtcbiAgICB0YWlsMSA9IGNhbmRpZGF0ZS5maWxlMWluZGV4O1xuICAgIHRhaWwyID0gY2FuZGlkYXRlLmZpbGUyaW5kZXg7XG5cbiAgICBpZiAobWlzbWF0Y2hMZW5ndGgxIHx8IG1pc21hdGNoTGVuZ3RoMikge1xuICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICBmaWxlMTogW3RhaWwxICsgMSwgbWlzbWF0Y2hMZW5ndGgxXSxcbiAgICAgICAgZmlsZTI6IFt0YWlsMiArIDEsIG1pc21hdGNoTGVuZ3RoMl1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHJlc3VsdC5yZXZlcnNlKCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGRpZmYzTWVyZ2VJbmRpY2VzKGEsIG8sIGIpIHtcbiAgLy8gR2l2ZW4gdGhyZWUgZmlsZXMsIEEsIE8sIGFuZCBCLCB3aGVyZSBib3RoIEEgYW5kIEIgYXJlXG4gIC8vIGluZGVwZW5kZW50bHkgZGVyaXZlZCBmcm9tIE8sIHJldHVybnMgYSBmYWlybHkgY29tcGxpY2F0ZWRcbiAgLy8gaW50ZXJuYWwgcmVwcmVzZW50YXRpb24gb2YgbWVyZ2UgZGVjaXNpb25zIGl0J3MgdGFrZW4uIFRoZVxuICAvLyBpbnRlcmVzdGVkIHJlYWRlciBtYXkgd2lzaCB0byBjb25zdWx0XG4gIC8vXG4gIC8vIFNhbmplZXYgS2hhbm5hLCBLZXNoYXYgS3VuYWwsIGFuZCBCZW5qYW1pbiBDLiBQaWVyY2UuIFwiQVxuICAvLyBGb3JtYWwgSW52ZXN0aWdhdGlvbiBvZiBEaWZmMy5cIiBJbiBBcnZpbmQgYW5kIFByYXNhZCxcbiAgLy8gZWRpdG9ycywgRm91bmRhdGlvbnMgb2YgU29mdHdhcmUgVGVjaG5vbG9neSBhbmQgVGhlb3JldGljYWxcbiAgLy8gQ29tcHV0ZXIgU2NpZW5jZSAoRlNUVENTKSwgRGVjZW1iZXIgMjAwNy5cbiAgLy9cbiAgLy8gKGh0dHA6Ly93d3cuY2lzLnVwZW5uLmVkdS9+YmNwaWVyY2UvcGFwZXJzL2RpZmYzLXNob3J0LnBkZilcbiAgdmFyIGk7XG5cbiAgdmFyIG0xID0gZGlmZkluZGljZXMobywgYSk7XG4gIHZhciBtMiA9IGRpZmZJbmRpY2VzKG8sIGIpO1xuXG4gIHZhciBodW5rcyA9IFtdO1xuXG4gIGZ1bmN0aW9uIGFkZEh1bmsoaCwgc2lkZSkge1xuICAgIGh1bmtzLnB1c2goW2guZmlsZTFbMF0sIHNpZGUsIGguZmlsZTFbMV0sIGguZmlsZTJbMF0sIGguZmlsZTJbMV1dKTtcbiAgfVxuICBmb3IgKGkgPSAwOyBpIDwgbTEubGVuZ3RoOyBpKyspIHtcbiAgICBhZGRIdW5rKG0xW2ldLCAwKTtcbiAgfVxuICBmb3IgKGkgPSAwOyBpIDwgbTIubGVuZ3RoOyBpKyspIHtcbiAgICBhZGRIdW5rKG0yW2ldLCAyKTtcbiAgfVxuICBodW5rcy5zb3J0KGZ1bmN0aW9uKHgsIHkpIHtcbiAgICByZXR1cm4geFswXSAtIHlbMF1cbiAgfSk7XG5cbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIgY29tbW9uT2Zmc2V0ID0gMDtcblxuICBmdW5jdGlvbiBjb3B5Q29tbW9uKHRhcmdldE9mZnNldCkge1xuICAgIGlmICh0YXJnZXRPZmZzZXQgPiBjb21tb25PZmZzZXQpIHtcbiAgICAgIHJlc3VsdC5wdXNoKFsxLCBjb21tb25PZmZzZXQsIHRhcmdldE9mZnNldCAtIGNvbW1vbk9mZnNldF0pO1xuICAgICAgY29tbW9uT2Zmc2V0ID0gdGFyZ2V0T2Zmc2V0O1xuICAgIH1cbiAgfVxuXG4gIGZvciAodmFyIGh1bmtJbmRleCA9IDA7IGh1bmtJbmRleCA8IGh1bmtzLmxlbmd0aDsgaHVua0luZGV4KyspIHtcbiAgICB2YXIgZmlyc3RIdW5rSW5kZXggPSBodW5rSW5kZXg7XG4gICAgdmFyIGh1bmsgPSBodW5rc1todW5rSW5kZXhdO1xuICAgIHZhciByZWdpb25MaHMgPSBodW5rWzBdO1xuICAgIHZhciByZWdpb25SaHMgPSByZWdpb25MaHMgKyBodW5rWzJdO1xuICAgIHdoaWxlIChodW5rSW5kZXggPCBodW5rcy5sZW5ndGggLSAxKSB7XG4gICAgICB2YXIgbWF5YmVPdmVybGFwcGluZyA9IGh1bmtzW2h1bmtJbmRleCArIDFdO1xuICAgICAgdmFyIG1heWJlTGhzID0gbWF5YmVPdmVybGFwcGluZ1swXTtcbiAgICAgIGlmIChtYXliZUxocyA+IHJlZ2lvblJocykgYnJlYWs7XG4gICAgICByZWdpb25SaHMgPSBNYXRoLm1heChyZWdpb25SaHMsIG1heWJlTGhzICsgbWF5YmVPdmVybGFwcGluZ1syXSk7XG4gICAgICBodW5rSW5kZXgrKztcbiAgICB9XG5cbiAgICBjb3B5Q29tbW9uKHJlZ2lvbkxocyk7XG4gICAgaWYgKGZpcnN0SHVua0luZGV4ID09IGh1bmtJbmRleCkge1xuICAgICAgLy8gVGhlIFwib3ZlcmxhcFwiIHdhcyBvbmx5IG9uZSBodW5rIGxvbmcsIG1lYW5pbmcgdGhhdFxuICAgICAgLy8gdGhlcmUncyBubyBjb25mbGljdCBoZXJlLiBFaXRoZXIgYSBhbmQgbyB3ZXJlIHRoZVxuICAgICAgLy8gc2FtZSwgb3IgYiBhbmQgbyB3ZXJlIHRoZSBzYW1lLlxuICAgICAgaWYgKGh1bmtbNF0gPiAwKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKFtodW5rWzFdLCBodW5rWzNdLCBodW5rWzRdXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEEgcHJvcGVyIGNvbmZsaWN0LiBEZXRlcm1pbmUgdGhlIGV4dGVudHMgb2YgdGhlXG4gICAgICAvLyByZWdpb25zIGludm9sdmVkIGZyb20gYSwgbyBhbmQgYi4gRWZmZWN0aXZlbHkgbWVyZ2VcbiAgICAgIC8vIGFsbCB0aGUgaHVua3Mgb24gdGhlIGxlZnQgaW50byBvbmUgZ2lhbnQgaHVuaywgYW5kXG4gICAgICAvLyBkbyB0aGUgc2FtZSBmb3IgdGhlIHJpZ2h0OyB0aGVuLCBjb3JyZWN0IGZvciBza2V3XG4gICAgICAvLyBpbiB0aGUgcmVnaW9ucyBvZiBvIHRoYXQgZWFjaCBzaWRlIGNoYW5nZWQsIGFuZFxuICAgICAgLy8gcmVwb3J0IGFwcHJvcHJpYXRlIHNwYW5zIGZvciB0aGUgdGhyZWUgc2lkZXMuXG4gICAgICB2YXIgcmVnaW9ucyA9IHtcbiAgICAgICAgMDogW2EubGVuZ3RoLCAtMSwgby5sZW5ndGgsIC0xXSxcbiAgICAgICAgMjogW2IubGVuZ3RoLCAtMSwgby5sZW5ndGgsIC0xXVxuICAgICAgfTtcbiAgICAgIGZvciAoaSA9IGZpcnN0SHVua0luZGV4OyBpIDw9IGh1bmtJbmRleDsgaSsrKSB7XG4gICAgICAgIGh1bmsgPSBodW5rc1tpXTtcbiAgICAgICAgdmFyIHNpZGUgPSBodW5rWzFdO1xuICAgICAgICB2YXIgciA9IHJlZ2lvbnNbc2lkZV07XG4gICAgICAgIHZhciBvTGhzID0gaHVua1swXTtcbiAgICAgICAgdmFyIG9SaHMgPSBvTGhzICsgaHVua1syXTtcbiAgICAgICAgdmFyIGFiTGhzID0gaHVua1szXTtcbiAgICAgICAgdmFyIGFiUmhzID0gYWJMaHMgKyBodW5rWzRdO1xuICAgICAgICByWzBdID0gTWF0aC5taW4oYWJMaHMsIHJbMF0pO1xuICAgICAgICByWzFdID0gTWF0aC5tYXgoYWJSaHMsIHJbMV0pO1xuICAgICAgICByWzJdID0gTWF0aC5taW4ob0xocywgclsyXSk7XG4gICAgICAgIHJbM10gPSBNYXRoLm1heChvUmhzLCByWzNdKTtcbiAgICAgIH1cbiAgICAgIHZhciBhTGhzID0gcmVnaW9uc1swXVswXSArIChyZWdpb25MaHMgLSByZWdpb25zWzBdWzJdKTtcbiAgICAgIHZhciBhUmhzID0gcmVnaW9uc1swXVsxXSArIChyZWdpb25SaHMgLSByZWdpb25zWzBdWzNdKTtcbiAgICAgIHZhciBiTGhzID0gcmVnaW9uc1syXVswXSArIChyZWdpb25MaHMgLSByZWdpb25zWzJdWzJdKTtcbiAgICAgIHZhciBiUmhzID0gcmVnaW9uc1syXVsxXSArIChyZWdpb25SaHMgLSByZWdpb25zWzJdWzNdKTtcbiAgICAgIHJlc3VsdC5wdXNoKFstMSxcbiAgICAgICAgYUxocywgYVJocyAtIGFMaHMsXG4gICAgICAgIHJlZ2lvbkxocywgcmVnaW9uUmhzIC0gcmVnaW9uTGhzLFxuICAgICAgICBiTGhzLCBiUmhzIC0gYkxoc1xuICAgICAgXSk7XG4gICAgfVxuICAgIGNvbW1vbk9mZnNldCA9IHJlZ2lvblJocztcbiAgfVxuXG4gIGNvcHlDb21tb24oby5sZW5ndGgpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBkaWZmM01lcmdlKGEsIG8sIGIpIHtcbiAgLy8gQXBwbGllcyB0aGUgb3V0cHV0IG9mIERpZmYuZGlmZjNfbWVyZ2VfaW5kaWNlcyB0byBhY3R1YWxseVxuICAvLyBjb25zdHJ1Y3QgdGhlIG1lcmdlZCBmaWxlOyB0aGUgcmV0dXJuZWQgcmVzdWx0IGFsdGVybmF0ZXNcbiAgLy8gYmV0d2VlbiBcIm9rXCIgYW5kIFwiY29uZmxpY3RcIiBibG9ja3MuXG5cbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIgZmlsZXMgPSBbYSwgbywgYl07XG4gIHZhciBpbmRpY2VzID0gZGlmZjNNZXJnZUluZGljZXMoYSwgbywgYik7XG5cbiAgdmFyIG9rTGluZXMgPSBbXTtcblxuICBmdW5jdGlvbiBmbHVzaE9rKCkge1xuICAgIGlmIChva0xpbmVzLmxlbmd0aCkge1xuICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICBvazogb2tMaW5lc1xuICAgICAgfSk7XG4gICAgfVxuICAgIG9rTGluZXMgPSBbXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHB1c2hPayh4cykge1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgeHMubGVuZ3RoOyBqKyspIHtcbiAgICAgIG9rTGluZXMucHVzaCh4c1tqXSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaXNUcnVlQ29uZmxpY3QocmVjKSB7XG4gICAgaWYgKHJlY1syXSAhPSByZWNbNl0pIHJldHVybiB0cnVlO1xuICAgIHZhciBhb2ZmID0gcmVjWzFdO1xuICAgIHZhciBib2ZmID0gcmVjWzVdO1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgcmVjWzJdOyBqKyspIHtcbiAgICAgIGlmIChhW2ogKyBhb2ZmXSAhPSBiW2ogKyBib2ZmXSkgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaW5kaWNlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciB4ID0gaW5kaWNlc1tpXTtcbiAgICB2YXIgc2lkZSA9IHhbMF07XG4gICAgaWYgKHNpZGUgPT0gLTEpIHtcbiAgICAgIGlmICghaXNUcnVlQ29uZmxpY3QoeCkpIHtcbiAgICAgICAgcHVzaE9rKGZpbGVzWzBdLnNsaWNlKHhbMV0sIHhbMV0gKyB4WzJdKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmbHVzaE9rKCk7XG4gICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICBjb25mbGljdDoge1xuICAgICAgICAgICAgYTogYS5zbGljZSh4WzFdLCB4WzFdICsgeFsyXSksXG4gICAgICAgICAgICBhSW5kZXg6IHhbMV0sXG4gICAgICAgICAgICBvOiBvLnNsaWNlKHhbM10sIHhbM10gKyB4WzRdKSxcbiAgICAgICAgICAgIG9JbmRleDogeFszXSxcbiAgICAgICAgICAgIGI6IGIuc2xpY2UoeFs1XSwgeFs1XSArIHhbNl0pLFxuICAgICAgICAgICAgYkluZGV4OiB4WzVdXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcHVzaE9rKGZpbGVzW3NpZGVdLnNsaWNlKHhbMV0sIHhbMV0gKyB4WzJdKSk7XG4gICAgfVxuICB9XG5cbiAgZmx1c2hPaygpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGRpZmYzTWVyZ2U7XG4iLCJpbXBvcnQgQXN5bmNMb2NrIGZyb20gJ2FzeW5jLWxvY2snO1xuaW1wb3J0IEhhc2ggZnJvbSAnc2hhLmpzL3NoYTEuanMnO1xuaW1wb3J0IGNyYzMyIGZyb20gJ2NyYy0zMic7XG5pbXBvcnQgcGFrbyBmcm9tICdwYWtvJztcbmltcG9ydCBpZ25vcmUgZnJvbSAnaWdub3JlJztcbmltcG9ydCBwaWZ5IGZyb20gJ3BpZnknO1xuaW1wb3J0IGNsZWFuR2l0UmVmIGZyb20gJ2NsZWFuLWdpdC1yZWYnO1xuaW1wb3J0IGRpZmYzTWVyZ2UgZnJvbSAnZGlmZjMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEdpdFByb2dyZXNzRXZlbnRcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBwaGFzZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IGxvYWRlZFxuICogQHByb3BlcnR5IHtudW1iZXJ9IHRvdGFsXG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgUHJvZ3Jlc3NDYWxsYmFja1xuICogQHBhcmFtIHtHaXRQcm9ncmVzc0V2ZW50fSBwcm9ncmVzc1xuICogQHJldHVybnMge3ZvaWQgfCBQcm9taXNlPHZvaWQ+fVxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gR2l0SHR0cFJlcXVlc3RcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB1cmwgLSBUaGUgVVJMIHRvIHJlcXVlc3RcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbbWV0aG9kPSdHRVQnXSAtIFRoZSBIVFRQIG1ldGhvZCB0byB1c2VcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0PHN0cmluZywgc3RyaW5nPn0gW2hlYWRlcnM9e31dIC0gSGVhZGVycyB0byBpbmNsdWRlIGluIHRoZSBIVFRQIHJlcXVlc3RcbiAqIEBwcm9wZXJ0eSB7QXN5bmNJdGVyYWJsZUl0ZXJhdG9yPFVpbnQ4QXJyYXk+fSBbYm9keV0gLSBBbiBhc3luYyBpdGVyYXRvciBvZiBVaW50OEFycmF5cyB0aGF0IG1ha2UgdXAgdGhlIGJvZHkgb2YgUE9TVCByZXF1ZXN0c1xuICogQHByb3BlcnR5IHtQcm9ncmVzc0NhbGxiYWNrfSBbb25Qcm9ncmVzc10gLSBSZXNlcnZlZCBmb3IgZnV0dXJlIHVzZSAoZW1pdHRpbmcgYEdpdFByb2dyZXNzRXZlbnRgcylcbiAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBbc2lnbmFsXSAtIFJlc2VydmVkIGZvciBmdXR1cmUgdXNlIChjYW5jZWxpbmcgYSByZXF1ZXN0KVxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gR2l0SHR0cFJlc3BvbnNlXG4gKiBAcHJvcGVydHkge3N0cmluZ30gdXJsIC0gVGhlIGZpbmFsIFVSTCB0aGF0IHdhcyBmZXRjaGVkIGFmdGVyIGFueSByZWRpcmVjdHNcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbbWV0aG9kXSAtIFRoZSBIVFRQIG1ldGhvZCB0aGF0IHdhcyB1c2VkXG4gKiBAcHJvcGVydHkge09iamVjdDxzdHJpbmcsIHN0cmluZz59IFtoZWFkZXJzXSAtIEhUVFAgcmVzcG9uc2UgaGVhZGVyc1xuICogQHByb3BlcnR5IHtBc3luY0l0ZXJhYmxlSXRlcmF0b3I8VWludDhBcnJheT59IFtib2R5XSAtIEFuIGFzeW5jIGl0ZXJhdG9yIG9mIFVpbnQ4QXJyYXlzIHRoYXQgbWFrZSB1cCB0aGUgYm9keSBvZiB0aGUgcmVzcG9uc2VcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzdGF0dXNDb2RlIC0gVGhlIEhUVFAgc3RhdHVzIGNvZGVcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzdGF0dXNNZXNzYWdlIC0gVGhlIEhUVFAgc3RhdHVzIG1lc3NhZ2VcbiAqL1xuXG4vKipcbiAqIEBjYWxsYmFjayBIdHRwRmV0Y2hcbiAqIEBwYXJhbSB7R2l0SHR0cFJlcXVlc3R9IHJlcXVlc3RcbiAqIEByZXR1cm5zIHtQcm9taXNlPEdpdEh0dHBSZXNwb25zZT59XG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBIdHRwQ2xpZW50XG4gKiBAcHJvcGVydHkge0h0dHBGZXRjaH0gcmVxdWVzdFxuICovXG5cbi8qKlxuICogQSBnaXQgY29tbWl0IG9iamVjdC5cbiAqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBDb21taXRPYmplY3RcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBtZXNzYWdlIENvbW1pdCBtZXNzYWdlXG4gKiBAcHJvcGVydHkge3N0cmluZ30gdHJlZSBTSEEtMSBvYmplY3QgaWQgb2YgY29ycmVzcG9uZGluZyBmaWxlIHRyZWVcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nW119IHBhcmVudCBhbiBhcnJheSBvZiB6ZXJvIG9yIG1vcmUgU0hBLTEgb2JqZWN0IGlkc1xuICogQHByb3BlcnR5IHtPYmplY3R9IGF1dGhvclxuICogQHByb3BlcnR5IHtzdHJpbmd9IGF1dGhvci5uYW1lIFRoZSBhdXRob3IncyBuYW1lXG4gKiBAcHJvcGVydHkge3N0cmluZ30gYXV0aG9yLmVtYWlsIFRoZSBhdXRob3IncyBlbWFpbFxuICogQHByb3BlcnR5IHtudW1iZXJ9IGF1dGhvci50aW1lc3RhbXAgVVRDIFVuaXggdGltZXN0YW1wIGluIHNlY29uZHNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBhdXRob3IudGltZXpvbmVPZmZzZXQgVGltZXpvbmUgZGlmZmVyZW5jZSBmcm9tIFVUQyBpbiBtaW51dGVzXG4gKiBAcHJvcGVydHkge09iamVjdH0gY29tbWl0dGVyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gY29tbWl0dGVyLm5hbWUgVGhlIGNvbW1pdHRlcidzIG5hbWVcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBjb21taXR0ZXIuZW1haWwgVGhlIGNvbW1pdHRlcidzIGVtYWlsXG4gKiBAcHJvcGVydHkge251bWJlcn0gY29tbWl0dGVyLnRpbWVzdGFtcCBVVEMgVW5peCB0aW1lc3RhbXAgaW4gc2Vjb25kc1xuICogQHByb3BlcnR5IHtudW1iZXJ9IGNvbW1pdHRlci50aW1lem9uZU9mZnNldCBUaW1lem9uZSBkaWZmZXJlbmNlIGZyb20gVVRDIGluIG1pbnV0ZXNcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbZ3Bnc2lnXSBQR1Agc2lnbmF0dXJlIChpZiBwcmVzZW50KVxuICovXG5cbi8qKlxuICogQW4gZW50cnkgZnJvbSBhIGdpdCB0cmVlIG9iamVjdC4gRmlsZXMgYXJlIGNhbGxlZCAnYmxvYnMnIGFuZCBkaXJlY3RvcmllcyBhcmUgY2FsbGVkICd0cmVlcycuXG4gKlxuICogQHR5cGVkZWYge09iamVjdH0gVHJlZUVudHJ5XG4gKiBAcHJvcGVydHkge3N0cmluZ30gbW9kZSB0aGUgNiBkaWdpdCBoZXhhZGVjaW1hbCBtb2RlXG4gKiBAcHJvcGVydHkge3N0cmluZ30gcGF0aCB0aGUgbmFtZSBvZiB0aGUgZmlsZSBvciBkaXJlY3RvcnlcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBvaWQgdGhlIFNIQS0xIG9iamVjdCBpZCBvZiB0aGUgYmxvYiBvciB0cmVlXG4gKiBAcHJvcGVydHkgeydjb21taXQnfCdibG9iJ3wndHJlZSd9IHR5cGUgdGhlIHR5cGUgb2Ygb2JqZWN0XG4gKi9cblxuLyoqXG4gKiBBIGdpdCB0cmVlIG9iamVjdC4gVHJlZXMgcmVwcmVzZW50IGEgZGlyZWN0b3J5IHNuYXBzaG90LlxuICpcbiAqIEB0eXBlZGVmIHtUcmVlRW50cnlbXX0gVHJlZU9iamVjdFxuICovXG5cbi8qKlxuICogQSBnaXQgYW5ub3RhdGVkIHRhZyBvYmplY3QuXG4gKlxuICogQHR5cGVkZWYge09iamVjdH0gVGFnT2JqZWN0XG4gKiBAcHJvcGVydHkge3N0cmluZ30gb2JqZWN0IFNIQS0xIG9iamVjdCBpZCBvZiBvYmplY3QgYmVpbmcgdGFnZ2VkXG4gKiBAcHJvcGVydHkgeydibG9iJyB8ICd0cmVlJyB8ICdjb21taXQnIHwgJ3RhZyd9IHR5cGUgdGhlIHR5cGUgb2YgdGhlIG9iamVjdCBiZWluZyB0YWdnZWRcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB0YWcgdGhlIHRhZyBuYW1lXG4gKiBAcHJvcGVydHkge09iamVjdH0gdGFnZ2VyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gdGFnZ2VyLm5hbWUgdGhlIHRhZ2dlcidzIG5hbWVcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB0YWdnZXIuZW1haWwgdGhlIHRhZ2dlcidzIGVtYWlsXG4gKiBAcHJvcGVydHkge251bWJlcn0gdGFnZ2VyLnRpbWVzdGFtcCBVVEMgVW5peCB0aW1lc3RhbXAgaW4gc2Vjb25kc1xuICogQHByb3BlcnR5IHtudW1iZXJ9IHRhZ2dlci50aW1lem9uZU9mZnNldCB0aW1lem9uZSBkaWZmZXJlbmNlIGZyb20gVVRDIGluIG1pbnV0ZXNcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBtZXNzYWdlIHRhZyBtZXNzYWdlXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2dwZ3NpZ10gUEdQIHNpZ25hdHVyZSAoaWYgcHJlc2VudClcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFJlYWRDb21taXRSZXN1bHRcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBvaWQgLSBTSEEtMSBvYmplY3QgaWQgb2YgdGhpcyBjb21taXRcbiAqIEBwcm9wZXJ0eSB7Q29tbWl0T2JqZWN0fSBjb21taXQgLSB0aGUgcGFyc2VkIGNvbW1pdCBvYmplY3RcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBwYXlsb2FkIC0gUEdQIHNpZ25pbmcgcGF5bG9hZFxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gU2VydmVyUmVmIC0gVGhpcyBvYmplY3QgaGFzIHRoZSBmb2xsb3dpbmcgc2NoZW1hOlxuICogQHByb3BlcnR5IHtzdHJpbmd9IHJlZiAtIFRoZSBuYW1lIG9mIHRoZSByZWZcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBvaWQgLSBUaGUgU0hBLTEgb2JqZWN0IGlkIHRoZSByZWYgcG9pbnRzIHRvXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW3RhcmdldF0gLSBUaGUgdGFyZ2V0IHJlZiBwb2ludGVkIHRvIGJ5IGEgc3ltYm9saWMgcmVmXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW3BlZWxlZF0gLSBJZiB0aGUgb2lkIGlzIHRoZSBTSEEtMSBvYmplY3QgaWQgb2YgYW4gYW5ub3RhdGVkIHRhZywgdGhpcyBpcyB0aGUgU0hBLTEgb2JqZWN0IGlkIHRoYXQgdGhlIGFubm90YXRlZCB0YWcgcG9pbnRzIHRvXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiBXYWxrZXJcbiAqIEBwcm9wZXJ0eSB7U3ltYm9sfSBTeW1ib2woJ0dpdFdhbGtlclN5bWJvbCcpXG4gKi9cblxuLyoqXG4gKiBOb3JtYWxpemVkIHN1YnNldCBvZiBmaWxlc3lzdGVtIGBzdGF0YCBkYXRhOlxuICpcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFN0YXRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjdGltZVNlY29uZHNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjdGltZU5hbm9zZWNvbmRzXG4gKiBAcHJvcGVydHkge251bWJlcn0gbXRpbWVTZWNvbmRzXG4gKiBAcHJvcGVydHkge251bWJlcn0gbXRpbWVOYW5vc2Vjb25kc1xuICogQHByb3BlcnR5IHtudW1iZXJ9IGRldlxuICogQHByb3BlcnR5IHtudW1iZXJ9IGlub1xuICogQHByb3BlcnR5IHtudW1iZXJ9IG1vZGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB1aWRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBnaWRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzaXplXG4gKi9cblxuLyoqXG4gKiBUaGUgYFdhbGtlckVudHJ5YCBpcyBhbiBpbnRlcmZhY2UgdGhhdCBhYnN0cmFjdHMgY29tcHV0aW5nIG1hbnkgY29tbW9uIHRyZWUgLyBibG9iIHN0YXRzLlxuICpcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFdhbGtlckVudHJ5XG4gKiBAcHJvcGVydHkge2Z1bmN0aW9uKCk6IFByb21pc2U8J3RyZWUnfCdibG9iJ3wnc3BlY2lhbCd8J2NvbW1pdCc+fSB0eXBlXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9uKCk6IFByb21pc2U8bnVtYmVyPn0gbW9kZVxuICogQHByb3BlcnR5IHtmdW5jdGlvbigpOiBQcm9taXNlPHN0cmluZz59IG9pZFxuICogQHByb3BlcnR5IHtmdW5jdGlvbigpOiBQcm9taXNlPFVpbnQ4QXJyYXl8dm9pZD59IGNvbnRlbnRcbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb24oKTogUHJvbWlzZTxTdGF0Pn0gc3RhdFxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gQ2FsbGJhY2tGc0NsaWVudFxuICogQHByb3BlcnR5IHtmdW5jdGlvbn0gcmVhZEZpbGUgLSBodHRwczovL25vZGVqcy5vcmcvYXBpL2ZzLmh0bWwjZnNfZnNfcmVhZGZpbGVfcGF0aF9vcHRpb25zX2NhbGxiYWNrXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9ufSB3cml0ZUZpbGUgLSBodHRwczovL25vZGVqcy5vcmcvYXBpL2ZzLmh0bWwjZnNfZnNfd3JpdGVmaWxlX2ZpbGVfZGF0YV9vcHRpb25zX2NhbGxiYWNrXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9ufSB1bmxpbmsgLSBodHRwczovL25vZGVqcy5vcmcvYXBpL2ZzLmh0bWwjZnNfZnNfdW5saW5rX3BhdGhfY2FsbGJhY2tcbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IHJlYWRkaXIgLSBodHRwczovL25vZGVqcy5vcmcvYXBpL2ZzLmh0bWwjZnNfZnNfcmVhZGRpcl9wYXRoX29wdGlvbnNfY2FsbGJhY2tcbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IG1rZGlyIC0gaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9mcy5odG1sI2ZzX2ZzX21rZGlyX3BhdGhfbW9kZV9jYWxsYmFja1xuICogQHByb3BlcnR5IHtmdW5jdGlvbn0gcm1kaXIgLSBodHRwczovL25vZGVqcy5vcmcvYXBpL2ZzLmh0bWwjZnNfZnNfcm1kaXJfcGF0aF9jYWxsYmFja1xuICogQHByb3BlcnR5IHtmdW5jdGlvbn0gc3RhdCAtIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvZnMuaHRtbCNmc19mc19zdGF0X3BhdGhfb3B0aW9uc19jYWxsYmFja1xuICogQHByb3BlcnR5IHtmdW5jdGlvbn0gbHN0YXQgLSBodHRwczovL25vZGVqcy5vcmcvYXBpL2ZzLmh0bWwjZnNfZnNfbHN0YXRfcGF0aF9vcHRpb25zX2NhbGxiYWNrXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBbcmVhZGxpbmtdIC0gaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9mcy5odG1sI2ZzX2ZzX3JlYWRsaW5rX3BhdGhfb3B0aW9uc19jYWxsYmFja1xuICogQHByb3BlcnR5IHtmdW5jdGlvbn0gW3N5bWxpbmtdIC0gaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9mcy5odG1sI2ZzX2ZzX3N5bWxpbmtfdGFyZ2V0X3BhdGhfdHlwZV9jYWxsYmFja1xuICogQHByb3BlcnR5IHtmdW5jdGlvbn0gW2NobW9kXSAtIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvZnMuaHRtbCNmc19mc19jaG1vZF9wYXRoX21vZGVfY2FsbGJhY2tcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFByb21pc2VGc0NsaWVudFxuICogQHByb3BlcnR5IHtPYmplY3R9IHByb21pc2VzXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBwcm9taXNlcy5yZWFkRmlsZSAtIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvZnMuaHRtbCNmc19mc3Byb21pc2VzX3JlYWRmaWxlX3BhdGhfb3B0aW9uc1xuICogQHByb3BlcnR5IHtmdW5jdGlvbn0gcHJvbWlzZXMud3JpdGVGaWxlIC0gaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9mcy5odG1sI2ZzX2ZzcHJvbWlzZXNfd3JpdGVmaWxlX2ZpbGVfZGF0YV9vcHRpb25zXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBwcm9taXNlcy51bmxpbmsgLSBodHRwczovL25vZGVqcy5vcmcvYXBpL2ZzLmh0bWwjZnNfZnNwcm9taXNlc191bmxpbmtfcGF0aFxuICogQHByb3BlcnR5IHtmdW5jdGlvbn0gcHJvbWlzZXMucmVhZGRpciAtIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvZnMuaHRtbCNmc19mc3Byb21pc2VzX3JlYWRkaXJfcGF0aF9vcHRpb25zXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBwcm9taXNlcy5ta2RpciAtIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvZnMuaHRtbCNmc19mc3Byb21pc2VzX21rZGlyX3BhdGhfb3B0aW9uc1xuICogQHByb3BlcnR5IHtmdW5jdGlvbn0gcHJvbWlzZXMucm1kaXIgLSBodHRwczovL25vZGVqcy5vcmcvYXBpL2ZzLmh0bWwjZnNfZnNwcm9taXNlc19ybWRpcl9wYXRoXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBwcm9taXNlcy5zdGF0IC0gaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9mcy5odG1sI2ZzX2ZzcHJvbWlzZXNfc3RhdF9wYXRoX29wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IHByb21pc2VzLmxzdGF0IC0gaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9mcy5odG1sI2ZzX2ZzcHJvbWlzZXNfbHN0YXRfcGF0aF9vcHRpb25zXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBbcHJvbWlzZXMucmVhZGxpbmtdIC0gaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9mcy5odG1sI2ZzX2ZzcHJvbWlzZXNfcmVhZGxpbmtfcGF0aF9vcHRpb25zXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBbcHJvbWlzZXMuc3ltbGlua10gLSBodHRwczovL25vZGVqcy5vcmcvYXBpL2ZzLmh0bWwjZnNfZnNwcm9taXNlc19zeW1saW5rX3RhcmdldF9wYXRoX3R5cGVcbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IFtwcm9taXNlcy5jaG1vZF0gLSBodHRwczovL25vZGVqcy5vcmcvYXBpL2ZzLmh0bWwjZnNfZnNwcm9taXNlc19jaG1vZF9wYXRoX21vZGVcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtDYWxsYmFja0ZzQ2xpZW50IHwgUHJvbWlzZUZzQ2xpZW50fSBGc0NsaWVudFxuICovXG5cbi8qKlxuICogQGNhbGxiYWNrIE1lc3NhZ2VDYWxsYmFja1xuICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2VcbiAqIEByZXR1cm5zIHt2b2lkIHwgUHJvbWlzZTx2b2lkPn1cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEdpdEF1dGhcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbdXNlcm5hbWVdXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW3Bhc3N3b3JkXVxuICogQHByb3BlcnR5IHtPYmplY3Q8c3RyaW5nLCBzdHJpbmc+fSBbaGVhZGVyc11cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2NhbmNlbF0gVGVsbHMgZ2l0IHRvIHRocm93IGEgYFVzZXJDYW5jZWxlZEVycm9yYCAoaW5zdGVhZCBvZiBhbiBgSHR0cEVycm9yYCkuXG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgQXV0aENhbGxiYWNrXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsXG4gKiBAcGFyYW0ge0dpdEF1dGh9IGF1dGggTWlnaHQgaGF2ZSBzb21lIHZhbHVlcyBpZiB0aGUgVVJMIGl0c2VsZiBvcmlnaW5hbGx5IGNvbnRhaW5lZCBhIHVzZXJuYW1lIG9yIHBhc3N3b3JkLlxuICogQHJldHVybnMge0dpdEF1dGggfCB2b2lkIHwgUHJvbWlzZTxHaXRBdXRoIHwgdm9pZD59XG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgQXV0aEZhaWx1cmVDYWxsYmFja1xuICogQHBhcmFtIHtzdHJpbmd9IHVybFxuICogQHBhcmFtIHtHaXRBdXRofSBhdXRoIFRoZSBjcmVkZW50aWFscyB0aGF0IGZhaWxlZFxuICogQHJldHVybnMge0dpdEF1dGggfCB2b2lkIHwgUHJvbWlzZTxHaXRBdXRoIHwgdm9pZD59XG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgQXV0aFN1Y2Nlc3NDYWxsYmFja1xuICogQHBhcmFtIHtzdHJpbmd9IHVybFxuICogQHBhcmFtIHtHaXRBdXRofSBhdXRoXG4gKiBAcmV0dXJucyB7dm9pZCB8IFByb21pc2U8dm9pZD59XG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBTaWduUGFyYW1zXG4gKiBAcHJvcGVydHkge3N0cmluZ30gcGF5bG9hZCAtIGEgcGxhaW50ZXh0IG1lc3NhZ2VcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzZWNyZXRLZXkgLSBhbiAnQVNDSUkgYXJtb3InIGVuY29kZWQgUEdQIGtleSAodGVjaG5pY2FsbHkgY2FuIGFjdHVhbGx5IGNvbnRhaW4gX211bHRpcGxlXyBrZXlzKVxuICovXG5cbi8qKlxuICogQGNhbGxiYWNrIFNpZ25DYWxsYmFja1xuICogQHBhcmFtIHtTaWduUGFyYW1zfSBhcmdzXG4gKiBAcmV0dXJuIHt7c2lnbmF0dXJlOiBzdHJpbmd9IHwgUHJvbWlzZTx7c2lnbmF0dXJlOiBzdHJpbmd9Pn0gLSBhbiAnQVNDSUkgYXJtb3InIGVuY29kZWQgXCJkZXRhY2hlZFwiIHNpZ25hdHVyZVxuICovXG5cbi8qKlxuICogQGNhbGxiYWNrIFdhbGtlck1hcFxuICogQHBhcmFtIHtzdHJpbmd9IGZpbGVuYW1lXG4gKiBAcGFyYW0ge1dhbGtlckVudHJ5W119IGVudHJpZXNcbiAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59XG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgV2Fsa2VyUmVkdWNlXG4gKiBAcGFyYW0ge2FueX0gcGFyZW50XG4gKiBAcGFyYW0ge2FueVtdfSBjaGlsZHJlblxuICogQHJldHVybnMge1Byb21pc2U8YW55Pn1cbiAqL1xuXG4vKipcbiAqIEBjYWxsYmFjayBXYWxrZXJJdGVyYXRlQ2FsbGJhY2tcbiAqIEBwYXJhbSB7V2Fsa2VyRW50cnlbXX0gZW50cmllc1xuICogQHJldHVybnMge1Byb21pc2U8YW55W10+fVxuICovXG5cbi8qKlxuICogQGNhbGxiYWNrIFdhbGtlckl0ZXJhdGVcbiAqIEBwYXJhbSB7V2Fsa2VySXRlcmF0ZUNhbGxiYWNrfSB3YWxrXG4gKiBAcGFyYW0ge0l0ZXJhYmxlSXRlcmF0b3I8V2Fsa2VyRW50cnlbXT59IGNoaWxkcmVuXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxhbnlbXT59XG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBSZWZVcGRhdGVTdGF0dXNcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gb2tcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBlcnJvclxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gUHVzaFJlc3VsdFxuICogQHByb3BlcnR5IHtib29sZWFufSBva1xuICogQHByb3BlcnR5IHs/c3RyaW5nfSBlcnJvclxuICogQHByb3BlcnR5IHtPYmplY3Q8c3RyaW5nLCBSZWZVcGRhdGVTdGF0dXM+fSByZWZzXG4gKiBAcHJvcGVydHkge09iamVjdDxzdHJpbmcsIHN0cmluZz59IFtoZWFkZXJzXVxuICovXG5cbi8qKlxuICogQHR5cGVkZWYgezB8MX0gSGVhZFN0YXR1c1xuICovXG5cbi8qKlxuICogQHR5cGVkZWYgezB8MXwyfSBXb3JrZGlyU3RhdHVzXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7MHwxfDJ8M30gU3RhZ2VTdGF0dXNcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtbc3RyaW5nLCBIZWFkU3RhdHVzLCBXb3JrZGlyU3RhdHVzLCBTdGFnZVN0YXR1c119IFN0YXR1c1Jvd1xuICovXG5cbmNsYXNzIEJhc2VFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIC8vIFNldHRpbmcgdGhpcyBoZXJlIGFsbG93cyBUUyB0byBpbmZlciB0aGF0IGFsbCBnaXQgZXJyb3JzIGhhdmUgYSBgY2FsbGVyYCBwcm9wZXJ0eSBhbmRcbiAgICAvLyB0aGF0IGl0cyB0eXBlIGlzIHN0cmluZy5cbiAgICB0aGlzLmNhbGxlciA9ICcnO1xuICB9XG5cbiAgdG9KU09OKCkge1xuICAgIC8vIEVycm9yIG9iamVjdHMgYXJlbid0IG5vcm1hbGx5IHNlcmlhbGl6YWJsZS4gU28gd2UgZG8gc29tZXRoaW5nIGFib3V0IHRoYXQuXG4gICAgcmV0dXJuIHtcbiAgICAgIGNvZGU6IHRoaXMuY29kZSxcbiAgICAgIGRhdGE6IHRoaXMuZGF0YSxcbiAgICAgIGNhbGxlcjogdGhpcy5jYWxsZXIsXG4gICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2UsXG4gICAgICBzdGFjazogdGhpcy5zdGFjayxcbiAgICB9XG4gIH1cblxuICBmcm9tSlNPTihqc29uKSB7XG4gICAgY29uc3QgZSA9IG5ldyBCYXNlRXJyb3IoanNvbi5tZXNzYWdlKTtcbiAgICBlLmNvZGUgPSBqc29uLmNvZGU7XG4gICAgZS5kYXRhID0ganNvbi5kYXRhO1xuICAgIGUuY2FsbGVyID0ganNvbi5jYWxsZXI7XG4gICAgZS5zdGFjayA9IGpzb24uc3RhY2s7XG4gICAgcmV0dXJuIGVcbiAgfVxuXG4gIGdldCBpc0lzb21vcnBoaWNHaXRFcnJvcigpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG59XG5cbmNsYXNzIEludGVybmFsRXJyb3IgZXh0ZW5kcyBCYXNlRXJyb3Ige1xuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2VcbiAgICovXG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICBzdXBlcihcbiAgICAgIGBBbiBpbnRlcm5hbCBlcnJvciBjYXVzZWQgdGhpcyBjb21tYW5kIHRvIGZhaWwuIFBsZWFzZSBmaWxlIGEgYnVnIHJlcG9ydCBhdCBodHRwczovL2dpdGh1Yi5jb20vaXNvbW9ycGhpYy1naXQvaXNvbW9ycGhpYy1naXQvaXNzdWVzIHdpdGggdGhpcyBlcnJvciBtZXNzYWdlOiAke21lc3NhZ2V9YFxuICAgICk7XG4gICAgdGhpcy5jb2RlID0gdGhpcy5uYW1lID0gSW50ZXJuYWxFcnJvci5jb2RlO1xuICAgIHRoaXMuZGF0YSA9IHsgbWVzc2FnZSB9O1xuICB9XG59XG4vKiogQHR5cGUgeydJbnRlcm5hbEVycm9yJ30gKi9cbkludGVybmFsRXJyb3IuY29kZSA9ICdJbnRlcm5hbEVycm9yJztcblxuLy8gTW9kZWxlZCBhZnRlciBodHRwczovL2dpdGh1Yi5jb20vdGpmb250YWluZS9ub2RlLWJ1ZmZlcmN1cnNvclxuLy8gYnV0IHdpdGggdGhlIGdvYWwgb2YgYmVpbmcgbXVjaCBsaWdodGVyIHdlaWdodC5cbmNsYXNzIEJ1ZmZlckN1cnNvciB7XG4gIGNvbnN0cnVjdG9yKGJ1ZmZlcikge1xuICAgIHRoaXMuYnVmZmVyID0gYnVmZmVyO1xuICAgIHRoaXMuX3N0YXJ0ID0gMDtcbiAgfVxuXG4gIGVvZigpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhcnQgPj0gdGhpcy5idWZmZXIubGVuZ3RoXG4gIH1cblxuICB0ZWxsKCkge1xuICAgIHJldHVybiB0aGlzLl9zdGFydFxuICB9XG5cbiAgc2VlayhuKSB7XG4gICAgdGhpcy5fc3RhcnQgPSBuO1xuICB9XG5cbiAgc2xpY2Uobikge1xuICAgIGNvbnN0IHIgPSB0aGlzLmJ1ZmZlci5zbGljZSh0aGlzLl9zdGFydCwgdGhpcy5fc3RhcnQgKyBuKTtcbiAgICB0aGlzLl9zdGFydCArPSBuO1xuICAgIHJldHVybiByXG4gIH1cblxuICB0b1N0cmluZyhlbmMsIGxlbmd0aCkge1xuICAgIGNvbnN0IHIgPSB0aGlzLmJ1ZmZlci50b1N0cmluZyhlbmMsIHRoaXMuX3N0YXJ0LCB0aGlzLl9zdGFydCArIGxlbmd0aCk7XG4gICAgdGhpcy5fc3RhcnQgKz0gbGVuZ3RoO1xuICAgIHJldHVybiByXG4gIH1cblxuICB3cml0ZSh2YWx1ZSwgbGVuZ3RoLCBlbmMpIHtcbiAgICBjb25zdCByID0gdGhpcy5idWZmZXIud3JpdGUodmFsdWUsIHRoaXMuX3N0YXJ0LCBsZW5ndGgsIGVuYyk7XG4gICAgdGhpcy5fc3RhcnQgKz0gbGVuZ3RoO1xuICAgIHJldHVybiByXG4gIH1cblxuICBjb3B5KHNvdXJjZSwgc3RhcnQsIGVuZCkge1xuICAgIGNvbnN0IHIgPSBzb3VyY2UuY29weSh0aGlzLmJ1ZmZlciwgdGhpcy5fc3RhcnQsIHN0YXJ0LCBlbmQpO1xuICAgIHRoaXMuX3N0YXJ0ICs9IHI7XG4gICAgcmV0dXJuIHJcbiAgfVxuXG4gIHJlYWRVSW50OCgpIHtcbiAgICBjb25zdCByID0gdGhpcy5idWZmZXIucmVhZFVJbnQ4KHRoaXMuX3N0YXJ0KTtcbiAgICB0aGlzLl9zdGFydCArPSAxO1xuICAgIHJldHVybiByXG4gIH1cblxuICB3cml0ZVVJbnQ4KHZhbHVlKSB7XG4gICAgY29uc3QgciA9IHRoaXMuYnVmZmVyLndyaXRlVUludDgodmFsdWUsIHRoaXMuX3N0YXJ0KTtcbiAgICB0aGlzLl9zdGFydCArPSAxO1xuICAgIHJldHVybiByXG4gIH1cblxuICByZWFkVUludDE2QkUoKSB7XG4gICAgY29uc3QgciA9IHRoaXMuYnVmZmVyLnJlYWRVSW50MTZCRSh0aGlzLl9zdGFydCk7XG4gICAgdGhpcy5fc3RhcnQgKz0gMjtcbiAgICByZXR1cm4gclxuICB9XG5cbiAgd3JpdGVVSW50MTZCRSh2YWx1ZSkge1xuICAgIGNvbnN0IHIgPSB0aGlzLmJ1ZmZlci53cml0ZVVJbnQxNkJFKHZhbHVlLCB0aGlzLl9zdGFydCk7XG4gICAgdGhpcy5fc3RhcnQgKz0gMjtcbiAgICByZXR1cm4gclxuICB9XG5cbiAgcmVhZFVJbnQzMkJFKCkge1xuICAgIGNvbnN0IHIgPSB0aGlzLmJ1ZmZlci5yZWFkVUludDMyQkUodGhpcy5fc3RhcnQpO1xuICAgIHRoaXMuX3N0YXJ0ICs9IDQ7XG4gICAgcmV0dXJuIHJcbiAgfVxuXG4gIHdyaXRlVUludDMyQkUodmFsdWUpIHtcbiAgICBjb25zdCByID0gdGhpcy5idWZmZXIud3JpdGVVSW50MzJCRSh2YWx1ZSwgdGhpcy5fc3RhcnQpO1xuICAgIHRoaXMuX3N0YXJ0ICs9IDQ7XG4gICAgcmV0dXJuIHJcbiAgfVxufVxuXG5mdW5jdGlvbiBjb21wYXJlU3RyaW5ncyhhLCBiKSB7XG4gIC8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS80MDM1NTEwNy8yMTY4NDE2XG4gIHJldHVybiAtKGEgPCBiKSB8fCArKGEgPiBiKVxufVxuXG5mdW5jdGlvbiBjb21wYXJlUGF0aChhLCBiKSB7XG4gIC8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS80MDM1NTEwNy8yMTY4NDE2XG4gIHJldHVybiBjb21wYXJlU3RyaW5ncyhhLnBhdGgsIGIucGF0aClcbn1cblxuLyoqXG4gKiBGcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9naXQvZ2l0L2Jsb2IvbWFzdGVyL0RvY3VtZW50YXRpb24vdGVjaG5pY2FsL2luZGV4LWZvcm1hdC50eHRcbiAqXG4gKiAzMi1iaXQgbW9kZSwgc3BsaXQgaW50byAoaGlnaCB0byBsb3cgYml0cylcbiAqXG4gKiAgNC1iaXQgb2JqZWN0IHR5cGVcbiAqICAgIHZhbGlkIHZhbHVlcyBpbiBiaW5hcnkgYXJlIDEwMDAgKHJlZ3VsYXIgZmlsZSksIDEwMTAgKHN5bWJvbGljIGxpbmspXG4gKiAgICBhbmQgMTExMCAoZ2l0bGluaylcbiAqXG4gKiAgMy1iaXQgdW51c2VkXG4gKlxuICogIDktYml0IHVuaXggcGVybWlzc2lvbi4gT25seSAwNzU1IGFuZCAwNjQ0IGFyZSB2YWxpZCBmb3IgcmVndWxhciBmaWxlcy5cbiAqICBTeW1ib2xpYyBsaW5rcyBhbmQgZ2l0bGlua3MgaGF2ZSB2YWx1ZSAwIGluIHRoaXMgZmllbGQuXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZU1vZGUobW9kZSkge1xuICAvLyBOb3RlOiBCcm93c2VyRlMgd2lsbCB1c2UgLTEgZm9yIFwidW5rbm93blwiXG4gIC8vIEkgbmVlZCB0byBtYWtlIGl0IG5vbi1uZWdhdGl2ZSBmb3IgdGhlc2UgYml0c2hpZnRzIHRvIHdvcmsuXG4gIGxldCB0eXBlID0gbW9kZSA+IDAgPyBtb2RlID4+IDEyIDogMDtcbiAgLy8gSWYgaXQgaXNuJ3QgdmFsaWQsIGFzc3VtZSBpdCBhcyBhIFwicmVndWxhciBmaWxlXCJcbiAgLy8gMDEwMCA9IGRpcmVjdG9yeVxuICAvLyAxMDAwID0gcmVndWxhciBmaWxlXG4gIC8vIDEwMTAgPSBzeW1saW5rXG4gIC8vIDExMTAgPSBnaXRsaW5rXG4gIGlmIChcbiAgICB0eXBlICE9PSAwYjAxMDAgJiZcbiAgICB0eXBlICE9PSAwYjEwMDAgJiZcbiAgICB0eXBlICE9PSAwYjEwMTAgJiZcbiAgICB0eXBlICE9PSAwYjExMTBcbiAgKSB7XG4gICAgdHlwZSA9IDBiMTAwMDtcbiAgfVxuICBsZXQgcGVybWlzc2lvbnMgPSBtb2RlICYgMG83Nzc7XG4gIC8vIElzIHRoZSBmaWxlIGV4ZWN1dGFibGU/IHRoZW4gNzU1LiBFbHNlIDY0NC5cbiAgaWYgKHBlcm1pc3Npb25zICYgMGIwMDEwMDEwMDEpIHtcbiAgICBwZXJtaXNzaW9ucyA9IDBvNzU1O1xuICB9IGVsc2Uge1xuICAgIHBlcm1pc3Npb25zID0gMG82NDQ7XG4gIH1cbiAgLy8gSWYgaXQncyBub3QgYSByZWd1bGFyIGZpbGUsIHNjcnViIGFsbCBwZXJtaXNzaW9uc1xuICBpZiAodHlwZSAhPT0gMGIxMDAwKSBwZXJtaXNzaW9ucyA9IDA7XG4gIHJldHVybiAodHlwZSA8PCAxMikgKyBwZXJtaXNzaW9uc1xufVxuXG5jb25zdCBNQVhfVUlOVDMyID0gMiAqKiAzMjtcblxuZnVuY3Rpb24gU2Vjb25kc05hbm9zZWNvbmRzKFxuICBnaXZlblNlY29uZHMsXG4gIGdpdmVuTmFub3NlY29uZHMsXG4gIG1pbGxpc2Vjb25kcyxcbiAgZGF0ZVxuKSB7XG4gIGlmIChnaXZlblNlY29uZHMgIT09IHVuZGVmaW5lZCAmJiBnaXZlbk5hbm9zZWNvbmRzICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gW2dpdmVuU2Vjb25kcywgZ2l2ZW5OYW5vc2Vjb25kc11cbiAgfVxuICBpZiAobWlsbGlzZWNvbmRzID09PSB1bmRlZmluZWQpIHtcbiAgICBtaWxsaXNlY29uZHMgPSBkYXRlLnZhbHVlT2YoKTtcbiAgfVxuICBjb25zdCBzZWNvbmRzID0gTWF0aC5mbG9vcihtaWxsaXNlY29uZHMgLyAxMDAwKTtcbiAgY29uc3QgbmFub3NlY29uZHMgPSAobWlsbGlzZWNvbmRzIC0gc2Vjb25kcyAqIDEwMDApICogMTAwMDAwMDtcbiAgcmV0dXJuIFtzZWNvbmRzLCBuYW5vc2Vjb25kc11cbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplU3RhdHMoZSkge1xuICBjb25zdCBbY3RpbWVTZWNvbmRzLCBjdGltZU5hbm9zZWNvbmRzXSA9IFNlY29uZHNOYW5vc2Vjb25kcyhcbiAgICBlLmN0aW1lU2Vjb25kcyxcbiAgICBlLmN0aW1lTmFub3NlY29uZHMsXG4gICAgZS5jdGltZU1zLFxuICAgIGUuY3RpbWVcbiAgKTtcbiAgY29uc3QgW210aW1lU2Vjb25kcywgbXRpbWVOYW5vc2Vjb25kc10gPSBTZWNvbmRzTmFub3NlY29uZHMoXG4gICAgZS5tdGltZVNlY29uZHMsXG4gICAgZS5tdGltZU5hbm9zZWNvbmRzLFxuICAgIGUubXRpbWVNcyxcbiAgICBlLm10aW1lXG4gICk7XG5cbiAgcmV0dXJuIHtcbiAgICBjdGltZVNlY29uZHM6IGN0aW1lU2Vjb25kcyAlIE1BWF9VSU5UMzIsXG4gICAgY3RpbWVOYW5vc2Vjb25kczogY3RpbWVOYW5vc2Vjb25kcyAlIE1BWF9VSU5UMzIsXG4gICAgbXRpbWVTZWNvbmRzOiBtdGltZVNlY29uZHMgJSBNQVhfVUlOVDMyLFxuICAgIG10aW1lTmFub3NlY29uZHM6IG10aW1lTmFub3NlY29uZHMgJSBNQVhfVUlOVDMyLFxuICAgIGRldjogZS5kZXYgJSBNQVhfVUlOVDMyLFxuICAgIGlubzogZS5pbm8gJSBNQVhfVUlOVDMyLFxuICAgIG1vZGU6IG5vcm1hbGl6ZU1vZGUoZS5tb2RlICUgTUFYX1VJTlQzMiksXG4gICAgdWlkOiBlLnVpZCAlIE1BWF9VSU5UMzIsXG4gICAgZ2lkOiBlLmdpZCAlIE1BWF9VSU5UMzIsXG4gICAgLy8gc2l6ZSBvZiAtMSBoYXBwZW5zIG92ZXIgYSBCcm93c2VyRlMgSFRUUCBCYWNrZW5kIHRoYXQgZG9lc24ndCBzZXJ2ZSBDb250ZW50LUxlbmd0aCBoZWFkZXJzXG4gICAgLy8gKGxpa2UgdGhlIEthcm1hIHdlYnNlcnZlcikgYmVjYXVzZSBCcm93c2VyRlMgSFRUUCBCYWNrZW5kIHVzZXMgSFRUUCBIRUFEIHJlcXVlc3RzIHRvIGRvIGZzLnN0YXRcbiAgICBzaXplOiBlLnNpemUgPiAtMSA/IGUuc2l6ZSAlIE1BWF9VSU5UMzIgOiAwLFxuICB9XG59XG5cbmZ1bmN0aW9uIHRvSGV4KGJ1ZmZlcikge1xuICBsZXQgaGV4ID0gJyc7XG4gIGZvciAoY29uc3QgYnl0ZSBvZiBuZXcgVWludDhBcnJheShidWZmZXIpKSB7XG4gICAgaWYgKGJ5dGUgPCAxNikgaGV4ICs9ICcwJztcbiAgICBoZXggKz0gYnl0ZS50b1N0cmluZygxNik7XG4gIH1cbiAgcmV0dXJuIGhleFxufVxuXG4vKiBlc2xpbnQtZW52IG5vZGUsIGJyb3dzZXIgKi9cblxubGV0IHN1cHBvcnRzU3VidGxlU0hBMSA9IG51bGw7XG5cbmFzeW5jIGZ1bmN0aW9uIHNoYXN1bShidWZmZXIpIHtcbiAgaWYgKHN1cHBvcnRzU3VidGxlU0hBMSA9PT0gbnVsbCkge1xuICAgIHN1cHBvcnRzU3VidGxlU0hBMSA9IGF3YWl0IHRlc3RTdWJ0bGVTSEExKCk7XG4gIH1cbiAgcmV0dXJuIHN1cHBvcnRzU3VidGxlU0hBMSA/IHN1YnRsZVNIQTEoYnVmZmVyKSA6IHNoYXN1bVN5bmMoYnVmZmVyKVxufVxuXG4vLyBUaGlzIGlzIG1vZGVsZWQgYWZ0ZXIgQGRvbWluaWN0YXJyJ3MgXCJzaGFzdW1cIiBtb2R1bGUsXG4vLyBidXQgd2l0aG91dCB0aGUgJ2pzb24tc3RhYmxlLXN0cmluZ2lmeScgZGVwZW5kZW5jeSBhbmRcbi8vIGV4dHJhIHR5cGUtY2FzdGluZyBmZWF0dXJlcy5cbmZ1bmN0aW9uIHNoYXN1bVN5bmMoYnVmZmVyKSB7XG4gIHJldHVybiBuZXcgSGFzaCgpLnVwZGF0ZShidWZmZXIpLmRpZ2VzdCgnaGV4Jylcbn1cblxuYXN5bmMgZnVuY3Rpb24gc3VidGxlU0hBMShidWZmZXIpIHtcbiAgY29uc3QgaGFzaCA9IGF3YWl0IGNyeXB0by5zdWJ0bGUuZGlnZXN0KCdTSEEtMScsIGJ1ZmZlcik7XG4gIHJldHVybiB0b0hleChoYXNoKVxufVxuXG5hc3luYyBmdW5jdGlvbiB0ZXN0U3VidGxlU0hBMSgpIHtcbiAgLy8gSSdtIHVzaW5nIGEgcmF0aGVyIGNydWRlIG1ldGhvZCBvZiBwcm9ncmVzc2l2ZSBlbmhhbmNlbWVudCwgYmVjYXVzZVxuICAvLyBzb21lIGJyb3dzZXJzIHRoYXQgaGF2ZSBjcnlwdG8uc3VidGxlLmRpZ2VzdCBkb24ndCBhY3R1YWxseSBpbXBsZW1lbnQgU0hBLTEuXG4gIHRyeSB7XG4gICAgY29uc3QgaGFzaCA9IGF3YWl0IHN1YnRsZVNIQTEobmV3IFVpbnQ4QXJyYXkoW10pKTtcbiAgICBpZiAoaGFzaCA9PT0gJ2RhMzlhM2VlNWU2YjRiMGQzMjU1YmZlZjk1NjAxODkwYWZkODA3MDknKSByZXR1cm4gdHJ1ZVxuICB9IGNhdGNoIChfKSB7XG4gICAgLy8gbm8gYm90aGVyXG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbi8vIEV4dHJhY3QgMS1iaXQgYXNzdW1lLXZhbGlkLCAxLWJpdCBleHRlbmRlZCBmbGFnLCAyLWJpdCBtZXJnZSBzdGF0ZSBmbGFnLCAxMi1iaXQgcGF0aCBsZW5ndGggZmxhZ1xuZnVuY3Rpb24gcGFyc2VDYWNoZUVudHJ5RmxhZ3MoYml0cykge1xuICByZXR1cm4ge1xuICAgIGFzc3VtZVZhbGlkOiBCb29sZWFuKGJpdHMgJiAwYjEwMDAwMDAwMDAwMDAwMDApLFxuICAgIGV4dGVuZGVkOiBCb29sZWFuKGJpdHMgJiAwYjAxMDAwMDAwMDAwMDAwMDApLFxuICAgIHN0YWdlOiAoYml0cyAmIDBiMDAxMTAwMDAwMDAwMDAwMCkgPj4gMTIsXG4gICAgbmFtZUxlbmd0aDogYml0cyAmIDBiMDAwMDExMTExMTExMTExMSxcbiAgfVxufVxuXG5mdW5jdGlvbiByZW5kZXJDYWNoZUVudHJ5RmxhZ3MoZW50cnkpIHtcbiAgY29uc3QgZmxhZ3MgPSBlbnRyeS5mbGFncztcbiAgLy8gMS1iaXQgZXh0ZW5kZWQgZmxhZyAobXVzdCBiZSB6ZXJvIGluIHZlcnNpb24gMilcbiAgZmxhZ3MuZXh0ZW5kZWQgPSBmYWxzZTtcbiAgLy8gMTItYml0IG5hbWUgbGVuZ3RoIGlmIHRoZSBsZW5ndGggaXMgbGVzcyB0aGFuIDB4RkZGOyBvdGhlcndpc2UgMHhGRkZcbiAgLy8gaXMgc3RvcmVkIGluIHRoaXMgZmllbGQuXG4gIGZsYWdzLm5hbWVMZW5ndGggPSBNYXRoLm1pbihCdWZmZXIuZnJvbShlbnRyeS5wYXRoKS5sZW5ndGgsIDB4ZmZmKTtcbiAgcmV0dXJuIChcbiAgICAoZmxhZ3MuYXNzdW1lVmFsaWQgPyAwYjEwMDAwMDAwMDAwMDAwMDAgOiAwKSArXG4gICAgKGZsYWdzLmV4dGVuZGVkID8gMGIwMTAwMDAwMDAwMDAwMDAwIDogMCkgK1xuICAgICgoZmxhZ3Muc3RhZ2UgJiAwYjExKSA8PCAxMikgK1xuICAgIChmbGFncy5uYW1lTGVuZ3RoICYgMGIxMTExMTExMTExMTEpXG4gIClcbn1cblxuY2xhc3MgR2l0SW5kZXgge1xuICAvKjo6XG4gICBfZW50cmllczogTWFwPHN0cmluZywgQ2FjaGVFbnRyeT5cbiAgIF9kaXJ0eTogYm9vbGVhbiAvLyBVc2VkIHRvIGRldGVybWluZSBpZiBpbmRleCBuZWVkcyB0byBiZSBzYXZlZCB0byBmaWxlc3lzdGVtXG4gICAqL1xuICBjb25zdHJ1Y3RvcihlbnRyaWVzKSB7XG4gICAgdGhpcy5fZGlydHkgPSBmYWxzZTtcbiAgICB0aGlzLl9lbnRyaWVzID0gZW50cmllcyB8fCBuZXcgTWFwKCk7XG4gIH1cblxuICBzdGF0aWMgYXN5bmMgZnJvbShidWZmZXIpIHtcbiAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKGJ1ZmZlcikpIHtcbiAgICAgIHJldHVybiBHaXRJbmRleC5mcm9tQnVmZmVyKGJ1ZmZlcilcbiAgICB9IGVsc2UgaWYgKGJ1ZmZlciA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG5ldyBHaXRJbmRleChudWxsKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgSW50ZXJuYWxFcnJvcignaW52YWxpZCB0eXBlIHBhc3NlZCB0byBHaXRJbmRleC5mcm9tJylcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgYXN5bmMgZnJvbUJ1ZmZlcihidWZmZXIpIHtcbiAgICAvLyBWZXJpZnkgc2hhc3VtXG4gICAgY29uc3Qgc2hhQ29tcHV0ZWQgPSBhd2FpdCBzaGFzdW0oYnVmZmVyLnNsaWNlKDAsIC0yMCkpO1xuICAgIGNvbnN0IHNoYUNsYWltZWQgPSBidWZmZXIuc2xpY2UoLTIwKS50b1N0cmluZygnaGV4Jyk7XG4gICAgaWYgKHNoYUNsYWltZWQgIT09IHNoYUNvbXB1dGVkKSB7XG4gICAgICB0aHJvdyBuZXcgSW50ZXJuYWxFcnJvcihcbiAgICAgICAgYEludmFsaWQgY2hlY2tzdW0gaW4gR2l0SW5kZXggYnVmZmVyOiBleHBlY3RlZCAke3NoYUNsYWltZWR9IGJ1dCBzYXcgJHtzaGFDb21wdXRlZH1gXG4gICAgICApXG4gICAgfVxuICAgIGNvbnN0IHJlYWRlciA9IG5ldyBCdWZmZXJDdXJzb3IoYnVmZmVyKTtcbiAgICBjb25zdCBfZW50cmllcyA9IG5ldyBNYXAoKTtcbiAgICBjb25zdCBtYWdpYyA9IHJlYWRlci50b1N0cmluZygndXRmOCcsIDQpO1xuICAgIGlmIChtYWdpYyAhPT0gJ0RJUkMnKSB7XG4gICAgICB0aHJvdyBuZXcgSW50ZXJuYWxFcnJvcihgSW5hdmxpZCBkaXJjYWNoZSBtYWdpYyBmaWxlIG51bWJlcjogJHttYWdpY31gKVxuICAgIH1cbiAgICBjb25zdCB2ZXJzaW9uID0gcmVhZGVyLnJlYWRVSW50MzJCRSgpO1xuICAgIGlmICh2ZXJzaW9uICE9PSAyKSB7XG4gICAgICB0aHJvdyBuZXcgSW50ZXJuYWxFcnJvcihgVW5zdXBwb3J0ZWQgZGlyY2FjaGUgdmVyc2lvbjogJHt2ZXJzaW9ufWApXG4gICAgfVxuICAgIGNvbnN0IG51bUVudHJpZXMgPSByZWFkZXIucmVhZFVJbnQzMkJFKCk7XG4gICAgbGV0IGkgPSAwO1xuICAgIHdoaWxlICghcmVhZGVyLmVvZigpICYmIGkgPCBudW1FbnRyaWVzKSB7XG4gICAgICBjb25zdCBlbnRyeSA9IHt9O1xuICAgICAgZW50cnkuY3RpbWVTZWNvbmRzID0gcmVhZGVyLnJlYWRVSW50MzJCRSgpO1xuICAgICAgZW50cnkuY3RpbWVOYW5vc2Vjb25kcyA9IHJlYWRlci5yZWFkVUludDMyQkUoKTtcbiAgICAgIGVudHJ5Lm10aW1lU2Vjb25kcyA9IHJlYWRlci5yZWFkVUludDMyQkUoKTtcbiAgICAgIGVudHJ5Lm10aW1lTmFub3NlY29uZHMgPSByZWFkZXIucmVhZFVJbnQzMkJFKCk7XG4gICAgICBlbnRyeS5kZXYgPSByZWFkZXIucmVhZFVJbnQzMkJFKCk7XG4gICAgICBlbnRyeS5pbm8gPSByZWFkZXIucmVhZFVJbnQzMkJFKCk7XG4gICAgICBlbnRyeS5tb2RlID0gcmVhZGVyLnJlYWRVSW50MzJCRSgpO1xuICAgICAgZW50cnkudWlkID0gcmVhZGVyLnJlYWRVSW50MzJCRSgpO1xuICAgICAgZW50cnkuZ2lkID0gcmVhZGVyLnJlYWRVSW50MzJCRSgpO1xuICAgICAgZW50cnkuc2l6ZSA9IHJlYWRlci5yZWFkVUludDMyQkUoKTtcbiAgICAgIGVudHJ5Lm9pZCA9IHJlYWRlci5zbGljZSgyMCkudG9TdHJpbmcoJ2hleCcpO1xuICAgICAgY29uc3QgZmxhZ3MgPSByZWFkZXIucmVhZFVJbnQxNkJFKCk7XG4gICAgICBlbnRyeS5mbGFncyA9IHBhcnNlQ2FjaGVFbnRyeUZsYWdzKGZsYWdzKTtcbiAgICAgIC8vIFRPRE86IGhhbmRsZSBpZiAodmVyc2lvbiA9PT0gMyAmJiBlbnRyeS5mbGFncy5leHRlbmRlZClcbiAgICAgIGNvbnN0IHBhdGhsZW5ndGggPSBidWZmZXIuaW5kZXhPZigwLCByZWFkZXIudGVsbCgpICsgMSkgLSByZWFkZXIudGVsbCgpO1xuICAgICAgaWYgKHBhdGhsZW5ndGggPCAxKSB7XG4gICAgICAgIHRocm93IG5ldyBJbnRlcm5hbEVycm9yKGBHb3QgYSBwYXRoIGxlbmd0aCBvZjogJHtwYXRobGVuZ3RofWApXG4gICAgICB9XG4gICAgICAvLyBUT0RPOiBoYW5kbGUgcGF0aG5hbWVzIGxhcmdlciB0aGFuIDEyIGJpdHNcbiAgICAgIGVudHJ5LnBhdGggPSByZWFkZXIudG9TdHJpbmcoJ3V0ZjgnLCBwYXRobGVuZ3RoKTtcbiAgICAgIC8vIFRoZSBuZXh0IGJpdCBpcyBhd2t3YXJkLiBXZSBleHBlY3QgMSB0byA4IG51bGwgY2hhcmFjdGVyc1xuICAgICAgLy8gc3VjaCB0aGF0IHRoZSB0b3RhbCBzaXplIG9mIHRoZSBlbnRyeSBpcyBhIG11bHRpcGxlIG9mIDggYml0cy5cbiAgICAgIC8vIChIZW5jZSBzdWJ0cmFjdCAxMiBieXRlcyBmb3IgdGhlIGhlYWRlci4pXG4gICAgICBsZXQgcGFkZGluZyA9IDggLSAoKHJlYWRlci50ZWxsKCkgLSAxMikgJSA4KTtcbiAgICAgIGlmIChwYWRkaW5nID09PSAwKSBwYWRkaW5nID0gODtcbiAgICAgIHdoaWxlIChwYWRkaW5nLS0pIHtcbiAgICAgICAgY29uc3QgdG1wID0gcmVhZGVyLnJlYWRVSW50OCgpO1xuICAgICAgICBpZiAodG1wICE9PSAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEludGVybmFsRXJyb3IoXG4gICAgICAgICAgICBgRXhwZWN0ZWQgMS04IG51bGwgY2hhcmFjdGVycyBidXQgZ290ICcke3RtcH0nIGFmdGVyICR7ZW50cnkucGF0aH1gXG4gICAgICAgICAgKVxuICAgICAgICB9IGVsc2UgaWYgKHJlYWRlci5lb2YoKSkge1xuICAgICAgICAgIHRocm93IG5ldyBJbnRlcm5hbEVycm9yKCdVbmV4cGVjdGVkIGVuZCBvZiBmaWxlJylcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gZW5kIG9mIGF3a3dhcmQgcGFydFxuICAgICAgX2VudHJpZXMuc2V0KGVudHJ5LnBhdGgsIGVudHJ5KTtcbiAgICAgIGkrKztcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBHaXRJbmRleChfZW50cmllcylcbiAgfVxuXG4gIGdldCBlbnRyaWVzKCkge1xuICAgIHJldHVybiBbLi4udGhpcy5fZW50cmllcy52YWx1ZXMoKV0uc29ydChjb21wYXJlUGF0aClcbiAgfVxuXG4gIGdldCBlbnRyaWVzTWFwKCkge1xuICAgIHJldHVybiB0aGlzLl9lbnRyaWVzXG4gIH1cblxuICAqW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgZm9yIChjb25zdCBlbnRyeSBvZiB0aGlzLmVudHJpZXMpIHtcbiAgICAgIHlpZWxkIGVudHJ5O1xuICAgIH1cbiAgfVxuXG4gIGluc2VydCh7IGZpbGVwYXRoLCBzdGF0cywgb2lkIH0pIHtcbiAgICBzdGF0cyA9IG5vcm1hbGl6ZVN0YXRzKHN0YXRzKTtcbiAgICBjb25zdCBiZmlsZXBhdGggPSBCdWZmZXIuZnJvbShmaWxlcGF0aCk7XG4gICAgY29uc3QgZW50cnkgPSB7XG4gICAgICBjdGltZVNlY29uZHM6IHN0YXRzLmN0aW1lU2Vjb25kcyxcbiAgICAgIGN0aW1lTmFub3NlY29uZHM6IHN0YXRzLmN0aW1lTmFub3NlY29uZHMsXG4gICAgICBtdGltZVNlY29uZHM6IHN0YXRzLm10aW1lU2Vjb25kcyxcbiAgICAgIG10aW1lTmFub3NlY29uZHM6IHN0YXRzLm10aW1lTmFub3NlY29uZHMsXG4gICAgICBkZXY6IHN0YXRzLmRldixcbiAgICAgIGlubzogc3RhdHMuaW5vLFxuICAgICAgLy8gV2UgcHJvdmlkZSBhIGZhbGxiYWNrIHZhbHVlIGZvciBgbW9kZWAgaGVyZSBiZWNhdXNlIG5vdCBhbGwgZnNcbiAgICAgIC8vIGltcGxlbWVudGF0aW9ucyBhc3NpZ24gaXQsIGJ1dCB3ZSB1c2UgaXQgaW4gR2l0VHJlZS5cbiAgICAgIC8vICcxMDA2NDQnIGlzIGZvciBhIFwicmVndWxhciBub24tZXhlY3V0YWJsZSBmaWxlXCJcbiAgICAgIG1vZGU6IHN0YXRzLm1vZGUgfHwgMG8xMDA2NDQsXG4gICAgICB1aWQ6IHN0YXRzLnVpZCxcbiAgICAgIGdpZDogc3RhdHMuZ2lkLFxuICAgICAgc2l6ZTogc3RhdHMuc2l6ZSxcbiAgICAgIHBhdGg6IGZpbGVwYXRoLFxuICAgICAgb2lkOiBvaWQsXG4gICAgICBmbGFnczoge1xuICAgICAgICBhc3N1bWVWYWxpZDogZmFsc2UsXG4gICAgICAgIGV4dGVuZGVkOiBmYWxzZSxcbiAgICAgICAgc3RhZ2U6IDAsXG4gICAgICAgIG5hbWVMZW5ndGg6IGJmaWxlcGF0aC5sZW5ndGggPCAweGZmZiA/IGJmaWxlcGF0aC5sZW5ndGggOiAweGZmZixcbiAgICAgIH0sXG4gICAgfTtcbiAgICB0aGlzLl9lbnRyaWVzLnNldChlbnRyeS5wYXRoLCBlbnRyeSk7XG4gICAgdGhpcy5fZGlydHkgPSB0cnVlO1xuICB9XG5cbiAgZGVsZXRlKHsgZmlsZXBhdGggfSkge1xuICAgIGlmICh0aGlzLl9lbnRyaWVzLmhhcyhmaWxlcGF0aCkpIHtcbiAgICAgIHRoaXMuX2VudHJpZXMuZGVsZXRlKGZpbGVwYXRoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChjb25zdCBrZXkgb2YgdGhpcy5fZW50cmllcy5rZXlzKCkpIHtcbiAgICAgICAgaWYgKGtleS5zdGFydHNXaXRoKGZpbGVwYXRoICsgJy8nKSkge1xuICAgICAgICAgIHRoaXMuX2VudHJpZXMuZGVsZXRlKGtleSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fZGlydHkgPSB0cnVlO1xuICB9XG5cbiAgY2xlYXIoKSB7XG4gICAgdGhpcy5fZW50cmllcy5jbGVhcigpO1xuICAgIHRoaXMuX2RpcnR5ID0gdHJ1ZTtcbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5lbnRyaWVzXG4gICAgICAubWFwKGVudHJ5ID0+IGAke2VudHJ5Lm1vZGUudG9TdHJpbmcoOCl9ICR7ZW50cnkub2lkfSAgICAke2VudHJ5LnBhdGh9YClcbiAgICAgIC5qb2luKCdcXG4nKVxuICB9XG5cbiAgYXN5bmMgdG9PYmplY3QoKSB7XG4gICAgY29uc3QgaGVhZGVyID0gQnVmZmVyLmFsbG9jKDEyKTtcbiAgICBjb25zdCB3cml0ZXIgPSBuZXcgQnVmZmVyQ3Vyc29yKGhlYWRlcik7XG4gICAgd3JpdGVyLndyaXRlKCdESVJDJywgNCwgJ3V0ZjgnKTtcbiAgICB3cml0ZXIud3JpdGVVSW50MzJCRSgyKTtcbiAgICB3cml0ZXIud3JpdGVVSW50MzJCRSh0aGlzLmVudHJpZXMubGVuZ3RoKTtcbiAgICBjb25zdCBib2R5ID0gQnVmZmVyLmNvbmNhdChcbiAgICAgIHRoaXMuZW50cmllcy5tYXAoZW50cnkgPT4ge1xuICAgICAgICBjb25zdCBicGF0aCA9IEJ1ZmZlci5mcm9tKGVudHJ5LnBhdGgpO1xuICAgICAgICAvLyB0aGUgZml4ZWQgbGVuZ3RoICsgdGhlIGZpbGVuYW1lICsgYXQgbGVhc3Qgb25lIG51bGwgY2hhciA9PiBhbGlnbiBieSA4XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IE1hdGguY2VpbCgoNjIgKyBicGF0aC5sZW5ndGggKyAxKSAvIDgpICogODtcbiAgICAgICAgY29uc3Qgd3JpdHRlbiA9IEJ1ZmZlci5hbGxvYyhsZW5ndGgpO1xuICAgICAgICBjb25zdCB3cml0ZXIgPSBuZXcgQnVmZmVyQ3Vyc29yKHdyaXR0ZW4pO1xuICAgICAgICBjb25zdCBzdGF0ID0gbm9ybWFsaXplU3RhdHMoZW50cnkpO1xuICAgICAgICB3cml0ZXIud3JpdGVVSW50MzJCRShzdGF0LmN0aW1lU2Vjb25kcyk7XG4gICAgICAgIHdyaXRlci53cml0ZVVJbnQzMkJFKHN0YXQuY3RpbWVOYW5vc2Vjb25kcyk7XG4gICAgICAgIHdyaXRlci53cml0ZVVJbnQzMkJFKHN0YXQubXRpbWVTZWNvbmRzKTtcbiAgICAgICAgd3JpdGVyLndyaXRlVUludDMyQkUoc3RhdC5tdGltZU5hbm9zZWNvbmRzKTtcbiAgICAgICAgd3JpdGVyLndyaXRlVUludDMyQkUoc3RhdC5kZXYpO1xuICAgICAgICB3cml0ZXIud3JpdGVVSW50MzJCRShzdGF0Lmlubyk7XG4gICAgICAgIHdyaXRlci53cml0ZVVJbnQzMkJFKHN0YXQubW9kZSk7XG4gICAgICAgIHdyaXRlci53cml0ZVVJbnQzMkJFKHN0YXQudWlkKTtcbiAgICAgICAgd3JpdGVyLndyaXRlVUludDMyQkUoc3RhdC5naWQpO1xuICAgICAgICB3cml0ZXIud3JpdGVVSW50MzJCRShzdGF0LnNpemUpO1xuICAgICAgICB3cml0ZXIud3JpdGUoZW50cnkub2lkLCAyMCwgJ2hleCcpO1xuICAgICAgICB3cml0ZXIud3JpdGVVSW50MTZCRShyZW5kZXJDYWNoZUVudHJ5RmxhZ3MoZW50cnkpKTtcbiAgICAgICAgd3JpdGVyLndyaXRlKGVudHJ5LnBhdGgsIGJwYXRoLmxlbmd0aCwgJ3V0ZjgnKTtcbiAgICAgICAgcmV0dXJuIHdyaXR0ZW5cbiAgICAgIH0pXG4gICAgKTtcbiAgICBjb25zdCBtYWluID0gQnVmZmVyLmNvbmNhdChbaGVhZGVyLCBib2R5XSk7XG4gICAgY29uc3Qgc3VtID0gYXdhaXQgc2hhc3VtKG1haW4pO1xuICAgIHJldHVybiBCdWZmZXIuY29uY2F0KFttYWluLCBCdWZmZXIuZnJvbShzdW0sICdoZXgnKV0pXG4gIH1cbn1cblxuZnVuY3Rpb24gY29tcGFyZVN0YXRzKGVudHJ5LCBzdGF0cykge1xuICAvLyBDb21wYXJpc29uIGJhc2VkIG9uIHRoZSBkZXNjcmlwdGlvbiBpbiBQYXJhZ3JhcGggNCBvZlxuICAvLyBodHRwczovL3d3dy5rZXJuZWwub3JnL3B1Yi9zb2Z0d2FyZS9zY20vZ2l0L2RvY3MvdGVjaG5pY2FsL3JhY3ktZ2l0LnR4dFxuICBjb25zdCBlID0gbm9ybWFsaXplU3RhdHMoZW50cnkpO1xuICBjb25zdCBzID0gbm9ybWFsaXplU3RhdHMoc3RhdHMpO1xuICBjb25zdCBzdGFsZW5lc3MgPVxuICAgIGUubW9kZSAhPT0gcy5tb2RlIHx8XG4gICAgZS5tdGltZVNlY29uZHMgIT09IHMubXRpbWVTZWNvbmRzIHx8XG4gICAgZS5jdGltZVNlY29uZHMgIT09IHMuY3RpbWVTZWNvbmRzIHx8XG4gICAgZS51aWQgIT09IHMudWlkIHx8XG4gICAgZS5naWQgIT09IHMuZ2lkIHx8XG4gICAgZS5pbm8gIT09IHMuaW5vIHx8XG4gICAgZS5zaXplICE9PSBzLnNpemU7XG4gIHJldHVybiBzdGFsZW5lc3Ncbn1cblxuLy8gaW1wb3J0IExvY2tNYW5hZ2VyIGZyb20gJ3RyYXZpeC1sb2NrLW1hbmFnZXInXG5cbi8vIGltcG9ydCBMb2NrIGZyb20gJy4uL3V0aWxzLmpzJ1xuXG4vLyBjb25zdCBsbSA9IG5ldyBMb2NrTWFuYWdlcigpXG5sZXQgbG9jayA9IG51bGw7XG5cbmNvbnN0IEluZGV4Q2FjaGUgPSBTeW1ib2woJ0luZGV4Q2FjaGUnKTtcblxuZnVuY3Rpb24gY3JlYXRlQ2FjaGUoKSB7XG4gIHJldHVybiB7XG4gICAgbWFwOiBuZXcgTWFwKCksXG4gICAgc3RhdHM6IG5ldyBNYXAoKSxcbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiB1cGRhdGVDYWNoZWRJbmRleEZpbGUoZnMsIGZpbGVwYXRoLCBjYWNoZSkge1xuICBjb25zdCBzdGF0ID0gYXdhaXQgZnMubHN0YXQoZmlsZXBhdGgpO1xuICBjb25zdCByYXdJbmRleEZpbGUgPSBhd2FpdCBmcy5yZWFkKGZpbGVwYXRoKTtcbiAgY29uc3QgaW5kZXggPSBhd2FpdCBHaXRJbmRleC5mcm9tKHJhd0luZGV4RmlsZSk7XG4gIC8vIGNhY2hlIHRoZSBHaXRJbmRleCBvYmplY3Qgc28gd2UgZG9uJ3QgbmVlZCB0byByZS1yZWFkIGl0IGV2ZXJ5IHRpbWUuXG4gIGNhY2hlLm1hcC5zZXQoZmlsZXBhdGgsIGluZGV4KTtcbiAgLy8gU2F2ZSB0aGUgc3RhdCBkYXRhIGZvciB0aGUgaW5kZXggc28gd2Uga25vdyB3aGV0aGVyIHRoZSBjYWNoZWQgZmlsZSBpcyBzdGFsZSAobW9kaWZpZWQgYnkgYW4gb3V0c2lkZSBwcm9jZXNzKS5cbiAgY2FjaGUuc3RhdHMuc2V0KGZpbGVwYXRoLCBzdGF0KTtcbn1cblxuLy8gRGV0ZXJtaW5lIHdoZXRoZXIgb3VyIGNvcHkgb2YgdGhlIGluZGV4IGZpbGUgaXMgc3RhbGVcbmFzeW5jIGZ1bmN0aW9uIGlzSW5kZXhTdGFsZShmcywgZmlsZXBhdGgsIGNhY2hlKSB7XG4gIGNvbnN0IHNhdmVkU3RhdHMgPSBjYWNoZS5zdGF0cy5nZXQoZmlsZXBhdGgpO1xuICBpZiAoc2F2ZWRTdGF0cyA9PT0gdW5kZWZpbmVkKSByZXR1cm4gdHJ1ZVxuICBjb25zdCBjdXJyU3RhdHMgPSBhd2FpdCBmcy5sc3RhdChmaWxlcGF0aCk7XG4gIGlmIChzYXZlZFN0YXRzID09PSBudWxsKSByZXR1cm4gZmFsc2VcbiAgaWYgKGN1cnJTdGF0cyA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlXG4gIHJldHVybiBjb21wYXJlU3RhdHMoc2F2ZWRTdGF0cywgY3VyclN0YXRzKVxufVxuXG5jbGFzcyBHaXRJbmRleE1hbmFnZXIge1xuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdHNcbiAgICogQHBhcmFtIHtpbXBvcnQoJy4uL21vZGVscy9GaWxlU3lzdGVtLmpzJykuRmlsZVN5c3RlbX0gb3B0cy5mc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy5naXRkaXJcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdHMuY2FjaGVcbiAgICogQHBhcmFtIHtmdW5jdGlvbihHaXRJbmRleCk6IGFueX0gY2xvc3VyZVxuICAgKi9cbiAgc3RhdGljIGFzeW5jIGFjcXVpcmUoeyBmcywgZ2l0ZGlyLCBjYWNoZSB9LCBjbG9zdXJlKSB7XG4gICAgaWYgKCFjYWNoZVtJbmRleENhY2hlXSkgY2FjaGVbSW5kZXhDYWNoZV0gPSBjcmVhdGVDYWNoZSgpO1xuXG4gICAgY29uc3QgZmlsZXBhdGggPSBgJHtnaXRkaXJ9L2luZGV4YDtcbiAgICBpZiAobG9jayA9PT0gbnVsbCkgbG9jayA9IG5ldyBBc3luY0xvY2soeyBtYXhQZW5kaW5nOiBJbmZpbml0eSB9KTtcbiAgICBsZXQgcmVzdWx0O1xuICAgIGF3YWl0IGxvY2suYWNxdWlyZShmaWxlcGF0aCwgYXN5bmMgZnVuY3Rpb24oKSB7XG4gICAgICAvLyBBY3F1aXJlIGEgZmlsZSBsb2NrIHdoaWxlIHdlJ3JlIHJlYWRpbmcgdGhlIGluZGV4XG4gICAgICAvLyB0byBtYWtlIHN1cmUgb3RoZXIgcHJvY2Vzc2VzIGFyZW4ndCB3cml0aW5nIHRvIGl0XG4gICAgICAvLyBzaW11bHRhbmVvdXNseSwgd2hpY2ggY291bGQgcmVzdWx0IGluIGEgY29ycnVwdGVkIGluZGV4LlxuICAgICAgLy8gY29uc3QgZmlsZUxvY2sgPSBhd2FpdCBMb2NrKGZpbGVwYXRoKVxuICAgICAgaWYgKGF3YWl0IGlzSW5kZXhTdGFsZShmcywgZmlsZXBhdGgsIGNhY2hlW0luZGV4Q2FjaGVdKSkge1xuICAgICAgICBhd2FpdCB1cGRhdGVDYWNoZWRJbmRleEZpbGUoZnMsIGZpbGVwYXRoLCBjYWNoZVtJbmRleENhY2hlXSk7XG4gICAgICB9XG4gICAgICBjb25zdCBpbmRleCA9IGNhY2hlW0luZGV4Q2FjaGVdLm1hcC5nZXQoZmlsZXBhdGgpO1xuICAgICAgcmVzdWx0ID0gYXdhaXQgY2xvc3VyZShpbmRleCk7XG4gICAgICBpZiAoaW5kZXguX2RpcnR5KSB7XG4gICAgICAgIC8vIEFjcXVpcmUgYSBmaWxlIGxvY2sgd2hpbGUgd2UncmUgd3JpdGluZyB0aGUgaW5kZXggZmlsZVxuICAgICAgICAvLyBsZXQgZmlsZUxvY2sgPSBhd2FpdCBMb2NrKGZpbGVwYXRoKVxuICAgICAgICBjb25zdCBidWZmZXIgPSBhd2FpdCBpbmRleC50b09iamVjdCgpO1xuICAgICAgICBhd2FpdCBmcy53cml0ZShmaWxlcGF0aCwgYnVmZmVyKTtcbiAgICAgICAgLy8gVXBkYXRlIGNhY2hlZCBzdGF0IHZhbHVlXG4gICAgICAgIGNhY2hlW0luZGV4Q2FjaGVdLnN0YXRzLnNldChmaWxlcGF0aCwgYXdhaXQgZnMubHN0YXQoZmlsZXBhdGgpKTtcbiAgICAgICAgaW5kZXguX2RpcnR5ID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG59XG5cbmZ1bmN0aW9uIGJhc2VuYW1lKHBhdGgpIHtcbiAgY29uc3QgbGFzdCA9IE1hdGgubWF4KHBhdGgubGFzdEluZGV4T2YoJy8nKSwgcGF0aC5sYXN0SW5kZXhPZignXFxcXCcpKTtcbiAgaWYgKGxhc3QgPiAtMSkge1xuICAgIHBhdGggPSBwYXRoLnNsaWNlKGxhc3QgKyAxKTtcbiAgfVxuICByZXR1cm4gcGF0aFxufVxuXG5mdW5jdGlvbiBkaXJuYW1lKHBhdGgpIHtcbiAgY29uc3QgbGFzdCA9IE1hdGgubWF4KHBhdGgubGFzdEluZGV4T2YoJy8nKSwgcGF0aC5sYXN0SW5kZXhPZignXFxcXCcpKTtcbiAgaWYgKGxhc3QgPT09IC0xKSByZXR1cm4gJy4nXG4gIGlmIChsYXN0ID09PSAwKSByZXR1cm4gJy8nXG4gIHJldHVybiBwYXRoLnNsaWNlKDAsIGxhc3QpXG59XG5cbi8qOjpcbnR5cGUgTm9kZSA9IHtcbiAgdHlwZTogc3RyaW5nLFxuICBmdWxscGF0aDogc3RyaW5nLFxuICBiYXNlbmFtZTogc3RyaW5nLFxuICBtZXRhZGF0YTogT2JqZWN0LCAvLyBtb2RlLCBvaWRcbiAgcGFyZW50PzogTm9kZSxcbiAgY2hpbGRyZW46IEFycmF5PE5vZGU+XG59XG4qL1xuXG5mdW5jdGlvbiBmbGF0RmlsZUxpc3RUb0RpcmVjdG9yeVN0cnVjdHVyZShmaWxlcykge1xuICBjb25zdCBpbm9kZXMgPSBuZXcgTWFwKCk7XG4gIGNvbnN0IG1rZGlyID0gZnVuY3Rpb24obmFtZSkge1xuICAgIGlmICghaW5vZGVzLmhhcyhuYW1lKSkge1xuICAgICAgY29uc3QgZGlyID0ge1xuICAgICAgICB0eXBlOiAndHJlZScsXG4gICAgICAgIGZ1bGxwYXRoOiBuYW1lLFxuICAgICAgICBiYXNlbmFtZTogYmFzZW5hbWUobmFtZSksXG4gICAgICAgIG1ldGFkYXRhOiB7fSxcbiAgICAgICAgY2hpbGRyZW46IFtdLFxuICAgICAgfTtcbiAgICAgIGlub2Rlcy5zZXQobmFtZSwgZGlyKTtcbiAgICAgIC8vIFRoaXMgcmVjdXJzaXZlbHkgZ2VuZXJhdGVzIGFueSBtaXNzaW5nIHBhcmVudCBmb2xkZXJzLlxuICAgICAgLy8gV2UgZG8gaXQgYWZ0ZXIgd2UndmUgYWRkZWQgdGhlIGlub2RlIHRvIHRoZSBzZXQgc28gdGhhdFxuICAgICAgLy8gd2UgZG9uJ3QgcmVjdXJzZSBpbmZpbml0ZWx5IHRyeWluZyB0byBjcmVhdGUgdGhlIHJvb3QgJy4nIGRpcm5hbWUuXG4gICAgICBkaXIucGFyZW50ID0gbWtkaXIoZGlybmFtZShuYW1lKSk7XG4gICAgICBpZiAoZGlyLnBhcmVudCAmJiBkaXIucGFyZW50ICE9PSBkaXIpIGRpci5wYXJlbnQuY2hpbGRyZW4ucHVzaChkaXIpO1xuICAgIH1cbiAgICByZXR1cm4gaW5vZGVzLmdldChuYW1lKVxuICB9O1xuXG4gIGNvbnN0IG1rZmlsZSA9IGZ1bmN0aW9uKG5hbWUsIG1ldGFkYXRhKSB7XG4gICAgaWYgKCFpbm9kZXMuaGFzKG5hbWUpKSB7XG4gICAgICBjb25zdCBmaWxlID0ge1xuICAgICAgICB0eXBlOiAnYmxvYicsXG4gICAgICAgIGZ1bGxwYXRoOiBuYW1lLFxuICAgICAgICBiYXNlbmFtZTogYmFzZW5hbWUobmFtZSksXG4gICAgICAgIG1ldGFkYXRhOiBtZXRhZGF0YSxcbiAgICAgICAgLy8gVGhpcyByZWN1cnNpdmVseSBnZW5lcmF0ZXMgYW55IG1pc3NpbmcgcGFyZW50IGZvbGRlcnMuXG4gICAgICAgIHBhcmVudDogbWtkaXIoZGlybmFtZShuYW1lKSksXG4gICAgICAgIGNoaWxkcmVuOiBbXSxcbiAgICAgIH07XG4gICAgICBpZiAoZmlsZS5wYXJlbnQpIGZpbGUucGFyZW50LmNoaWxkcmVuLnB1c2goZmlsZSk7XG4gICAgICBpbm9kZXMuc2V0KG5hbWUsIGZpbGUpO1xuICAgIH1cbiAgICByZXR1cm4gaW5vZGVzLmdldChuYW1lKVxuICB9O1xuXG4gIG1rZGlyKCcuJyk7XG4gIGZvciAoY29uc3QgZmlsZSBvZiBmaWxlcykge1xuICAgIG1rZmlsZShmaWxlLnBhdGgsIGZpbGUpO1xuICB9XG4gIHJldHVybiBpbm9kZXNcbn1cblxuLyoqXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IG1vZGVcbiAqL1xuZnVuY3Rpb24gbW9kZTJ0eXBlKG1vZGUpIHtcbiAgLy8gcHJldHRpZXItaWdub3JlXG4gIHN3aXRjaCAobW9kZSkge1xuICAgIGNhc2UgMG8wNDAwMDA6IHJldHVybiAndHJlZSdcbiAgICBjYXNlIDBvMTAwNjQ0OiByZXR1cm4gJ2Jsb2InXG4gICAgY2FzZSAwbzEwMDc1NTogcmV0dXJuICdibG9iJ1xuICAgIGNhc2UgMG8xMjAwMDA6IHJldHVybiAnYmxvYidcbiAgICBjYXNlIDBvMTYwMDAwOiByZXR1cm4gJ2NvbW1pdCdcbiAgfVxuICB0aHJvdyBuZXcgSW50ZXJuYWxFcnJvcihgVW5leHBlY3RlZCBHaXRUcmVlIGVudHJ5IG1vZGU6ICR7bW9kZS50b1N0cmluZyg4KX1gKVxufVxuXG5jbGFzcyBHaXRXYWxrZXJJbmRleCB7XG4gIGNvbnN0cnVjdG9yKHsgZnMsIGdpdGRpciwgY2FjaGUgfSkge1xuICAgIHRoaXMudHJlZVByb21pc2UgPSBHaXRJbmRleE1hbmFnZXIuYWNxdWlyZShcbiAgICAgIHsgZnMsIGdpdGRpciwgY2FjaGUgfSxcbiAgICAgIGFzeW5jIGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICAgIHJldHVybiBmbGF0RmlsZUxpc3RUb0RpcmVjdG9yeVN0cnVjdHVyZShpbmRleC5lbnRyaWVzKVxuICAgICAgfVxuICAgICk7XG4gICAgY29uc3Qgd2Fsa2VyID0gdGhpcztcbiAgICB0aGlzLkNvbnN0cnVjdEVudHJ5ID0gY2xhc3MgU3RhZ2VFbnRyeSB7XG4gICAgICBjb25zdHJ1Y3RvcihmdWxscGF0aCkge1xuICAgICAgICB0aGlzLl9mdWxscGF0aCA9IGZ1bGxwYXRoO1xuICAgICAgICB0aGlzLl90eXBlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX21vZGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fc3RhdCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9vaWQgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgYXN5bmMgdHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIHdhbGtlci50eXBlKHRoaXMpXG4gICAgICB9XG5cbiAgICAgIGFzeW5jIG1vZGUoKSB7XG4gICAgICAgIHJldHVybiB3YWxrZXIubW9kZSh0aGlzKVxuICAgICAgfVxuXG4gICAgICBhc3luYyBzdGF0KCkge1xuICAgICAgICByZXR1cm4gd2Fsa2VyLnN0YXQodGhpcylcbiAgICAgIH1cblxuICAgICAgYXN5bmMgY29udGVudCgpIHtcbiAgICAgICAgcmV0dXJuIHdhbGtlci5jb250ZW50KHRoaXMpXG4gICAgICB9XG5cbiAgICAgIGFzeW5jIG9pZCgpIHtcbiAgICAgICAgcmV0dXJuIHdhbGtlci5vaWQodGhpcylcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgYXN5bmMgcmVhZGRpcihlbnRyeSkge1xuICAgIGNvbnN0IGZpbGVwYXRoID0gZW50cnkuX2Z1bGxwYXRoO1xuICAgIGNvbnN0IHRyZWUgPSBhd2FpdCB0aGlzLnRyZWVQcm9taXNlO1xuICAgIGNvbnN0IGlub2RlID0gdHJlZS5nZXQoZmlsZXBhdGgpO1xuICAgIGlmICghaW5vZGUpIHJldHVybiBudWxsXG4gICAgaWYgKGlub2RlLnR5cGUgPT09ICdibG9iJykgcmV0dXJuIG51bGxcbiAgICBpZiAoaW5vZGUudHlwZSAhPT0gJ3RyZWUnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEVOT1RESVI6IG5vdCBhIGRpcmVjdG9yeSwgc2NhbmRpciAnJHtmaWxlcGF0aH0nYClcbiAgICB9XG4gICAgY29uc3QgbmFtZXMgPSBpbm9kZS5jaGlsZHJlbi5tYXAoaW5vZGUgPT4gaW5vZGUuZnVsbHBhdGgpO1xuICAgIG5hbWVzLnNvcnQoY29tcGFyZVN0cmluZ3MpO1xuICAgIHJldHVybiBuYW1lc1xuICB9XG5cbiAgYXN5bmMgdHlwZShlbnRyeSkge1xuICAgIGlmIChlbnRyeS5fdHlwZSA9PT0gZmFsc2UpIHtcbiAgICAgIGF3YWl0IGVudHJ5LnN0YXQoKTtcbiAgICB9XG4gICAgcmV0dXJuIGVudHJ5Ll90eXBlXG4gIH1cblxuICBhc3luYyBtb2RlKGVudHJ5KSB7XG4gICAgaWYgKGVudHJ5Ll9tb2RlID09PSBmYWxzZSkge1xuICAgICAgYXdhaXQgZW50cnkuc3RhdCgpO1xuICAgIH1cbiAgICByZXR1cm4gZW50cnkuX21vZGVcbiAgfVxuXG4gIGFzeW5jIHN0YXQoZW50cnkpIHtcbiAgICBpZiAoZW50cnkuX3N0YXQgPT09IGZhbHNlKSB7XG4gICAgICBjb25zdCB0cmVlID0gYXdhaXQgdGhpcy50cmVlUHJvbWlzZTtcbiAgICAgIGNvbnN0IGlub2RlID0gdHJlZS5nZXQoZW50cnkuX2Z1bGxwYXRoKTtcbiAgICAgIGlmICghaW5vZGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBFTk9FTlQ6IG5vIHN1Y2ggZmlsZSBvciBkaXJlY3RvcnksIGxzdGF0ICcke2VudHJ5Ll9mdWxscGF0aH0nYFxuICAgICAgICApXG4gICAgICB9XG4gICAgICBjb25zdCBzdGF0cyA9IGlub2RlLnR5cGUgPT09ICd0cmVlJyA/IHt9IDogbm9ybWFsaXplU3RhdHMoaW5vZGUubWV0YWRhdGEpO1xuICAgICAgZW50cnkuX3R5cGUgPSBpbm9kZS50eXBlID09PSAndHJlZScgPyAndHJlZScgOiBtb2RlMnR5cGUoc3RhdHMubW9kZSk7XG4gICAgICBlbnRyeS5fbW9kZSA9IHN0YXRzLm1vZGU7XG4gICAgICBpZiAoaW5vZGUudHlwZSA9PT0gJ3RyZWUnKSB7XG4gICAgICAgIGVudHJ5Ll9zdGF0ID0gdW5kZWZpbmVkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZW50cnkuX3N0YXQgPSBzdGF0cztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVudHJ5Ll9zdGF0XG4gIH1cblxuICBhc3luYyBjb250ZW50KF9lbnRyeSkge1xuICAgIC8vIENhbm5vdCBnZXQgY29udGVudCBmb3IgYW4gaW5kZXggZW50cnlcbiAgfVxuXG4gIGFzeW5jIG9pZChlbnRyeSkge1xuICAgIGlmIChlbnRyeS5fb2lkID09PSBmYWxzZSkge1xuICAgICAgY29uc3QgdHJlZSA9IGF3YWl0IHRoaXMudHJlZVByb21pc2U7XG4gICAgICBjb25zdCBpbm9kZSA9IHRyZWUuZ2V0KGVudHJ5Ll9mdWxscGF0aCk7XG4gICAgICBlbnRyeS5fb2lkID0gaW5vZGUubWV0YWRhdGEub2lkO1xuICAgIH1cbiAgICByZXR1cm4gZW50cnkuX29pZFxuICB9XG59XG5cbi8vIFRoaXMgaXMgcGFydCBvZiBhbiBlbGFib3JhdGUgc3lzdGVtIHRvIGZhY2lsaXRhdGUgY29kZS1zcGxpdHRpbmcgLyB0cmVlLXNoYWtpbmcuXG4vLyBjb21tYW5kcy93YWxrLmpzIGNhbiBkZXBlbmQgb24gb25seSB0aGlzLCBhbmQgdGhlIGFjdHVhbCBXYWxrZXIgY2xhc3NlcyBleHBvcnRlZFxuLy8gY2FuIGJlIG9wYXF1ZSAtIG9ubHkgaGF2aW5nIGEgc2luZ2xlIHByb3BlcnR5ICh0aGlzIHN5bWJvbCkgdGhhdCBpcyBub3QgZW51bWVyYWJsZSxcbi8vIGFuZCB0aHVzIHRoZSBjb25zdHJ1Y3RvciBjYW4gYmUgcGFzc2VkIGFzIGFuIGFyZ3VtZW50IHRvIHdhbGsgd2hpbGUgYmVpbmcgXCJ1bnVzYWJsZVwiXG4vLyBvdXRzaWRlIG9mIGl0LlxuY29uc3QgR2l0V2Fsa1N5bWJvbCA9IFN5bWJvbCgnR2l0V2Fsa1N5bWJvbCcpO1xuXG4vLyBAdHMtY2hlY2tcblxuLyoqXG4gKiBAcmV0dXJucyB7V2Fsa2VyfVxuICovXG5mdW5jdGlvbiBTVEFHRSgpIHtcbiAgY29uc3QgbyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBHaXRXYWxrU3ltYm9sLCB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uKHsgZnMsIGdpdGRpciwgY2FjaGUgfSkge1xuICAgICAgcmV0dXJuIG5ldyBHaXRXYWxrZXJJbmRleCh7IGZzLCBnaXRkaXIsIGNhY2hlIH0pXG4gICAgfSxcbiAgfSk7XG4gIE9iamVjdC5mcmVlemUobyk7XG4gIHJldHVybiBvXG59XG5cbi8vIEB0cy1jaGVja1xuXG5jbGFzcyBOb3RGb3VuZEVycm9yIGV4dGVuZHMgQmFzZUVycm9yIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB3aGF0XG4gICAqL1xuICBjb25zdHJ1Y3Rvcih3aGF0KSB7XG4gICAgc3VwZXIoYENvdWxkIG5vdCBmaW5kICR7d2hhdH0uYCk7XG4gICAgdGhpcy5jb2RlID0gdGhpcy5uYW1lID0gTm90Rm91bmRFcnJvci5jb2RlO1xuICAgIHRoaXMuZGF0YSA9IHsgd2hhdCB9O1xuICB9XG59XG4vKiogQHR5cGUgeydOb3RGb3VuZEVycm9yJ30gKi9cbk5vdEZvdW5kRXJyb3IuY29kZSA9ICdOb3RGb3VuZEVycm9yJztcblxuY2xhc3MgT2JqZWN0VHlwZUVycm9yIGV4dGVuZHMgQmFzZUVycm9yIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvaWRcbiAgICogQHBhcmFtIHsnYmxvYid8J2NvbW1pdCd8J3RhZyd8J3RyZWUnfSBhY3R1YWxcbiAgICogQHBhcmFtIHsnYmxvYid8J2NvbW1pdCd8J3RhZyd8J3RyZWUnfSBleHBlY3RlZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2ZpbGVwYXRoXVxuICAgKi9cbiAgY29uc3RydWN0b3Iob2lkLCBhY3R1YWwsIGV4cGVjdGVkLCBmaWxlcGF0aCkge1xuICAgIHN1cGVyKFxuICAgICAgYE9iamVjdCAke29pZH0gJHtcbiAgICAgICAgZmlsZXBhdGggPyBgYXQgJHtmaWxlcGF0aH1gIDogJydcbiAgICAgIH13YXMgYW50aWNpcGF0ZWQgdG8gYmUgYSAke2V4cGVjdGVkfSBidXQgaXQgaXMgYSAke2FjdHVhbH0uYFxuICAgICk7XG4gICAgdGhpcy5jb2RlID0gdGhpcy5uYW1lID0gT2JqZWN0VHlwZUVycm9yLmNvZGU7XG4gICAgdGhpcy5kYXRhID0geyBvaWQsIGFjdHVhbCwgZXhwZWN0ZWQsIGZpbGVwYXRoIH07XG4gIH1cbn1cbi8qKiBAdHlwZSB7J09iamVjdFR5cGVFcnJvcid9ICovXG5PYmplY3RUeXBlRXJyb3IuY29kZSA9ICdPYmplY3RUeXBlRXJyb3InO1xuXG5jbGFzcyBJbnZhbGlkT2lkRXJyb3IgZXh0ZW5kcyBCYXNlRXJyb3Ige1xuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih2YWx1ZSkge1xuICAgIHN1cGVyKGBFeHBlY3RlZCBhIDQwLWNoYXIgaGV4IG9iamVjdCBpZCBidXQgc2F3IFwiJHt2YWx1ZX1cIi5gKTtcbiAgICB0aGlzLmNvZGUgPSB0aGlzLm5hbWUgPSBJbnZhbGlkT2lkRXJyb3IuY29kZTtcbiAgICB0aGlzLmRhdGEgPSB7IHZhbHVlIH07XG4gIH1cbn1cbi8qKiBAdHlwZSB7J0ludmFsaWRPaWRFcnJvcid9ICovXG5JbnZhbGlkT2lkRXJyb3IuY29kZSA9ICdJbnZhbGlkT2lkRXJyb3InO1xuXG5jbGFzcyBOb1JlZnNwZWNFcnJvciBleHRlbmRzIEJhc2VFcnJvciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVtb3RlXG4gICAqL1xuICBjb25zdHJ1Y3RvcihyZW1vdGUpIHtcbiAgICBzdXBlcihgQ291bGQgbm90IGZpbmQgYSBmZXRjaCByZWZzcGVjIGZvciByZW1vdGUgXCIke3JlbW90ZX1cIi4gTWFrZSBzdXJlIHRoZSBjb25maWcgZmlsZSBoYXMgYW4gZW50cnkgbGlrZSB0aGUgZm9sbG93aW5nOlxuW3JlbW90ZSBcIiR7cmVtb3RlfVwiXVxuXFx0ZmV0Y2ggPSArcmVmcy9oZWFkcy8qOnJlZnMvcmVtb3Rlcy9vcmlnaW4vKlxuYCk7XG4gICAgdGhpcy5jb2RlID0gdGhpcy5uYW1lID0gTm9SZWZzcGVjRXJyb3IuY29kZTtcbiAgICB0aGlzLmRhdGEgPSB7IHJlbW90ZSB9O1xuICB9XG59XG4vKiogQHR5cGUgeydOb1JlZnNwZWNFcnJvcid9ICovXG5Ob1JlZnNwZWNFcnJvci5jb2RlID0gJ05vUmVmc3BlY0Vycm9yJztcblxuY2xhc3MgR2l0UGFja2VkUmVmcyB7XG4gIGNvbnN0cnVjdG9yKHRleHQpIHtcbiAgICB0aGlzLnJlZnMgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5wYXJzZWRDb25maWcgPSBbXTtcbiAgICBpZiAodGV4dCkge1xuICAgICAgbGV0IGtleSA9IG51bGw7XG4gICAgICB0aGlzLnBhcnNlZENvbmZpZyA9IHRleHRcbiAgICAgICAgLnRyaW0oKVxuICAgICAgICAuc3BsaXQoJ1xcbicpXG4gICAgICAgIC5tYXAobGluZSA9PiB7XG4gICAgICAgICAgaWYgKC9eXFxzKiMvLnRlc3QobGluZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGxpbmUsIGNvbW1lbnQ6IHRydWUgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBpID0gbGluZS5pbmRleE9mKCcgJyk7XG4gICAgICAgICAgaWYgKGxpbmUuc3RhcnRzV2l0aCgnXicpKSB7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIGEgb2lkIGZvciB0aGUgY29tbWl0IGFzc29jaWF0ZWQgd2l0aCB0aGUgYW5ub3RhdGVkIHRhZyBpbW1lZGlhdGVseSBwcmVjZWRpbmcgdGhpcyBsaW5lLlxuICAgICAgICAgICAgLy8gVHJpbSBvZmYgdGhlICdeJ1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBsaW5lLnNsaWNlKDEpO1xuICAgICAgICAgICAgLy8gVGhlIHRhZ25hbWVee30gc3ludGF4IGlzIGJhc2VkIG9uIHRoZSBvdXRwdXQgb2YgYGdpdCBzaG93LXJlZiAtLXRhZ3MgLWRgXG4gICAgICAgICAgICB0aGlzLnJlZnMuc2V0KGtleSArICdee30nLCB2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4geyBsaW5lLCByZWY6IGtleSwgcGVlbGVkOiB2YWx1ZSB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgYW4gb2lkIGZvbGxvd2VkIGJ5IHRoZSByZWYgbmFtZVxuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBsaW5lLnNsaWNlKDAsIGkpO1xuICAgICAgICAgICAga2V5ID0gbGluZS5zbGljZShpICsgMSk7XG4gICAgICAgICAgICB0aGlzLnJlZnMuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIHsgbGluZSwgcmVmOiBrZXksIG9pZDogdmFsdWUgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBzdGF0aWMgZnJvbSh0ZXh0KSB7XG4gICAgcmV0dXJuIG5ldyBHaXRQYWNrZWRSZWZzKHRleHQpXG4gIH1cblxuICBkZWxldGUocmVmKSB7XG4gICAgdGhpcy5wYXJzZWRDb25maWcgPSB0aGlzLnBhcnNlZENvbmZpZy5maWx0ZXIoZW50cnkgPT4gZW50cnkucmVmICE9PSByZWYpO1xuICAgIHRoaXMucmVmcy5kZWxldGUocmVmKTtcbiAgfVxuXG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLnBhcnNlZENvbmZpZy5tYXAoKHsgbGluZSB9KSA9PiBsaW5lKS5qb2luKCdcXG4nKSArICdcXG4nXG4gIH1cbn1cblxuY2xhc3MgR2l0UmVmU3BlYyB7XG4gIGNvbnN0cnVjdG9yKHsgcmVtb3RlUGF0aCwgbG9jYWxQYXRoLCBmb3JjZSwgbWF0Y2hQcmVmaXggfSkge1xuICAgIE9iamVjdC5hc3NpZ24odGhpcywge1xuICAgICAgcmVtb3RlUGF0aCxcbiAgICAgIGxvY2FsUGF0aCxcbiAgICAgIGZvcmNlLFxuICAgICAgbWF0Y2hQcmVmaXgsXG4gICAgfSk7XG4gIH1cblxuICBzdGF0aWMgZnJvbShyZWZzcGVjKSB7XG4gICAgY29uc3QgW1xuICAgICAgZm9yY2VNYXRjaCxcbiAgICAgIHJlbW90ZVBhdGgsXG4gICAgICByZW1vdGVHbG9iTWF0Y2gsXG4gICAgICBsb2NhbFBhdGgsXG4gICAgICBsb2NhbEdsb2JNYXRjaCxcbiAgICBdID0gcmVmc3BlYy5tYXRjaCgvXihcXCs/KSguKj8pKFxcKj8pOiguKj8pKFxcKj8pJC8pLnNsaWNlKDEpO1xuICAgIGNvbnN0IGZvcmNlID0gZm9yY2VNYXRjaCA9PT0gJysnO1xuICAgIGNvbnN0IHJlbW90ZUlzR2xvYiA9IHJlbW90ZUdsb2JNYXRjaCA9PT0gJyonO1xuICAgIGNvbnN0IGxvY2FsSXNHbG9iID0gbG9jYWxHbG9iTWF0Y2ggPT09ICcqJztcbiAgICAvLyB2YWxpZGF0ZVxuICAgIC8vIFRPRE86IE1ha2UgdGhpcyBjaGVjayBtb3JlIG51YW5jZWQsIGFuZCBkZXBlbmQgb24gd2hldGhlciB0aGlzIGlzIGEgZmV0Y2ggcmVmc3BlYyBvciBhIHB1c2ggcmVmc3BlY1xuICAgIGlmIChyZW1vdGVJc0dsb2IgIT09IGxvY2FsSXNHbG9iKSB7XG4gICAgICB0aHJvdyBuZXcgSW50ZXJuYWxFcnJvcignSW52YWxpZCByZWZzcGVjJylcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBHaXRSZWZTcGVjKHtcbiAgICAgIHJlbW90ZVBhdGgsXG4gICAgICBsb2NhbFBhdGgsXG4gICAgICBmb3JjZSxcbiAgICAgIG1hdGNoUHJlZml4OiByZW1vdGVJc0dsb2IsXG4gICAgfSlcbiAgICAvLyBUT0RPOiBXZSBuZWVkIHRvIHJ1biByZXNvbHZlUmVmIG9uIGJvdGggcGF0aHMgdG8gZXhwYW5kIHRoZW0gdG8gdGhlaXIgZnVsbCBuYW1lLlxuICB9XG5cbiAgdHJhbnNsYXRlKHJlbW90ZUJyYW5jaCkge1xuICAgIGlmICh0aGlzLm1hdGNoUHJlZml4KSB7XG4gICAgICBpZiAocmVtb3RlQnJhbmNoLnN0YXJ0c1dpdGgodGhpcy5yZW1vdGVQYXRoKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbFBhdGggKyByZW1vdGVCcmFuY2gucmVwbGFjZSh0aGlzLnJlbW90ZVBhdGgsICcnKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocmVtb3RlQnJhbmNoID09PSB0aGlzLnJlbW90ZVBhdGgpIHJldHVybiB0aGlzLmxvY2FsUGF0aFxuICAgIH1cbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgcmV2ZXJzZVRyYW5zbGF0ZShsb2NhbEJyYW5jaCkge1xuICAgIGlmICh0aGlzLm1hdGNoUHJlZml4KSB7XG4gICAgICBpZiAobG9jYWxCcmFuY2guc3RhcnRzV2l0aCh0aGlzLmxvY2FsUGF0aCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVtb3RlUGF0aCArIGxvY2FsQnJhbmNoLnJlcGxhY2UodGhpcy5sb2NhbFBhdGgsICcnKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAobG9jYWxCcmFuY2ggPT09IHRoaXMubG9jYWxQYXRoKSByZXR1cm4gdGhpcy5yZW1vdGVQYXRoXG4gICAgfVxuICAgIHJldHVybiBudWxsXG4gIH1cbn1cblxuY2xhc3MgR2l0UmVmU3BlY1NldCB7XG4gIGNvbnN0cnVjdG9yKHJ1bGVzID0gW10pIHtcbiAgICB0aGlzLnJ1bGVzID0gcnVsZXM7XG4gIH1cblxuICBzdGF0aWMgZnJvbShyZWZzcGVjcykge1xuICAgIGNvbnN0IHJ1bGVzID0gW107XG4gICAgZm9yIChjb25zdCByZWZzcGVjIG9mIHJlZnNwZWNzKSB7XG4gICAgICBydWxlcy5wdXNoKEdpdFJlZlNwZWMuZnJvbShyZWZzcGVjKSk7IC8vIG1pZ2h0IHRocm93XG4gICAgfVxuICAgIHJldHVybiBuZXcgR2l0UmVmU3BlY1NldChydWxlcylcbiAgfVxuXG4gIGFkZChyZWZzcGVjKSB7XG4gICAgY29uc3QgcnVsZSA9IEdpdFJlZlNwZWMuZnJvbShyZWZzcGVjKTsgLy8gbWlnaHQgdGhyb3dcbiAgICB0aGlzLnJ1bGVzLnB1c2gocnVsZSk7XG4gIH1cblxuICB0cmFuc2xhdGUocmVtb3RlUmVmcykge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGZvciAoY29uc3QgcnVsZSBvZiB0aGlzLnJ1bGVzKSB7XG4gICAgICBmb3IgKGNvbnN0IHJlbW90ZVJlZiBvZiByZW1vdGVSZWZzKSB7XG4gICAgICAgIGNvbnN0IGxvY2FsUmVmID0gcnVsZS50cmFuc2xhdGUocmVtb3RlUmVmKTtcbiAgICAgICAgaWYgKGxvY2FsUmVmKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goW3JlbW90ZVJlZiwgbG9jYWxSZWZdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICB0cmFuc2xhdGVPbmUocmVtb3RlUmVmKSB7XG4gICAgbGV0IHJlc3VsdCA9IG51bGw7XG4gICAgZm9yIChjb25zdCBydWxlIG9mIHRoaXMucnVsZXMpIHtcbiAgICAgIGNvbnN0IGxvY2FsUmVmID0gcnVsZS50cmFuc2xhdGUocmVtb3RlUmVmKTtcbiAgICAgIGlmIChsb2NhbFJlZikge1xuICAgICAgICByZXN1bHQgPSBsb2NhbFJlZjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG5cbiAgbG9jYWxOYW1lc3BhY2VzKCkge1xuICAgIHJldHVybiB0aGlzLnJ1bGVzXG4gICAgICAuZmlsdGVyKHJ1bGUgPT4gcnVsZS5tYXRjaFByZWZpeClcbiAgICAgIC5tYXAocnVsZSA9PiBydWxlLmxvY2FsUGF0aC5yZXBsYWNlKC9cXC8kLywgJycpKVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbXBhcmVSZWZOYW1lcyhhLCBiKSB7XG4gIC8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS80MDM1NTEwNy8yMTY4NDE2XG4gIGNvbnN0IF9hID0gYS5yZXBsYWNlKC9cXF5cXHtcXH0kLywgJycpO1xuICBjb25zdCBfYiA9IGIucmVwbGFjZSgvXFxeXFx7XFx9JC8sICcnKTtcbiAgY29uc3QgdG1wID0gLShfYSA8IF9iKSB8fCArKF9hID4gX2IpO1xuICBpZiAodG1wID09PSAwKSB7XG4gICAgcmV0dXJuIGEuZW5kc1dpdGgoJ157fScpID8gMSA6IC0xXG4gIH1cbiAgcmV0dXJuIHRtcFxufVxuXG5mdW5jdGlvbiBub3JtYWxpemVQYXRoKHBhdGgpIHtcbiAgcmV0dXJuIHBhdGhcbiAgICAucmVwbGFjZSgvXFwvXFwuXFwvL2csICcvJykgLy8gUmVwbGFjZSAnLy4vJyB3aXRoICcvJ1xuICAgIC5yZXBsYWNlKC9cXC97Mix9L2csICcvJykgLy8gUmVwbGFjZSBjb25zZWN1dGl2ZSAnLydcbiAgICAucmVwbGFjZSgvXlxcL1xcLiQvLCAnLycpIC8vIGlmIHBhdGggPT09ICcvLicgcmV0dXJuICcvJ1xuICAgIC5yZXBsYWNlKC9eXFwuXFwvJC8sICcuJykgLy8gaWYgcGF0aCA9PT0gJy4vJyByZXR1cm4gJy4nXG4gICAgLnJlcGxhY2UoL15cXC5cXC8vLCAnJykgLy8gUmVtb3ZlIGxlYWRpbmcgJy4vJ1xuICAgIC5yZXBsYWNlKC9cXC9cXC4kLywgJycpIC8vIFJlbW92ZSB0cmFpbGluZyAnLy4nXG4gICAgLnJlcGxhY2UoLyguKylcXC8kLywgJyQxJykgLy8gUmVtb3ZlIHRyYWlsaW5nICcvJ1xuICAgIC5yZXBsYWNlKC9eJC8sICcuJykgLy8gaWYgcGF0aCA9PT0gJycgcmV0dXJuICcuJ1xufVxuXG4vLyBGb3Igc29tZSByZWFzb24gcGF0aC5wb3NpeC5qb2luIGlzIHVuZGVmaW5lZCBpbiB3ZWJwYWNrXG5cbmZ1bmN0aW9uIGpvaW4oLi4ucGFydHMpIHtcbiAgcmV0dXJuIG5vcm1hbGl6ZVBhdGgocGFydHMubWFwKG5vcm1hbGl6ZVBhdGgpLmpvaW4oJy8nKSlcbn1cblxuLy8gVGhpcyBpcyBzdHJhaWdodCBmcm9tIHBhcnNlX3VuaXRfZmFjdG9yIGluIGNvbmZpZy5jIG9mIGNhbm9uaWNhbCBnaXRcbmNvbnN0IG51bSA9IHZhbCA9PiB7XG4gIHZhbCA9IHZhbC50b0xvd2VyQ2FzZSgpO1xuICBsZXQgbiA9IHBhcnNlSW50KHZhbCk7XG4gIGlmICh2YWwuZW5kc1dpdGgoJ2snKSkgbiAqPSAxMDI0O1xuICBpZiAodmFsLmVuZHNXaXRoKCdtJykpIG4gKj0gMTAyNCAqIDEwMjQ7XG4gIGlmICh2YWwuZW5kc1dpdGgoJ2cnKSkgbiAqPSAxMDI0ICogMTAyNCAqIDEwMjQ7XG4gIHJldHVybiBuXG59O1xuXG4vLyBUaGlzIGlzIHN0cmFpZ2h0IGZyb20gZ2l0X3BhcnNlX21heWJlX2Jvb2xfdGV4dCBpbiBjb25maWcuYyBvZiBjYW5vbmljYWwgZ2l0XG5jb25zdCBib29sID0gdmFsID0+IHtcbiAgdmFsID0gdmFsLnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xuICBpZiAodmFsID09PSAndHJ1ZScgfHwgdmFsID09PSAneWVzJyB8fCB2YWwgPT09ICdvbicpIHJldHVybiB0cnVlXG4gIGlmICh2YWwgPT09ICdmYWxzZScgfHwgdmFsID09PSAnbm8nIHx8IHZhbCA9PT0gJ29mZicpIHJldHVybiBmYWxzZVxuICB0aHJvdyBFcnJvcihcbiAgICBgRXhwZWN0ZWQgJ3RydWUnLCAnZmFsc2UnLCAneWVzJywgJ25vJywgJ29uJywgb3IgJ29mZicsIGJ1dCBnb3QgJHt2YWx9YFxuICApXG59O1xuXG5jb25zdCBzY2hlbWEgPSB7XG4gIGNvcmU6IHtcbiAgICBmaWxlbW9kZTogYm9vbCxcbiAgICBiYXJlOiBib29sLFxuICAgIGxvZ2FsbHJlZnVwZGF0ZXM6IGJvb2wsXG4gICAgc3ltbGlua3M6IGJvb2wsXG4gICAgaWdub3JlY2FzZTogYm9vbCxcbiAgICBiaWdGaWxlVGhyZXNob2xkOiBudW0sXG4gIH0sXG59O1xuXG4vLyBodHRwczovL2dpdC1zY20uY29tL2RvY3MvZ2l0LWNvbmZpZyNfc3ludGF4XG5cbi8vIHNlY3Rpb24gc3RhcnRzIHdpdGggWyBhbmQgZW5kcyB3aXRoIF1cbi8vIHNlY3Rpb24gaXMgYWxwaGFudW1lcmljIChBU0NJSSkgd2l0aCAtIGFuZCAuXG4vLyBzZWN0aW9uIGlzIGNhc2UgaW5zZW5zaXRpdmVcbi8vIHN1YnNlY3Rpb24gaXMgb3B0aW9ubmFsXG4vLyBzdWJzZWN0aW9uIGlzIHNwZWNpZmllZCBhZnRlciBzZWN0aW9uIGFuZCBvbmUgb3IgbW9yZSBzcGFjZXNcbi8vIHN1YnNlY3Rpb24gaXMgc3BlY2lmaWVkIGJldHdlZW4gZG91YmxlIHF1b3Rlc1xuY29uc3QgU0VDVElPTl9MSU5FX1JFR0VYID0gL15cXFsoW0EtWmEtejAtOS0uXSspKD86IFwiKC4qKVwiKT9cXF0kLztcbmNvbnN0IFNFQ1RJT05fUkVHRVggPSAvXltBLVphLXowLTktLl0rJC87XG5cbi8vIHZhcmlhYmxlIGxpbmVzIGNvbnRhaW4gYSBuYW1lLCBhbmQgZXF1YWwgc2lnbiBhbmQgdGhlbiBhIHZhbHVlXG4vLyB2YXJpYWJsZSBsaW5lcyBjYW4gYWxzbyBvbmx5IGNvbnRhaW4gYSBuYW1lICh0aGUgaW1wbGljaXQgdmFsdWUgaXMgYSBib29sZWFuIHRydWUpXG4vLyB2YXJpYWJsZSBuYW1lIGlzIGFscGhhbnVtZXJpYyAoQVNDSUkpIHdpdGggLVxuLy8gdmFyaWFibGUgbmFtZSBzdGFydHMgd2l0aCBhbiBhbHBoYWJldGljIGNoYXJhY3RlclxuLy8gdmFyaWFibGUgbmFtZSBpcyBjYXNlIGluc2Vuc2l0aXZlXG5jb25zdCBWQVJJQUJMRV9MSU5FX1JFR0VYID0gL14oW0EtWmEtel1bQS1aYS16LV0qKSg/OiAqPSAqKC4qKSk/JC87XG5jb25zdCBWQVJJQUJMRV9OQU1FX1JFR0VYID0gL15bQS1aYS16XVtBLVphLXotXSokLztcblxuY29uc3QgVkFSSUFCTEVfVkFMVUVfQ09NTUVOVF9SRUdFWCA9IC9eKC4qPykoICpbIztdLiopJC87XG5cbmNvbnN0IGV4dHJhY3RTZWN0aW9uTGluZSA9IGxpbmUgPT4ge1xuICBjb25zdCBtYXRjaGVzID0gU0VDVElPTl9MSU5FX1JFR0VYLmV4ZWMobGluZSk7XG4gIGlmIChtYXRjaGVzICE9IG51bGwpIHtcbiAgICBjb25zdCBbc2VjdGlvbiwgc3Vic2VjdGlvbl0gPSBtYXRjaGVzLnNsaWNlKDEpO1xuICAgIHJldHVybiBbc2VjdGlvbiwgc3Vic2VjdGlvbl1cbiAgfVxuICByZXR1cm4gbnVsbFxufTtcblxuY29uc3QgZXh0cmFjdFZhcmlhYmxlTGluZSA9IGxpbmUgPT4ge1xuICBjb25zdCBtYXRjaGVzID0gVkFSSUFCTEVfTElORV9SRUdFWC5leGVjKGxpbmUpO1xuICBpZiAobWF0Y2hlcyAhPSBudWxsKSB7XG4gICAgY29uc3QgW25hbWUsIHJhd1ZhbHVlID0gJ3RydWUnXSA9IG1hdGNoZXMuc2xpY2UoMSk7XG4gICAgY29uc3QgdmFsdWVXaXRob3V0Q29tbWVudHMgPSByZW1vdmVDb21tZW50cyhyYXdWYWx1ZSk7XG4gICAgY29uc3QgdmFsdWVXaXRob3V0UXVvdGVzID0gcmVtb3ZlUXVvdGVzKHZhbHVlV2l0aG91dENvbW1lbnRzKTtcbiAgICByZXR1cm4gW25hbWUsIHZhbHVlV2l0aG91dFF1b3Rlc11cbiAgfVxuICByZXR1cm4gbnVsbFxufTtcblxuY29uc3QgcmVtb3ZlQ29tbWVudHMgPSByYXdWYWx1ZSA9PiB7XG4gIGNvbnN0IGNvbW1lbnRNYXRjaGVzID0gVkFSSUFCTEVfVkFMVUVfQ09NTUVOVF9SRUdFWC5leGVjKHJhd1ZhbHVlKTtcbiAgaWYgKGNvbW1lbnRNYXRjaGVzID09IG51bGwpIHtcbiAgICByZXR1cm4gcmF3VmFsdWVcbiAgfVxuICBjb25zdCBbdmFsdWVXaXRob3V0Q29tbWVudCwgY29tbWVudF0gPSBjb21tZW50TWF0Y2hlcy5zbGljZSgxKTtcbiAgLy8gaWYgb2RkIG51bWJlciBvZiBxdW90ZXMgYmVmb3JlIGFuZCBhZnRlciBjb21tZW50ID0+IGNvbW1lbnQgaXMgZXNjYXBlZFxuICBpZiAoXG4gICAgaGFzT2RkTnVtYmVyT2ZRdW90ZXModmFsdWVXaXRob3V0Q29tbWVudCkgJiZcbiAgICBoYXNPZGROdW1iZXJPZlF1b3Rlcyhjb21tZW50KVxuICApIHtcbiAgICByZXR1cm4gYCR7dmFsdWVXaXRob3V0Q29tbWVudH0ke2NvbW1lbnR9YFxuICB9XG4gIHJldHVybiB2YWx1ZVdpdGhvdXRDb21tZW50XG59O1xuXG5jb25zdCBoYXNPZGROdW1iZXJPZlF1b3RlcyA9IHRleHQgPT4ge1xuICBjb25zdCBudW1iZXJPZlF1b3RlcyA9ICh0ZXh0Lm1hdGNoKC8oPzpefFteXFxcXF0pXCIvZykgfHwgW10pLmxlbmd0aDtcbiAgcmV0dXJuIG51bWJlck9mUXVvdGVzICUgMiAhPT0gMFxufTtcblxuY29uc3QgcmVtb3ZlUXVvdGVzID0gdGV4dCA9PiB7XG4gIHJldHVybiB0ZXh0LnNwbGl0KCcnKS5yZWR1Y2UoKG5ld1RleHQsIGMsIGlkeCwgdGV4dCkgPT4ge1xuICAgIGNvbnN0IGlzUXVvdGUgPSBjID09PSAnXCInICYmIHRleHRbaWR4IC0gMV0gIT09ICdcXFxcJztcbiAgICBjb25zdCBpc0VzY2FwZUZvclF1b3RlID0gYyA9PT0gJ1xcXFwnICYmIHRleHRbaWR4ICsgMV0gPT09ICdcIic7XG4gICAgaWYgKGlzUXVvdGUgfHwgaXNFc2NhcGVGb3JRdW90ZSkge1xuICAgICAgcmV0dXJuIG5ld1RleHRcbiAgICB9XG4gICAgcmV0dXJuIG5ld1RleHQgKyBjXG4gIH0sICcnKVxufTtcblxuY29uc3QgbG93ZXIgPSB0ZXh0ID0+IHtcbiAgcmV0dXJuIHRleHQgIT0gbnVsbCA/IHRleHQudG9Mb3dlckNhc2UoKSA6IG51bGxcbn07XG5cbmNvbnN0IGdldFBhdGggPSAoc2VjdGlvbiwgc3Vic2VjdGlvbiwgbmFtZSkgPT4ge1xuICByZXR1cm4gW2xvd2VyKHNlY3Rpb24pLCBzdWJzZWN0aW9uLCBsb3dlcihuYW1lKV1cbiAgICAuZmlsdGVyKGEgPT4gYSAhPSBudWxsKVxuICAgIC5qb2luKCcuJylcbn07XG5cbmNvbnN0IGZpbmRMYXN0SW5kZXggPSAoYXJyYXksIGNhbGxiYWNrKSA9PiB7XG4gIHJldHVybiBhcnJheS5yZWR1Y2UoKGxhc3RJbmRleCwgaXRlbSwgaW5kZXgpID0+IHtcbiAgICByZXR1cm4gY2FsbGJhY2soaXRlbSkgPyBpbmRleCA6IGxhc3RJbmRleFxuICB9LCAtMSlcbn07XG5cbi8vIE5vdGU6IHRoZXJlIGFyZSBhIExPVCBvZiBlZGdlIGNhc2VzIHRoYXQgYXJlbid0IGNvdmVyZWQgKGUuZy4ga2V5cyBpbiBzZWN0aW9ucyB0aGF0IGFsc29cbi8vIGhhdmUgc3Vic2VjdGlvbnMsIFtpbmNsdWRlXSBkaXJlY3RpdmVzLCBldGMuXG5jbGFzcyBHaXRDb25maWcge1xuICBjb25zdHJ1Y3Rvcih0ZXh0KSB7XG4gICAgbGV0IHNlY3Rpb24gPSBudWxsO1xuICAgIGxldCBzdWJzZWN0aW9uID0gbnVsbDtcbiAgICB0aGlzLnBhcnNlZENvbmZpZyA9IHRleHQuc3BsaXQoJ1xcbicpLm1hcChsaW5lID0+IHtcbiAgICAgIGxldCBuYW1lID0gbnVsbDtcbiAgICAgIGxldCB2YWx1ZSA9IG51bGw7XG5cbiAgICAgIGNvbnN0IHRyaW1tZWRMaW5lID0gbGluZS50cmltKCk7XG4gICAgICBjb25zdCBleHRyYWN0ZWRTZWN0aW9uID0gZXh0cmFjdFNlY3Rpb25MaW5lKHRyaW1tZWRMaW5lKTtcbiAgICAgIGNvbnN0IGlzU2VjdGlvbiA9IGV4dHJhY3RlZFNlY3Rpb24gIT0gbnVsbDtcbiAgICAgIGlmIChpc1NlY3Rpb24pIHtcbiAgICAgICAgO1tzZWN0aW9uLCBzdWJzZWN0aW9uXSA9IGV4dHJhY3RlZFNlY3Rpb247XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBleHRyYWN0ZWRWYXJpYWJsZSA9IGV4dHJhY3RWYXJpYWJsZUxpbmUodHJpbW1lZExpbmUpO1xuICAgICAgICBjb25zdCBpc1ZhcmlhYmxlID0gZXh0cmFjdGVkVmFyaWFibGUgIT0gbnVsbDtcbiAgICAgICAgaWYgKGlzVmFyaWFibGUpIHtcbiAgICAgICAgICA7W25hbWUsIHZhbHVlXSA9IGV4dHJhY3RlZFZhcmlhYmxlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHBhdGggPSBnZXRQYXRoKHNlY3Rpb24sIHN1YnNlY3Rpb24sIG5hbWUpO1xuICAgICAgcmV0dXJuIHsgbGluZSwgaXNTZWN0aW9uLCBzZWN0aW9uLCBzdWJzZWN0aW9uLCBuYW1lLCB2YWx1ZSwgcGF0aCB9XG4gICAgfSk7XG4gIH1cblxuICBzdGF0aWMgZnJvbSh0ZXh0KSB7XG4gICAgcmV0dXJuIG5ldyBHaXRDb25maWcodGV4dClcbiAgfVxuXG4gIGFzeW5jIGdldChwYXRoLCBnZXRhbGwgPSBmYWxzZSkge1xuICAgIGNvbnN0IGFsbFZhbHVlcyA9IHRoaXMucGFyc2VkQ29uZmlnXG4gICAgICAuZmlsdGVyKGNvbmZpZyA9PiBjb25maWcucGF0aCA9PT0gcGF0aC50b0xvd2VyQ2FzZSgpKVxuICAgICAgLm1hcCgoeyBzZWN0aW9uLCBuYW1lLCB2YWx1ZSB9KSA9PiB7XG4gICAgICAgIGNvbnN0IGZuID0gc2NoZW1hW3NlY3Rpb25dICYmIHNjaGVtYVtzZWN0aW9uXVtuYW1lXTtcbiAgICAgICAgcmV0dXJuIGZuID8gZm4odmFsdWUpIDogdmFsdWVcbiAgICAgIH0pO1xuICAgIHJldHVybiBnZXRhbGwgPyBhbGxWYWx1ZXMgOiBhbGxWYWx1ZXMucG9wKClcbiAgfVxuXG4gIGFzeW5jIGdldGFsbChwYXRoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KHBhdGgsIHRydWUpXG4gIH1cblxuICBhc3luYyBnZXRTdWJzZWN0aW9ucyhzZWN0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VkQ29uZmlnXG4gICAgICAuZmlsdGVyKGNvbmZpZyA9PiBjb25maWcuc2VjdGlvbiA9PT0gc2VjdGlvbiAmJiBjb25maWcuaXNTZWN0aW9uKVxuICAgICAgLm1hcChjb25maWcgPT4gY29uZmlnLnN1YnNlY3Rpb24pXG4gIH1cblxuICBhc3luYyBkZWxldGVTZWN0aW9uKHNlY3Rpb24sIHN1YnNlY3Rpb24pIHtcbiAgICB0aGlzLnBhcnNlZENvbmZpZyA9IHRoaXMucGFyc2VkQ29uZmlnLmZpbHRlcihcbiAgICAgIGNvbmZpZyA9PlxuICAgICAgICAhKGNvbmZpZy5zZWN0aW9uID09PSBzZWN0aW9uICYmIGNvbmZpZy5zdWJzZWN0aW9uID09PSBzdWJzZWN0aW9uKVxuICAgICk7XG4gIH1cblxuICBhc3luYyBhcHBlbmQocGF0aCwgdmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5zZXQocGF0aCwgdmFsdWUsIHRydWUpXG4gIH1cblxuICBhc3luYyBzZXQocGF0aCwgdmFsdWUsIGFwcGVuZCA9IGZhbHNlKSB7XG4gICAgY29uc3QgY29uZmlnSW5kZXggPSBmaW5kTGFzdEluZGV4KFxuICAgICAgdGhpcy5wYXJzZWRDb25maWcsXG4gICAgICBjb25maWcgPT4gY29uZmlnLnBhdGggPT09IHBhdGgudG9Mb3dlckNhc2UoKVxuICAgICk7XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgIGlmIChjb25maWdJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgdGhpcy5wYXJzZWRDb25maWcuc3BsaWNlKGNvbmZpZ0luZGV4LCAxKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGNvbmZpZ0luZGV4ICE9PSAtMSkge1xuICAgICAgICBjb25zdCBjb25maWcgPSB0aGlzLnBhcnNlZENvbmZpZ1tjb25maWdJbmRleF07XG4gICAgICAgIGNvbnN0IG1vZGlmaWVkQ29uZmlnID0gT2JqZWN0LmFzc2lnbih7fSwgY29uZmlnLCB7XG4gICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgbW9kaWZpZWQ6IHRydWUsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoYXBwZW5kKSB7XG4gICAgICAgICAgdGhpcy5wYXJzZWRDb25maWcuc3BsaWNlKGNvbmZpZ0luZGV4ICsgMSwgMCwgbW9kaWZpZWRDb25maWcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucGFyc2VkQ29uZmlnW2NvbmZpZ0luZGV4XSA9IG1vZGlmaWVkQ29uZmlnO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBzZWN0aW9uUGF0aCA9IHBhdGhcbiAgICAgICAgICAuc3BsaXQoJy4nKVxuICAgICAgICAgIC5zbGljZSgwLCAtMSlcbiAgICAgICAgICAuam9pbignLicpXG4gICAgICAgICAgLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGNvbnN0IHNlY3Rpb25JbmRleCA9IHRoaXMucGFyc2VkQ29uZmlnLmZpbmRJbmRleChcbiAgICAgICAgICBjb25maWcgPT4gY29uZmlnLnBhdGggPT09IHNlY3Rpb25QYXRoXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IFtzZWN0aW9uLCBzdWJzZWN0aW9uXSA9IHNlY3Rpb25QYXRoLnNwbGl0KCcuJyk7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBwYXRoLnNwbGl0KCcuJykucG9wKCk7XG4gICAgICAgIGNvbnN0IG5ld0NvbmZpZyA9IHtcbiAgICAgICAgICBzZWN0aW9uLFxuICAgICAgICAgIHN1YnNlY3Rpb24sXG4gICAgICAgICAgbmFtZSxcbiAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICBtb2RpZmllZDogdHJ1ZSxcbiAgICAgICAgICBwYXRoOiBnZXRQYXRoKHNlY3Rpb24sIHN1YnNlY3Rpb24sIG5hbWUpLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoU0VDVElPTl9SRUdFWC50ZXN0KHNlY3Rpb24pICYmIFZBUklBQkxFX05BTUVfUkVHRVgudGVzdChuYW1lKSkge1xuICAgICAgICAgIGlmIChzZWN0aW9uSW5kZXggPj0gMCkge1xuICAgICAgICAgICAgLy8gUmV1c2UgZXhpc3Rpbmcgc2VjdGlvblxuICAgICAgICAgICAgdGhpcy5wYXJzZWRDb25maWcuc3BsaWNlKHNlY3Rpb25JbmRleCArIDEsIDAsIG5ld0NvbmZpZyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEFkZCBhIG5ldyBzZWN0aW9uXG4gICAgICAgICAgICBjb25zdCBuZXdTZWN0aW9uID0ge1xuICAgICAgICAgICAgICBzZWN0aW9uLFxuICAgICAgICAgICAgICBzdWJzZWN0aW9uLFxuICAgICAgICAgICAgICBtb2RpZmllZDogdHJ1ZSxcbiAgICAgICAgICAgICAgcGF0aDogZ2V0UGF0aChzZWN0aW9uLCBzdWJzZWN0aW9uLCBudWxsKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLnBhcnNlZENvbmZpZy5wdXNoKG5ld1NlY3Rpb24sIG5ld0NvbmZpZyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VkQ29uZmlnXG4gICAgICAubWFwKCh7IGxpbmUsIHNlY3Rpb24sIHN1YnNlY3Rpb24sIG5hbWUsIHZhbHVlLCBtb2RpZmllZCA9IGZhbHNlIH0pID0+IHtcbiAgICAgICAgaWYgKCFtb2RpZmllZCkge1xuICAgICAgICAgIHJldHVybiBsaW5lXG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5hbWUgIT0gbnVsbCAmJiB2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIGBcXHQke25hbWV9ID0gJHt2YWx1ZX1gXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN1YnNlY3Rpb24gIT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBgWyR7c2VjdGlvbn0gXCIke3N1YnNlY3Rpb259XCJdYFxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgWyR7c2VjdGlvbn1dYFxuICAgICAgfSlcbiAgICAgIC5qb2luKCdcXG4nKVxuICB9XG59XG5cbmNsYXNzIEdpdENvbmZpZ01hbmFnZXIge1xuICBzdGF0aWMgYXN5bmMgZ2V0KHsgZnMsIGdpdGRpciB9KSB7XG4gICAgLy8gV2UgY2FuIGltcHJvdmUgZWZmaWNpZW5jeSBsYXRlciBpZiBuZWVkZWQuXG4gICAgLy8gVE9ETzogcmVhZCBmcm9tIGZ1bGwgbGlzdCBvZiBnaXQgY29uZmlnIGZpbGVzXG4gICAgY29uc3QgdGV4dCA9IGF3YWl0IGZzLnJlYWQoYCR7Z2l0ZGlyfS9jb25maWdgLCB7IGVuY29kaW5nOiAndXRmOCcgfSk7XG4gICAgcmV0dXJuIEdpdENvbmZpZy5mcm9tKHRleHQpXG4gIH1cblxuICBzdGF0aWMgYXN5bmMgc2F2ZSh7IGZzLCBnaXRkaXIsIGNvbmZpZyB9KSB7XG4gICAgLy8gV2UgY2FuIGltcHJvdmUgZWZmaWNpZW5jeSBsYXRlciBpZiBuZWVkZWQuXG4gICAgLy8gVE9ETzogaGFuZGxlIHNhdmluZyB0byB0aGUgY29ycmVjdCBnbG9iYWwvdXNlci9yZXBvIGxvY2F0aW9uXG4gICAgYXdhaXQgZnMud3JpdGUoYCR7Z2l0ZGlyfS9jb25maWdgLCBjb25maWcudG9TdHJpbmcoKSwge1xuICAgICAgZW5jb2Rpbmc6ICd1dGY4JyxcbiAgICB9KTtcbiAgfVxufVxuXG4vLyBUaGlzIGlzIGEgY29udmVuaWVuY2Ugd3JhcHBlciBmb3IgcmVhZGluZyBhbmQgd3JpdGluZyBmaWxlcyBpbiB0aGUgJ3JlZnMnIGRpcmVjdG9yeS5cblxuLy8gQHNlZSBodHRwczovL2dpdC1zY20uY29tL2RvY3MvZ2l0LXJldi1wYXJzZS5odG1sI19zcGVjaWZ5aW5nX3JldmlzaW9uc1xuY29uc3QgcmVmcGF0aHMgPSByZWYgPT4gW1xuICBgJHtyZWZ9YCxcbiAgYHJlZnMvJHtyZWZ9YCxcbiAgYHJlZnMvdGFncy8ke3JlZn1gLFxuICBgcmVmcy9oZWFkcy8ke3JlZn1gLFxuICBgcmVmcy9yZW1vdGVzLyR7cmVmfWAsXG4gIGByZWZzL3JlbW90ZXMvJHtyZWZ9L0hFQURgLFxuXTtcblxuLy8gQHNlZSBodHRwczovL2dpdC1zY20uY29tL2RvY3MvZ2l0cmVwb3NpdG9yeS1sYXlvdXRcbmNvbnN0IEdJVF9GSUxFUyA9IFsnY29uZmlnJywgJ2Rlc2NyaXB0aW9uJywgJ2luZGV4JywgJ3NoYWxsb3cnLCAnY29tbW9uZGlyJ107XG5cbmNsYXNzIEdpdFJlZk1hbmFnZXIge1xuICBzdGF0aWMgYXN5bmMgdXBkYXRlUmVtb3RlUmVmcyh7XG4gICAgZnMsXG4gICAgZ2l0ZGlyLFxuICAgIHJlbW90ZSxcbiAgICByZWZzLFxuICAgIHN5bXJlZnMsXG4gICAgdGFncyxcbiAgICByZWZzcGVjcyA9IHVuZGVmaW5lZCxcbiAgICBwcnVuZSA9IGZhbHNlLFxuICAgIHBydW5lVGFncyA9IGZhbHNlLFxuICB9KSB7XG4gICAgLy8gVmFsaWRhdGUgaW5wdXRcbiAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIHJlZnMudmFsdWVzKCkpIHtcbiAgICAgIGlmICghdmFsdWUubWF0Y2goL1swLTlhLWZdezQwfS8pKSB7XG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkT2lkRXJyb3IodmFsdWUpXG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGNvbmZpZyA9IGF3YWl0IEdpdENvbmZpZ01hbmFnZXIuZ2V0KHsgZnMsIGdpdGRpciB9KTtcbiAgICBpZiAoIXJlZnNwZWNzKSB7XG4gICAgICByZWZzcGVjcyA9IGF3YWl0IGNvbmZpZy5nZXRhbGwoYHJlbW90ZS4ke3JlbW90ZX0uZmV0Y2hgKTtcbiAgICAgIGlmIChyZWZzcGVjcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IE5vUmVmc3BlY0Vycm9yKHJlbW90ZSlcbiAgICAgIH1cbiAgICAgIC8vIFRoZXJlJ3Mgc29tZSBpbnRlcmVzdGluZyBiZWhhdmlvciB3aXRoIEhFQUQgdGhhdCBkb2Vzbid0IGZvbGxvdyB0aGUgcmVmc3BlYy5cbiAgICAgIHJlZnNwZWNzLnVuc2hpZnQoYCtIRUFEOnJlZnMvcmVtb3Rlcy8ke3JlbW90ZX0vSEVBRGApO1xuICAgIH1cbiAgICBjb25zdCByZWZzcGVjID0gR2l0UmVmU3BlY1NldC5mcm9tKHJlZnNwZWNzKTtcbiAgICBjb25zdCBhY3R1YWxSZWZzVG9Xcml0ZSA9IG5ldyBNYXAoKTtcbiAgICAvLyBEZWxldGUgYWxsIGN1cnJlbnQgdGFncyBpZiB0aGUgcHJ1bmVUYWdzIGFyZ3VtZW50IGlzIHRydWUuXG4gICAgaWYgKHBydW5lVGFncykge1xuICAgICAgY29uc3QgdGFncyA9IGF3YWl0IEdpdFJlZk1hbmFnZXIubGlzdFJlZnMoe1xuICAgICAgICBmcyxcbiAgICAgICAgZ2l0ZGlyLFxuICAgICAgICBmaWxlcGF0aDogJ3JlZnMvdGFncycsXG4gICAgICB9KTtcbiAgICAgIGF3YWl0IEdpdFJlZk1hbmFnZXIuZGVsZXRlUmVmcyh7XG4gICAgICAgIGZzLFxuICAgICAgICBnaXRkaXIsXG4gICAgICAgIHJlZnM6IHRhZ3MubWFwKHRhZyA9PiBgcmVmcy90YWdzLyR7dGFnfWApLFxuICAgICAgfSk7XG4gICAgfVxuICAgIC8vIEFkZCBhbGwgdGFncyBpZiB0aGUgZmV0Y2ggdGFncyBhcmd1bWVudCBpcyB0cnVlLlxuICAgIGlmICh0YWdzKSB7XG4gICAgICBmb3IgKGNvbnN0IHNlcnZlclJlZiBvZiByZWZzLmtleXMoKSkge1xuICAgICAgICBpZiAoc2VydmVyUmVmLnN0YXJ0c1dpdGgoJ3JlZnMvdGFncycpICYmICFzZXJ2ZXJSZWYuZW5kc1dpdGgoJ157fScpKSB7XG4gICAgICAgICAgLy8gR2l0J3MgYmVoYXZpb3IgaXMgdG8gb25seSBmZXRjaCB0YWdzIHRoYXQgZG8gbm90IGNvbmZsaWN0IHdpdGggdGFncyBhbHJlYWR5IHByZXNlbnQuXG4gICAgICAgICAgaWYgKCEoYXdhaXQgR2l0UmVmTWFuYWdlci5leGlzdHMoeyBmcywgZ2l0ZGlyLCByZWY6IHNlcnZlclJlZiB9KSkpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIGEgZGVyZWZlcmVuY2VkIGFuIGFubm90YXRlZCB0YWcgdmFsdWUgYXZhaWxhYmxlLCBwcmVmZXIgdGhhdC5cbiAgICAgICAgICAgIGNvbnN0IG9pZCA9IHJlZnMuZ2V0KHNlcnZlclJlZiArICdee30nKSB8fCByZWZzLmdldChzZXJ2ZXJSZWYpO1xuICAgICAgICAgICAgYWN0dWFsUmVmc1RvV3JpdGUuc2V0KHNlcnZlclJlZiwgb2lkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gQ29tYmluZSByZWZzIGFuZCBzeW1yZWZzIGdpdmluZyBzeW1yZWZzIHByaW9yaXR5XG4gICAgY29uc3QgcmVmVHJhbnNsYXRpb25zID0gcmVmc3BlYy50cmFuc2xhdGUoWy4uLnJlZnMua2V5cygpXSk7XG4gICAgZm9yIChjb25zdCBbc2VydmVyUmVmLCB0cmFuc2xhdGVkUmVmXSBvZiByZWZUcmFuc2xhdGlvbnMpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gcmVmcy5nZXQoc2VydmVyUmVmKTtcbiAgICAgIGFjdHVhbFJlZnNUb1dyaXRlLnNldCh0cmFuc2xhdGVkUmVmLCB2YWx1ZSk7XG4gICAgfVxuICAgIGNvbnN0IHN5bXJlZlRyYW5zbGF0aW9ucyA9IHJlZnNwZWMudHJhbnNsYXRlKFsuLi5zeW1yZWZzLmtleXMoKV0pO1xuICAgIGZvciAoY29uc3QgW3NlcnZlclJlZiwgdHJhbnNsYXRlZFJlZl0gb2Ygc3ltcmVmVHJhbnNsYXRpb25zKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IHN5bXJlZnMuZ2V0KHNlcnZlclJlZik7XG4gICAgICBjb25zdCBzeW10YXJnZXQgPSByZWZzcGVjLnRyYW5zbGF0ZU9uZSh2YWx1ZSk7XG4gICAgICBpZiAoc3ltdGFyZ2V0KSB7XG4gICAgICAgIGFjdHVhbFJlZnNUb1dyaXRlLnNldCh0cmFuc2xhdGVkUmVmLCBgcmVmOiAke3N5bXRhcmdldH1gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gSWYgYHBydW5lYCBhcmd1bWVudCBpcyB0cnVlLCBjbGVhciBvdXQgdGhlIGV4aXN0aW5nIGxvY2FsIHJlZnNwZWMgcm9vdHNcbiAgICBjb25zdCBwcnVuZWQgPSBbXTtcbiAgICBpZiAocHJ1bmUpIHtcbiAgICAgIGZvciAoY29uc3QgZmlsZXBhdGggb2YgcmVmc3BlYy5sb2NhbE5hbWVzcGFjZXMoKSkge1xuICAgICAgICBjb25zdCByZWZzID0gKFxuICAgICAgICAgIGF3YWl0IEdpdFJlZk1hbmFnZXIubGlzdFJlZnMoe1xuICAgICAgICAgICAgZnMsXG4gICAgICAgICAgICBnaXRkaXIsXG4gICAgICAgICAgICBmaWxlcGF0aCxcbiAgICAgICAgICB9KVxuICAgICAgICApLm1hcChmaWxlID0+IGAke2ZpbGVwYXRofS8ke2ZpbGV9YCk7XG4gICAgICAgIGZvciAoY29uc3QgcmVmIG9mIHJlZnMpIHtcbiAgICAgICAgICBpZiAoIWFjdHVhbFJlZnNUb1dyaXRlLmhhcyhyZWYpKSB7XG4gICAgICAgICAgICBwcnVuZWQucHVzaChyZWYpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHBydW5lZC5sZW5ndGggPiAwKSB7XG4gICAgICAgIGF3YWl0IEdpdFJlZk1hbmFnZXIuZGVsZXRlUmVmcyh7IGZzLCBnaXRkaXIsIHJlZnM6IHBydW5lZCB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gVXBkYXRlIGZpbGVzXG4gICAgLy8gVE9ETzogRm9yIGxhcmdlIHJlcG9zIHdpdGggYSBoaXN0b3J5IG9mIHRob3VzYW5kcyBvZiBwdWxsIHJlcXVlc3RzXG4gICAgLy8gKGkuZS4gZ2l0bGFiLWNlKSBpdCB3b3VsZCBiZSB2YXN0bHkgbW9yZSBlZmZpY2llbnQgdG8gd3JpdGUgdGhlbVxuICAgIC8vIHRvIC5naXQvcGFja2VkLXJlZnMuXG4gICAgLy8gVGhlIHRyaWNrIGlzIHRvIG1ha2Ugc3VyZSB3ZSBhKSBkb24ndCB3cml0ZSBhIHBhY2tlZCByZWYgdGhhdCBpc1xuICAgIC8vIGFscmVhZHkgc2hhZG93ZWQgYnkgYSBsb29zZSByZWYgYW5kIGIpIGRvbid0IGxvb3NlIGFueSByZWZzIGFscmVhZHlcbiAgICAvLyBpbiBwYWNrZWQtcmVmcy4gRG9pbmcgdGhpcyBlZmZpY2llbnRseSBtYXkgYmUgZGlmZmljdWx0LiBBXG4gICAgLy8gc29sdXRpb24gdGhhdCBtaWdodCB3b3JrIGlzXG4gICAgLy8gYSkgbG9hZCB0aGUgY3VycmVudCBwYWNrZWQtcmVmcyBmaWxlXG4gICAgLy8gYikgYWRkIGFjdHVhbFJlZnNUb1dyaXRlLCBvdmVycmlkaW5nIHRoZSBleGlzdGluZyB2YWx1ZXMgaWYgcHJlc2VudFxuICAgIC8vIGMpIGVudW1lcmF0ZSBhbGwgdGhlIGxvb3NlIHJlZnMgY3VycmVudGx5IGluIC5naXQvcmVmcy9yZW1vdGVzLyR7cmVtb3RlfVxuICAgIC8vIGQpIG92ZXJ3cml0ZSB0aGVpciB2YWx1ZSB3aXRoIHRoZSBuZXcgdmFsdWUuXG4gICAgLy8gRXhhbXBsZXMgb2YgcmVmcyB3ZSBuZWVkIHRvIGF2b2lkIHdyaXRpbmcgaW4gbG9vc2UgZm9ybWF0IGZvciBlZmZpY2llbnkncyBzYWtlXG4gICAgLy8gYXJlIC5naXQvcmVmcy9yZW1vdGVzL29yaWdpbi9yZWZzL3JlbW90ZXMvcmVtb3RlX21pcnJvcl8zMDU5XG4gICAgLy8gYW5kIC5naXQvcmVmcy9yZW1vdGVzL29yaWdpbi9yZWZzL21lcmdlLXJlcXVlc3RzXG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgYWN0dWFsUmVmc1RvV3JpdGUpIHtcbiAgICAgIGF3YWl0IGZzLndyaXRlKGpvaW4oZ2l0ZGlyLCBrZXkpLCBgJHt2YWx1ZS50cmltKCl9XFxuYCwgJ3V0ZjgnKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgcHJ1bmVkIH1cbiAgfVxuXG4gIC8vIFRPRE86IG1ha2UgdGhpcyBsZXNzIGNydWRlP1xuICBzdGF0aWMgYXN5bmMgd3JpdGVSZWYoeyBmcywgZ2l0ZGlyLCByZWYsIHZhbHVlIH0pIHtcbiAgICAvLyBWYWxpZGF0ZSBpbnB1dFxuICAgIGlmICghdmFsdWUubWF0Y2goL1swLTlhLWZdezQwfS8pKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZE9pZEVycm9yKHZhbHVlKVxuICAgIH1cbiAgICBhd2FpdCBmcy53cml0ZShqb2luKGdpdGRpciwgcmVmKSwgYCR7dmFsdWUudHJpbSgpfVxcbmAsICd1dGY4Jyk7XG4gIH1cblxuICBzdGF0aWMgYXN5bmMgd3JpdGVTeW1ib2xpY1JlZih7IGZzLCBnaXRkaXIsIHJlZiwgdmFsdWUgfSkge1xuICAgIGF3YWl0IGZzLndyaXRlKGpvaW4oZ2l0ZGlyLCByZWYpLCAncmVmOiAnICsgYCR7dmFsdWUudHJpbSgpfVxcbmAsICd1dGY4Jyk7XG4gIH1cblxuICBzdGF0aWMgYXN5bmMgZGVsZXRlUmVmKHsgZnMsIGdpdGRpciwgcmVmIH0pIHtcbiAgICByZXR1cm4gR2l0UmVmTWFuYWdlci5kZWxldGVSZWZzKHsgZnMsIGdpdGRpciwgcmVmczogW3JlZl0gfSlcbiAgfVxuXG4gIHN0YXRpYyBhc3luYyBkZWxldGVSZWZzKHsgZnMsIGdpdGRpciwgcmVmcyB9KSB7XG4gICAgLy8gRGVsZXRlIHJlZ3VsYXIgcmVmXG4gICAgYXdhaXQgUHJvbWlzZS5hbGwocmVmcy5tYXAocmVmID0+IGZzLnJtKGpvaW4oZ2l0ZGlyLCByZWYpKSkpO1xuICAgIC8vIERlbGV0ZSBhbnkgcGFja2VkIHJlZlxuICAgIGxldCB0ZXh0ID0gYXdhaXQgZnMucmVhZChgJHtnaXRkaXJ9L3BhY2tlZC1yZWZzYCwgeyBlbmNvZGluZzogJ3V0ZjgnIH0pO1xuICAgIGNvbnN0IHBhY2tlZCA9IEdpdFBhY2tlZFJlZnMuZnJvbSh0ZXh0KTtcbiAgICBjb25zdCBiZWZvcmVTaXplID0gcGFja2VkLnJlZnMuc2l6ZTtcbiAgICBmb3IgKGNvbnN0IHJlZiBvZiByZWZzKSB7XG4gICAgICBpZiAocGFja2VkLnJlZnMuaGFzKHJlZikpIHtcbiAgICAgICAgcGFja2VkLmRlbGV0ZShyZWYpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocGFja2VkLnJlZnMuc2l6ZSA8IGJlZm9yZVNpemUpIHtcbiAgICAgIHRleHQgPSBwYWNrZWQudG9TdHJpbmcoKTtcbiAgICAgIGF3YWl0IGZzLndyaXRlKGAke2dpdGRpcn0vcGFja2VkLXJlZnNgLCB0ZXh0LCB7IGVuY29kaW5nOiAndXRmOCcgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBhcmdzXG4gICAqIEBwYXJhbSB7aW1wb3J0KCcuLi9tb2RlbHMvRmlsZVN5c3RlbS5qcycpLkZpbGVTeXN0ZW19IGFyZ3MuZnNcbiAgICogQHBhcmFtIHtzdHJpbmd9IGFyZ3MuZ2l0ZGlyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhcmdzLnJlZlxuICAgKiBAcGFyYW0ge251bWJlcn0gW2FyZ3MuZGVwdGhdXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHN0cmluZz59XG4gICAqL1xuICBzdGF0aWMgYXN5bmMgcmVzb2x2ZSh7IGZzLCBnaXRkaXIsIHJlZiwgZGVwdGggPSB1bmRlZmluZWQgfSkge1xuICAgIGlmIChkZXB0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBkZXB0aC0tO1xuICAgICAgaWYgKGRlcHRoID09PSAtMSkge1xuICAgICAgICByZXR1cm4gcmVmXG4gICAgICB9XG4gICAgfVxuICAgIGxldCBzaGE7XG4gICAgLy8gSXMgaXQgYSByZWYgcG9pbnRlcj9cbiAgICBpZiAocmVmLnN0YXJ0c1dpdGgoJ3JlZjogJykpIHtcbiAgICAgIHJlZiA9IHJlZi5zbGljZSgncmVmOiAnLmxlbmd0aCk7XG4gICAgICByZXR1cm4gR2l0UmVmTWFuYWdlci5yZXNvbHZlKHsgZnMsIGdpdGRpciwgcmVmLCBkZXB0aCB9KVxuICAgIH1cbiAgICAvLyBJcyBpdCBhIGNvbXBsZXRlIGFuZCB2YWxpZCBTSEE/XG4gICAgaWYgKHJlZi5sZW5ndGggPT09IDQwICYmIC9bMC05YS1mXXs0MH0vLnRlc3QocmVmKSkge1xuICAgICAgcmV0dXJuIHJlZlxuICAgIH1cbiAgICAvLyBXZSBuZWVkIHRvIGFsdGVybmF0ZSBiZXR3ZWVuIHRoZSBmaWxlIHN5c3RlbSBhbmQgdGhlIHBhY2tlZC1yZWZzXG4gICAgY29uc3QgcGFja2VkTWFwID0gYXdhaXQgR2l0UmVmTWFuYWdlci5wYWNrZWRSZWZzKHsgZnMsIGdpdGRpciB9KTtcbiAgICAvLyBMb29rIGluIGFsbCB0aGUgcHJvcGVyIHBhdGhzLCBpbiB0aGlzIG9yZGVyXG4gICAgY29uc3QgYWxscGF0aHMgPSByZWZwYXRocyhyZWYpLmZpbHRlcihwID0+ICFHSVRfRklMRVMuaW5jbHVkZXMocCkpOyAvLyBleGNsdWRlIGdpdCBzeXN0ZW0gZmlsZXMgKCM3MDkpXG5cbiAgICBmb3IgKGNvbnN0IHJlZiBvZiBhbGxwYXRocykge1xuICAgICAgc2hhID1cbiAgICAgICAgKGF3YWl0IGZzLnJlYWQoYCR7Z2l0ZGlyfS8ke3JlZn1gLCB7IGVuY29kaW5nOiAndXRmOCcgfSkpIHx8XG4gICAgICAgIHBhY2tlZE1hcC5nZXQocmVmKTtcbiAgICAgIGlmIChzaGEpIHtcbiAgICAgICAgcmV0dXJuIEdpdFJlZk1hbmFnZXIucmVzb2x2ZSh7IGZzLCBnaXRkaXIsIHJlZjogc2hhLnRyaW0oKSwgZGVwdGggfSlcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gRG8gd2UgZ2l2ZSB1cD9cbiAgICB0aHJvdyBuZXcgTm90Rm91bmRFcnJvcihyZWYpXG4gIH1cblxuICBzdGF0aWMgYXN5bmMgZXhpc3RzKHsgZnMsIGdpdGRpciwgcmVmIH0pIHtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgR2l0UmVmTWFuYWdlci5leHBhbmQoeyBmcywgZ2l0ZGlyLCByZWYgfSk7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG5cbiAgc3RhdGljIGFzeW5jIGV4cGFuZCh7IGZzLCBnaXRkaXIsIHJlZiB9KSB7XG4gICAgLy8gSXMgaXQgYSBjb21wbGV0ZSBhbmQgdmFsaWQgU0hBP1xuICAgIGlmIChyZWYubGVuZ3RoID09PSA0MCAmJiAvWzAtOWEtZl17NDB9Ly50ZXN0KHJlZikpIHtcbiAgICAgIHJldHVybiByZWZcbiAgICB9XG4gICAgLy8gV2UgbmVlZCB0byBhbHRlcm5hdGUgYmV0d2VlbiB0aGUgZmlsZSBzeXN0ZW0gYW5kIHRoZSBwYWNrZWQtcmVmc1xuICAgIGNvbnN0IHBhY2tlZE1hcCA9IGF3YWl0IEdpdFJlZk1hbmFnZXIucGFja2VkUmVmcyh7IGZzLCBnaXRkaXIgfSk7XG4gICAgLy8gTG9vayBpbiBhbGwgdGhlIHByb3BlciBwYXRocywgaW4gdGhpcyBvcmRlclxuICAgIGNvbnN0IGFsbHBhdGhzID0gcmVmcGF0aHMocmVmKTtcbiAgICBmb3IgKGNvbnN0IHJlZiBvZiBhbGxwYXRocykge1xuICAgICAgaWYgKGF3YWl0IGZzLmV4aXN0cyhgJHtnaXRkaXJ9LyR7cmVmfWApKSByZXR1cm4gcmVmXG4gICAgICBpZiAocGFja2VkTWFwLmhhcyhyZWYpKSByZXR1cm4gcmVmXG4gICAgfVxuICAgIC8vIERvIHdlIGdpdmUgdXA/XG4gICAgdGhyb3cgbmV3IE5vdEZvdW5kRXJyb3IocmVmKVxuICB9XG5cbiAgc3RhdGljIGFzeW5jIGV4cGFuZEFnYWluc3RNYXAoeyByZWYsIG1hcCB9KSB7XG4gICAgLy8gTG9vayBpbiBhbGwgdGhlIHByb3BlciBwYXRocywgaW4gdGhpcyBvcmRlclxuICAgIGNvbnN0IGFsbHBhdGhzID0gcmVmcGF0aHMocmVmKTtcbiAgICBmb3IgKGNvbnN0IHJlZiBvZiBhbGxwYXRocykge1xuICAgICAgaWYgKGF3YWl0IG1hcC5oYXMocmVmKSkgcmV0dXJuIHJlZlxuICAgIH1cbiAgICAvLyBEbyB3ZSBnaXZlIHVwP1xuICAgIHRocm93IG5ldyBOb3RGb3VuZEVycm9yKHJlZilcbiAgfVxuXG4gIHN0YXRpYyByZXNvbHZlQWdhaW5zdE1hcCh7IHJlZiwgZnVsbHJlZiA9IHJlZiwgZGVwdGggPSB1bmRlZmluZWQsIG1hcCB9KSB7XG4gICAgaWYgKGRlcHRoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGRlcHRoLS07XG4gICAgICBpZiAoZGVwdGggPT09IC0xKSB7XG4gICAgICAgIHJldHVybiB7IGZ1bGxyZWYsIG9pZDogcmVmIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gSXMgaXQgYSByZWYgcG9pbnRlcj9cbiAgICBpZiAocmVmLnN0YXJ0c1dpdGgoJ3JlZjogJykpIHtcbiAgICAgIHJlZiA9IHJlZi5zbGljZSgncmVmOiAnLmxlbmd0aCk7XG4gICAgICByZXR1cm4gR2l0UmVmTWFuYWdlci5yZXNvbHZlQWdhaW5zdE1hcCh7IHJlZiwgZnVsbHJlZiwgZGVwdGgsIG1hcCB9KVxuICAgIH1cbiAgICAvLyBJcyBpdCBhIGNvbXBsZXRlIGFuZCB2YWxpZCBTSEE/XG4gICAgaWYgKHJlZi5sZW5ndGggPT09IDQwICYmIC9bMC05YS1mXXs0MH0vLnRlc3QocmVmKSkge1xuICAgICAgcmV0dXJuIHsgZnVsbHJlZiwgb2lkOiByZWYgfVxuICAgIH1cbiAgICAvLyBMb29rIGluIGFsbCB0aGUgcHJvcGVyIHBhdGhzLCBpbiB0aGlzIG9yZGVyXG4gICAgY29uc3QgYWxscGF0aHMgPSByZWZwYXRocyhyZWYpO1xuICAgIGZvciAoY29uc3QgcmVmIG9mIGFsbHBhdGhzKSB7XG4gICAgICBjb25zdCBzaGEgPSBtYXAuZ2V0KHJlZik7XG4gICAgICBpZiAoc2hhKSB7XG4gICAgICAgIHJldHVybiBHaXRSZWZNYW5hZ2VyLnJlc29sdmVBZ2FpbnN0TWFwKHtcbiAgICAgICAgICByZWY6IHNoYS50cmltKCksXG4gICAgICAgICAgZnVsbHJlZjogcmVmLFxuICAgICAgICAgIGRlcHRoLFxuICAgICAgICAgIG1hcCxcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gRG8gd2UgZ2l2ZSB1cD9cbiAgICB0aHJvdyBuZXcgTm90Rm91bmRFcnJvcihyZWYpXG4gIH1cblxuICBzdGF0aWMgYXN5bmMgcGFja2VkUmVmcyh7IGZzLCBnaXRkaXIgfSkge1xuICAgIGNvbnN0IHRleHQgPSBhd2FpdCBmcy5yZWFkKGAke2dpdGRpcn0vcGFja2VkLXJlZnNgLCB7IGVuY29kaW5nOiAndXRmOCcgfSk7XG4gICAgY29uc3QgcGFja2VkID0gR2l0UGFja2VkUmVmcy5mcm9tKHRleHQpO1xuICAgIHJldHVybiBwYWNrZWQucmVmc1xuICB9XG5cbiAgLy8gTGlzdCBhbGwgdGhlIHJlZnMgdGhhdCBtYXRjaCB0aGUgYGZpbGVwYXRoYCBwcmVmaXhcbiAgc3RhdGljIGFzeW5jIGxpc3RSZWZzKHsgZnMsIGdpdGRpciwgZmlsZXBhdGggfSkge1xuICAgIGNvbnN0IHBhY2tlZE1hcCA9IEdpdFJlZk1hbmFnZXIucGFja2VkUmVmcyh7IGZzLCBnaXRkaXIgfSk7XG4gICAgbGV0IGZpbGVzID0gbnVsbDtcbiAgICB0cnkge1xuICAgICAgZmlsZXMgPSBhd2FpdCBmcy5yZWFkZGlyRGVlcChgJHtnaXRkaXJ9LyR7ZmlsZXBhdGh9YCk7XG4gICAgICBmaWxlcyA9IGZpbGVzLm1hcCh4ID0+IHgucmVwbGFjZShgJHtnaXRkaXJ9LyR7ZmlsZXBhdGh9L2AsICcnKSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBmaWxlcyA9IFtdO1xuICAgIH1cblxuICAgIGZvciAobGV0IGtleSBvZiAoYXdhaXQgcGFja2VkTWFwKS5rZXlzKCkpIHtcbiAgICAgIC8vIGZpbHRlciBieSBwcmVmaXhcbiAgICAgIGlmIChrZXkuc3RhcnRzV2l0aChmaWxlcGF0aCkpIHtcbiAgICAgICAgLy8gcmVtb3ZlIHByZWZpeFxuICAgICAgICBrZXkgPSBrZXkucmVwbGFjZShmaWxlcGF0aCArICcvJywgJycpO1xuICAgICAgICAvLyBEb24ndCBpbmNsdWRlIGR1cGxpY2F0ZXM7IHRoZSBsb29zZSBmaWxlcyBoYXZlIHByZWNlZGVuY2UgYW55d2F5XG4gICAgICAgIGlmICghZmlsZXMuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgIGZpbGVzLnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBzaW5jZSB3ZSBqdXN0IGFwcGVuZGVkIHRoaW5ncyBvbnRvIGFuIGFycmF5LCB3ZSBuZWVkIHRvIHNvcnQgdGhlbSBub3dcbiAgICBmaWxlcy5zb3J0KGNvbXBhcmVSZWZOYW1lcyk7XG4gICAgcmV0dXJuIGZpbGVzXG4gIH1cblxuICBzdGF0aWMgYXN5bmMgbGlzdEJyYW5jaGVzKHsgZnMsIGdpdGRpciwgcmVtb3RlIH0pIHtcbiAgICBpZiAocmVtb3RlKSB7XG4gICAgICByZXR1cm4gR2l0UmVmTWFuYWdlci5saXN0UmVmcyh7XG4gICAgICAgIGZzLFxuICAgICAgICBnaXRkaXIsXG4gICAgICAgIGZpbGVwYXRoOiBgcmVmcy9yZW1vdGVzLyR7cmVtb3RlfWAsXG4gICAgICB9KVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gR2l0UmVmTWFuYWdlci5saXN0UmVmcyh7IGZzLCBnaXRkaXIsIGZpbGVwYXRoOiBgcmVmcy9oZWFkc2AgfSlcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgYXN5bmMgbGlzdFRhZ3MoeyBmcywgZ2l0ZGlyIH0pIHtcbiAgICBjb25zdCB0YWdzID0gYXdhaXQgR2l0UmVmTWFuYWdlci5saXN0UmVmcyh7XG4gICAgICBmcyxcbiAgICAgIGdpdGRpcixcbiAgICAgIGZpbGVwYXRoOiBgcmVmcy90YWdzYCxcbiAgICB9KTtcbiAgICByZXR1cm4gdGFncy5maWx0ZXIoeCA9PiAheC5lbmRzV2l0aCgnXnt9JykpXG4gIH1cbn1cblxuZnVuY3Rpb24gY29tcGFyZVRyZWVFbnRyeVBhdGgoYSwgYikge1xuICAvLyBHaXQgc29ydHMgdHJlZSBlbnRyaWVzIGFzIGlmIHRoZXJlIGlzIGEgdHJhaWxpbmcgc2xhc2ggb24gZGlyZWN0b3J5IG5hbWVzLlxuICByZXR1cm4gY29tcGFyZVN0cmluZ3MoYXBwZW5kU2xhc2hJZkRpcihhKSwgYXBwZW5kU2xhc2hJZkRpcihiKSlcbn1cblxuZnVuY3Rpb24gYXBwZW5kU2xhc2hJZkRpcihlbnRyeSkge1xuICByZXR1cm4gZW50cnkubW9kZSA9PT0gJzA0MDAwMCcgPyBlbnRyeS5wYXRoICsgJy8nIDogZW50cnkucGF0aFxufVxuXG4vKipcbiAqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBUcmVlRW50cnlcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBtb2RlIC0gdGhlIDYgZGlnaXQgaGV4YWRlY2ltYWwgbW9kZVxuICogQHByb3BlcnR5IHtzdHJpbmd9IHBhdGggLSB0aGUgbmFtZSBvZiB0aGUgZmlsZSBvciBkaXJlY3RvcnlcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBvaWQgLSB0aGUgU0hBLTEgb2JqZWN0IGlkIG9mIHRoZSBibG9iIG9yIHRyZWVcbiAqIEBwcm9wZXJ0eSB7J2NvbW1pdCd8J2Jsb2InfCd0cmVlJ30gdHlwZSAtIHRoZSB0eXBlIG9mIG9iamVjdFxuICovXG5cbmZ1bmN0aW9uIG1vZGUydHlwZSQxKG1vZGUpIHtcbiAgLy8gcHJldHRpZXItaWdub3JlXG4gIHN3aXRjaCAobW9kZSkge1xuICAgIGNhc2UgJzA0MDAwMCc6IHJldHVybiAndHJlZSdcbiAgICBjYXNlICcxMDA2NDQnOiByZXR1cm4gJ2Jsb2InXG4gICAgY2FzZSAnMTAwNzU1JzogcmV0dXJuICdibG9iJ1xuICAgIGNhc2UgJzEyMDAwMCc6IHJldHVybiAnYmxvYidcbiAgICBjYXNlICcxNjAwMDAnOiByZXR1cm4gJ2NvbW1pdCdcbiAgfVxuICB0aHJvdyBuZXcgSW50ZXJuYWxFcnJvcihgVW5leHBlY3RlZCBHaXRUcmVlIGVudHJ5IG1vZGU6ICR7bW9kZX1gKVxufVxuXG5mdW5jdGlvbiBwYXJzZUJ1ZmZlcihidWZmZXIpIHtcbiAgY29uc3QgX2VudHJpZXMgPSBbXTtcbiAgbGV0IGN1cnNvciA9IDA7XG4gIHdoaWxlIChjdXJzb3IgPCBidWZmZXIubGVuZ3RoKSB7XG4gICAgY29uc3Qgc3BhY2UgPSBidWZmZXIuaW5kZXhPZigzMiwgY3Vyc29yKTtcbiAgICBpZiAoc3BhY2UgPT09IC0xKSB7XG4gICAgICB0aHJvdyBuZXcgSW50ZXJuYWxFcnJvcihcbiAgICAgICAgYEdpdFRyZWU6IEVycm9yIHBhcnNpbmcgYnVmZmVyIGF0IGJ5dGUgbG9jYXRpb24gJHtjdXJzb3J9OiBDb3VsZCBub3QgZmluZCB0aGUgbmV4dCBzcGFjZSBjaGFyYWN0ZXIuYFxuICAgICAgKVxuICAgIH1cbiAgICBjb25zdCBudWxsY2hhciA9IGJ1ZmZlci5pbmRleE9mKDAsIGN1cnNvcik7XG4gICAgaWYgKG51bGxjaGFyID09PSAtMSkge1xuICAgICAgdGhyb3cgbmV3IEludGVybmFsRXJyb3IoXG4gICAgICAgIGBHaXRUcmVlOiBFcnJvciBwYXJzaW5nIGJ1ZmZlciBhdCBieXRlIGxvY2F0aW9uICR7Y3Vyc29yfTogQ291bGQgbm90IGZpbmQgdGhlIG5leHQgbnVsbCBjaGFyYWN0ZXIuYFxuICAgICAgKVxuICAgIH1cbiAgICBsZXQgbW9kZSA9IGJ1ZmZlci5zbGljZShjdXJzb3IsIHNwYWNlKS50b1N0cmluZygndXRmOCcpO1xuICAgIGlmIChtb2RlID09PSAnNDAwMDAnKSBtb2RlID0gJzA0MDAwMCc7IC8vIG1ha2VzIGl0IGxpbmUgdXAgbmVhdGVyIGluIHByaW50ZWQgb3V0cHV0XG4gICAgY29uc3QgdHlwZSA9IG1vZGUydHlwZSQxKG1vZGUpO1xuICAgIGNvbnN0IHBhdGggPSBidWZmZXIuc2xpY2Uoc3BhY2UgKyAxLCBudWxsY2hhcikudG9TdHJpbmcoJ3V0ZjgnKTtcbiAgICBjb25zdCBvaWQgPSBidWZmZXIuc2xpY2UobnVsbGNoYXIgKyAxLCBudWxsY2hhciArIDIxKS50b1N0cmluZygnaGV4Jyk7XG4gICAgY3Vyc29yID0gbnVsbGNoYXIgKyAyMTtcbiAgICBfZW50cmllcy5wdXNoKHsgbW9kZSwgcGF0aCwgb2lkLCB0eXBlIH0pO1xuICB9XG4gIHJldHVybiBfZW50cmllc1xufVxuXG5mdW5jdGlvbiBsaW1pdE1vZGVUb0FsbG93ZWQobW9kZSkge1xuICBpZiAodHlwZW9mIG1vZGUgPT09ICdudW1iZXInKSB7XG4gICAgbW9kZSA9IG1vZGUudG9TdHJpbmcoOCk7XG4gIH1cbiAgLy8gdHJlZVxuICBpZiAobW9kZS5tYXRjaCgvXjA/NC4qLykpIHJldHVybiAnMDQwMDAwJyAvLyBEaXJlY3RvcnlcbiAgaWYgKG1vZGUubWF0Y2goL14xMDA2LiovKSkgcmV0dXJuICcxMDA2NDQnIC8vIFJlZ3VsYXIgbm9uLWV4ZWN1dGFibGUgZmlsZVxuICBpZiAobW9kZS5tYXRjaCgvXjEwMDcuKi8pKSByZXR1cm4gJzEwMDc1NScgLy8gUmVndWxhciBleGVjdXRhYmxlIGZpbGVcbiAgaWYgKG1vZGUubWF0Y2goL14xMjAuKi8pKSByZXR1cm4gJzEyMDAwMCcgLy8gU3ltYm9saWMgbGlua1xuICBpZiAobW9kZS5tYXRjaCgvXjE2MC4qLykpIHJldHVybiAnMTYwMDAwJyAvLyBDb21taXQgKGdpdCBzdWJtb2R1bGUgcmVmZXJlbmNlKVxuICB0aHJvdyBuZXcgSW50ZXJuYWxFcnJvcihgQ291bGQgbm90IHVuZGVyc3RhbmQgZmlsZSBtb2RlOiAke21vZGV9YClcbn1cblxuZnVuY3Rpb24gbnVkZ2VJbnRvU2hhcGUoZW50cnkpIHtcbiAgaWYgKCFlbnRyeS5vaWQgJiYgZW50cnkuc2hhKSB7XG4gICAgZW50cnkub2lkID0gZW50cnkuc2hhOyAvLyBHaXRodWJcbiAgfVxuICBlbnRyeS5tb2RlID0gbGltaXRNb2RlVG9BbGxvd2VkKGVudHJ5Lm1vZGUpOyAvLyBpbmRleFxuICBpZiAoIWVudHJ5LnR5cGUpIHtcbiAgICBlbnRyeS50eXBlID0gbW9kZTJ0eXBlJDEoZW50cnkubW9kZSk7IC8vIGluZGV4XG4gIH1cbiAgcmV0dXJuIGVudHJ5XG59XG5cbmNsYXNzIEdpdFRyZWUge1xuICBjb25zdHJ1Y3RvcihlbnRyaWVzKSB7XG4gICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihlbnRyaWVzKSkge1xuICAgICAgdGhpcy5fZW50cmllcyA9IHBhcnNlQnVmZmVyKGVudHJpZXMpO1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShlbnRyaWVzKSkge1xuICAgICAgdGhpcy5fZW50cmllcyA9IGVudHJpZXMubWFwKG51ZGdlSW50b1NoYXBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEludGVybmFsRXJyb3IoJ2ludmFsaWQgdHlwZSBwYXNzZWQgdG8gR2l0VHJlZSBjb25zdHJ1Y3RvcicpXG4gICAgfVxuICAgIC8vIFRyZWUgZW50cmllcyBhcmUgbm90IHNvcnRlZCBhbHBoYWJldGljYWxseSBpbiB0aGUgdXN1YWwgc2Vuc2UgKHNlZSBgY29tcGFyZVRyZWVFbnRyeVBhdGhgKVxuICAgIC8vIGJ1dCBpdCBpcyBpbXBvcnRhbnQgbGF0ZXIgb24gdGhhdCB0aGVzZSBiZSBzb3J0ZWQgaW4gdGhlIHNhbWUgb3JkZXIgYXMgdGhleSB3b3VsZCBiZSByZXR1cm5lZCBmcm9tIHJlYWRkaXIuXG4gICAgdGhpcy5fZW50cmllcy5zb3J0KGNvbXBhcmVQYXRoKTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tKHRyZWUpIHtcbiAgICByZXR1cm4gbmV3IEdpdFRyZWUodHJlZSlcbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5fZW50cmllc1xuICAgICAgLm1hcChlbnRyeSA9PiBgJHtlbnRyeS5tb2RlfSAke2VudHJ5LnR5cGV9ICR7ZW50cnkub2lkfSAgICAke2VudHJ5LnBhdGh9YClcbiAgICAgIC5qb2luKCdcXG4nKVxuICB9XG5cbiAgdG9PYmplY3QoKSB7XG4gICAgLy8gQWRqdXN0IHRoZSBzb3J0IG9yZGVyIHRvIG1hdGNoIGdpdCdzXG4gICAgY29uc3QgZW50cmllcyA9IFsuLi50aGlzLl9lbnRyaWVzXTtcbiAgICBlbnRyaWVzLnNvcnQoY29tcGFyZVRyZWVFbnRyeVBhdGgpO1xuICAgIHJldHVybiBCdWZmZXIuY29uY2F0KFxuICAgICAgZW50cmllcy5tYXAoZW50cnkgPT4ge1xuICAgICAgICBjb25zdCBtb2RlID0gQnVmZmVyLmZyb20oZW50cnkubW9kZS5yZXBsYWNlKC9eMC8sICcnKSk7XG4gICAgICAgIGNvbnN0IHNwYWNlID0gQnVmZmVyLmZyb20oJyAnKTtcbiAgICAgICAgY29uc3QgcGF0aCA9IEJ1ZmZlci5mcm9tKGVudHJ5LnBhdGgsICd1dGY4Jyk7XG4gICAgICAgIGNvbnN0IG51bGxjaGFyID0gQnVmZmVyLmZyb20oWzBdKTtcbiAgICAgICAgY29uc3Qgb2lkID0gQnVmZmVyLmZyb20oZW50cnkub2lkLCAnaGV4Jyk7XG4gICAgICAgIHJldHVybiBCdWZmZXIuY29uY2F0KFttb2RlLCBzcGFjZSwgcGF0aCwgbnVsbGNoYXIsIG9pZF0pXG4gICAgICB9KVxuICAgIClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7VHJlZUVudHJ5W119XG4gICAqL1xuICBlbnRyaWVzKCkge1xuICAgIHJldHVybiB0aGlzLl9lbnRyaWVzXG4gIH1cblxuICAqW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgZm9yIChjb25zdCBlbnRyeSBvZiB0aGlzLl9lbnRyaWVzKSB7XG4gICAgICB5aWVsZCBlbnRyeTtcbiAgICB9XG4gIH1cbn1cblxuY2xhc3MgR2l0T2JqZWN0IHtcbiAgc3RhdGljIHdyYXAoeyB0eXBlLCBvYmplY3QgfSkge1xuICAgIHJldHVybiBCdWZmZXIuY29uY2F0KFtcbiAgICAgIEJ1ZmZlci5mcm9tKGAke3R5cGV9ICR7b2JqZWN0LmJ5dGVMZW5ndGgudG9TdHJpbmcoKX1cXHgwMGApLFxuICAgICAgQnVmZmVyLmZyb20ob2JqZWN0KSxcbiAgICBdKVxuICB9XG5cbiAgc3RhdGljIHVud3JhcChidWZmZXIpIHtcbiAgICBjb25zdCBzID0gYnVmZmVyLmluZGV4T2YoMzIpOyAvLyBmaXJzdCBzcGFjZVxuICAgIGNvbnN0IGkgPSBidWZmZXIuaW5kZXhPZigwKTsgLy8gZmlyc3QgbnVsbCB2YWx1ZVxuICAgIGNvbnN0IHR5cGUgPSBidWZmZXIuc2xpY2UoMCwgcykudG9TdHJpbmcoJ3V0ZjgnKTsgLy8gZ2V0IHR5cGUgb2Ygb2JqZWN0XG4gICAgY29uc3QgbGVuZ3RoID0gYnVmZmVyLnNsaWNlKHMgKyAxLCBpKS50b1N0cmluZygndXRmOCcpOyAvLyBnZXQgdHlwZSBvZiBvYmplY3RcbiAgICBjb25zdCBhY3R1YWxMZW5ndGggPSBidWZmZXIubGVuZ3RoIC0gKGkgKyAxKTtcbiAgICAvLyB2ZXJpZnkgbGVuZ3RoXG4gICAgaWYgKHBhcnNlSW50KGxlbmd0aCkgIT09IGFjdHVhbExlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEludGVybmFsRXJyb3IoXG4gICAgICAgIGBMZW5ndGggbWlzbWF0Y2g6IGV4cGVjdGVkICR7bGVuZ3RofSBieXRlcyBidXQgZ290ICR7YWN0dWFsTGVuZ3RofSBpbnN0ZWFkLmBcbiAgICAgIClcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGUsXG4gICAgICBvYmplY3Q6IEJ1ZmZlci5mcm9tKGJ1ZmZlci5zbGljZShpICsgMSkpLFxuICAgIH1cbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiByZWFkT2JqZWN0TG9vc2UoeyBmcywgZ2l0ZGlyLCBvaWQgfSkge1xuICBjb25zdCBzb3VyY2UgPSBgb2JqZWN0cy8ke29pZC5zbGljZSgwLCAyKX0vJHtvaWQuc2xpY2UoMil9YDtcbiAgY29uc3QgZmlsZSA9IGF3YWl0IGZzLnJlYWQoYCR7Z2l0ZGlyfS8ke3NvdXJjZX1gKTtcbiAgaWYgKCFmaWxlKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuICByZXR1cm4geyBvYmplY3Q6IGZpbGUsIGZvcm1hdDogJ2RlZmxhdGVkJywgc291cmNlIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0J1ZmZlcn0gZGVsdGFcbiAqIEBwYXJhbSB7QnVmZmVyfSBzb3VyY2VcbiAqIEByZXR1cm5zIHtCdWZmZXJ9XG4gKi9cbmZ1bmN0aW9uIGFwcGx5RGVsdGEoZGVsdGEsIHNvdXJjZSkge1xuICBjb25zdCByZWFkZXIgPSBuZXcgQnVmZmVyQ3Vyc29yKGRlbHRhKTtcbiAgY29uc3Qgc291cmNlU2l6ZSA9IHJlYWRWYXJJbnRMRShyZWFkZXIpO1xuXG4gIGlmIChzb3VyY2VTaXplICE9PSBzb3VyY2UuYnl0ZUxlbmd0aCkge1xuICAgIHRocm93IG5ldyBJbnRlcm5hbEVycm9yKFxuICAgICAgYGFwcGx5RGVsdGEgZXhwZWN0ZWQgc291cmNlIGJ1ZmZlciB0byBiZSAke3NvdXJjZVNpemV9IGJ5dGVzIGJ1dCB0aGUgcHJvdmlkZWQgYnVmZmVyIHdhcyAke3NvdXJjZS5sZW5ndGh9IGJ5dGVzYFxuICAgIClcbiAgfVxuICBjb25zdCB0YXJnZXRTaXplID0gcmVhZFZhckludExFKHJlYWRlcik7XG4gIGxldCB0YXJnZXQ7XG5cbiAgY29uc3QgZmlyc3RPcCA9IHJlYWRPcChyZWFkZXIsIHNvdXJjZSk7XG4gIC8vIFNwZWVkIG9wdGltaXphdGlvbiAtIHJldHVybiByYXcgYnVmZmVyIGlmIGl0J3MganVzdCBzaW5nbGUgc2ltcGxlIGNvcHlcbiAgaWYgKGZpcnN0T3AuYnl0ZUxlbmd0aCA9PT0gdGFyZ2V0U2l6ZSkge1xuICAgIHRhcmdldCA9IGZpcnN0T3A7XG4gIH0gZWxzZSB7XG4gICAgLy8gT3RoZXJ3aXNlLCBhbGxvY2F0ZSBhIGZyZXNoIGJ1ZmZlciBhbmQgc2xpY2VzXG4gICAgdGFyZ2V0ID0gQnVmZmVyLmFsbG9jKHRhcmdldFNpemUpO1xuICAgIGNvbnN0IHdyaXRlciA9IG5ldyBCdWZmZXJDdXJzb3IodGFyZ2V0KTtcbiAgICB3cml0ZXIuY29weShmaXJzdE9wKTtcblxuICAgIHdoaWxlICghcmVhZGVyLmVvZigpKSB7XG4gICAgICB3cml0ZXIuY29weShyZWFkT3AocmVhZGVyLCBzb3VyY2UpKTtcbiAgICB9XG5cbiAgICBjb25zdCB0ZWxsID0gd3JpdGVyLnRlbGwoKTtcbiAgICBpZiAodGFyZ2V0U2l6ZSAhPT0gdGVsbCkge1xuICAgICAgdGhyb3cgbmV3IEludGVybmFsRXJyb3IoXG4gICAgICAgIGBhcHBseURlbHRhIGV4cGVjdGVkIHRhcmdldCBidWZmZXIgdG8gYmUgJHt0YXJnZXRTaXplfSBieXRlcyBidXQgdGhlIHJlc3VsdGluZyBidWZmZXIgd2FzICR7dGVsbH0gYnl0ZXNgXG4gICAgICApXG4gICAgfVxuICB9XG4gIHJldHVybiB0YXJnZXRcbn1cblxuZnVuY3Rpb24gcmVhZFZhckludExFKHJlYWRlcikge1xuICBsZXQgcmVzdWx0ID0gMDtcbiAgbGV0IHNoaWZ0ID0gMDtcbiAgbGV0IGJ5dGUgPSBudWxsO1xuICBkbyB7XG4gICAgYnl0ZSA9IHJlYWRlci5yZWFkVUludDgoKTtcbiAgICByZXN1bHQgfD0gKGJ5dGUgJiAwYjAxMTExMTExKSA8PCBzaGlmdDtcbiAgICBzaGlmdCArPSA3O1xuICB9IHdoaWxlIChieXRlICYgMGIxMDAwMDAwMClcbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5mdW5jdGlvbiByZWFkQ29tcGFjdExFKHJlYWRlciwgZmxhZ3MsIHNpemUpIHtcbiAgbGV0IHJlc3VsdCA9IDA7XG4gIGxldCBzaGlmdCA9IDA7XG4gIHdoaWxlIChzaXplLS0pIHtcbiAgICBpZiAoZmxhZ3MgJiAwYjAwMDAwMDAxKSB7XG4gICAgICByZXN1bHQgfD0gcmVhZGVyLnJlYWRVSW50OCgpIDw8IHNoaWZ0O1xuICAgIH1cbiAgICBmbGFncyA+Pj0gMTtcbiAgICBzaGlmdCArPSA4O1xuICB9XG4gIHJldHVybiByZXN1bHRcbn1cblxuZnVuY3Rpb24gcmVhZE9wKHJlYWRlciwgc291cmNlKSB7XG4gIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICBjb25zdCBieXRlID0gcmVhZGVyLnJlYWRVSW50OCgpO1xuICBjb25zdCBDT1BZID0gMGIxMDAwMDAwMDtcbiAgY29uc3QgT0ZGUyA9IDBiMDAwMDExMTE7XG4gIGNvbnN0IFNJWkUgPSAwYjAxMTEwMDAwO1xuICBpZiAoYnl0ZSAmIENPUFkpIHtcbiAgICAvLyBjb3B5IGNvbnNpc3RzIG9mIDQgYnl0ZSBvZmZzZXQsIDMgYnl0ZSBzaXplIChpbiBMRSBvcmRlcilcbiAgICBjb25zdCBvZmZzZXQgPSByZWFkQ29tcGFjdExFKHJlYWRlciwgYnl0ZSAmIE9GRlMsIDQpO1xuICAgIGxldCBzaXplID0gcmVhZENvbXBhY3RMRShyZWFkZXIsIChieXRlICYgU0laRSkgPj4gNCwgMyk7XG4gICAgLy8gWXVwLiBUaGV5IHJlYWxseSBkaWQgdGhpcyBvcHRpbWl6YXRpb24uXG4gICAgaWYgKHNpemUgPT09IDApIHNpemUgPSAweDEwMDAwO1xuICAgIHJldHVybiBzb3VyY2Uuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBzaXplKVxuICB9IGVsc2Uge1xuICAgIC8vIGluc2VydFxuICAgIHJldHVybiByZWFkZXIuc2xpY2UoYnl0ZSlcbiAgfVxufVxuXG4vLyBDb252ZXJ0IGEgdmFsdWUgdG8gYW4gQXN5bmMgSXRlcmF0b3Jcbi8vIFRoaXMgd2lsbCBiZSBlYXNpZXIgd2l0aCBhc3luYyBnZW5lcmF0b3IgZnVuY3Rpb25zLlxuZnVuY3Rpb24gZnJvbVZhbHVlKHZhbHVlKSB7XG4gIGxldCBxdWV1ZSA9IFt2YWx1ZV07XG4gIHJldHVybiB7XG4gICAgbmV4dCgpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoeyBkb25lOiBxdWV1ZS5sZW5ndGggPT09IDAsIHZhbHVlOiBxdWV1ZS5wb3AoKSB9KVxuICAgIH0sXG4gICAgcmV0dXJuKCkge1xuICAgICAgcXVldWUgPSBbXTtcbiAgICAgIHJldHVybiB7fVxuICAgIH0sXG4gICAgW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpIHtcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfSxcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRJdGVyYXRvcihpdGVyYWJsZSkge1xuICBpZiAoaXRlcmFibGVbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKSB7XG4gICAgcmV0dXJuIGl0ZXJhYmxlW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpXG4gIH1cbiAgaWYgKGl0ZXJhYmxlW1N5bWJvbC5pdGVyYXRvcl0pIHtcbiAgICByZXR1cm4gaXRlcmFibGVbU3ltYm9sLml0ZXJhdG9yXSgpXG4gIH1cbiAgaWYgKGl0ZXJhYmxlLm5leHQpIHtcbiAgICByZXR1cm4gaXRlcmFibGVcbiAgfVxuICByZXR1cm4gZnJvbVZhbHVlKGl0ZXJhYmxlKVxufVxuXG4vLyBpbnNwaXJlZCBieSAnZ2FydGFsJyBidXQgbGlnaHRlci13ZWlnaHQgYW5kIG1vcmUgYmF0dGxlLXRlc3RlZC5cbmNsYXNzIFN0cmVhbVJlYWRlciB7XG4gIGNvbnN0cnVjdG9yKHN0cmVhbSkge1xuICAgIHRoaXMuc3RyZWFtID0gZ2V0SXRlcmF0b3Ioc3RyZWFtKTtcbiAgICB0aGlzLmJ1ZmZlciA9IG51bGw7XG4gICAgdGhpcy5jdXJzb3IgPSAwO1xuICAgIHRoaXMudW5kb0N1cnNvciA9IDA7XG4gICAgdGhpcy5zdGFydGVkID0gZmFsc2U7XG4gICAgdGhpcy5fZW5kZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9kaXNjYXJkZWRCeXRlcyA9IDA7XG4gIH1cblxuICBlb2YoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2VuZGVkICYmIHRoaXMuY3Vyc29yID09PSB0aGlzLmJ1ZmZlci5sZW5ndGhcbiAgfVxuXG4gIHRlbGwoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Rpc2NhcmRlZEJ5dGVzICsgdGhpcy5jdXJzb3JcbiAgfVxuXG4gIGFzeW5jIGJ5dGUoKSB7XG4gICAgaWYgKHRoaXMuZW9mKCkpIHJldHVyblxuICAgIGlmICghdGhpcy5zdGFydGVkKSBhd2FpdCB0aGlzLl9pbml0KCk7XG4gICAgaWYgKHRoaXMuY3Vyc29yID09PSB0aGlzLmJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgIGF3YWl0IHRoaXMuX2xvYWRuZXh0KCk7XG4gICAgICBpZiAodGhpcy5fZW5kZWQpIHJldHVyblxuICAgIH1cbiAgICB0aGlzLl9tb3ZlQ3Vyc29yKDEpO1xuICAgIHJldHVybiB0aGlzLmJ1ZmZlclt0aGlzLnVuZG9DdXJzb3JdXG4gIH1cblxuICBhc3luYyBjaHVuaygpIHtcbiAgICBpZiAodGhpcy5lb2YoKSkgcmV0dXJuXG4gICAgaWYgKCF0aGlzLnN0YXJ0ZWQpIGF3YWl0IHRoaXMuX2luaXQoKTtcbiAgICBpZiAodGhpcy5jdXJzb3IgPT09IHRoaXMuYnVmZmVyLmxlbmd0aCkge1xuICAgICAgYXdhaXQgdGhpcy5fbG9hZG5leHQoKTtcbiAgICAgIGlmICh0aGlzLl9lbmRlZCkgcmV0dXJuXG4gICAgfVxuICAgIHRoaXMuX21vdmVDdXJzb3IodGhpcy5idWZmZXIubGVuZ3RoKTtcbiAgICByZXR1cm4gdGhpcy5idWZmZXIuc2xpY2UodGhpcy51bmRvQ3Vyc29yLCB0aGlzLmN1cnNvcilcbiAgfVxuXG4gIGFzeW5jIHJlYWQobikge1xuICAgIGlmICh0aGlzLmVvZigpKSByZXR1cm5cbiAgICBpZiAoIXRoaXMuc3RhcnRlZCkgYXdhaXQgdGhpcy5faW5pdCgpO1xuICAgIGlmICh0aGlzLmN1cnNvciArIG4gPiB0aGlzLmJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgIHRoaXMuX3RyaW0oKTtcbiAgICAgIGF3YWl0IHRoaXMuX2FjY3VtdWxhdGUobik7XG4gICAgfVxuICAgIHRoaXMuX21vdmVDdXJzb3Iobik7XG4gICAgcmV0dXJuIHRoaXMuYnVmZmVyLnNsaWNlKHRoaXMudW5kb0N1cnNvciwgdGhpcy5jdXJzb3IpXG4gIH1cblxuICBhc3luYyBza2lwKG4pIHtcbiAgICBpZiAodGhpcy5lb2YoKSkgcmV0dXJuXG4gICAgaWYgKCF0aGlzLnN0YXJ0ZWQpIGF3YWl0IHRoaXMuX2luaXQoKTtcbiAgICBpZiAodGhpcy5jdXJzb3IgKyBuID4gdGhpcy5idWZmZXIubGVuZ3RoKSB7XG4gICAgICB0aGlzLl90cmltKCk7XG4gICAgICBhd2FpdCB0aGlzLl9hY2N1bXVsYXRlKG4pO1xuICAgIH1cbiAgICB0aGlzLl9tb3ZlQ3Vyc29yKG4pO1xuICB9XG5cbiAgYXN5bmMgdW5kbygpIHtcbiAgICB0aGlzLmN1cnNvciA9IHRoaXMudW5kb0N1cnNvcjtcbiAgfVxuXG4gIGFzeW5jIF9uZXh0KCkge1xuICAgIHRoaXMuc3RhcnRlZCA9IHRydWU7XG4gICAgbGV0IHsgZG9uZSwgdmFsdWUgfSA9IGF3YWl0IHRoaXMuc3RyZWFtLm5leHQoKTtcbiAgICBpZiAoZG9uZSkge1xuICAgICAgdGhpcy5fZW5kZWQgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIHZhbHVlID0gQnVmZmVyLmZyb20odmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWVcbiAgfVxuXG4gIF90cmltKCkge1xuICAgIC8vIFRocm93IGF3YXkgcGFydHMgb2YgdGhlIGJ1ZmZlciB3ZSBkb24ndCBuZWVkIGFueW1vcmVcbiAgICAvLyBhc3NlcnQodGhpcy5jdXJzb3IgPD0gdGhpcy5idWZmZXIubGVuZ3RoKVxuICAgIHRoaXMuYnVmZmVyID0gdGhpcy5idWZmZXIuc2xpY2UodGhpcy51bmRvQ3Vyc29yKTtcbiAgICB0aGlzLmN1cnNvciAtPSB0aGlzLnVuZG9DdXJzb3I7XG4gICAgdGhpcy5fZGlzY2FyZGVkQnl0ZXMgKz0gdGhpcy51bmRvQ3Vyc29yO1xuICAgIHRoaXMudW5kb0N1cnNvciA9IDA7XG4gIH1cblxuICBfbW92ZUN1cnNvcihuKSB7XG4gICAgdGhpcy51bmRvQ3Vyc29yID0gdGhpcy5jdXJzb3I7XG4gICAgdGhpcy5jdXJzb3IgKz0gbjtcbiAgICBpZiAodGhpcy5jdXJzb3IgPiB0aGlzLmJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgIHRoaXMuY3Vyc29yID0gdGhpcy5idWZmZXIubGVuZ3RoO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIF9hY2N1bXVsYXRlKG4pIHtcbiAgICBpZiAodGhpcy5fZW5kZWQpIHJldHVyblxuICAgIC8vIEV4cGFuZCB0aGUgYnVmZmVyIHVudGlsIHdlIGhhdmUgTiBieXRlcyBvZiBkYXRhXG4gICAgLy8gb3Igd2UndmUgcmVhY2hlZCB0aGUgZW5kIG9mIHRoZSBzdHJlYW1cbiAgICBjb25zdCBidWZmZXJzID0gW3RoaXMuYnVmZmVyXTtcbiAgICB3aGlsZSAodGhpcy5jdXJzb3IgKyBuID4gbGVuZ3RoQnVmZmVycyhidWZmZXJzKSkge1xuICAgICAgY29uc3QgbmV4dGJ1ZmZlciA9IGF3YWl0IHRoaXMuX25leHQoKTtcbiAgICAgIGlmICh0aGlzLl9lbmRlZCkgYnJlYWtcbiAgICAgIGJ1ZmZlcnMucHVzaChuZXh0YnVmZmVyKTtcbiAgICB9XG4gICAgdGhpcy5idWZmZXIgPSBCdWZmZXIuY29uY2F0KGJ1ZmZlcnMpO1xuICB9XG5cbiAgYXN5bmMgX2xvYWRuZXh0KCkge1xuICAgIHRoaXMuX2Rpc2NhcmRlZEJ5dGVzICs9IHRoaXMuYnVmZmVyLmxlbmd0aDtcbiAgICB0aGlzLnVuZG9DdXJzb3IgPSAwO1xuICAgIHRoaXMuY3Vyc29yID0gMDtcbiAgICB0aGlzLmJ1ZmZlciA9IGF3YWl0IHRoaXMuX25leHQoKTtcbiAgfVxuXG4gIGFzeW5jIF9pbml0KCkge1xuICAgIHRoaXMuYnVmZmVyID0gYXdhaXQgdGhpcy5fbmV4dCgpO1xuICB9XG59XG5cbi8vIFRoaXMgaGVscGVyIGZ1bmN0aW9uIGhlbHBzIHVzIHBvc3Rwb25lIGNvbmNhdGVuYXRpbmcgYnVmZmVycywgd2hpY2hcbi8vIHdvdWxkIGNyZWF0ZSBpbnRlcm1lZGlhdGUgYnVmZmVyIG9iamVjdHMsXG5mdW5jdGlvbiBsZW5ndGhCdWZmZXJzKGJ1ZmZlcnMpIHtcbiAgcmV0dXJuIGJ1ZmZlcnMucmVkdWNlKChhY2MsIGJ1ZmZlcikgPT4gYWNjICsgYnVmZmVyLmxlbmd0aCwgMClcbn1cblxuLy8gTXkgdmVyc2lvbiBvZiBnaXQtbGlzdC1wYWNrIC0gcm91Z2hseSAxNXggZmFzdGVyIHRoYW4gdGhlIG9yaWdpbmFsXG5cbmFzeW5jIGZ1bmN0aW9uIGxpc3RwYWNrKHN0cmVhbSwgb25EYXRhKSB7XG4gIGNvbnN0IHJlYWRlciA9IG5ldyBTdHJlYW1SZWFkZXIoc3RyZWFtKTtcbiAgbGV0IFBBQ0sgPSBhd2FpdCByZWFkZXIucmVhZCg0KTtcbiAgUEFDSyA9IFBBQ0sudG9TdHJpbmcoJ3V0ZjgnKTtcbiAgaWYgKFBBQ0sgIT09ICdQQUNLJykge1xuICAgIHRocm93IG5ldyBJbnRlcm5hbEVycm9yKGBJbnZhbGlkIFBBQ0sgaGVhZGVyICcke1BBQ0t9J2ApXG4gIH1cblxuICBsZXQgdmVyc2lvbiA9IGF3YWl0IHJlYWRlci5yZWFkKDQpO1xuICB2ZXJzaW9uID0gdmVyc2lvbi5yZWFkVUludDMyQkUoMCk7XG4gIGlmICh2ZXJzaW9uICE9PSAyKSB7XG4gICAgdGhyb3cgbmV3IEludGVybmFsRXJyb3IoYEludmFsaWQgcGFja2ZpbGUgdmVyc2lvbjogJHt2ZXJzaW9ufWApXG4gIH1cblxuICBsZXQgbnVtT2JqZWN0cyA9IGF3YWl0IHJlYWRlci5yZWFkKDQpO1xuICBudW1PYmplY3RzID0gbnVtT2JqZWN0cy5yZWFkVUludDMyQkUoMCk7XG4gIC8vIElmIChmb3Igc29tZSBnb2Rmb3JzYWtlbiByZWFzb24pIHRoaXMgaXMgYW4gZW1wdHkgcGFja2ZpbGUsIGFib3J0IG5vdy5cbiAgaWYgKG51bU9iamVjdHMgPCAxKSByZXR1cm5cblxuICB3aGlsZSAoIXJlYWRlci5lb2YoKSAmJiBudW1PYmplY3RzLS0pIHtcbiAgICBjb25zdCBvZmZzZXQgPSByZWFkZXIudGVsbCgpO1xuICAgIGNvbnN0IHsgdHlwZSwgbGVuZ3RoLCBvZnMsIHJlZmVyZW5jZSB9ID0gYXdhaXQgcGFyc2VIZWFkZXIocmVhZGVyKTtcbiAgICBjb25zdCBpbmZsYXRvciA9IG5ldyBwYWtvLkluZmxhdGUoKTtcbiAgICB3aGlsZSAoIWluZmxhdG9yLnJlc3VsdCkge1xuICAgICAgY29uc3QgY2h1bmsgPSBhd2FpdCByZWFkZXIuY2h1bmsoKTtcbiAgICAgIGlmIChyZWFkZXIuZW5kZWQpIGJyZWFrXG4gICAgICBpbmZsYXRvci5wdXNoKGNodW5rLCBmYWxzZSk7XG4gICAgICBpZiAoaW5mbGF0b3IuZXJyKSB7XG4gICAgICAgIHRocm93IG5ldyBJbnRlcm5hbEVycm9yKGBQYWtvIGVycm9yOiAke2luZmxhdG9yLm1zZ31gKVxuICAgICAgfVxuICAgICAgaWYgKGluZmxhdG9yLnJlc3VsdCkge1xuICAgICAgICBpZiAoaW5mbGF0b3IucmVzdWx0Lmxlbmd0aCAhPT0gbGVuZ3RoKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEludGVybmFsRXJyb3IoXG4gICAgICAgICAgICBgSW5mbGF0ZWQgb2JqZWN0IHNpemUgaXMgZGlmZmVyZW50IGZyb20gdGhhdCBzdGF0ZWQgaW4gcGFja2ZpbGUuYFxuICAgICAgICAgIClcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEJhY2t0cmFjayBwYXJzZXIgdG8gd2hlcmUgZGVmbGF0ZWQgZGF0YSBlbmRzXG4gICAgICAgIGF3YWl0IHJlYWRlci51bmRvKCk7XG4gICAgICAgIGF3YWl0IHJlYWRlci5yZWFkKGNodW5rLmxlbmd0aCAtIGluZmxhdG9yLnN0cm0uYXZhaWxfaW4pO1xuICAgICAgICBjb25zdCBlbmQgPSByZWFkZXIudGVsbCgpO1xuICAgICAgICBhd2FpdCBvbkRhdGEoe1xuICAgICAgICAgIGRhdGE6IGluZmxhdG9yLnJlc3VsdCxcbiAgICAgICAgICB0eXBlLFxuICAgICAgICAgIG51bTogbnVtT2JqZWN0cyxcbiAgICAgICAgICBvZmZzZXQsXG4gICAgICAgICAgZW5kLFxuICAgICAgICAgIHJlZmVyZW5jZSxcbiAgICAgICAgICBvZnMsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBwYXJzZUhlYWRlcihyZWFkZXIpIHtcbiAgLy8gT2JqZWN0IHR5cGUgaXMgZW5jb2RlZCBpbiBiaXRzIDY1NFxuICBsZXQgYnl0ZSA9IGF3YWl0IHJlYWRlci5ieXRlKCk7XG4gIGNvbnN0IHR5cGUgPSAoYnl0ZSA+PiA0KSAmIDBiMTExO1xuICAvLyBUaGUgbGVuZ3RoIGVuY29kaW5nIGdldCBjb21wbGljYXRlZC5cbiAgLy8gTGFzdCBmb3VyIGJpdHMgb2YgbGVuZ3RoIGlzIGVuY29kZWQgaW4gYml0cyAzMjEwXG4gIGxldCBsZW5ndGggPSBieXRlICYgMGIxMTExO1xuICAvLyBXaGV0aGVyIHRoZSBuZXh0IGJ5dGUgaXMgcGFydCBvZiB0aGUgdmFyaWFibGUtbGVuZ3RoIGVuY29kZWQgbnVtYmVyXG4gIC8vIGlzIGVuY29kZWQgaW4gYml0IDdcbiAgaWYgKGJ5dGUgJiAwYjEwMDAwMDAwKSB7XG4gICAgbGV0IHNoaWZ0ID0gNDtcbiAgICBkbyB7XG4gICAgICBieXRlID0gYXdhaXQgcmVhZGVyLmJ5dGUoKTtcbiAgICAgIGxlbmd0aCB8PSAoYnl0ZSAmIDBiMDExMTExMTEpIDw8IHNoaWZ0O1xuICAgICAgc2hpZnQgKz0gNztcbiAgICB9IHdoaWxlIChieXRlICYgMGIxMDAwMDAwMClcbiAgfVxuICAvLyBIYW5kbGUgZGVsdGlmaWVkIG9iamVjdHNcbiAgbGV0IG9mcztcbiAgbGV0IHJlZmVyZW5jZTtcbiAgaWYgKHR5cGUgPT09IDYpIHtcbiAgICBsZXQgc2hpZnQgPSAwO1xuICAgIG9mcyA9IDA7XG4gICAgY29uc3QgYnl0ZXMgPSBbXTtcbiAgICBkbyB7XG4gICAgICBieXRlID0gYXdhaXQgcmVhZGVyLmJ5dGUoKTtcbiAgICAgIG9mcyB8PSAoYnl0ZSAmIDBiMDExMTExMTEpIDw8IHNoaWZ0O1xuICAgICAgc2hpZnQgKz0gNztcbiAgICAgIGJ5dGVzLnB1c2goYnl0ZSk7XG4gICAgfSB3aGlsZSAoYnl0ZSAmIDBiMTAwMDAwMDApXG4gICAgcmVmZXJlbmNlID0gQnVmZmVyLmZyb20oYnl0ZXMpO1xuICB9XG4gIGlmICh0eXBlID09PSA3KSB7XG4gICAgY29uc3QgYnVmID0gYXdhaXQgcmVhZGVyLnJlYWQoMjApO1xuICAgIHJlZmVyZW5jZSA9IGJ1ZjtcbiAgfVxuICByZXR1cm4geyB0eXBlLCBsZW5ndGgsIG9mcywgcmVmZXJlbmNlIH1cbn1cblxuLyogZXNsaW50LWVudiBub2RlLCBicm93c2VyICovXG5cbmxldCBzdXBwb3J0c0RlY29tcHJlc3Npb25TdHJlYW0gPSBmYWxzZTtcblxuYXN5bmMgZnVuY3Rpb24gaW5mbGF0ZShidWZmZXIpIHtcbiAgaWYgKHN1cHBvcnRzRGVjb21wcmVzc2lvblN0cmVhbSA9PT0gbnVsbCkge1xuICAgIHN1cHBvcnRzRGVjb21wcmVzc2lvblN0cmVhbSA9IHRlc3REZWNvbXByZXNzaW9uU3RyZWFtKCk7XG4gIH1cbiAgcmV0dXJuIHN1cHBvcnRzRGVjb21wcmVzc2lvblN0cmVhbVxuICAgID8gYnJvd3NlckluZmxhdGUoYnVmZmVyKVxuICAgIDogcGFrby5pbmZsYXRlKGJ1ZmZlcilcbn1cblxuYXN5bmMgZnVuY3Rpb24gYnJvd3NlckluZmxhdGUoYnVmZmVyKSB7XG4gIGNvbnN0IGRzID0gbmV3IERlY29tcHJlc3Npb25TdHJlYW0oJ2RlZmxhdGUnKTtcbiAgY29uc3QgZCA9IG5ldyBCbG9iKFtidWZmZXJdKS5zdHJlYW0oKS5waXBlVGhyb3VnaChkcyk7XG4gIHJldHVybiBuZXcgVWludDhBcnJheShhd2FpdCBuZXcgUmVzcG9uc2UoZCkuYXJyYXlCdWZmZXIoKSlcbn1cblxuZnVuY3Rpb24gdGVzdERlY29tcHJlc3Npb25TdHJlYW0oKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgZHMgPSBuZXcgRGVjb21wcmVzc2lvblN0cmVhbSgnZGVmbGF0ZScpO1xuICAgIGlmIChkcykgcmV0dXJuIHRydWVcbiAgfSBjYXRjaCAoXykge1xuICAgIC8vIG5vIGJvdGhlclxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBkZWNvZGVWYXJJbnQocmVhZGVyKSB7XG4gIGNvbnN0IGJ5dGVzID0gW107XG4gIGxldCBieXRlID0gMDtcbiAgbGV0IG11bHRpYnl0ZSA9IDA7XG4gIGRvIHtcbiAgICBieXRlID0gcmVhZGVyLnJlYWRVSW50OCgpO1xuICAgIC8vIFdlIGtlZXAgYml0cyA2NTQzMjEwXG4gICAgY29uc3QgbGFzdFNldmVuID0gYnl0ZSAmIDBiMDExMTExMTE7XG4gICAgYnl0ZXMucHVzaChsYXN0U2V2ZW4pO1xuICAgIC8vIFdoZXRoZXIgdGhlIG5leHQgYnl0ZSBpcyBwYXJ0IG9mIHRoZSB2YXJpYWJsZS1sZW5ndGggZW5jb2RlZCBudW1iZXJcbiAgICAvLyBpcyBlbmNvZGVkIGluIGJpdCA3XG4gICAgbXVsdGlieXRlID0gYnl0ZSAmIDBiMTAwMDAwMDA7XG4gIH0gd2hpbGUgKG11bHRpYnl0ZSlcbiAgLy8gTm93IHRoYXQgYWxsIHRoZSBieXRlcyBhcmUgaW4gYmlnLWVuZGlhbiBvcmRlcixcbiAgLy8gYWx0ZXJuYXRlIHNoaWZ0aW5nIHRoZSBiaXRzIGxlZnQgYnkgNyBhbmQgT1ItaW5nIHRoZSBuZXh0IGJ5dGUuXG4gIC8vIEFuZC4uLiBkbyBhIHdlaXJkIGluY3JlbWVudC1ieS1vbmUgdGhpbmcgdGhhdCBJIGRvbid0IHF1aXRlIHVuZGVyc3RhbmQuXG4gIHJldHVybiBieXRlcy5yZWR1Y2UoKGEsIGIpID0+ICgoYSArIDEpIDw8IDcpIHwgYiwgLTEpXG59XG5cbi8vIEknbSBwcmV0dHkgbXVjaCBjb3B5aW5nIHRoaXMgb25lIGZyb20gdGhlIGdpdCBDIHNvdXJjZSBjb2RlLFxuLy8gYmVjYXVzZSBpdCBtYWtlcyBubyBzZW5zZS5cbmZ1bmN0aW9uIG90aGVyVmFySW50RGVjb2RlKHJlYWRlciwgc3RhcnRXaXRoKSB7XG4gIGxldCByZXN1bHQgPSBzdGFydFdpdGg7XG4gIGxldCBzaGlmdCA9IDQ7XG4gIGxldCBieXRlID0gbnVsbDtcbiAgZG8ge1xuICAgIGJ5dGUgPSByZWFkZXIucmVhZFVJbnQ4KCk7XG4gICAgcmVzdWx0IHw9IChieXRlICYgMGIwMTExMTExMSkgPDwgc2hpZnQ7XG4gICAgc2hpZnQgKz0gNztcbiAgfSB3aGlsZSAoYnl0ZSAmIDBiMTAwMDAwMDApXG4gIHJldHVybiByZXN1bHRcbn1cblxuY2xhc3MgR2l0UGFja0luZGV4IHtcbiAgY29uc3RydWN0b3Ioc3R1ZmYpIHtcbiAgICBPYmplY3QuYXNzaWduKHRoaXMsIHN0dWZmKTtcbiAgICB0aGlzLm9mZnNldENhY2hlID0ge307XG4gIH1cblxuICBzdGF0aWMgYXN5bmMgZnJvbUlkeCh7IGlkeCwgZ2V0RXh0ZXJuYWxSZWZEZWx0YSB9KSB7XG4gICAgY29uc3QgcmVhZGVyID0gbmV3IEJ1ZmZlckN1cnNvcihpZHgpO1xuICAgIGNvbnN0IG1hZ2ljID0gcmVhZGVyLnNsaWNlKDQpLnRvU3RyaW5nKCdoZXgnKTtcbiAgICAvLyBDaGVjayBmb3IgSURYIHYyIG1hZ2ljIG51bWJlclxuICAgIGlmIChtYWdpYyAhPT0gJ2ZmNzQ0ZjYzJykge1xuICAgICAgcmV0dXJuIC8vIHVuZGVmaW5lZFxuICAgIH1cbiAgICBjb25zdCB2ZXJzaW9uID0gcmVhZGVyLnJlYWRVSW50MzJCRSgpO1xuICAgIGlmICh2ZXJzaW9uICE9PSAyKSB7XG4gICAgICB0aHJvdyBuZXcgSW50ZXJuYWxFcnJvcihcbiAgICAgICAgYFVuYWJsZSB0byByZWFkIHZlcnNpb24gJHt2ZXJzaW9ufSBwYWNrZmlsZSBJRFguIChPbmx5IHZlcnNpb24gMiBzdXBwb3J0ZWQpYFxuICAgICAgKVxuICAgIH1cbiAgICBpZiAoaWR4LmJ5dGVMZW5ndGggPiAyMDQ4ICogMTAyNCAqIDEwMjQpIHtcbiAgICAgIHRocm93IG5ldyBJbnRlcm5hbEVycm9yKFxuICAgICAgICBgVG8ga2VlcCBpbXBsZW1lbnRhdGlvbiBzaW1wbGUsIEkgaGF2ZW4ndCBpbXBsZW1lbnRlZCB0aGUgbGF5ZXIgNSBmZWF0dXJlIG5lZWRlZCB0byBzdXBwb3J0IHBhY2tmaWxlcyA+IDJHQiBpbiBzaXplLmBcbiAgICAgIClcbiAgICB9XG4gICAgLy8gU2tpcCBvdmVyIGZhbm91dCB0YWJsZVxuICAgIHJlYWRlci5zZWVrKHJlYWRlci50ZWxsKCkgKyA0ICogMjU1KTtcbiAgICAvLyBHZXQgaGFzaGVzXG4gICAgY29uc3Qgc2l6ZSA9IHJlYWRlci5yZWFkVUludDMyQkUoKTtcbiAgICBjb25zdCBoYXNoZXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgICAgY29uc3QgaGFzaCA9IHJlYWRlci5zbGljZSgyMCkudG9TdHJpbmcoJ2hleCcpO1xuICAgICAgaGFzaGVzW2ldID0gaGFzaDtcbiAgICB9XG4gICAgcmVhZGVyLnNlZWsocmVhZGVyLnRlbGwoKSArIDQgKiBzaXplKTtcbiAgICAvLyBTa2lwIG92ZXIgQ1JDc1xuICAgIC8vIEdldCBvZmZzZXRzXG4gICAgY29uc3Qgb2Zmc2V0cyA9IG5ldyBNYXAoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgICAgb2Zmc2V0cy5zZXQoaGFzaGVzW2ldLCByZWFkZXIucmVhZFVJbnQzMkJFKCkpO1xuICAgIH1cbiAgICBjb25zdCBwYWNrZmlsZVNoYSA9IHJlYWRlci5zbGljZSgyMCkudG9TdHJpbmcoJ2hleCcpO1xuICAgIHJldHVybiBuZXcgR2l0UGFja0luZGV4KHtcbiAgICAgIGhhc2hlcyxcbiAgICAgIGNyY3M6IHt9LFxuICAgICAgb2Zmc2V0cyxcbiAgICAgIHBhY2tmaWxlU2hhLFxuICAgICAgZ2V0RXh0ZXJuYWxSZWZEZWx0YSxcbiAgICB9KVxuICB9XG5cbiAgc3RhdGljIGFzeW5jIGZyb21QYWNrKHsgcGFjaywgZ2V0RXh0ZXJuYWxSZWZEZWx0YSwgb25Qcm9ncmVzcyB9KSB7XG4gICAgY29uc3QgbGlzdHBhY2tUeXBlcyA9IHtcbiAgICAgIDE6ICdjb21taXQnLFxuICAgICAgMjogJ3RyZWUnLFxuICAgICAgMzogJ2Jsb2InLFxuICAgICAgNDogJ3RhZycsXG4gICAgICA2OiAnb2ZzLWRlbHRhJyxcbiAgICAgIDc6ICdyZWYtZGVsdGEnLFxuICAgIH07XG4gICAgY29uc3Qgb2Zmc2V0VG9PYmplY3QgPSB7fTtcblxuICAgIC8vIE9sZGVyIHBhY2tmaWxlcyBkbyBOT1QgdXNlIHRoZSBzaGFzdW0gb2YgdGhlIHBhY2sgaXRzZWxmLFxuICAgIC8vIHNvIGl0IGlzIHJlY29tbWVuZGVkIHRvIGp1c3QgdXNlIHdoYXRldmVyIGJ5dGVzIGFyZSBpbiB0aGUgdHJhaWxlci5cbiAgICAvLyBTb3VyY2U6IGh0dHBzOi8vZ2l0aHViLmNvbS9naXQvZ2l0L2NvbW1pdC8xMTkwYTFhY2Y4MDBhY2RjZmQ3NTY5Zjg3YWMxNTYwZTJkMDc3NDE0XG4gICAgY29uc3QgcGFja2ZpbGVTaGEgPSBwYWNrLnNsaWNlKC0yMCkudG9TdHJpbmcoJ2hleCcpO1xuXG4gICAgY29uc3QgaGFzaGVzID0gW107XG4gICAgY29uc3QgY3JjcyA9IHt9O1xuICAgIGNvbnN0IG9mZnNldHMgPSBuZXcgTWFwKCk7XG4gICAgbGV0IHRvdGFsT2JqZWN0Q291bnQgPSBudWxsO1xuICAgIGxldCBsYXN0UGVyY2VudCA9IG51bGw7XG5cbiAgICBhd2FpdCBsaXN0cGFjayhbcGFja10sIGFzeW5jICh7IGRhdGEsIHR5cGUsIHJlZmVyZW5jZSwgb2Zmc2V0LCBudW0gfSkgPT4ge1xuICAgICAgaWYgKHRvdGFsT2JqZWN0Q291bnQgPT09IG51bGwpIHRvdGFsT2JqZWN0Q291bnQgPSBudW07XG4gICAgICBjb25zdCBwZXJjZW50ID0gTWF0aC5mbG9vcihcbiAgICAgICAgKCh0b3RhbE9iamVjdENvdW50IC0gbnVtKSAqIDEwMCkgLyB0b3RhbE9iamVjdENvdW50XG4gICAgICApO1xuICAgICAgaWYgKHBlcmNlbnQgIT09IGxhc3RQZXJjZW50KSB7XG4gICAgICAgIGlmIChvblByb2dyZXNzKSB7XG4gICAgICAgICAgYXdhaXQgb25Qcm9ncmVzcyh7XG4gICAgICAgICAgICBwaGFzZTogJ1JlY2VpdmluZyBvYmplY3RzJyxcbiAgICAgICAgICAgIGxvYWRlZDogdG90YWxPYmplY3RDb3VudCAtIG51bSxcbiAgICAgICAgICAgIHRvdGFsOiB0b3RhbE9iamVjdENvdW50LFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBsYXN0UGVyY2VudCA9IHBlcmNlbnQ7XG4gICAgICAvLyBDaGFuZ2UgdHlwZSBmcm9tIGEgbnVtYmVyIHRvIGEgbWVhbmluZ2Z1bCBzdHJpbmdcbiAgICAgIHR5cGUgPSBsaXN0cGFja1R5cGVzW3R5cGVdO1xuXG4gICAgICBpZiAoWydjb21taXQnLCAndHJlZScsICdibG9iJywgJ3RhZyddLmluY2x1ZGVzKHR5cGUpKSB7XG4gICAgICAgIG9mZnNldFRvT2JqZWN0W29mZnNldF0gPSB7XG4gICAgICAgICAgdHlwZSxcbiAgICAgICAgICBvZmZzZXQsXG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdvZnMtZGVsdGEnKSB7XG4gICAgICAgIG9mZnNldFRvT2JqZWN0W29mZnNldF0gPSB7XG4gICAgICAgICAgdHlwZSxcbiAgICAgICAgICBvZmZzZXQsXG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdyZWYtZGVsdGEnKSB7XG4gICAgICAgIG9mZnNldFRvT2JqZWN0W29mZnNldF0gPSB7XG4gICAgICAgICAgdHlwZSxcbiAgICAgICAgICBvZmZzZXQsXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBXZSBuZWVkIHRvIGtub3cgdGhlIGxlbmd0aHMgb2YgdGhlIHNsaWNlcyB0byBjb21wdXRlIHRoZSBDUkNzLlxuICAgIGNvbnN0IG9mZnNldEFycmF5ID0gT2JqZWN0LmtleXMob2Zmc2V0VG9PYmplY3QpLm1hcChOdW1iZXIpO1xuICAgIGZvciAoY29uc3QgW2ksIHN0YXJ0XSBvZiBvZmZzZXRBcnJheS5lbnRyaWVzKCkpIHtcbiAgICAgIGNvbnN0IGVuZCA9XG4gICAgICAgIGkgKyAxID09PSBvZmZzZXRBcnJheS5sZW5ndGggPyBwYWNrLmJ5dGVMZW5ndGggLSAyMCA6IG9mZnNldEFycmF5W2kgKyAxXTtcbiAgICAgIGNvbnN0IG8gPSBvZmZzZXRUb09iamVjdFtzdGFydF07XG4gICAgICBjb25zdCBjcmMgPSBjcmMzMi5idWYocGFjay5zbGljZShzdGFydCwgZW5kKSkgPj4+IDA7XG4gICAgICBvLmVuZCA9IGVuZDtcbiAgICAgIG8uY3JjID0gY3JjO1xuICAgIH1cblxuICAgIC8vIFdlIGRvbid0IGhhdmUgdGhlIGhhc2hlcyB5ZXQuIEJ1dCB3ZSBjYW4gZ2VuZXJhdGUgdGhlbSB1c2luZyB0aGUgLnJlYWRTbGljZSBmdW5jdGlvbiFcbiAgICBjb25zdCBwID0gbmV3IEdpdFBhY2tJbmRleCh7XG4gICAgICBwYWNrOiBQcm9taXNlLnJlc29sdmUocGFjayksXG4gICAgICBwYWNrZmlsZVNoYSxcbiAgICAgIGNyY3MsXG4gICAgICBoYXNoZXMsXG4gICAgICBvZmZzZXRzLFxuICAgICAgZ2V0RXh0ZXJuYWxSZWZEZWx0YSxcbiAgICB9KTtcblxuICAgIC8vIFJlc29sdmUgZGVsdGFzIGFuZCBjb21wdXRlIHRoZSBvaWRzXG4gICAgbGFzdFBlcmNlbnQgPSBudWxsO1xuICAgIGxldCBjb3VudCA9IDA7XG4gICAgY29uc3Qgb2JqZWN0c0J5RGVwdGggPSBbMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMF07XG4gICAgZm9yIChsZXQgb2Zmc2V0IGluIG9mZnNldFRvT2JqZWN0KSB7XG4gICAgICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KTtcbiAgICAgIGNvbnN0IHBlcmNlbnQgPSBNYXRoLmZsb29yKChjb3VudCsrICogMTAwKSAvIHRvdGFsT2JqZWN0Q291bnQpO1xuICAgICAgaWYgKHBlcmNlbnQgIT09IGxhc3RQZXJjZW50KSB7XG4gICAgICAgIGlmIChvblByb2dyZXNzKSB7XG4gICAgICAgICAgYXdhaXQgb25Qcm9ncmVzcyh7XG4gICAgICAgICAgICBwaGFzZTogJ1Jlc29sdmluZyBkZWx0YXMnLFxuICAgICAgICAgICAgbG9hZGVkOiBjb3VudCxcbiAgICAgICAgICAgIHRvdGFsOiB0b3RhbE9iamVjdENvdW50LFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBsYXN0UGVyY2VudCA9IHBlcmNlbnQ7XG5cbiAgICAgIGNvbnN0IG8gPSBvZmZzZXRUb09iamVjdFtvZmZzZXRdO1xuICAgICAgaWYgKG8ub2lkKSBjb250aW51ZVxuICAgICAgdHJ5IHtcbiAgICAgICAgcC5yZWFkRGVwdGggPSAwO1xuICAgICAgICBwLmV4dGVybmFsUmVhZERlcHRoID0gMDtcbiAgICAgICAgY29uc3QgeyB0eXBlLCBvYmplY3QgfSA9IGF3YWl0IHAucmVhZFNsaWNlKHsgc3RhcnQ6IG9mZnNldCB9KTtcbiAgICAgICAgb2JqZWN0c0J5RGVwdGhbcC5yZWFkRGVwdGhdICs9IDE7XG4gICAgICAgIGNvbnN0IG9pZCA9IGF3YWl0IHNoYXN1bShHaXRPYmplY3Qud3JhcCh7IHR5cGUsIG9iamVjdCB9KSk7XG4gICAgICAgIG8ub2lkID0gb2lkO1xuICAgICAgICBoYXNoZXMucHVzaChvaWQpO1xuICAgICAgICBvZmZzZXRzLnNldChvaWQsIG9mZnNldCk7XG4gICAgICAgIGNyY3Nbb2lkXSA9IG8uY3JjO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG4gICAgfVxuXG4gICAgaGFzaGVzLnNvcnQoKTtcbiAgICByZXR1cm4gcFxuICB9XG5cbiAgYXN5bmMgdG9CdWZmZXIoKSB7XG4gICAgY29uc3QgYnVmZmVycyA9IFtdO1xuICAgIGNvbnN0IHdyaXRlID0gKHN0ciwgZW5jb2RpbmcpID0+IHtcbiAgICAgIGJ1ZmZlcnMucHVzaChCdWZmZXIuZnJvbShzdHIsIGVuY29kaW5nKSk7XG4gICAgfTtcbiAgICAvLyBXcml0ZSBvdXQgSURYIHYyIG1hZ2ljIG51bWJlclxuICAgIHdyaXRlKCdmZjc0NGY2MycsICdoZXgnKTtcbiAgICAvLyBXcml0ZSBvdXQgdmVyc2lvbiBudW1iZXIgMlxuICAgIHdyaXRlKCcwMDAwMDAwMicsICdoZXgnKTtcbiAgICAvLyBXcml0ZSBmYW5vdXQgdGFibGVcbiAgICBjb25zdCBmYW5vdXRCdWZmZXIgPSBuZXcgQnVmZmVyQ3Vyc29yKEJ1ZmZlci5hbGxvYygyNTYgKiA0KSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAyNTY7IGkrKykge1xuICAgICAgbGV0IGNvdW50ID0gMDtcbiAgICAgIGZvciAoY29uc3QgaGFzaCBvZiB0aGlzLmhhc2hlcykge1xuICAgICAgICBpZiAocGFyc2VJbnQoaGFzaC5zbGljZSgwLCAyKSwgMTYpIDw9IGkpIGNvdW50Kys7XG4gICAgICB9XG4gICAgICBmYW5vdXRCdWZmZXIud3JpdGVVSW50MzJCRShjb3VudCk7XG4gICAgfVxuICAgIGJ1ZmZlcnMucHVzaChmYW5vdXRCdWZmZXIuYnVmZmVyKTtcbiAgICAvLyBXcml0ZSBvdXQgaGFzaGVzXG4gICAgZm9yIChjb25zdCBoYXNoIG9mIHRoaXMuaGFzaGVzKSB7XG4gICAgICB3cml0ZShoYXNoLCAnaGV4Jyk7XG4gICAgfVxuICAgIC8vIFdyaXRlIG91dCBjcmNzXG4gICAgY29uc3QgY3Jjc0J1ZmZlciA9IG5ldyBCdWZmZXJDdXJzb3IoQnVmZmVyLmFsbG9jKHRoaXMuaGFzaGVzLmxlbmd0aCAqIDQpKTtcbiAgICBmb3IgKGNvbnN0IGhhc2ggb2YgdGhpcy5oYXNoZXMpIHtcbiAgICAgIGNyY3NCdWZmZXIud3JpdGVVSW50MzJCRSh0aGlzLmNyY3NbaGFzaF0pO1xuICAgIH1cbiAgICBidWZmZXJzLnB1c2goY3Jjc0J1ZmZlci5idWZmZXIpO1xuICAgIC8vIFdyaXRlIG91dCBvZmZzZXRzXG4gICAgY29uc3Qgb2Zmc2V0c0J1ZmZlciA9IG5ldyBCdWZmZXJDdXJzb3IoQnVmZmVyLmFsbG9jKHRoaXMuaGFzaGVzLmxlbmd0aCAqIDQpKTtcbiAgICBmb3IgKGNvbnN0IGhhc2ggb2YgdGhpcy5oYXNoZXMpIHtcbiAgICAgIG9mZnNldHNCdWZmZXIud3JpdGVVSW50MzJCRSh0aGlzLm9mZnNldHMuZ2V0KGhhc2gpKTtcbiAgICB9XG4gICAgYnVmZmVycy5wdXNoKG9mZnNldHNCdWZmZXIuYnVmZmVyKTtcbiAgICAvLyBXcml0ZSBvdXQgcGFja2ZpbGUgY2hlY2tzdW1cbiAgICB3cml0ZSh0aGlzLnBhY2tmaWxlU2hhLCAnaGV4Jyk7XG4gICAgLy8gV3JpdGUgb3V0IHNoYXN1bVxuICAgIGNvbnN0IHRvdGFsQnVmZmVyID0gQnVmZmVyLmNvbmNhdChidWZmZXJzKTtcbiAgICBjb25zdCBzaGEgPSBhd2FpdCBzaGFzdW0odG90YWxCdWZmZXIpO1xuICAgIGNvbnN0IHNoYUJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygyMCk7XG4gICAgc2hhQnVmZmVyLndyaXRlKHNoYSwgJ2hleCcpO1xuICAgIHJldHVybiBCdWZmZXIuY29uY2F0KFt0b3RhbEJ1ZmZlciwgc2hhQnVmZmVyXSlcbiAgfVxuXG4gIGFzeW5jIGxvYWQoeyBwYWNrIH0pIHtcbiAgICB0aGlzLnBhY2sgPSBwYWNrO1xuICB9XG5cbiAgYXN5bmMgdW5sb2FkKCkge1xuICAgIHRoaXMucGFjayA9IG51bGw7XG4gIH1cblxuICBhc3luYyByZWFkKHsgb2lkIH0pIHtcbiAgICBpZiAoIXRoaXMub2Zmc2V0cy5nZXQob2lkKSkge1xuICAgICAgaWYgKHRoaXMuZ2V0RXh0ZXJuYWxSZWZEZWx0YSkge1xuICAgICAgICB0aGlzLmV4dGVybmFsUmVhZERlcHRoKys7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEV4dGVybmFsUmVmRGVsdGEob2lkKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEludGVybmFsRXJyb3IoYENvdWxkIG5vdCByZWFkIG9iamVjdCAke29pZH0gZnJvbSBwYWNrZmlsZWApXG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5vZmZzZXRzLmdldChvaWQpO1xuICAgIHJldHVybiB0aGlzLnJlYWRTbGljZSh7IHN0YXJ0IH0pXG4gIH1cblxuICBhc3luYyByZWFkU2xpY2UoeyBzdGFydCB9KSB7XG4gICAgaWYgKHRoaXMub2Zmc2V0Q2FjaGVbc3RhcnRdKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5vZmZzZXRDYWNoZVtzdGFydF0pXG4gICAgfVxuICAgIHRoaXMucmVhZERlcHRoKys7XG4gICAgY29uc3QgdHlwZXMgPSB7XG4gICAgICAwYjAwMTAwMDA6ICdjb21taXQnLFxuICAgICAgMGIwMTAwMDAwOiAndHJlZScsXG4gICAgICAwYjAxMTAwMDA6ICdibG9iJyxcbiAgICAgIDBiMTAwMDAwMDogJ3RhZycsXG4gICAgICAwYjExMDAwMDA6ICdvZnNfZGVsdGEnLFxuICAgICAgMGIxMTEwMDAwOiAncmVmX2RlbHRhJyxcbiAgICB9O1xuICAgIGlmICghdGhpcy5wYWNrKSB7XG4gICAgICB0aHJvdyBuZXcgSW50ZXJuYWxFcnJvcihcbiAgICAgICAgJ1RyaWVkIHRvIHJlYWQgZnJvbSBhIEdpdFBhY2tJbmRleCB3aXRoIG5vIHBhY2tmaWxlIGxvYWRlZCBpbnRvIG1lbW9yeSdcbiAgICAgIClcbiAgICB9XG4gICAgY29uc3QgcmF3ID0gKGF3YWl0IHRoaXMucGFjaykuc2xpY2Uoc3RhcnQpO1xuICAgIGNvbnN0IHJlYWRlciA9IG5ldyBCdWZmZXJDdXJzb3IocmF3KTtcbiAgICBjb25zdCBieXRlID0gcmVhZGVyLnJlYWRVSW50OCgpO1xuICAgIC8vIE9iamVjdCB0eXBlIGlzIGVuY29kZWQgaW4gYml0cyA2NTRcbiAgICBjb25zdCBidHlwZSA9IGJ5dGUgJiAwYjExMTAwMDA7XG4gICAgbGV0IHR5cGUgPSB0eXBlc1tidHlwZV07XG4gICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEludGVybmFsRXJyb3IoJ1VucmVjb2duaXplZCB0eXBlOiAwYicgKyBidHlwZS50b1N0cmluZygyKSlcbiAgICB9XG4gICAgLy8gVGhlIGxlbmd0aCBlbmNvZGluZyBnZXQgY29tcGxpY2F0ZWQuXG4gICAgLy8gTGFzdCBmb3VyIGJpdHMgb2YgbGVuZ3RoIGlzIGVuY29kZWQgaW4gYml0cyAzMjEwXG4gICAgY29uc3QgbGFzdEZvdXIgPSBieXRlICYgMGIxMTExO1xuICAgIGxldCBsZW5ndGggPSBsYXN0Rm91cjtcbiAgICAvLyBXaGV0aGVyIHRoZSBuZXh0IGJ5dGUgaXMgcGFydCBvZiB0aGUgdmFyaWFibGUtbGVuZ3RoIGVuY29kZWQgbnVtYmVyXG4gICAgLy8gaXMgZW5jb2RlZCBpbiBiaXQgN1xuICAgIGNvbnN0IG11bHRpYnl0ZSA9IGJ5dGUgJiAwYjEwMDAwMDAwO1xuICAgIGlmIChtdWx0aWJ5dGUpIHtcbiAgICAgIGxlbmd0aCA9IG90aGVyVmFySW50RGVjb2RlKHJlYWRlciwgbGFzdEZvdXIpO1xuICAgIH1cbiAgICBsZXQgYmFzZSA9IG51bGw7XG4gICAgbGV0IG9iamVjdCA9IG51bGw7XG4gICAgLy8gSGFuZGxlIGRlbHRpZmllZCBvYmplY3RzXG4gICAgaWYgKHR5cGUgPT09ICdvZnNfZGVsdGEnKSB7XG4gICAgICBjb25zdCBvZmZzZXQgPSBkZWNvZGVWYXJJbnQocmVhZGVyKTtcbiAgICAgIGNvbnN0IGJhc2VPZmZzZXQgPSBzdGFydCAtIG9mZnNldFxuICAgICAgOyh7IG9iamVjdDogYmFzZSwgdHlwZSB9ID0gYXdhaXQgdGhpcy5yZWFkU2xpY2UoeyBzdGFydDogYmFzZU9mZnNldCB9KSk7XG4gICAgfVxuICAgIGlmICh0eXBlID09PSAncmVmX2RlbHRhJykge1xuICAgICAgY29uc3Qgb2lkID0gcmVhZGVyLnNsaWNlKDIwKS50b1N0cmluZygnaGV4JylcbiAgICAgIDsoeyBvYmplY3Q6IGJhc2UsIHR5cGUgfSA9IGF3YWl0IHRoaXMucmVhZCh7IG9pZCB9KSk7XG4gICAgfVxuICAgIC8vIEhhbmRsZSB1bmRlbHRpZmllZCBvYmplY3RzXG4gICAgY29uc3QgYnVmZmVyID0gcmF3LnNsaWNlKHJlYWRlci50ZWxsKCkpO1xuICAgIG9iamVjdCA9IEJ1ZmZlci5mcm9tKGF3YWl0IGluZmxhdGUoYnVmZmVyKSk7XG4gICAgLy8gQXNzZXJ0IHRoYXQgdGhlIG9iamVjdCBsZW5ndGggaXMgYXMgZXhwZWN0ZWQuXG4gICAgaWYgKG9iamVjdC5ieXRlTGVuZ3RoICE9PSBsZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBJbnRlcm5hbEVycm9yKFxuICAgICAgICBgUGFja2ZpbGUgdG9sZCB1cyBvYmplY3Qgd291bGQgaGF2ZSBsZW5ndGggJHtsZW5ndGh9IGJ1dCBpdCBoYWQgbGVuZ3RoICR7b2JqZWN0LmJ5dGVMZW5ndGh9YFxuICAgICAgKVxuICAgIH1cbiAgICBpZiAoYmFzZSkge1xuICAgICAgb2JqZWN0ID0gQnVmZmVyLmZyb20oYXBwbHlEZWx0YShvYmplY3QsIGJhc2UpKTtcbiAgICB9XG4gICAgLy8gQ2FjaGUgdGhlIHJlc3VsdCBiYXNlZCBvbiBkZXB0aC5cbiAgICBpZiAodGhpcy5yZWFkRGVwdGggPiAzKSB7XG4gICAgICAvLyBoYW5kIHR1bmVkIGZvciBzcGVlZCAvIG1lbW9yeSB1c2FnZSB0cmFkZW9mZlxuICAgICAgdGhpcy5vZmZzZXRDYWNoZVtzdGFydF0gPSB7IHR5cGUsIG9iamVjdCB9O1xuICAgIH1cbiAgICByZXR1cm4geyB0eXBlLCBmb3JtYXQ6ICdjb250ZW50Jywgb2JqZWN0IH1cbiAgfVxufVxuXG5jb25zdCBQYWNrZmlsZUNhY2hlID0gU3ltYm9sKCdQYWNrZmlsZUNhY2hlJyk7XG5cbmFzeW5jIGZ1bmN0aW9uIGxvYWRQYWNrSW5kZXgoe1xuICBmcyxcbiAgZmlsZW5hbWUsXG4gIGdldEV4dGVybmFsUmVmRGVsdGEsXG4gIGVtaXR0ZXIsXG4gIGVtaXR0ZXJQcmVmaXgsXG59KSB7XG4gIGNvbnN0IGlkeCA9IGF3YWl0IGZzLnJlYWQoZmlsZW5hbWUpO1xuICByZXR1cm4gR2l0UGFja0luZGV4LmZyb21JZHgoeyBpZHgsIGdldEV4dGVybmFsUmVmRGVsdGEgfSlcbn1cblxuZnVuY3Rpb24gcmVhZFBhY2tJbmRleCh7XG4gIGZzLFxuICBjYWNoZSxcbiAgZmlsZW5hbWUsXG4gIGdldEV4dGVybmFsUmVmRGVsdGEsXG4gIGVtaXR0ZXIsXG4gIGVtaXR0ZXJQcmVmaXgsXG59KSB7XG4gIC8vIFRyeSB0byBnZXQgdGhlIHBhY2tmaWxlIGluZGV4IGZyb20gdGhlIGluLW1lbW9yeSBjYWNoZVxuICBpZiAoIWNhY2hlW1BhY2tmaWxlQ2FjaGVdKSBjYWNoZVtQYWNrZmlsZUNhY2hlXSA9IG5ldyBNYXAoKTtcbiAgbGV0IHAgPSBjYWNoZVtQYWNrZmlsZUNhY2hlXS5nZXQoZmlsZW5hbWUpO1xuICBpZiAoIXApIHtcbiAgICBwID0gbG9hZFBhY2tJbmRleCh7XG4gICAgICBmcyxcbiAgICAgIGZpbGVuYW1lLFxuICAgICAgZ2V0RXh0ZXJuYWxSZWZEZWx0YSxcbiAgICAgIGVtaXR0ZXIsXG4gICAgICBlbWl0dGVyUHJlZml4LFxuICAgIH0pO1xuICAgIGNhY2hlW1BhY2tmaWxlQ2FjaGVdLnNldChmaWxlbmFtZSwgcCk7XG4gIH1cbiAgcmV0dXJuIHBcbn1cblxuYXN5bmMgZnVuY3Rpb24gcmVhZE9iamVjdFBhY2tlZCh7XG4gIGZzLFxuICBjYWNoZSxcbiAgZ2l0ZGlyLFxuICBvaWQsXG4gIGZvcm1hdCA9ICdjb250ZW50JyxcbiAgZ2V0RXh0ZXJuYWxSZWZEZWx0YSxcbn0pIHtcbiAgLy8gQ2hlY2sgdG8gc2VlIGlmIGl0J3MgaW4gYSBwYWNrZmlsZS5cbiAgLy8gSXRlcmF0ZSB0aHJvdWdoIGFsbCB0aGUgLmlkeCBmaWxlc1xuICBsZXQgbGlzdCA9IGF3YWl0IGZzLnJlYWRkaXIoam9pbihnaXRkaXIsICdvYmplY3RzL3BhY2snKSk7XG4gIGxpc3QgPSBsaXN0LmZpbHRlcih4ID0+IHguZW5kc1dpdGgoJy5pZHgnKSk7XG4gIGZvciAoY29uc3QgZmlsZW5hbWUgb2YgbGlzdCkge1xuICAgIGNvbnN0IGluZGV4RmlsZSA9IGAke2dpdGRpcn0vb2JqZWN0cy9wYWNrLyR7ZmlsZW5hbWV9YDtcbiAgICBjb25zdCBwID0gYXdhaXQgcmVhZFBhY2tJbmRleCh7XG4gICAgICBmcyxcbiAgICAgIGNhY2hlLFxuICAgICAgZmlsZW5hbWU6IGluZGV4RmlsZSxcbiAgICAgIGdldEV4dGVybmFsUmVmRGVsdGEsXG4gICAgfSk7XG4gICAgaWYgKHAuZXJyb3IpIHRocm93IG5ldyBJbnRlcm5hbEVycm9yKHAuZXJyb3IpXG4gICAgLy8gSWYgdGhlIHBhY2tmaWxlIERPRVMgaGF2ZSB0aGUgb2lkIHdlJ3JlIGxvb2tpbmcgZm9yLi4uXG4gICAgaWYgKHAub2Zmc2V0cy5oYXMob2lkKSkge1xuICAgICAgLy8gR2V0IHRoZSByZXNvbHZlZCBnaXQgb2JqZWN0IGZyb20gdGhlIHBhY2tmaWxlXG4gICAgICBpZiAoIXAucGFjaykge1xuICAgICAgICBjb25zdCBwYWNrRmlsZSA9IGluZGV4RmlsZS5yZXBsYWNlKC9pZHgkLywgJ3BhY2snKTtcbiAgICAgICAgcC5wYWNrID0gZnMucmVhZChwYWNrRmlsZSk7XG4gICAgICB9XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBwLnJlYWQoeyBvaWQsIGdldEV4dGVybmFsUmVmRGVsdGEgfSk7XG4gICAgICByZXN1bHQuZm9ybWF0ID0gJ2NvbnRlbnQnO1xuICAgICAgcmVzdWx0LnNvdXJjZSA9IGBvYmplY3RzL3BhY2svJHtmaWxlbmFtZS5yZXBsYWNlKC9pZHgkLywgJ3BhY2snKX1gO1xuICAgICAgcmV0dXJuIHJlc3VsdFxuICAgIH1cbiAgfVxuICAvLyBGYWlsZWQgdG8gZmluZCBpdFxuICByZXR1cm4gbnVsbFxufVxuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBhcmdzXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vbW9kZWxzL0ZpbGVTeXN0ZW0uanMnKS5GaWxlU3lzdGVtfSBhcmdzLmZzXG4gKiBAcGFyYW0ge2FueX0gYXJncy5jYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGFyZ3MuZ2l0ZGlyXG4gKiBAcGFyYW0ge3N0cmluZ30gYXJncy5vaWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5mb3JtYXRdXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIF9yZWFkT2JqZWN0KHtcbiAgZnMsXG4gIGNhY2hlLFxuICBnaXRkaXIsXG4gIG9pZCxcbiAgZm9ybWF0ID0gJ2NvbnRlbnQnLFxufSkge1xuICAvLyBDdXJyeSB0aGUgY3VycmVudCByZWFkIG1ldGhvZCBzbyB0aGF0IHRoZSBwYWNrZmlsZSB1bi1kZWx0aWZpY2F0aW9uXG4gIC8vIHByb2Nlc3MgY2FuIGFjcXVpcmUgZXh0ZXJuYWwgcmVmLWRlbHRhcy5cbiAgY29uc3QgZ2V0RXh0ZXJuYWxSZWZEZWx0YSA9IG9pZCA9PiBfcmVhZE9iamVjdCh7IGZzLCBjYWNoZSwgZ2l0ZGlyLCBvaWQgfSk7XG5cbiAgbGV0IHJlc3VsdDtcbiAgLy8gRW1wdHkgdHJlZSAtIGhhcmQtY29kZWQgc28gd2UgY2FuIHVzZSBpdCBhcyBhIHNob3J0aGFuZC5cbiAgLy8gTm90ZTogSSB0aGluayB0aGUgY2Fub25pY2FsIGdpdCBpbXBsZW1lbnRhdGlvbiBtdXN0IGRvIHRoaXMgdG9vIGJlY2F1c2VcbiAgLy8gYGdpdCBjYXQtZmlsZSAtdCA0YjgyNWRjNjQyY2I2ZWI5YTA2MGU1NGJmOGQ2OTI4OGZiZWU0OTA0YCBwcmludHMgXCJ0cmVlXCIgZXZlbiBpbiBlbXB0eSByZXBvcy5cbiAgaWYgKG9pZCA9PT0gJzRiODI1ZGM2NDJjYjZlYjlhMDYwZTU0YmY4ZDY5Mjg4ZmJlZTQ5MDQnKSB7XG4gICAgcmVzdWx0ID0geyBmb3JtYXQ6ICd3cmFwcGVkJywgb2JqZWN0OiBCdWZmZXIuZnJvbShgdHJlZSAwXFx4MDBgKSB9O1xuICB9XG4gIC8vIExvb2sgZm9yIGl0IGluIHRoZSBsb29zZSBvYmplY3QgZGlyZWN0b3J5LlxuICBpZiAoIXJlc3VsdCkge1xuICAgIHJlc3VsdCA9IGF3YWl0IHJlYWRPYmplY3RMb29zZSh7IGZzLCBnaXRkaXIsIG9pZCB9KTtcbiAgfVxuICAvLyBDaGVjayB0byBzZWUgaWYgaXQncyBpbiBhIHBhY2tmaWxlLlxuICBpZiAoIXJlc3VsdCkge1xuICAgIHJlc3VsdCA9IGF3YWl0IHJlYWRPYmplY3RQYWNrZWQoe1xuICAgICAgZnMsXG4gICAgICBjYWNoZSxcbiAgICAgIGdpdGRpcixcbiAgICAgIG9pZCxcbiAgICAgIGdldEV4dGVybmFsUmVmRGVsdGEsXG4gICAgfSk7XG4gIH1cbiAgLy8gRmluYWxseVxuICBpZiAoIXJlc3VsdCkge1xuICAgIHRocm93IG5ldyBOb3RGb3VuZEVycm9yKG9pZClcbiAgfVxuXG4gIGlmIChmb3JtYXQgPT09ICdkZWZsYXRlZCcpIHtcbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICAvLyBCRUhPTEQhIFRIRSBPTkxZIFRJTUUgSSdWRSBFVkVSIFdBTlRFRCBUTyBVU0UgQSBDQVNFIFNUQVRFTUVOVCBXSVRIIEZPTExPV1RIUk9VR0ghXG4gIC8vIGVzbGludC1pZ25vcmVcbiAgLyogZXNsaW50LWRpc2FibGUgbm8tZmFsbHRocm91Z2ggKi9cbiAgc3dpdGNoIChyZXN1bHQuZm9ybWF0KSB7XG4gICAgY2FzZSAnZGVmbGF0ZWQnOiB7XG4gICAgICByZXN1bHQub2JqZWN0ID0gQnVmZmVyLmZyb20oYXdhaXQgaW5mbGF0ZShyZXN1bHQub2JqZWN0KSk7XG4gICAgICByZXN1bHQuZm9ybWF0ID0gJ3dyYXBwZWQnO1xuICAgIH1cbiAgICBjYXNlICd3cmFwcGVkJzoge1xuICAgICAgaWYgKGZvcm1hdCA9PT0gJ3dyYXBwZWQnICYmIHJlc3VsdC5mb3JtYXQgPT09ICd3cmFwcGVkJykge1xuICAgICAgICByZXR1cm4gcmVzdWx0XG4gICAgICB9XG4gICAgICBjb25zdCBzaGEgPSBhd2FpdCBzaGFzdW0ocmVzdWx0Lm9iamVjdCk7XG4gICAgICBpZiAoc2hhICE9PSBvaWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEludGVybmFsRXJyb3IoXG4gICAgICAgICAgYFNIQSBjaGVjayBmYWlsZWQhIEV4cGVjdGVkICR7b2lkfSwgY29tcHV0ZWQgJHtzaGF9YFxuICAgICAgICApXG4gICAgICB9XG4gICAgICBjb25zdCB7IG9iamVjdCwgdHlwZSB9ID0gR2l0T2JqZWN0LnVud3JhcChyZXN1bHQub2JqZWN0KTtcbiAgICAgIHJlc3VsdC50eXBlID0gdHlwZTtcbiAgICAgIHJlc3VsdC5vYmplY3QgPSBvYmplY3Q7XG4gICAgICByZXN1bHQuZm9ybWF0ID0gJ2NvbnRlbnQnO1xuICAgIH1cbiAgICBjYXNlICdjb250ZW50Jzoge1xuICAgICAgaWYgKGZvcm1hdCA9PT0gJ2NvbnRlbnQnKSByZXR1cm4gcmVzdWx0XG4gICAgICBicmVha1xuICAgIH1cbiAgICBkZWZhdWx0OiB7XG4gICAgICB0aHJvdyBuZXcgSW50ZXJuYWxFcnJvcihgaW52YWxpZCBmb3JtYXQgXCIke3Jlc3VsdC5mb3JtYXR9XCJgKVxuICAgIH1cbiAgfVxuICAvKiBlc2xpbnQtZW5hYmxlIG5vLWZhbGx0aHJvdWdoICovXG59XG5cbmNsYXNzIEFscmVhZHlFeGlzdHNFcnJvciBleHRlbmRzIEJhc2VFcnJvciB7XG4gIC8qKlxuICAgKiBAcGFyYW0geydub3RlJ3wncmVtb3RlJ3wndGFnJ3wnYnJhbmNoJ30gbm91blxuICAgKiBAcGFyYW0ge3N0cmluZ30gd2hlcmVcbiAgICogQHBhcmFtIHtib29sZWFufSBjYW5Gb3JjZVxuICAgKi9cbiAgY29uc3RydWN0b3Iobm91biwgd2hlcmUsIGNhbkZvcmNlID0gdHJ1ZSkge1xuICAgIHN1cGVyKFxuICAgICAgYEZhaWxlZCB0byBjcmVhdGUgJHtub3VufSBhdCAke3doZXJlfSBiZWNhdXNlIGl0IGFscmVhZHkgZXhpc3RzLiR7XG4gICAgICAgIGNhbkZvcmNlXG4gICAgICAgICAgPyBgIChIaW50OiB1c2UgJ2ZvcmNlOiB0cnVlJyBwYXJhbWV0ZXIgdG8gb3ZlcndyaXRlIGV4aXN0aW5nICR7bm91bn0uKWBcbiAgICAgICAgICA6ICcnXG4gICAgICB9YFxuICAgICk7XG4gICAgdGhpcy5jb2RlID0gdGhpcy5uYW1lID0gQWxyZWFkeUV4aXN0c0Vycm9yLmNvZGU7XG4gICAgdGhpcy5kYXRhID0geyBub3VuLCB3aGVyZSwgY2FuRm9yY2UgfTtcbiAgfVxufVxuLyoqIEB0eXBlIHsnQWxyZWFkeUV4aXN0c0Vycm9yJ30gKi9cbkFscmVhZHlFeGlzdHNFcnJvci5jb2RlID0gJ0FscmVhZHlFeGlzdHNFcnJvcic7XG5cbmNsYXNzIEFtYmlndW91c0Vycm9yIGV4dGVuZHMgQmFzZUVycm9yIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7J29pZHMnfCdyZWZzJ30gbm91bnNcbiAgICogQHBhcmFtIHtzdHJpbmd9IHNob3J0XG4gICAqIEBwYXJhbSB7c3RyaW5nW119IG1hdGNoZXNcbiAgICovXG4gIGNvbnN0cnVjdG9yKG5vdW5zLCBzaG9ydCwgbWF0Y2hlcykge1xuICAgIHN1cGVyKFxuICAgICAgYEZvdW5kIG11bHRpcGxlICR7bm91bnN9IG1hdGNoaW5nIFwiJHtzaG9ydH1cIiAoJHttYXRjaGVzLmpvaW4oXG4gICAgICAgICcsICdcbiAgICAgICl9KS4gVXNlIGEgbG9uZ2VyIGFiYnJldmlhdGlvbiBsZW5ndGggdG8gZGlzYW1iaWd1YXRlIHRoZW0uYFxuICAgICk7XG4gICAgdGhpcy5jb2RlID0gdGhpcy5uYW1lID0gQW1iaWd1b3VzRXJyb3IuY29kZTtcbiAgICB0aGlzLmRhdGEgPSB7IG5vdW5zLCBzaG9ydCwgbWF0Y2hlcyB9O1xuICB9XG59XG4vKiogQHR5cGUgeydBbWJpZ3VvdXNFcnJvcid9ICovXG5BbWJpZ3VvdXNFcnJvci5jb2RlID0gJ0FtYmlndW91c0Vycm9yJztcblxuY2xhc3MgQ2hlY2tvdXRDb25mbGljdEVycm9yIGV4dGVuZHMgQmFzZUVycm9yIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nW119IGZpbGVwYXRoc1xuICAgKi9cbiAgY29uc3RydWN0b3IoZmlsZXBhdGhzKSB7XG4gICAgc3VwZXIoXG4gICAgICBgWW91ciBsb2NhbCBjaGFuZ2VzIHRvIHRoZSBmb2xsb3dpbmcgZmlsZXMgd291bGQgYmUgb3ZlcndyaXR0ZW4gYnkgY2hlY2tvdXQ6ICR7ZmlsZXBhdGhzLmpvaW4oXG4gICAgICAgICcsICdcbiAgICAgICl9YFxuICAgICk7XG4gICAgdGhpcy5jb2RlID0gdGhpcy5uYW1lID0gQ2hlY2tvdXRDb25mbGljdEVycm9yLmNvZGU7XG4gICAgdGhpcy5kYXRhID0geyBmaWxlcGF0aHMgfTtcbiAgfVxufVxuLyoqIEB0eXBlIHsnQ2hlY2tvdXRDb25mbGljdEVycm9yJ30gKi9cbkNoZWNrb3V0Q29uZmxpY3RFcnJvci5jb2RlID0gJ0NoZWNrb3V0Q29uZmxpY3RFcnJvcic7XG5cbmNsYXNzIENvbW1pdE5vdEZldGNoZWRFcnJvciBleHRlbmRzIEJhc2VFcnJvciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVmXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvaWRcbiAgICovXG4gIGNvbnN0cnVjdG9yKHJlZiwgb2lkKSB7XG4gICAgc3VwZXIoXG4gICAgICBgRmFpbGVkIHRvIGNoZWNrb3V0IFwiJHtyZWZ9XCIgYmVjYXVzZSBjb21taXQgJHtvaWR9IGlzIG5vdCBhdmFpbGFibGUgbG9jYWxseS4gRG8gYSBnaXQgZmV0Y2ggdG8gbWFrZSB0aGUgYnJhbmNoIGF2YWlsYWJsZSBsb2NhbGx5LmBcbiAgICApO1xuICAgIHRoaXMuY29kZSA9IHRoaXMubmFtZSA9IENvbW1pdE5vdEZldGNoZWRFcnJvci5jb2RlO1xuICAgIHRoaXMuZGF0YSA9IHsgcmVmLCBvaWQgfTtcbiAgfVxufVxuLyoqIEB0eXBlIHsnQ29tbWl0Tm90RmV0Y2hlZEVycm9yJ30gKi9cbkNvbW1pdE5vdEZldGNoZWRFcnJvci5jb2RlID0gJ0NvbW1pdE5vdEZldGNoZWRFcnJvcic7XG5cbmNsYXNzIEVtcHR5U2VydmVyUmVzcG9uc2VFcnJvciBleHRlbmRzIEJhc2VFcnJvciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKGBFbXB0eSByZXNwb25zZSBmcm9tIGdpdCBzZXJ2ZXIuYCk7XG4gICAgdGhpcy5jb2RlID0gdGhpcy5uYW1lID0gRW1wdHlTZXJ2ZXJSZXNwb25zZUVycm9yLmNvZGU7XG4gICAgdGhpcy5kYXRhID0ge307XG4gIH1cbn1cbi8qKiBAdHlwZSB7J0VtcHR5U2VydmVyUmVzcG9uc2VFcnJvcid9ICovXG5FbXB0eVNlcnZlclJlc3BvbnNlRXJyb3IuY29kZSA9ICdFbXB0eVNlcnZlclJlc3BvbnNlRXJyb3InO1xuXG5jbGFzcyBGYXN0Rm9yd2FyZEVycm9yIGV4dGVuZHMgQmFzZUVycm9yIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoYEEgc2ltcGxlIGZhc3QtZm9yd2FyZCBtZXJnZSB3YXMgbm90IHBvc3NpYmxlLmApO1xuICAgIHRoaXMuY29kZSA9IHRoaXMubmFtZSA9IEZhc3RGb3J3YXJkRXJyb3IuY29kZTtcbiAgICB0aGlzLmRhdGEgPSB7fTtcbiAgfVxufVxuLyoqIEB0eXBlIHsnRmFzdEZvcndhcmRFcnJvcid9ICovXG5GYXN0Rm9yd2FyZEVycm9yLmNvZGUgPSAnRmFzdEZvcndhcmRFcnJvcic7XG5cbmNsYXNzIEdpdFB1c2hFcnJvciBleHRlbmRzIEJhc2VFcnJvciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHJldHR5RGV0YWlsc1xuICAgKiBAcGFyYW0ge1B1c2hSZXN1bHR9IHJlc3VsdFxuICAgKi9cbiAgY29uc3RydWN0b3IocHJldHR5RGV0YWlscywgcmVzdWx0KSB7XG4gICAgc3VwZXIoYE9uZSBvciBtb3JlIGJyYW5jaGVzIHdlcmUgbm90IHVwZGF0ZWQ6ICR7cHJldHR5RGV0YWlsc31gKTtcbiAgICB0aGlzLmNvZGUgPSB0aGlzLm5hbWUgPSBHaXRQdXNoRXJyb3IuY29kZTtcbiAgICB0aGlzLmRhdGEgPSB7IHByZXR0eURldGFpbHMsIHJlc3VsdCB9O1xuICB9XG59XG4vKiogQHR5cGUgeydHaXRQdXNoRXJyb3InfSAqL1xuR2l0UHVzaEVycm9yLmNvZGUgPSAnR2l0UHVzaEVycm9yJztcblxuY2xhc3MgSHR0cEVycm9yIGV4dGVuZHMgQmFzZUVycm9yIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzdGF0dXNDb2RlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdGF0dXNNZXNzYWdlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZXNwb25zZVxuICAgKi9cbiAgY29uc3RydWN0b3Ioc3RhdHVzQ29kZSwgc3RhdHVzTWVzc2FnZSwgcmVzcG9uc2UpIHtcbiAgICBzdXBlcihgSFRUUCBFcnJvcjogJHtzdGF0dXNDb2RlfSAke3N0YXR1c01lc3NhZ2V9YCk7XG4gICAgdGhpcy5jb2RlID0gdGhpcy5uYW1lID0gSHR0cEVycm9yLmNvZGU7XG4gICAgdGhpcy5kYXRhID0geyBzdGF0dXNDb2RlLCBzdGF0dXNNZXNzYWdlLCByZXNwb25zZSB9O1xuICB9XG59XG4vKiogQHR5cGUgeydIdHRwRXJyb3InfSAqL1xuSHR0cEVycm9yLmNvZGUgPSAnSHR0cEVycm9yJztcblxuY2xhc3MgSW52YWxpZEZpbGVwYXRoRXJyb3IgZXh0ZW5kcyBCYXNlRXJyb3Ige1xuICAvKipcbiAgICogQHBhcmFtIHsnbGVhZGluZy1zbGFzaCd8J3RyYWlsaW5nLXNsYXNoJ30gW3JlYXNvbl1cbiAgICovXG4gIGNvbnN0cnVjdG9yKHJlYXNvbikge1xuICAgIGxldCBtZXNzYWdlID0gJ2ludmFsaWQgZmlsZXBhdGgnO1xuICAgIGlmIChyZWFzb24gPT09ICdsZWFkaW5nLXNsYXNoJyB8fCByZWFzb24gPT09ICd0cmFpbGluZy1zbGFzaCcpIHtcbiAgICAgIG1lc3NhZ2UgPSBgXCJmaWxlcGF0aFwiIHBhcmFtZXRlciBzaG91bGQgbm90IGluY2x1ZGUgbGVhZGluZyBvciB0cmFpbGluZyBkaXJlY3Rvcnkgc2VwYXJhdG9ycyBiZWNhdXNlIHRoZXNlIGNhbiBjYXVzZSBwcm9ibGVtcyBvbiBzb21lIHBsYXRmb3Jtcy5gO1xuICAgIH1cbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLmNvZGUgPSB0aGlzLm5hbWUgPSBJbnZhbGlkRmlsZXBhdGhFcnJvci5jb2RlO1xuICAgIHRoaXMuZGF0YSA9IHsgcmVhc29uIH07XG4gIH1cbn1cbi8qKiBAdHlwZSB7J0ludmFsaWRGaWxlcGF0aEVycm9yJ30gKi9cbkludmFsaWRGaWxlcGF0aEVycm9yLmNvZGUgPSAnSW52YWxpZEZpbGVwYXRoRXJyb3InO1xuXG5jbGFzcyBJbnZhbGlkUmVmTmFtZUVycm9yIGV4dGVuZHMgQmFzZUVycm9yIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZWZcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN1Z2dlc3Rpb25cbiAgICogQHBhcmFtIHtib29sZWFufSBjYW5Gb3JjZVxuICAgKi9cbiAgY29uc3RydWN0b3IocmVmLCBzdWdnZXN0aW9uKSB7XG4gICAgc3VwZXIoXG4gICAgICBgXCIke3JlZn1cIiB3b3VsZCBiZSBhbiBpbnZhbGlkIGdpdCByZWZlcmVuY2UuIChIaW50OiBhIHZhbGlkIGFsdGVybmF0aXZlIHdvdWxkIGJlIFwiJHtzdWdnZXN0aW9ufVwiLilgXG4gICAgKTtcbiAgICB0aGlzLmNvZGUgPSB0aGlzLm5hbWUgPSBJbnZhbGlkUmVmTmFtZUVycm9yLmNvZGU7XG4gICAgdGhpcy5kYXRhID0geyByZWYsIHN1Z2dlc3Rpb24gfTtcbiAgfVxufVxuLyoqIEB0eXBlIHsnSW52YWxpZFJlZk5hbWVFcnJvcid9ICovXG5JbnZhbGlkUmVmTmFtZUVycm9yLmNvZGUgPSAnSW52YWxpZFJlZk5hbWVFcnJvcic7XG5cbmNsYXNzIE1heERlcHRoRXJyb3IgZXh0ZW5kcyBCYXNlRXJyb3Ige1xuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IGRlcHRoXG4gICAqL1xuICBjb25zdHJ1Y3RvcihkZXB0aCkge1xuICAgIHN1cGVyKGBNYXhpbXVtIHNlYXJjaCBkZXB0aCBvZiAke2RlcHRofSBleGNlZWRlZC5gKTtcbiAgICB0aGlzLmNvZGUgPSB0aGlzLm5hbWUgPSBNYXhEZXB0aEVycm9yLmNvZGU7XG4gICAgdGhpcy5kYXRhID0geyBkZXB0aCB9O1xuICB9XG59XG4vKiogQHR5cGUgeydNYXhEZXB0aEVycm9yJ30gKi9cbk1heERlcHRoRXJyb3IuY29kZSA9ICdNYXhEZXB0aEVycm9yJztcblxuY2xhc3MgTWVyZ2VOb3RTdXBwb3J0ZWRFcnJvciBleHRlbmRzIEJhc2VFcnJvciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKGBNZXJnZXMgd2l0aCBjb25mbGljdHMgYXJlIG5vdCBzdXBwb3J0ZWQgeWV0LmApO1xuICAgIHRoaXMuY29kZSA9IHRoaXMubmFtZSA9IE1lcmdlTm90U3VwcG9ydGVkRXJyb3IuY29kZTtcbiAgICB0aGlzLmRhdGEgPSB7fTtcbiAgfVxufVxuLyoqIEB0eXBlIHsnTWVyZ2VOb3RTdXBwb3J0ZWRFcnJvcid9ICovXG5NZXJnZU5vdFN1cHBvcnRlZEVycm9yLmNvZGUgPSAnTWVyZ2VOb3RTdXBwb3J0ZWRFcnJvcic7XG5cbmNsYXNzIE1pc3NpbmdOYW1lRXJyb3IgZXh0ZW5kcyBCYXNlRXJyb3Ige1xuICAvKipcbiAgICogQHBhcmFtIHsnYXV0aG9yJ3wnY29tbWl0dGVyJ3wndGFnZ2VyJ30gcm9sZVxuICAgKi9cbiAgY29uc3RydWN0b3Iocm9sZSkge1xuICAgIHN1cGVyKFxuICAgICAgYE5vIG5hbWUgd2FzIHByb3ZpZGVkIGZvciAke3JvbGV9IGluIHRoZSBhcmd1bWVudCBvciBpbiB0aGUgLmdpdC9jb25maWcgZmlsZS5gXG4gICAgKTtcbiAgICB0aGlzLmNvZGUgPSB0aGlzLm5hbWUgPSBNaXNzaW5nTmFtZUVycm9yLmNvZGU7XG4gICAgdGhpcy5kYXRhID0geyByb2xlIH07XG4gIH1cbn1cbi8qKiBAdHlwZSB7J01pc3NpbmdOYW1lRXJyb3InfSAqL1xuTWlzc2luZ05hbWVFcnJvci5jb2RlID0gJ01pc3NpbmdOYW1lRXJyb3InO1xuXG5jbGFzcyBNaXNzaW5nUGFyYW1ldGVyRXJyb3IgZXh0ZW5kcyBCYXNlRXJyb3Ige1xuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtZXRlclxuICAgKi9cbiAgY29uc3RydWN0b3IocGFyYW1ldGVyKSB7XG4gICAgc3VwZXIoXG4gICAgICBgVGhlIGZ1bmN0aW9uIHJlcXVpcmVzIGEgXCIke3BhcmFtZXRlcn1cIiBwYXJhbWV0ZXIgYnV0IG5vbmUgd2FzIHByb3ZpZGVkLmBcbiAgICApO1xuICAgIHRoaXMuY29kZSA9IHRoaXMubmFtZSA9IE1pc3NpbmdQYXJhbWV0ZXJFcnJvci5jb2RlO1xuICAgIHRoaXMuZGF0YSA9IHsgcGFyYW1ldGVyIH07XG4gIH1cbn1cbi8qKiBAdHlwZSB7J01pc3NpbmdQYXJhbWV0ZXJFcnJvcid9ICovXG5NaXNzaW5nUGFyYW1ldGVyRXJyb3IuY29kZSA9ICdNaXNzaW5nUGFyYW1ldGVyRXJyb3InO1xuXG5jbGFzcyBQYXJzZUVycm9yIGV4dGVuZHMgQmFzZUVycm9yIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBleHBlY3RlZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gYWN0dWFsXG4gICAqL1xuICBjb25zdHJ1Y3RvcihleHBlY3RlZCwgYWN0dWFsKSB7XG4gICAgc3VwZXIoYEV4cGVjdGVkIFwiJHtleHBlY3RlZH1cIiBidXQgcmVjZWl2ZWQgXCIke2FjdHVhbH1cIi5gKTtcbiAgICB0aGlzLmNvZGUgPSB0aGlzLm5hbWUgPSBQYXJzZUVycm9yLmNvZGU7XG4gICAgdGhpcy5kYXRhID0geyBleHBlY3RlZCwgYWN0dWFsIH07XG4gIH1cbn1cbi8qKiBAdHlwZSB7J1BhcnNlRXJyb3InfSAqL1xuUGFyc2VFcnJvci5jb2RlID0gJ1BhcnNlRXJyb3InO1xuXG5jbGFzcyBQdXNoUmVqZWN0ZWRFcnJvciBleHRlbmRzIEJhc2VFcnJvciB7XG4gIC8qKlxuICAgKiBAcGFyYW0geydub3QtZmFzdC1mb3J3YXJkJ3wndGFnLWV4aXN0cyd9IHJlYXNvblxuICAgKi9cbiAgY29uc3RydWN0b3IocmVhc29uKSB7XG4gICAgbGV0IG1lc3NhZ2UgPSAnJztcbiAgICBpZiAocmVhc29uID09PSAnbm90LWZhc3QtZm9yd2FyZCcpIHtcbiAgICAgIG1lc3NhZ2UgPSAnIGJlY2F1c2UgaXQgd2FzIG5vdCBhIHNpbXBsZSBmYXN0LWZvcndhcmQnO1xuICAgIH0gZWxzZSBpZiAocmVhc29uID09PSAndGFnLWV4aXN0cycpIHtcbiAgICAgIG1lc3NhZ2UgPSAnIGJlY2F1c2UgdGFnIGFscmVhZHkgZXhpc3RzJztcbiAgICB9XG4gICAgc3VwZXIoYFB1c2ggcmVqZWN0ZWQke21lc3NhZ2V9LiBVc2UgXCJmb3JjZTogdHJ1ZVwiIHRvIG92ZXJyaWRlLmApO1xuICAgIHRoaXMuY29kZSA9IHRoaXMubmFtZSA9IFB1c2hSZWplY3RlZEVycm9yLmNvZGU7XG4gICAgdGhpcy5kYXRhID0geyByZWFzb24gfTtcbiAgfVxufVxuLyoqIEB0eXBlIHsnUHVzaFJlamVjdGVkRXJyb3InfSAqL1xuUHVzaFJlamVjdGVkRXJyb3IuY29kZSA9ICdQdXNoUmVqZWN0ZWRFcnJvcic7XG5cbmNsYXNzIFJlbW90ZUNhcGFiaWxpdHlFcnJvciBleHRlbmRzIEJhc2VFcnJvciB7XG4gIC8qKlxuICAgKiBAcGFyYW0geydzaGFsbG93J3wnZGVlcGVuLXNpbmNlJ3wnZGVlcGVuLW5vdCd8J2RlZXBlbi1yZWxhdGl2ZSd9IGNhcGFiaWxpdHlcbiAgICogQHBhcmFtIHsnZGVwdGgnfCdzaW5jZSd8J2V4Y2x1ZGUnfCdyZWxhdGl2ZSd9IHBhcmFtZXRlclxuICAgKi9cbiAgY29uc3RydWN0b3IoY2FwYWJpbGl0eSwgcGFyYW1ldGVyKSB7XG4gICAgc3VwZXIoXG4gICAgICBgUmVtb3RlIGRvZXMgbm90IHN1cHBvcnQgdGhlIFwiJHtjYXBhYmlsaXR5fVwiIHNvIHRoZSBcIiR7cGFyYW1ldGVyfVwiIHBhcmFtZXRlciBjYW5ub3QgYmUgdXNlZC5gXG4gICAgKTtcbiAgICB0aGlzLmNvZGUgPSB0aGlzLm5hbWUgPSBSZW1vdGVDYXBhYmlsaXR5RXJyb3IuY29kZTtcbiAgICB0aGlzLmRhdGEgPSB7IGNhcGFiaWxpdHksIHBhcmFtZXRlciB9O1xuICB9XG59XG4vKiogQHR5cGUgeydSZW1vdGVDYXBhYmlsaXR5RXJyb3InfSAqL1xuUmVtb3RlQ2FwYWJpbGl0eUVycm9yLmNvZGUgPSAnUmVtb3RlQ2FwYWJpbGl0eUVycm9yJztcblxuY2xhc3MgU21hcnRIdHRwRXJyb3IgZXh0ZW5kcyBCYXNlRXJyb3Ige1xuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHByZXZpZXdcbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlc3BvbnNlXG4gICAqL1xuICBjb25zdHJ1Y3RvcihwcmV2aWV3LCByZXNwb25zZSkge1xuICAgIHN1cGVyKFxuICAgICAgYFJlbW90ZSBkaWQgbm90IHJlcGx5IHVzaW5nIHRoZSBcInNtYXJ0XCIgSFRUUCBwcm90b2NvbC4gRXhwZWN0ZWQgXCIwMDFlIyBzZXJ2aWNlPWdpdC11cGxvYWQtcGFja1wiIGJ1dCByZWNlaXZlZDogJHtwcmV2aWV3fWBcbiAgICApO1xuICAgIHRoaXMuY29kZSA9IHRoaXMubmFtZSA9IFNtYXJ0SHR0cEVycm9yLmNvZGU7XG4gICAgdGhpcy5kYXRhID0geyBwcmV2aWV3LCByZXNwb25zZSB9O1xuICB9XG59XG4vKiogQHR5cGUgeydTbWFydEh0dHBFcnJvcid9ICovXG5TbWFydEh0dHBFcnJvci5jb2RlID0gJ1NtYXJ0SHR0cEVycm9yJztcblxuY2xhc3MgVW5rbm93blRyYW5zcG9ydEVycm9yIGV4dGVuZHMgQmFzZUVycm9yIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1cmxcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRyYW5zcG9ydFxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3VnZ2VzdGlvblxuICAgKi9cbiAgY29uc3RydWN0b3IodXJsLCB0cmFuc3BvcnQsIHN1Z2dlc3Rpb24pIHtcbiAgICBzdXBlcihcbiAgICAgIGBHaXQgcmVtb3RlIFwiJHt1cmx9XCIgdXNlcyBhbiB1bnJlY29nbml6ZWQgdHJhbnNwb3J0IHByb3RvY29sOiBcIiR7dHJhbnNwb3J0fVwiYFxuICAgICk7XG4gICAgdGhpcy5jb2RlID0gdGhpcy5uYW1lID0gVW5rbm93blRyYW5zcG9ydEVycm9yLmNvZGU7XG4gICAgdGhpcy5kYXRhID0geyB1cmwsIHRyYW5zcG9ydCwgc3VnZ2VzdGlvbiB9O1xuICB9XG59XG4vKiogQHR5cGUgeydVbmtub3duVHJhbnNwb3J0RXJyb3InfSAqL1xuVW5rbm93blRyYW5zcG9ydEVycm9yLmNvZGUgPSAnVW5rbm93blRyYW5zcG9ydEVycm9yJztcblxuY2xhc3MgVXJsUGFyc2VFcnJvciBleHRlbmRzIEJhc2VFcnJvciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih1cmwpIHtcbiAgICBzdXBlcihgQ2Fubm90IHBhcnNlIHJlbW90ZSBVUkw6IFwiJHt1cmx9XCJgKTtcbiAgICB0aGlzLmNvZGUgPSB0aGlzLm5hbWUgPSBVcmxQYXJzZUVycm9yLmNvZGU7XG4gICAgdGhpcy5kYXRhID0geyB1cmwgfTtcbiAgfVxufVxuLyoqIEB0eXBlIHsnVXJsUGFyc2VFcnJvcid9ICovXG5VcmxQYXJzZUVycm9yLmNvZGUgPSAnVXJsUGFyc2VFcnJvcic7XG5cbmNsYXNzIFVzZXJDYW5jZWxlZEVycm9yIGV4dGVuZHMgQmFzZUVycm9yIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoYFRoZSBvcGVyYXRpb24gd2FzIGNhbmNlbGVkLmApO1xuICAgIHRoaXMuY29kZSA9IHRoaXMubmFtZSA9IFVzZXJDYW5jZWxlZEVycm9yLmNvZGU7XG4gICAgdGhpcy5kYXRhID0ge307XG4gIH1cbn1cbi8qKiBAdHlwZSB7J1VzZXJDYW5jZWxlZEVycm9yJ30gKi9cblVzZXJDYW5jZWxlZEVycm9yLmNvZGUgPSAnVXNlckNhbmNlbGVkRXJyb3InO1xuXG5cblxudmFyIEVycm9ycyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgX19wcm90b19fOiBudWxsLFxuICBBbHJlYWR5RXhpc3RzRXJyb3I6IEFscmVhZHlFeGlzdHNFcnJvcixcbiAgQW1iaWd1b3VzRXJyb3I6IEFtYmlndW91c0Vycm9yLFxuICBDaGVja291dENvbmZsaWN0RXJyb3I6IENoZWNrb3V0Q29uZmxpY3RFcnJvcixcbiAgQ29tbWl0Tm90RmV0Y2hlZEVycm9yOiBDb21taXROb3RGZXRjaGVkRXJyb3IsXG4gIEVtcHR5U2VydmVyUmVzcG9uc2VFcnJvcjogRW1wdHlTZXJ2ZXJSZXNwb25zZUVycm9yLFxuICBGYXN0Rm9yd2FyZEVycm9yOiBGYXN0Rm9yd2FyZEVycm9yLFxuICBHaXRQdXNoRXJyb3I6IEdpdFB1c2hFcnJvcixcbiAgSHR0cEVycm9yOiBIdHRwRXJyb3IsXG4gIEludGVybmFsRXJyb3I6IEludGVybmFsRXJyb3IsXG4gIEludmFsaWRGaWxlcGF0aEVycm9yOiBJbnZhbGlkRmlsZXBhdGhFcnJvcixcbiAgSW52YWxpZE9pZEVycm9yOiBJbnZhbGlkT2lkRXJyb3IsXG4gIEludmFsaWRSZWZOYW1lRXJyb3I6IEludmFsaWRSZWZOYW1lRXJyb3IsXG4gIE1heERlcHRoRXJyb3I6IE1heERlcHRoRXJyb3IsXG4gIE1lcmdlTm90U3VwcG9ydGVkRXJyb3I6IE1lcmdlTm90U3VwcG9ydGVkRXJyb3IsXG4gIE1pc3NpbmdOYW1lRXJyb3I6IE1pc3NpbmdOYW1lRXJyb3IsXG4gIE1pc3NpbmdQYXJhbWV0ZXJFcnJvcjogTWlzc2luZ1BhcmFtZXRlckVycm9yLFxuICBOb1JlZnNwZWNFcnJvcjogTm9SZWZzcGVjRXJyb3IsXG4gIE5vdEZvdW5kRXJyb3I6IE5vdEZvdW5kRXJyb3IsXG4gIE9iamVjdFR5cGVFcnJvcjogT2JqZWN0VHlwZUVycm9yLFxuICBQYXJzZUVycm9yOiBQYXJzZUVycm9yLFxuICBQdXNoUmVqZWN0ZWRFcnJvcjogUHVzaFJlamVjdGVkRXJyb3IsXG4gIFJlbW90ZUNhcGFiaWxpdHlFcnJvcjogUmVtb3RlQ2FwYWJpbGl0eUVycm9yLFxuICBTbWFydEh0dHBFcnJvcjogU21hcnRIdHRwRXJyb3IsXG4gIFVua25vd25UcmFuc3BvcnRFcnJvcjogVW5rbm93blRyYW5zcG9ydEVycm9yLFxuICBVcmxQYXJzZUVycm9yOiBVcmxQYXJzZUVycm9yLFxuICBVc2VyQ2FuY2VsZWRFcnJvcjogVXNlckNhbmNlbGVkRXJyb3Jcbn0pO1xuXG5mdW5jdGlvbiBmb3JtYXRBdXRob3IoeyBuYW1lLCBlbWFpbCwgdGltZXN0YW1wLCB0aW1lem9uZU9mZnNldCB9KSB7XG4gIHRpbWV6b25lT2Zmc2V0ID0gZm9ybWF0VGltZXpvbmVPZmZzZXQodGltZXpvbmVPZmZzZXQpO1xuICByZXR1cm4gYCR7bmFtZX0gPCR7ZW1haWx9PiAke3RpbWVzdGFtcH0gJHt0aW1lem9uZU9mZnNldH1gXG59XG5cbi8vIFRoZSBhbW91bnQgb2YgZWZmb3J0IHRoYXQgd2VudCBpbnRvIGNyYWZ0aW5nIHRoZXNlIGNhc2VzIHRvIGhhbmRsZVxuLy8gLTAgKGp1c3Qgc28gd2UgZG9uJ3QgbG9zZSB0aGF0IGluZm9ybWF0aW9uIHdoZW4gcGFyc2luZyBhbmQgcmVjb25zdHJ1Y3RpbmcpXG4vLyBidXQgY2FuIGFsc28gZGVmYXVsdCB0byArMCB3YXMgZXh0cmFvcmRpbmFyeS5cblxuZnVuY3Rpb24gZm9ybWF0VGltZXpvbmVPZmZzZXQobWludXRlcykge1xuICBjb25zdCBzaWduID0gc2ltcGxlU2lnbihuZWdhdGVFeGNlcHRGb3JaZXJvKG1pbnV0ZXMpKTtcbiAgbWludXRlcyA9IE1hdGguYWJzKG1pbnV0ZXMpO1xuICBjb25zdCBob3VycyA9IE1hdGguZmxvb3IobWludXRlcyAvIDYwKTtcbiAgbWludXRlcyAtPSBob3VycyAqIDYwO1xuICBsZXQgc3RySG91cnMgPSBTdHJpbmcoaG91cnMpO1xuICBsZXQgc3RyTWludXRlcyA9IFN0cmluZyhtaW51dGVzKTtcbiAgaWYgKHN0ckhvdXJzLmxlbmd0aCA8IDIpIHN0ckhvdXJzID0gJzAnICsgc3RySG91cnM7XG4gIGlmIChzdHJNaW51dGVzLmxlbmd0aCA8IDIpIHN0ck1pbnV0ZXMgPSAnMCcgKyBzdHJNaW51dGVzO1xuICByZXR1cm4gKHNpZ24gPT09IC0xID8gJy0nIDogJysnKSArIHN0ckhvdXJzICsgc3RyTWludXRlc1xufVxuXG5mdW5jdGlvbiBzaW1wbGVTaWduKG4pIHtcbiAgcmV0dXJuIE1hdGguc2lnbihuKSB8fCAoT2JqZWN0LmlzKG4sIC0wKSA/IC0xIDogMSlcbn1cblxuZnVuY3Rpb24gbmVnYXRlRXhjZXB0Rm9yWmVybyhuKSB7XG4gIHJldHVybiBuID09PSAwID8gbiA6IC1uXG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZU5ld2xpbmVzKHN0cikge1xuICAvLyByZW1vdmUgYWxsIDxDUj5cbiAgc3RyID0gc3RyLnJlcGxhY2UoL1xcci9nLCAnJyk7XG4gIC8vIG5vIGV4dHJhIG5ld2xpbmVzIHVwIGZyb250XG4gIHN0ciA9IHN0ci5yZXBsYWNlKC9eXFxuKy8sICcnKTtcbiAgLy8gYW5kIGEgc2luZ2xlIG5ld2xpbmUgYXQgdGhlIGVuZFxuICBzdHIgPSBzdHIucmVwbGFjZSgvXFxuKyQvLCAnJykgKyAnXFxuJztcbiAgcmV0dXJuIHN0clxufVxuXG5mdW5jdGlvbiBwYXJzZUF1dGhvcihhdXRob3IpIHtcbiAgY29uc3QgWywgbmFtZSwgZW1haWwsIHRpbWVzdGFtcCwgb2Zmc2V0XSA9IGF1dGhvci5tYXRjaChcbiAgICAvXiguKikgPCguKik+ICguKikgKC4qKSQvXG4gICk7XG4gIHJldHVybiB7XG4gICAgbmFtZTogbmFtZSxcbiAgICBlbWFpbDogZW1haWwsXG4gICAgdGltZXN0YW1wOiBOdW1iZXIodGltZXN0YW1wKSxcbiAgICB0aW1lem9uZU9mZnNldDogcGFyc2VUaW1lem9uZU9mZnNldChvZmZzZXQpLFxuICB9XG59XG5cbi8vIFRoZSBhbW91bnQgb2YgZWZmb3J0IHRoYXQgd2VudCBpbnRvIGNyYWZ0aW5nIHRoZXNlIGNhc2VzIHRvIGhhbmRsZVxuLy8gLTAgKGp1c3Qgc28gd2UgZG9uJ3QgbG9zZSB0aGF0IGluZm9ybWF0aW9uIHdoZW4gcGFyc2luZyBhbmQgcmVjb25zdHJ1Y3RpbmcpXG4vLyBidXQgY2FuIGFsc28gZGVmYXVsdCB0byArMCB3YXMgZXh0cmFvcmRpbmFyeS5cblxuZnVuY3Rpb24gcGFyc2VUaW1lem9uZU9mZnNldChvZmZzZXQpIHtcbiAgbGV0IFssIHNpZ24sIGhvdXJzLCBtaW51dGVzXSA9IG9mZnNldC5tYXRjaCgvKFxcK3wtKShcXGRcXGQpKFxcZFxcZCkvKTtcbiAgbWludXRlcyA9IChzaWduID09PSAnKycgPyAxIDogLTEpICogKE51bWJlcihob3VycykgKiA2MCArIE51bWJlcihtaW51dGVzKSk7XG4gIHJldHVybiBuZWdhdGVFeGNlcHRGb3JaZXJvJDEobWludXRlcylcbn1cblxuZnVuY3Rpb24gbmVnYXRlRXhjZXB0Rm9yWmVybyQxKG4pIHtcbiAgcmV0dXJuIG4gPT09IDAgPyBuIDogLW5cbn1cblxuY2xhc3MgR2l0QW5ub3RhdGVkVGFnIHtcbiAgY29uc3RydWN0b3IodGFnKSB7XG4gICAgaWYgKHR5cGVvZiB0YWcgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aGlzLl90YWcgPSB0YWc7XG4gICAgfSBlbHNlIGlmIChCdWZmZXIuaXNCdWZmZXIodGFnKSkge1xuICAgICAgdGhpcy5fdGFnID0gdGFnLnRvU3RyaW5nKCd1dGY4Jyk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdGFnID09PSAnb2JqZWN0Jykge1xuICAgICAgdGhpcy5fdGFnID0gR2l0QW5ub3RhdGVkVGFnLnJlbmRlcih0YWcpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgSW50ZXJuYWxFcnJvcihcbiAgICAgICAgJ2ludmFsaWQgdHlwZSBwYXNzZWQgdG8gR2l0QW5ub3RhdGVkVGFnIGNvbnN0cnVjdG9yJ1xuICAgICAgKVxuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBmcm9tKHRhZykge1xuICAgIHJldHVybiBuZXcgR2l0QW5ub3RhdGVkVGFnKHRhZylcbiAgfVxuXG4gIHN0YXRpYyByZW5kZXIob2JqKSB7XG4gICAgcmV0dXJuIGBvYmplY3QgJHtvYmoub2JqZWN0fVxudHlwZSAke29iai50eXBlfVxudGFnICR7b2JqLnRhZ31cbnRhZ2dlciAke2Zvcm1hdEF1dGhvcihvYmoudGFnZ2VyKX1cblxuJHtvYmoubWVzc2FnZX1cbiR7b2JqLmdwZ3NpZyA/IG9iai5ncGdzaWcgOiAnJ31gXG4gIH1cblxuICBqdXN0SGVhZGVycygpIHtcbiAgICByZXR1cm4gdGhpcy5fdGFnLnNsaWNlKDAsIHRoaXMuX3RhZy5pbmRleE9mKCdcXG5cXG4nKSlcbiAgfVxuXG4gIG1lc3NhZ2UoKSB7XG4gICAgY29uc3QgdGFnID0gdGhpcy53aXRob3V0U2lnbmF0dXJlKCk7XG4gICAgcmV0dXJuIHRhZy5zbGljZSh0YWcuaW5kZXhPZignXFxuXFxuJykgKyAyKVxuICB9XG5cbiAgcGFyc2UoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24odGhpcy5oZWFkZXJzKCksIHtcbiAgICAgIG1lc3NhZ2U6IHRoaXMubWVzc2FnZSgpLFxuICAgICAgZ3Bnc2lnOiB0aGlzLmdwZ3NpZygpLFxuICAgIH0pXG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RhZ1xuICB9XG5cbiAgaGVhZGVycygpIHtcbiAgICBjb25zdCBoZWFkZXJzID0gdGhpcy5qdXN0SGVhZGVycygpLnNwbGl0KCdcXG4nKTtcbiAgICBjb25zdCBocyA9IFtdO1xuICAgIGZvciAoY29uc3QgaCBvZiBoZWFkZXJzKSB7XG4gICAgICBpZiAoaFswXSA9PT0gJyAnKSB7XG4gICAgICAgIC8vIGNvbWJpbmUgd2l0aCBwcmV2aW91cyBoZWFkZXIgKHdpdGhvdXQgc3BhY2UgaW5kZW50KVxuICAgICAgICBoc1tocy5sZW5ndGggLSAxXSArPSAnXFxuJyArIGguc2xpY2UoMSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBocy5wdXNoKGgpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBvYmogPSB7fTtcbiAgICBmb3IgKGNvbnN0IGggb2YgaHMpIHtcbiAgICAgIGNvbnN0IGtleSA9IGguc2xpY2UoMCwgaC5pbmRleE9mKCcgJykpO1xuICAgICAgY29uc3QgdmFsdWUgPSBoLnNsaWNlKGguaW5kZXhPZignICcpICsgMSk7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmpba2V5XSkpIHtcbiAgICAgICAgb2JqW2tleV0ucHVzaCh2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvYmpba2V5XSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAob2JqLnRhZ2dlcikge1xuICAgICAgb2JqLnRhZ2dlciA9IHBhcnNlQXV0aG9yKG9iai50YWdnZXIpO1xuICAgIH1cbiAgICBpZiAob2JqLmNvbW1pdHRlcikge1xuICAgICAgb2JqLmNvbW1pdHRlciA9IHBhcnNlQXV0aG9yKG9iai5jb21taXR0ZXIpO1xuICAgIH1cbiAgICByZXR1cm4gb2JqXG4gIH1cblxuICB3aXRob3V0U2lnbmF0dXJlKCkge1xuICAgIGNvbnN0IHRhZyA9IG5vcm1hbGl6ZU5ld2xpbmVzKHRoaXMuX3RhZyk7XG4gICAgaWYgKHRhZy5pbmRleE9mKCdcXG4tLS0tLUJFR0lOIFBHUCBTSUdOQVRVUkUtLS0tLScpID09PSAtMSkgcmV0dXJuIHRhZ1xuICAgIHJldHVybiB0YWcuc2xpY2UoMCwgdGFnLmxhc3RJbmRleE9mKCdcXG4tLS0tLUJFR0lOIFBHUCBTSUdOQVRVUkUtLS0tLScpKVxuICB9XG5cbiAgZ3Bnc2lnKCkge1xuICAgIGlmICh0aGlzLl90YWcuaW5kZXhPZignXFxuLS0tLS1CRUdJTiBQR1AgU0lHTkFUVVJFLS0tLS0nKSA9PT0gLTEpIHJldHVyblxuICAgIGNvbnN0IHNpZ25hdHVyZSA9IHRoaXMuX3RhZy5zbGljZShcbiAgICAgIHRoaXMuX3RhZy5pbmRleE9mKCctLS0tLUJFR0lOIFBHUCBTSUdOQVRVUkUtLS0tLScpLFxuICAgICAgdGhpcy5fdGFnLmluZGV4T2YoJy0tLS0tRU5EIFBHUCBTSUdOQVRVUkUtLS0tLScpICtcbiAgICAgICAgJy0tLS0tRU5EIFBHUCBTSUdOQVRVUkUtLS0tLScubGVuZ3RoXG4gICAgKTtcbiAgICByZXR1cm4gbm9ybWFsaXplTmV3bGluZXMoc2lnbmF0dXJlKVxuICB9XG5cbiAgcGF5bG9hZCgpIHtcbiAgICByZXR1cm4gdGhpcy53aXRob3V0U2lnbmF0dXJlKCkgKyAnXFxuJ1xuICB9XG5cbiAgdG9PYmplY3QoKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHRoaXMuX3RhZywgJ3V0ZjgnKVxuICB9XG5cbiAgc3RhdGljIGFzeW5jIHNpZ24odGFnLCBzaWduLCBzZWNyZXRLZXkpIHtcbiAgICBjb25zdCBwYXlsb2FkID0gdGFnLnBheWxvYWQoKTtcbiAgICBsZXQgeyBzaWduYXR1cmUgfSA9IGF3YWl0IHNpZ24oeyBwYXlsb2FkLCBzZWNyZXRLZXkgfSk7XG4gICAgLy8gcmVub3JtYWxpemUgdGhlIGxpbmUgZW5kaW5ncyB0byB0aGUgb25lIHRydWUgbGluZS1lbmRpbmdcbiAgICBzaWduYXR1cmUgPSBub3JtYWxpemVOZXdsaW5lcyhzaWduYXR1cmUpO1xuICAgIGNvbnN0IHNpZ25lZFRhZyA9IHBheWxvYWQgKyBzaWduYXR1cmU7XG4gICAgLy8gcmV0dXJuIGEgbmV3IHRhZyBvYmplY3RcbiAgICByZXR1cm4gR2l0QW5ub3RhdGVkVGFnLmZyb20oc2lnbmVkVGFnKVxuICB9XG59XG5cbmZ1bmN0aW9uIGluZGVudChzdHIpIHtcbiAgcmV0dXJuIChcbiAgICBzdHJcbiAgICAgIC50cmltKClcbiAgICAgIC5zcGxpdCgnXFxuJylcbiAgICAgIC5tYXAoeCA9PiAnICcgKyB4KVxuICAgICAgLmpvaW4oJ1xcbicpICsgJ1xcbidcbiAgKVxufVxuXG5mdW5jdGlvbiBvdXRkZW50KHN0cikge1xuICByZXR1cm4gc3RyXG4gICAgLnNwbGl0KCdcXG4nKVxuICAgIC5tYXAoeCA9PiB4LnJlcGxhY2UoL14gLywgJycpKVxuICAgIC5qb2luKCdcXG4nKVxufVxuXG5jbGFzcyBHaXRDb21taXQge1xuICBjb25zdHJ1Y3Rvcihjb21taXQpIHtcbiAgICBpZiAodHlwZW9mIGNvbW1pdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRoaXMuX2NvbW1pdCA9IGNvbW1pdDtcbiAgICB9IGVsc2UgaWYgKEJ1ZmZlci5pc0J1ZmZlcihjb21taXQpKSB7XG4gICAgICB0aGlzLl9jb21taXQgPSBjb21taXQudG9TdHJpbmcoJ3V0ZjgnKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBjb21taXQgPT09ICdvYmplY3QnKSB7XG4gICAgICB0aGlzLl9jb21taXQgPSBHaXRDb21taXQucmVuZGVyKGNvbW1pdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBJbnRlcm5hbEVycm9yKCdpbnZhbGlkIHR5cGUgcGFzc2VkIHRvIEdpdENvbW1pdCBjb25zdHJ1Y3RvcicpXG4gICAgfVxuICB9XG5cbiAgc3RhdGljIGZyb21QYXlsb2FkU2lnbmF0dXJlKHsgcGF5bG9hZCwgc2lnbmF0dXJlIH0pIHtcbiAgICBjb25zdCBoZWFkZXJzID0gR2l0Q29tbWl0Lmp1c3RIZWFkZXJzKHBheWxvYWQpO1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBHaXRDb21taXQuanVzdE1lc3NhZ2UocGF5bG9hZCk7XG4gICAgY29uc3QgY29tbWl0ID0gbm9ybWFsaXplTmV3bGluZXMoXG4gICAgICBoZWFkZXJzICsgJ1xcbmdwZ3NpZycgKyBpbmRlbnQoc2lnbmF0dXJlKSArICdcXG4nICsgbWVzc2FnZVxuICAgICk7XG4gICAgcmV0dXJuIG5ldyBHaXRDb21taXQoY29tbWl0KVxuICB9XG5cbiAgc3RhdGljIGZyb20oY29tbWl0KSB7XG4gICAgcmV0dXJuIG5ldyBHaXRDb21taXQoY29tbWl0KVxuICB9XG5cbiAgdG9PYmplY3QoKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHRoaXMuX2NvbW1pdCwgJ3V0ZjgnKVxuICB9XG5cbiAgLy8gVG9kbzogYWxsb3cgc2V0dGluZyB0aGUgaGVhZGVycyBhbmQgbWVzc2FnZVxuICBoZWFkZXJzKCkge1xuICAgIHJldHVybiB0aGlzLnBhcnNlSGVhZGVycygpXG4gIH1cblxuICAvLyBUb2RvOiBhbGxvdyBzZXR0aW5nIHRoZSBoZWFkZXJzIGFuZCBtZXNzYWdlXG4gIG1lc3NhZ2UoKSB7XG4gICAgcmV0dXJuIEdpdENvbW1pdC5qdXN0TWVzc2FnZSh0aGlzLl9jb21taXQpXG4gIH1cblxuICBwYXJzZSgpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7IG1lc3NhZ2U6IHRoaXMubWVzc2FnZSgpIH0sIHRoaXMuaGVhZGVycygpKVxuICB9XG5cbiAgc3RhdGljIGp1c3RNZXNzYWdlKGNvbW1pdCkge1xuICAgIHJldHVybiBub3JtYWxpemVOZXdsaW5lcyhjb21taXQuc2xpY2UoY29tbWl0LmluZGV4T2YoJ1xcblxcbicpICsgMikpXG4gIH1cblxuICBzdGF0aWMganVzdEhlYWRlcnMoY29tbWl0KSB7XG4gICAgcmV0dXJuIGNvbW1pdC5zbGljZSgwLCBjb21taXQuaW5kZXhPZignXFxuXFxuJykpXG4gIH1cblxuICBwYXJzZUhlYWRlcnMoKSB7XG4gICAgY29uc3QgaGVhZGVycyA9IEdpdENvbW1pdC5qdXN0SGVhZGVycyh0aGlzLl9jb21taXQpLnNwbGl0KCdcXG4nKTtcbiAgICBjb25zdCBocyA9IFtdO1xuICAgIGZvciAoY29uc3QgaCBvZiBoZWFkZXJzKSB7XG4gICAgICBpZiAoaFswXSA9PT0gJyAnKSB7XG4gICAgICAgIC8vIGNvbWJpbmUgd2l0aCBwcmV2aW91cyBoZWFkZXIgKHdpdGhvdXQgc3BhY2UgaW5kZW50KVxuICAgICAgICBoc1tocy5sZW5ndGggLSAxXSArPSAnXFxuJyArIGguc2xpY2UoMSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBocy5wdXNoKGgpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBvYmogPSB7XG4gICAgICBwYXJlbnQ6IFtdLFxuICAgIH07XG4gICAgZm9yIChjb25zdCBoIG9mIGhzKSB7XG4gICAgICBjb25zdCBrZXkgPSBoLnNsaWNlKDAsIGguaW5kZXhPZignICcpKTtcbiAgICAgIGNvbnN0IHZhbHVlID0gaC5zbGljZShoLmluZGV4T2YoJyAnKSArIDEpO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqW2tleV0pKSB7XG4gICAgICAgIG9ialtrZXldLnB1c2godmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9iai5hdXRob3IpIHtcbiAgICAgIG9iai5hdXRob3IgPSBwYXJzZUF1dGhvcihvYmouYXV0aG9yKTtcbiAgICB9XG4gICAgaWYgKG9iai5jb21taXR0ZXIpIHtcbiAgICAgIG9iai5jb21taXR0ZXIgPSBwYXJzZUF1dGhvcihvYmouY29tbWl0dGVyKTtcbiAgICB9XG4gICAgcmV0dXJuIG9ialxuICB9XG5cbiAgc3RhdGljIHJlbmRlckhlYWRlcnMob2JqKSB7XG4gICAgbGV0IGhlYWRlcnMgPSAnJztcbiAgICBpZiAob2JqLnRyZWUpIHtcbiAgICAgIGhlYWRlcnMgKz0gYHRyZWUgJHtvYmoudHJlZX1cXG5gO1xuICAgIH0gZWxzZSB7XG4gICAgICBoZWFkZXJzICs9IGB0cmVlIDRiODI1ZGM2NDJjYjZlYjlhMDYwZTU0YmY4ZDY5Mjg4ZmJlZTQ5MDRcXG5gOyAvLyB0aGUgbnVsbCB0cmVlXG4gICAgfVxuICAgIGlmIChvYmoucGFyZW50KSB7XG4gICAgICBpZiAob2JqLnBhcmVudC5sZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgSW50ZXJuYWxFcnJvcihgY29tbWl0ICdwYXJlbnQnIHByb3BlcnR5IHNob3VsZCBiZSBhbiBhcnJheWApXG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IHAgb2Ygb2JqLnBhcmVudCkge1xuICAgICAgICBoZWFkZXJzICs9IGBwYXJlbnQgJHtwfVxcbmA7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGF1dGhvciA9IG9iai5hdXRob3I7XG4gICAgaGVhZGVycyArPSBgYXV0aG9yICR7Zm9ybWF0QXV0aG9yKGF1dGhvcil9XFxuYDtcbiAgICBjb25zdCBjb21taXR0ZXIgPSBvYmouY29tbWl0dGVyIHx8IG9iai5hdXRob3I7XG4gICAgaGVhZGVycyArPSBgY29tbWl0dGVyICR7Zm9ybWF0QXV0aG9yKGNvbW1pdHRlcil9XFxuYDtcbiAgICBpZiAob2JqLmdwZ3NpZykge1xuICAgICAgaGVhZGVycyArPSAnZ3Bnc2lnJyArIGluZGVudChvYmouZ3Bnc2lnKTtcbiAgICB9XG4gICAgcmV0dXJuIGhlYWRlcnNcbiAgfVxuXG4gIHN0YXRpYyByZW5kZXIob2JqKSB7XG4gICAgcmV0dXJuIEdpdENvbW1pdC5yZW5kZXJIZWFkZXJzKG9iaikgKyAnXFxuJyArIG5vcm1hbGl6ZU5ld2xpbmVzKG9iai5tZXNzYWdlKVxuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIHJldHVybiB0aGlzLl9jb21taXRcbiAgfVxuXG4gIHdpdGhvdXRTaWduYXR1cmUoKSB7XG4gICAgY29uc3QgY29tbWl0ID0gbm9ybWFsaXplTmV3bGluZXModGhpcy5fY29tbWl0KTtcbiAgICBpZiAoY29tbWl0LmluZGV4T2YoJ1xcbmdwZ3NpZycpID09PSAtMSkgcmV0dXJuIGNvbW1pdFxuICAgIGNvbnN0IGhlYWRlcnMgPSBjb21taXQuc2xpY2UoMCwgY29tbWl0LmluZGV4T2YoJ1xcbmdwZ3NpZycpKTtcbiAgICBjb25zdCBtZXNzYWdlID0gY29tbWl0LnNsaWNlKFxuICAgICAgY29tbWl0LmluZGV4T2YoJy0tLS0tRU5EIFBHUCBTSUdOQVRVUkUtLS0tLVxcbicpICtcbiAgICAgICAgJy0tLS0tRU5EIFBHUCBTSUdOQVRVUkUtLS0tLVxcbicubGVuZ3RoXG4gICAgKTtcbiAgICByZXR1cm4gbm9ybWFsaXplTmV3bGluZXMoaGVhZGVycyArICdcXG4nICsgbWVzc2FnZSlcbiAgfVxuXG4gIGlzb2xhdGVTaWduYXR1cmUoKSB7XG4gICAgY29uc3Qgc2lnbmF0dXJlID0gdGhpcy5fY29tbWl0LnNsaWNlKFxuICAgICAgdGhpcy5fY29tbWl0LmluZGV4T2YoJy0tLS0tQkVHSU4gUEdQIFNJR05BVFVSRS0tLS0tJyksXG4gICAgICB0aGlzLl9jb21taXQuaW5kZXhPZignLS0tLS1FTkQgUEdQIFNJR05BVFVSRS0tLS0tJykgK1xuICAgICAgICAnLS0tLS1FTkQgUEdQIFNJR05BVFVSRS0tLS0tJy5sZW5ndGhcbiAgICApO1xuICAgIHJldHVybiBvdXRkZW50KHNpZ25hdHVyZSlcbiAgfVxuXG4gIHN0YXRpYyBhc3luYyBzaWduKGNvbW1pdCwgc2lnbiwgc2VjcmV0S2V5KSB7XG4gICAgY29uc3QgcGF5bG9hZCA9IGNvbW1pdC53aXRob3V0U2lnbmF0dXJlKCk7XG4gICAgY29uc3QgbWVzc2FnZSA9IEdpdENvbW1pdC5qdXN0TWVzc2FnZShjb21taXQuX2NvbW1pdCk7XG4gICAgbGV0IHsgc2lnbmF0dXJlIH0gPSBhd2FpdCBzaWduKHsgcGF5bG9hZCwgc2VjcmV0S2V5IH0pO1xuICAgIC8vIHJlbm9ybWFsaXplIHRoZSBsaW5lIGVuZGluZ3MgdG8gdGhlIG9uZSB0cnVlIGxpbmUtZW5kaW5nXG4gICAgc2lnbmF0dXJlID0gbm9ybWFsaXplTmV3bGluZXMoc2lnbmF0dXJlKTtcbiAgICBjb25zdCBoZWFkZXJzID0gR2l0Q29tbWl0Lmp1c3RIZWFkZXJzKGNvbW1pdC5fY29tbWl0KTtcbiAgICBjb25zdCBzaWduZWRDb21taXQgPVxuICAgICAgaGVhZGVycyArICdcXG4nICsgJ2dwZ3NpZycgKyBpbmRlbnQoc2lnbmF0dXJlKSArICdcXG4nICsgbWVzc2FnZTtcbiAgICAvLyByZXR1cm4gYSBuZXcgY29tbWl0IG9iamVjdFxuICAgIHJldHVybiBHaXRDb21taXQuZnJvbShzaWduZWRDb21taXQpXG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gcmVzb2x2ZVRyZWUoeyBmcywgY2FjaGUsIGdpdGRpciwgb2lkIH0pIHtcbiAgLy8gRW1wdHkgdHJlZSAtIGJ5cGFzcyBgcmVhZE9iamVjdGBcbiAgaWYgKG9pZCA9PT0gJzRiODI1ZGM2NDJjYjZlYjlhMDYwZTU0YmY4ZDY5Mjg4ZmJlZTQ5MDQnKSB7XG4gICAgcmV0dXJuIHsgdHJlZTogR2l0VHJlZS5mcm9tKFtdKSwgb2lkIH1cbiAgfVxuICBjb25zdCB7IHR5cGUsIG9iamVjdCB9ID0gYXdhaXQgX3JlYWRPYmplY3QoeyBmcywgY2FjaGUsIGdpdGRpciwgb2lkIH0pO1xuICAvLyBSZXNvbHZlIGFubm90YXRlZCB0YWcgb2JqZWN0cyB0byB3aGF0ZXZlclxuICBpZiAodHlwZSA9PT0gJ3RhZycpIHtcbiAgICBvaWQgPSBHaXRBbm5vdGF0ZWRUYWcuZnJvbShvYmplY3QpLnBhcnNlKCkub2JqZWN0O1xuICAgIHJldHVybiByZXNvbHZlVHJlZSh7IGZzLCBjYWNoZSwgZ2l0ZGlyLCBvaWQgfSlcbiAgfVxuICAvLyBSZXNvbHZlIGNvbW1pdHMgdG8gdHJlZXNcbiAgaWYgKHR5cGUgPT09ICdjb21taXQnKSB7XG4gICAgb2lkID0gR2l0Q29tbWl0LmZyb20ob2JqZWN0KS5wYXJzZSgpLnRyZWU7XG4gICAgcmV0dXJuIHJlc29sdmVUcmVlKHsgZnMsIGNhY2hlLCBnaXRkaXIsIG9pZCB9KVxuICB9XG4gIGlmICh0eXBlICE9PSAndHJlZScpIHtcbiAgICB0aHJvdyBuZXcgT2JqZWN0VHlwZUVycm9yKG9pZCwgdHlwZSwgJ3RyZWUnKVxuICB9XG4gIHJldHVybiB7IHRyZWU6IEdpdFRyZWUuZnJvbShvYmplY3QpLCBvaWQgfVxufVxuXG5jbGFzcyBHaXRXYWxrZXJSZXBvIHtcbiAgY29uc3RydWN0b3IoeyBmcywgZ2l0ZGlyLCByZWYsIGNhY2hlIH0pIHtcbiAgICB0aGlzLmZzID0gZnM7XG4gICAgdGhpcy5jYWNoZSA9IGNhY2hlO1xuICAgIHRoaXMuZ2l0ZGlyID0gZ2l0ZGlyO1xuICAgIHRoaXMubWFwUHJvbWlzZSA9IChhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtYXAgPSBuZXcgTWFwKCk7XG4gICAgICBsZXQgb2lkO1xuICAgICAgdHJ5IHtcbiAgICAgICAgb2lkID0gYXdhaXQgR2l0UmVmTWFuYWdlci5yZXNvbHZlKHsgZnMsIGdpdGRpciwgcmVmIH0pO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIE5vdEZvdW5kRXJyb3IpIHtcbiAgICAgICAgICAvLyBIYW5kbGUgZnJlc2ggYnJhbmNoZXMgd2l0aCBubyBjb21taXRzXG4gICAgICAgICAgb2lkID0gJzRiODI1ZGM2NDJjYjZlYjlhMDYwZTU0YmY4ZDY5Mjg4ZmJlZTQ5MDQnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCB0cmVlID0gYXdhaXQgcmVzb2x2ZVRyZWUoeyBmcywgY2FjaGU6IHRoaXMuY2FjaGUsIGdpdGRpciwgb2lkIH0pO1xuICAgICAgdHJlZS50eXBlID0gJ3RyZWUnO1xuICAgICAgdHJlZS5tb2RlID0gJzQwMDAwJztcbiAgICAgIG1hcC5zZXQoJy4nLCB0cmVlKTtcbiAgICAgIHJldHVybiBtYXBcbiAgICB9KSgpO1xuICAgIGNvbnN0IHdhbGtlciA9IHRoaXM7XG4gICAgdGhpcy5Db25zdHJ1Y3RFbnRyeSA9IGNsYXNzIFRyZWVFbnRyeSB7XG4gICAgICBjb25zdHJ1Y3RvcihmdWxscGF0aCkge1xuICAgICAgICB0aGlzLl9mdWxscGF0aCA9IGZ1bGxwYXRoO1xuICAgICAgICB0aGlzLl90eXBlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX21vZGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fc3RhdCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9jb250ZW50ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX29pZCA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBhc3luYyB0eXBlKCkge1xuICAgICAgICByZXR1cm4gd2Fsa2VyLnR5cGUodGhpcylcbiAgICAgIH1cblxuICAgICAgYXN5bmMgbW9kZSgpIHtcbiAgICAgICAgcmV0dXJuIHdhbGtlci5tb2RlKHRoaXMpXG4gICAgICB9XG5cbiAgICAgIGFzeW5jIHN0YXQoKSB7XG4gICAgICAgIHJldHVybiB3YWxrZXIuc3RhdCh0aGlzKVxuICAgICAgfVxuXG4gICAgICBhc3luYyBjb250ZW50KCkge1xuICAgICAgICByZXR1cm4gd2Fsa2VyLmNvbnRlbnQodGhpcylcbiAgICAgIH1cblxuICAgICAgYXN5bmMgb2lkKCkge1xuICAgICAgICByZXR1cm4gd2Fsa2VyLm9pZCh0aGlzKVxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICBhc3luYyByZWFkZGlyKGVudHJ5KSB7XG4gICAgY29uc3QgZmlsZXBhdGggPSBlbnRyeS5fZnVsbHBhdGg7XG4gICAgY29uc3QgeyBmcywgY2FjaGUsIGdpdGRpciB9ID0gdGhpcztcbiAgICBjb25zdCBtYXAgPSBhd2FpdCB0aGlzLm1hcFByb21pc2U7XG4gICAgY29uc3Qgb2JqID0gbWFwLmdldChmaWxlcGF0aCk7XG4gICAgaWYgKCFvYmopIHRocm93IG5ldyBFcnJvcihgTm8gb2JqIGZvciAke2ZpbGVwYXRofWApXG4gICAgY29uc3Qgb2lkID0gb2JqLm9pZDtcbiAgICBpZiAoIW9pZCkgdGhyb3cgbmV3IEVycm9yKGBObyBvaWQgZm9yIG9iaiAke0pTT04uc3RyaW5naWZ5KG9iail9YClcbiAgICBpZiAob2JqLnR5cGUgIT09ICd0cmVlJykge1xuICAgICAgLy8gVE9ETzogc3VwcG9ydCBzdWJtb2R1bGVzICh0eXBlID09PSAnY29tbWl0JylcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICAgIGNvbnN0IHsgdHlwZSwgb2JqZWN0IH0gPSBhd2FpdCBfcmVhZE9iamVjdCh7IGZzLCBjYWNoZSwgZ2l0ZGlyLCBvaWQgfSk7XG4gICAgaWYgKHR5cGUgIT09IG9iai50eXBlKSB7XG4gICAgICB0aHJvdyBuZXcgT2JqZWN0VHlwZUVycm9yKG9pZCwgdHlwZSwgb2JqLnR5cGUpXG4gICAgfVxuICAgIGNvbnN0IHRyZWUgPSBHaXRUcmVlLmZyb20ob2JqZWN0KTtcbiAgICAvLyBjYWNoZSBhbGwgZW50cmllc1xuICAgIGZvciAoY29uc3QgZW50cnkgb2YgdHJlZSkge1xuICAgICAgbWFwLnNldChqb2luKGZpbGVwYXRoLCBlbnRyeS5wYXRoKSwgZW50cnkpO1xuICAgIH1cbiAgICByZXR1cm4gdHJlZS5lbnRyaWVzKCkubWFwKGVudHJ5ID0+IGpvaW4oZmlsZXBhdGgsIGVudHJ5LnBhdGgpKVxuICB9XG5cbiAgYXN5bmMgdHlwZShlbnRyeSkge1xuICAgIGlmIChlbnRyeS5fdHlwZSA9PT0gZmFsc2UpIHtcbiAgICAgIGNvbnN0IG1hcCA9IGF3YWl0IHRoaXMubWFwUHJvbWlzZTtcbiAgICAgIGNvbnN0IHsgdHlwZSB9ID0gbWFwLmdldChlbnRyeS5fZnVsbHBhdGgpO1xuICAgICAgZW50cnkuX3R5cGUgPSB0eXBlO1xuICAgIH1cbiAgICByZXR1cm4gZW50cnkuX3R5cGVcbiAgfVxuXG4gIGFzeW5jIG1vZGUoZW50cnkpIHtcbiAgICBpZiAoZW50cnkuX21vZGUgPT09IGZhbHNlKSB7XG4gICAgICBjb25zdCBtYXAgPSBhd2FpdCB0aGlzLm1hcFByb21pc2U7XG4gICAgICBjb25zdCB7IG1vZGUgfSA9IG1hcC5nZXQoZW50cnkuX2Z1bGxwYXRoKTtcbiAgICAgIGVudHJ5Ll9tb2RlID0gbm9ybWFsaXplTW9kZShwYXJzZUludChtb2RlLCA4KSk7XG4gICAgfVxuICAgIHJldHVybiBlbnRyeS5fbW9kZVxuICB9XG5cbiAgYXN5bmMgc3RhdChfZW50cnkpIHt9XG5cbiAgYXN5bmMgY29udGVudChlbnRyeSkge1xuICAgIGlmIChlbnRyeS5fY29udGVudCA9PT0gZmFsc2UpIHtcbiAgICAgIGNvbnN0IG1hcCA9IGF3YWl0IHRoaXMubWFwUHJvbWlzZTtcbiAgICAgIGNvbnN0IHsgZnMsIGNhY2hlLCBnaXRkaXIgfSA9IHRoaXM7XG4gICAgICBjb25zdCBvYmogPSBtYXAuZ2V0KGVudHJ5Ll9mdWxscGF0aCk7XG4gICAgICBjb25zdCBvaWQgPSBvYmoub2lkO1xuICAgICAgY29uc3QgeyB0eXBlLCBvYmplY3QgfSA9IGF3YWl0IF9yZWFkT2JqZWN0KHsgZnMsIGNhY2hlLCBnaXRkaXIsIG9pZCB9KTtcbiAgICAgIGlmICh0eXBlICE9PSAnYmxvYicpIHtcbiAgICAgICAgZW50cnkuX2NvbnRlbnQgPSB1bmRlZmluZWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbnRyeS5fY29udGVudCA9IG5ldyBVaW50OEFycmF5KG9iamVjdCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlbnRyeS5fY29udGVudFxuICB9XG5cbiAgYXN5bmMgb2lkKGVudHJ5KSB7XG4gICAgaWYgKGVudHJ5Ll9vaWQgPT09IGZhbHNlKSB7XG4gICAgICBjb25zdCBtYXAgPSBhd2FpdCB0aGlzLm1hcFByb21pc2U7XG4gICAgICBjb25zdCBvYmogPSBtYXAuZ2V0KGVudHJ5Ll9mdWxscGF0aCk7XG4gICAgICBlbnRyeS5fb2lkID0gb2JqLm9pZDtcbiAgICB9XG4gICAgcmV0dXJuIGVudHJ5Ll9vaWRcbiAgfVxufVxuXG4vLyBAdHMtY2hlY2tcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gYXJnc1xuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLnJlZj0nSEVBRCddXG4gKiBAcmV0dXJucyB7V2Fsa2VyfVxuICovXG5mdW5jdGlvbiBUUkVFKHsgcmVmID0gJ0hFQUQnIH0pIHtcbiAgY29uc3QgbyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBHaXRXYWxrU3ltYm9sLCB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uKHsgZnMsIGdpdGRpciwgY2FjaGUgfSkge1xuICAgICAgcmV0dXJuIG5ldyBHaXRXYWxrZXJSZXBvKHsgZnMsIGdpdGRpciwgcmVmLCBjYWNoZSB9KVxuICAgIH0sXG4gIH0pO1xuICBPYmplY3QuZnJlZXplKG8pO1xuICByZXR1cm4gb1xufVxuXG4vLyBAdHMtY2hlY2tcblxuY2xhc3MgR2l0V2Fsa2VyRnMge1xuICBjb25zdHJ1Y3Rvcih7IGZzLCBkaXIsIGdpdGRpciwgY2FjaGUgfSkge1xuICAgIHRoaXMuZnMgPSBmcztcbiAgICB0aGlzLmNhY2hlID0gY2FjaGU7XG4gICAgdGhpcy5kaXIgPSBkaXI7XG4gICAgdGhpcy5naXRkaXIgPSBnaXRkaXI7XG4gICAgY29uc3Qgd2Fsa2VyID0gdGhpcztcbiAgICB0aGlzLkNvbnN0cnVjdEVudHJ5ID0gY2xhc3MgV29ya2RpckVudHJ5IHtcbiAgICAgIGNvbnN0cnVjdG9yKGZ1bGxwYXRoKSB7XG4gICAgICAgIHRoaXMuX2Z1bGxwYXRoID0gZnVsbHBhdGg7XG4gICAgICAgIHRoaXMuX3R5cGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fbW9kZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9zdGF0ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2NvbnRlbnQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fb2lkID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGFzeW5jIHR5cGUoKSB7XG4gICAgICAgIHJldHVybiB3YWxrZXIudHlwZSh0aGlzKVxuICAgICAgfVxuXG4gICAgICBhc3luYyBtb2RlKCkge1xuICAgICAgICByZXR1cm4gd2Fsa2VyLm1vZGUodGhpcylcbiAgICAgIH1cblxuICAgICAgYXN5bmMgc3RhdCgpIHtcbiAgICAgICAgcmV0dXJuIHdhbGtlci5zdGF0KHRoaXMpXG4gICAgICB9XG5cbiAgICAgIGFzeW5jIGNvbnRlbnQoKSB7XG4gICAgICAgIHJldHVybiB3YWxrZXIuY29udGVudCh0aGlzKVxuICAgICAgfVxuXG4gICAgICBhc3luYyBvaWQoKSB7XG4gICAgICAgIHJldHVybiB3YWxrZXIub2lkKHRoaXMpXG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIGFzeW5jIHJlYWRkaXIoZW50cnkpIHtcbiAgICBjb25zdCBmaWxlcGF0aCA9IGVudHJ5Ll9mdWxscGF0aDtcbiAgICBjb25zdCB7IGZzLCBkaXIgfSA9IHRoaXM7XG4gICAgY29uc3QgbmFtZXMgPSBhd2FpdCBmcy5yZWFkZGlyKGpvaW4oZGlyLCBmaWxlcGF0aCkpO1xuICAgIGlmIChuYW1lcyA9PT0gbnVsbCkgcmV0dXJuIG51bGxcbiAgICByZXR1cm4gbmFtZXMubWFwKG5hbWUgPT4gam9pbihmaWxlcGF0aCwgbmFtZSkpXG4gIH1cblxuICBhc3luYyB0eXBlKGVudHJ5KSB7XG4gICAgaWYgKGVudHJ5Ll90eXBlID09PSBmYWxzZSkge1xuICAgICAgYXdhaXQgZW50cnkuc3RhdCgpO1xuICAgIH1cbiAgICByZXR1cm4gZW50cnkuX3R5cGVcbiAgfVxuXG4gIGFzeW5jIG1vZGUoZW50cnkpIHtcbiAgICBpZiAoZW50cnkuX21vZGUgPT09IGZhbHNlKSB7XG4gICAgICBhd2FpdCBlbnRyeS5zdGF0KCk7XG4gICAgfVxuICAgIHJldHVybiBlbnRyeS5fbW9kZVxuICB9XG5cbiAgYXN5bmMgc3RhdChlbnRyeSkge1xuICAgIGlmIChlbnRyeS5fc3RhdCA9PT0gZmFsc2UpIHtcbiAgICAgIGNvbnN0IHsgZnMsIGRpciB9ID0gdGhpcztcbiAgICAgIGxldCBzdGF0ID0gYXdhaXQgZnMubHN0YXQoYCR7ZGlyfS8ke2VudHJ5Ll9mdWxscGF0aH1gKTtcbiAgICAgIGlmICghc3RhdCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYEVOT0VOVDogbm8gc3VjaCBmaWxlIG9yIGRpcmVjdG9yeSwgbHN0YXQgJyR7ZW50cnkuX2Z1bGxwYXRofSdgXG4gICAgICAgIClcbiAgICAgIH1cbiAgICAgIGxldCB0eXBlID0gc3RhdC5pc0RpcmVjdG9yeSgpID8gJ3RyZWUnIDogJ2Jsb2InO1xuICAgICAgaWYgKHR5cGUgPT09ICdibG9iJyAmJiAhc3RhdC5pc0ZpbGUoKSAmJiAhc3RhdC5pc1N5bWJvbGljTGluaygpKSB7XG4gICAgICAgIHR5cGUgPSAnc3BlY2lhbCc7XG4gICAgICB9XG4gICAgICBlbnRyeS5fdHlwZSA9IHR5cGU7XG4gICAgICBzdGF0ID0gbm9ybWFsaXplU3RhdHMoc3RhdCk7XG4gICAgICBlbnRyeS5fbW9kZSA9IHN0YXQubW9kZTtcbiAgICAgIC8vIHdvcmthcm91bmQgZm9yIGEgQnJvd3NlckZTIGVkZ2UgY2FzZVxuICAgICAgaWYgKHN0YXQuc2l6ZSA9PT0gLTEgJiYgZW50cnkuX2FjdHVhbFNpemUpIHtcbiAgICAgICAgc3RhdC5zaXplID0gZW50cnkuX2FjdHVhbFNpemU7XG4gICAgICB9XG4gICAgICBlbnRyeS5fc3RhdCA9IHN0YXQ7XG4gICAgfVxuICAgIHJldHVybiBlbnRyeS5fc3RhdFxuICB9XG5cbiAgYXN5bmMgY29udGVudChlbnRyeSkge1xuICAgIGlmIChlbnRyeS5fY29udGVudCA9PT0gZmFsc2UpIHtcbiAgICAgIGNvbnN0IHsgZnMsIGRpciB9ID0gdGhpcztcbiAgICAgIGlmICgoYXdhaXQgZW50cnkudHlwZSgpKSA9PT0gJ3RyZWUnKSB7XG4gICAgICAgIGVudHJ5Ll9jb250ZW50ID0gdW5kZWZpbmVkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgY29udGVudCA9IGF3YWl0IGZzLnJlYWQoYCR7ZGlyfS8ke2VudHJ5Ll9mdWxscGF0aH1gKTtcbiAgICAgICAgLy8gd29ya2Fyb3VuZCBmb3IgYSBCcm93c2VyRlMgZWRnZSBjYXNlXG4gICAgICAgIGVudHJ5Ll9hY3R1YWxTaXplID0gY29udGVudC5sZW5ndGg7XG4gICAgICAgIGlmIChlbnRyeS5fc3RhdCAmJiBlbnRyeS5fc3RhdC5zaXplID09PSAtMSkge1xuICAgICAgICAgIGVudHJ5Ll9zdGF0LnNpemUgPSBlbnRyeS5fYWN0dWFsU2l6ZTtcbiAgICAgICAgfVxuICAgICAgICBlbnRyeS5fY29udGVudCA9IG5ldyBVaW50OEFycmF5KGNvbnRlbnQpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZW50cnkuX2NvbnRlbnRcbiAgfVxuXG4gIGFzeW5jIG9pZChlbnRyeSkge1xuICAgIGlmIChlbnRyeS5fb2lkID09PSBmYWxzZSkge1xuICAgICAgY29uc3QgeyBmcywgZ2l0ZGlyLCBjYWNoZSB9ID0gdGhpcztcbiAgICAgIGxldCBvaWQ7XG4gICAgICAvLyBTZWUgaWYgd2UgY2FuIHVzZSB0aGUgU0hBMSBoYXNoIGluIHRoZSBpbmRleC5cbiAgICAgIGF3YWl0IEdpdEluZGV4TWFuYWdlci5hY3F1aXJlKHsgZnMsIGdpdGRpciwgY2FjaGUgfSwgYXN5bmMgZnVuY3Rpb24oXG4gICAgICAgIGluZGV4XG4gICAgICApIHtcbiAgICAgICAgY29uc3Qgc3RhZ2UgPSBpbmRleC5lbnRyaWVzTWFwLmdldChlbnRyeS5fZnVsbHBhdGgpO1xuICAgICAgICBjb25zdCBzdGF0cyA9IGF3YWl0IGVudHJ5LnN0YXQoKTtcbiAgICAgICAgaWYgKCFzdGFnZSB8fCBjb21wYXJlU3RhdHMoc3RhdHMsIHN0YWdlKSkge1xuICAgICAgICAgIGNvbnN0IGNvbnRlbnQgPSBhd2FpdCBlbnRyeS5jb250ZW50KCk7XG4gICAgICAgICAgaWYgKGNvbnRlbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgb2lkID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvaWQgPSBhd2FpdCBzaGFzdW0oXG4gICAgICAgICAgICAgIEdpdE9iamVjdC53cmFwKHsgdHlwZTogJ2Jsb2InLCBvYmplY3Q6IGF3YWl0IGVudHJ5LmNvbnRlbnQoKSB9KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmIChzdGFnZSAmJiBvaWQgPT09IHN0YWdlLm9pZCkge1xuICAgICAgICAgICAgICBpbmRleC5pbnNlcnQoe1xuICAgICAgICAgICAgICAgIGZpbGVwYXRoOiBlbnRyeS5fZnVsbHBhdGgsXG4gICAgICAgICAgICAgICAgc3RhdHMsXG4gICAgICAgICAgICAgICAgb2lkOiBvaWQsXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBVc2UgdGhlIGluZGV4IFNIQTEgcmF0aGVyIHRoYW4gY29tcHV0ZSBpdFxuICAgICAgICAgIG9pZCA9IHN0YWdlLm9pZDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBlbnRyeS5fb2lkID0gb2lkO1xuICAgIH1cbiAgICByZXR1cm4gZW50cnkuX29pZFxuICB9XG59XG5cbi8vIEB0cy1jaGVja1xuXG4vKipcbiAqIEByZXR1cm5zIHtXYWxrZXJ9XG4gKi9cbmZ1bmN0aW9uIFdPUktESVIoKSB7XG4gIGNvbnN0IG8gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgR2l0V2Fsa1N5bWJvbCwge1xuICAgIHZhbHVlOiBmdW5jdGlvbih7IGZzLCBkaXIsIGdpdGRpciwgY2FjaGUgfSkge1xuICAgICAgcmV0dXJuIG5ldyBHaXRXYWxrZXJGcyh7IGZzLCBkaXIsIGdpdGRpciwgY2FjaGUgfSlcbiAgICB9LFxuICB9KTtcbiAgT2JqZWN0LmZyZWV6ZShvKTtcbiAgcmV0dXJuIG9cbn1cblxuLy8gQHRzLWNoZWNrXG5cbi8vIEknbSBwdXR0aW5nIHRoaXMgaW4gYSBNYW5hZ2VyIGJlY2F1c2UgSSByZWNrb24gaXQgY291bGQgYmVuZWZpdFxuLy8gZnJvbSBhIExPVCBvZiBjYWNoZWluZy5cblxuLy8gVE9ETzogSW1wbGVtZW50IC5naXQvaW5mby9leGNsdWRlXG5cbmNsYXNzIEdpdElnbm9yZU1hbmFnZXIge1xuICBzdGF0aWMgYXN5bmMgaXNJZ25vcmVkKHsgZnMsIGRpciwgZ2l0ZGlyID0gam9pbihkaXIsICcuZ2l0JyksIGZpbGVwYXRoIH0pIHtcbiAgICAvLyBBTFdBWVMgaWdub3JlIFwiLmdpdFwiIGZvbGRlcnMuXG4gICAgaWYgKGJhc2VuYW1lKGZpbGVwYXRoKSA9PT0gJy5naXQnKSByZXR1cm4gdHJ1ZVxuICAgIC8vICcuJyBpcyBub3QgYSB2YWxpZCBnaXRpZ25vcmUgZW50cnksIHNvICcuJyBpcyBuZXZlciBpZ25vcmVkXG4gICAgaWYgKGZpbGVwYXRoID09PSAnLicpIHJldHVybiBmYWxzZVxuICAgIC8vIEZpbmQgYWxsIHRoZSAuZ2l0aWdub3JlIGZpbGVzIHRoYXQgY291bGQgYWZmZWN0IHRoaXMgZmlsZVxuICAgIGNvbnN0IHBhaXJzID0gW1xuICAgICAge1xuICAgICAgICBnaXRpZ25vcmU6IGpvaW4oZGlyLCAnLmdpdGlnbm9yZScpLFxuICAgICAgICBmaWxlcGF0aCxcbiAgICAgIH0sXG4gICAgXTtcbiAgICBjb25zdCBwaWVjZXMgPSBmaWxlcGF0aC5zcGxpdCgnLycpO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgcGllY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBmb2xkZXIgPSBwaWVjZXMuc2xpY2UoMCwgaSkuam9pbignLycpO1xuICAgICAgY29uc3QgZmlsZSA9IHBpZWNlcy5zbGljZShpKS5qb2luKCcvJyk7XG4gICAgICBwYWlycy5wdXNoKHtcbiAgICAgICAgZ2l0aWdub3JlOiBqb2luKGRpciwgZm9sZGVyLCAnLmdpdGlnbm9yZScpLFxuICAgICAgICBmaWxlcGF0aDogZmlsZSxcbiAgICAgIH0pO1xuICAgIH1cbiAgICBsZXQgaWdub3JlZFN0YXR1cyA9IGZhbHNlO1xuICAgIGZvciAoY29uc3QgcCBvZiBwYWlycykge1xuICAgICAgbGV0IGZpbGU7XG4gICAgICB0cnkge1xuICAgICAgICBmaWxlID0gYXdhaXQgZnMucmVhZChwLmdpdGlnbm9yZSwgJ3V0ZjgnKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBpZiAoZXJyLmNvZGUgPT09ICdOT0VOVCcpIGNvbnRpbnVlXG4gICAgICB9XG4gICAgICBjb25zdCBpZ24gPSBpZ25vcmUoKS5hZGQoZmlsZSk7XG4gICAgICAvLyBJZiB0aGUgcGFyZW50IGRpcmVjdG9yeSBpcyBleGNsdWRlZCwgd2UgYXJlIGRvbmUuXG4gICAgICAvLyBcIkl0IGlzIG5vdCBwb3NzaWJsZSB0byByZS1pbmNsdWRlIGEgZmlsZSBpZiBhIHBhcmVudCBkaXJlY3Rvcnkgb2YgdGhhdCBmaWxlIGlzIGV4Y2x1ZGVkLiBHaXQgZG9lc27igJl0IGxpc3QgZXhjbHVkZWQgZGlyZWN0b3JpZXMgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMsIHNvIGFueSBwYXR0ZXJucyBvbiBjb250YWluZWQgZmlsZXMgaGF2ZSBubyBlZmZlY3QsIG5vIG1hdHRlciB3aGVyZSB0aGV5IGFyZSBkZWZpbmVkLlwiXG4gICAgICAvLyBzb3VyY2U6IGh0dHBzOi8vZ2l0LXNjbS5jb20vZG9jcy9naXRpZ25vcmVcbiAgICAgIGNvbnN0IHBhcmVudGRpciA9IGRpcm5hbWUocC5maWxlcGF0aCk7XG4gICAgICBpZiAocGFyZW50ZGlyICE9PSAnLicgJiYgaWduLmlnbm9yZXMocGFyZW50ZGlyKSkgcmV0dXJuIHRydWVcbiAgICAgIC8vIElmIHRoZSBmaWxlIGlzIGN1cnJlbnRseSBpZ25vcmVkLCB0ZXN0IGZvciBVTmlnbm9yaW5nLlxuICAgICAgaWYgKGlnbm9yZWRTdGF0dXMpIHtcbiAgICAgICAgaWdub3JlZFN0YXR1cyA9ICFpZ24udGVzdChwLmZpbGVwYXRoKS51bmlnbm9yZWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZ25vcmVkU3RhdHVzID0gaWduLnRlc3QocC5maWxlcGF0aCkuaWdub3JlZDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGlnbm9yZWRTdGF0dXNcbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgaXMganVzdCBhIGNvbGxlY3Rpb24gb2YgaGVscGVyIGZ1bmN0aW9ucyByZWFsbHkuIEF0IGxlYXN0IHRoYXQncyBob3cgaXQgc3RhcnRlZC5cbiAqL1xuY2xhc3MgRmlsZVN5c3RlbSB7XG4gIGNvbnN0cnVjdG9yKGZzKSB7XG4gICAgaWYgKHR5cGVvZiBmcy5fb3JpZ2luYWxfdW53cmFwcGVkX2ZzICE9PSAndW5kZWZpbmVkJykgcmV0dXJuIGZzXG5cbiAgICBjb25zdCBwcm9taXNlcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZnMsICdwcm9taXNlcycpO1xuICAgIGlmIChwcm9taXNlcyAmJiBwcm9taXNlcy5lbnVtZXJhYmxlKSB7XG4gICAgICB0aGlzLl9yZWFkRmlsZSA9IGZzLnByb21pc2VzLnJlYWRGaWxlLmJpbmQoZnMucHJvbWlzZXMpO1xuICAgICAgdGhpcy5fd3JpdGVGaWxlID0gZnMucHJvbWlzZXMud3JpdGVGaWxlLmJpbmQoZnMucHJvbWlzZXMpO1xuICAgICAgdGhpcy5fbWtkaXIgPSBmcy5wcm9taXNlcy5ta2Rpci5iaW5kKGZzLnByb21pc2VzKTtcbiAgICAgIHRoaXMuX3JtZGlyID0gZnMucHJvbWlzZXMucm1kaXIuYmluZChmcy5wcm9taXNlcyk7XG4gICAgICB0aGlzLl91bmxpbmsgPSBmcy5wcm9taXNlcy51bmxpbmsuYmluZChmcy5wcm9taXNlcyk7XG4gICAgICB0aGlzLl9zdGF0ID0gZnMucHJvbWlzZXMuc3RhdC5iaW5kKGZzLnByb21pc2VzKTtcbiAgICAgIHRoaXMuX2xzdGF0ID0gZnMucHJvbWlzZXMubHN0YXQuYmluZChmcy5wcm9taXNlcyk7XG4gICAgICB0aGlzLl9yZWFkZGlyID0gZnMucHJvbWlzZXMucmVhZGRpci5iaW5kKGZzLnByb21pc2VzKTtcbiAgICAgIHRoaXMuX3JlYWRsaW5rID0gZnMucHJvbWlzZXMucmVhZGxpbmsuYmluZChmcy5wcm9taXNlcyk7XG4gICAgICB0aGlzLl9zeW1saW5rID0gZnMucHJvbWlzZXMuc3ltbGluay5iaW5kKGZzLnByb21pc2VzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fcmVhZEZpbGUgPSBwaWZ5KGZzLnJlYWRGaWxlLmJpbmQoZnMpKTtcbiAgICAgIHRoaXMuX3dyaXRlRmlsZSA9IHBpZnkoZnMud3JpdGVGaWxlLmJpbmQoZnMpKTtcbiAgICAgIHRoaXMuX21rZGlyID0gcGlmeShmcy5ta2Rpci5iaW5kKGZzKSk7XG4gICAgICB0aGlzLl9ybWRpciA9IHBpZnkoZnMucm1kaXIuYmluZChmcykpO1xuICAgICAgdGhpcy5fdW5saW5rID0gcGlmeShmcy51bmxpbmsuYmluZChmcykpO1xuICAgICAgdGhpcy5fc3RhdCA9IHBpZnkoZnMuc3RhdC5iaW5kKGZzKSk7XG4gICAgICB0aGlzLl9sc3RhdCA9IHBpZnkoZnMubHN0YXQuYmluZChmcykpO1xuICAgICAgdGhpcy5fcmVhZGRpciA9IHBpZnkoZnMucmVhZGRpci5iaW5kKGZzKSk7XG4gICAgICB0aGlzLl9yZWFkbGluayA9IHBpZnkoZnMucmVhZGxpbmsuYmluZChmcykpO1xuICAgICAgdGhpcy5fc3ltbGluayA9IHBpZnkoZnMuc3ltbGluay5iaW5kKGZzKSk7XG4gICAgfVxuICAgIHRoaXMuX29yaWdpbmFsX3Vud3JhcHBlZF9mcyA9IGZzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0cnVlIGlmIGEgZmlsZSBleGlzdHMsIGZhbHNlIGlmIGl0IGRvZXNuJ3QgZXhpc3QuXG4gICAqIFJldGhyb3dzIGVycm9ycyB0aGF0IGFyZW4ndCByZWxhdGVkIHRvIGZpbGUgZXhpc3RhbmNlLlxuICAgKi9cbiAgYXN5bmMgZXhpc3RzKGZpbGVwYXRoLCBvcHRpb25zID0ge30pIHtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgdGhpcy5fc3RhdChmaWxlcGF0aCk7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKGVyci5jb2RlID09PSAnRU5PRU5UJyB8fCBlcnIuY29kZSA9PT0gJ0VOT1RESVInKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5sb2coJ1VuaGFuZGxlZCBlcnJvciBpbiBcIkZpbGVTeXN0ZW0uZXhpc3RzKClcIiBmdW5jdGlvbicsIGVycik7XG4gICAgICAgIHRocm93IGVyclxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGNvbnRlbnRzIG9mIGEgZmlsZSBpZiBpdCBleGlzdHMsIG90aGVyd2lzZSByZXR1cm5zIG51bGwuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmaWxlcGF0aFxuICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPEJ1ZmZlcnxzdHJpbmd8bnVsbD59XG4gICAqL1xuICBhc3luYyByZWFkKGZpbGVwYXRoLCBvcHRpb25zID0ge30pIHtcbiAgICB0cnkge1xuICAgICAgbGV0IGJ1ZmZlciA9IGF3YWl0IHRoaXMuX3JlYWRGaWxlKGZpbGVwYXRoLCBvcHRpb25zKTtcbiAgICAgIC8vIENvbnZlcnQgcGxhaW4gQXJyYXlCdWZmZXJzIHRvIEJ1ZmZlcnNcbiAgICAgIGlmICh0eXBlb2YgYnVmZmVyICE9PSAnc3RyaW5nJykge1xuICAgICAgICBidWZmZXIgPSBCdWZmZXIuZnJvbShidWZmZXIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJ1ZmZlclxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogV3JpdGUgYSBmaWxlIChjcmVhdGluZyBtaXNzaW5nIGRpcmVjdG9yaWVzIGlmIG5lZWQgYmUpIHdpdGhvdXQgdGhyb3dpbmcgZXJyb3JzLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZmlsZXBhdGhcbiAgICogQHBhcmFtIHtCdWZmZXJ8VWludDhBcnJheXxzdHJpbmd9IGNvbnRlbnRzXG4gICAqIEBwYXJhbSB7b2JqZWN0fHN0cmluZ30gW29wdGlvbnNdXG4gICAqL1xuICBhc3luYyB3cml0ZShmaWxlcGF0aCwgY29udGVudHMsIG9wdGlvbnMgPSB7fSkge1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCB0aGlzLl93cml0ZUZpbGUoZmlsZXBhdGgsIGNvbnRlbnRzLCBvcHRpb25zKTtcbiAgICAgIHJldHVyblxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgLy8gSG1tLiBMZXQncyB0cnkgbWtkaXJwIGFuZCB0cnkgYWdhaW4uXG4gICAgICBhd2FpdCB0aGlzLm1rZGlyKGRpcm5hbWUoZmlsZXBhdGgpKTtcbiAgICAgIGF3YWl0IHRoaXMuX3dyaXRlRmlsZShmaWxlcGF0aCwgY29udGVudHMsIG9wdGlvbnMpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBNYWtlIGEgZGlyZWN0b3J5IChvciBzZXJpZXMgb2YgbmVzdGVkIGRpcmVjdG9yaWVzKSB3aXRob3V0IHRocm93aW5nIGFuIGVycm9yIGlmIGl0IGFscmVhZHkgZXhpc3RzLlxuICAgKi9cbiAgYXN5bmMgbWtkaXIoZmlsZXBhdGgsIF9zZWxmQ2FsbCA9IGZhbHNlKSB7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRoaXMuX21rZGlyKGZpbGVwYXRoKTtcbiAgICAgIHJldHVyblxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgLy8gSWYgZXJyIGlzIG51bGwgdGhlbiBvcGVyYXRpb24gc3VjY2VlZGVkIVxuICAgICAgaWYgKGVyciA9PT0gbnVsbCkgcmV0dXJuXG4gICAgICAvLyBJZiB0aGUgZGlyZWN0b3J5IGFscmVhZHkgZXhpc3RzLCB0aGF0J3MgT0shXG4gICAgICBpZiAoZXJyLmNvZGUgPT09ICdFRVhJU1QnKSByZXR1cm5cbiAgICAgIC8vIEF2b2lkIGluZmluaXRlIGxvb3BzIG9mIGZhaWx1cmVcbiAgICAgIGlmIChfc2VsZkNhbGwpIHRocm93IGVyclxuICAgICAgLy8gSWYgd2UgZ290IGEgXCJubyBzdWNoIGZpbGUgb3IgZGlyZWN0b3J5IGVycm9yXCIgYmFja3VwIGFuZCB0cnkgYWdhaW4uXG4gICAgICBpZiAoZXJyLmNvZGUgPT09ICdFTk9FTlQnKSB7XG4gICAgICAgIGNvbnN0IHBhcmVudCA9IGRpcm5hbWUoZmlsZXBhdGgpO1xuICAgICAgICAvLyBDaGVjayB0byBzZWUgaWYgd2UndmUgZ29uZSB0b28gZmFyXG4gICAgICAgIGlmIChwYXJlbnQgPT09ICcuJyB8fCBwYXJlbnQgPT09ICcvJyB8fCBwYXJlbnQgPT09IGZpbGVwYXRoKSB0aHJvdyBlcnJcbiAgICAgICAgLy8gSW5maW5pdGUgcmVjdXJzaW9uLCB3aGF0IGNvdWxkIGdvIHdyb25nP1xuICAgICAgICBhd2FpdCB0aGlzLm1rZGlyKHBhcmVudCk7XG4gICAgICAgIGF3YWl0IHRoaXMubWtkaXIoZmlsZXBhdGgsIHRydWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEZWxldGUgYSBmaWxlIHdpdGhvdXQgdGhyb3dpbmcgYW4gZXJyb3IgaWYgaXQgaXMgYWxyZWFkeSBkZWxldGVkLlxuICAgKi9cbiAgYXN5bmMgcm0oZmlsZXBhdGgpIHtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgdGhpcy5fdW5saW5rKGZpbGVwYXRoKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmIChlcnIuY29kZSAhPT0gJ0VOT0VOVCcpIHRocm93IGVyclxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEZWxldGUgYSBkaXJlY3Rvcnkgd2l0aG91dCB0aHJvd2luZyBhbiBlcnJvciBpZiBpdCBpcyBhbHJlYWR5IGRlbGV0ZWQuXG4gICAqL1xuICBhc3luYyBybWRpcihmaWxlcGF0aCkge1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCB0aGlzLl9ybWRpcihmaWxlcGF0aCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAoZXJyLmNvZGUgIT09ICdFTk9FTlQnKSB0aHJvdyBlcnJcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVhZCBhIGRpcmVjdG9yeSB3aXRob3V0IHRocm93aW5nIGFuIGVycm9yIGlzIHRoZSBkaXJlY3RvcnkgZG9lc24ndCBleGlzdFxuICAgKi9cbiAgYXN5bmMgcmVhZGRpcihmaWxlcGF0aCkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBuYW1lcyA9IGF3YWl0IHRoaXMuX3JlYWRkaXIoZmlsZXBhdGgpO1xuICAgICAgLy8gT3JkZXJpbmcgaXMgbm90IGd1YXJhbnRlZWQsIGFuZCBzeXN0ZW0gc3BlY2lmaWMgKFdpbmRvd3MgdnMgVW5peClcbiAgICAgIC8vIHNvIHdlIG11c3Qgc29ydCB0aGVtIG91cnNlbHZlcy5cbiAgICAgIG5hbWVzLnNvcnQoY29tcGFyZVN0cmluZ3MpO1xuICAgICAgcmV0dXJuIG5hbWVzXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAoZXJyLmNvZGUgPT09ICdFTk9URElSJykgcmV0dXJuIG51bGxcbiAgICAgIHJldHVybiBbXVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYSBmbGFzdCBsaXN0IG9mIGFsbCB0aGUgZmlsZXMgbmVzdGVkIGluc2lkZSBhIGRpcmVjdG9yeVxuICAgKlxuICAgKiBCYXNlZCBvbiBhbiBlbGVnYW50IGNvbmN1cnJlbnQgcmVjdXJzaXZlIHNvbHV0aW9uIGZyb20gU09cbiAgICogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzQ1MTMwOTkwLzIxNjg0MTZcbiAgICovXG4gIGFzeW5jIHJlYWRkaXJEZWVwKGRpcikge1xuICAgIGNvbnN0IHN1YmRpcnMgPSBhd2FpdCB0aGlzLl9yZWFkZGlyKGRpcik7XG4gICAgY29uc3QgZmlsZXMgPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgIHN1YmRpcnMubWFwKGFzeW5jIHN1YmRpciA9PiB7XG4gICAgICAgIGNvbnN0IHJlcyA9IGRpciArICcvJyArIHN1YmRpcjtcbiAgICAgICAgcmV0dXJuIChhd2FpdCB0aGlzLl9zdGF0KHJlcykpLmlzRGlyZWN0b3J5KClcbiAgICAgICAgICA/IHRoaXMucmVhZGRpckRlZXAocmVzKVxuICAgICAgICAgIDogcmVzXG4gICAgICB9KVxuICAgICk7XG4gICAgcmV0dXJuIGZpbGVzLnJlZHVjZSgoYSwgZikgPT4gYS5jb25jYXQoZiksIFtdKVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgU3RhdHMgb2YgYSBmaWxlL3N5bWxpbmsgaWYgaXQgZXhpc3RzLCBvdGhlcndpc2UgcmV0dXJucyBudWxsLlxuICAgKiBSZXRocm93cyBlcnJvcnMgdGhhdCBhcmVuJ3QgcmVsYXRlZCB0byBmaWxlIGV4aXN0YW5jZS5cbiAgICovXG4gIGFzeW5jIGxzdGF0KGZpbGVuYW1lKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHN0YXRzID0gYXdhaXQgdGhpcy5fbHN0YXQoZmlsZW5hbWUpO1xuICAgICAgcmV0dXJuIHN0YXRzXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAoZXJyLmNvZGUgPT09ICdFTk9FTlQnKSB7XG4gICAgICAgIHJldHVybiBudWxsXG4gICAgICB9XG4gICAgICB0aHJvdyBlcnJcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVhZHMgdGhlIGNvbnRlbnRzIG9mIGEgc3ltbGluayBpZiBpdCBleGlzdHMsIG90aGVyd2lzZSByZXR1cm5zIG51bGwuXG4gICAqIFJldGhyb3dzIGVycm9ycyB0aGF0IGFyZW4ndCByZWxhdGVkIHRvIGZpbGUgZXhpc3RhbmNlLlxuICAgKi9cbiAgYXN5bmMgcmVhZGxpbmsoZmlsZW5hbWUsIG9wdHMgPSB7IGVuY29kaW5nOiAnYnVmZmVyJyB9KSB7XG4gICAgLy8gTm90ZTogRmlsZVN5c3RlbS5yZWFkbGluayByZXR1cm5zIGEgYnVmZmVyIGJ5IGRlZmF1bHRcbiAgICAvLyBzbyB3ZSBjYW4gZHVtcCBpdCBpbnRvIEdpdE9iamVjdC53cml0ZSBqdXN0IGxpa2UgYW55IG90aGVyIGZpbGUuXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB0aGlzLl9yZWFkbGluayhmaWxlbmFtZSwgb3B0cylcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmIChlcnIuY29kZSA9PT0gJ0VOT0VOVCcpIHtcbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgIH1cbiAgICAgIHRocm93IGVyclxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBXcml0ZSB0aGUgY29udGVudHMgb2YgYnVmZmVyIHRvIGEgc3ltbGluay5cbiAgICovXG4gIGFzeW5jIHdyaXRlbGluayhmaWxlbmFtZSwgYnVmZmVyKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N5bWxpbmsoYnVmZmVyLnRvU3RyaW5nKCd1dGY4JyksIGZpbGVuYW1lKVxuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHdyaXRlT2JqZWN0TG9vc2UoeyBmcywgZ2l0ZGlyLCBvYmplY3QsIGZvcm1hdCwgb2lkIH0pIHtcbiAgaWYgKGZvcm1hdCAhPT0gJ2RlZmxhdGVkJykge1xuICAgIHRocm93IG5ldyBJbnRlcm5hbEVycm9yKFxuICAgICAgJ0dpdE9iamVjdFN0b3JlTG9vc2UgZXhwZWN0cyBvYmplY3RzIHRvIHdyaXRlIHRvIGJlIGluIGRlZmxhdGVkIGZvcm1hdCdcbiAgICApXG4gIH1cbiAgY29uc3Qgc291cmNlID0gYG9iamVjdHMvJHtvaWQuc2xpY2UoMCwgMil9LyR7b2lkLnNsaWNlKDIpfWA7XG4gIGNvbnN0IGZpbGVwYXRoID0gYCR7Z2l0ZGlyfS8ke3NvdXJjZX1gO1xuICAvLyBEb24ndCBvdmVyd3JpdGUgZXhpc3RpbmcgZ2l0IG9iamVjdHMgLSB0aGlzIGhlbHBzIGF2b2lkIEVQRVJNIGVycm9ycy5cbiAgLy8gQWx0aG91Z2ggSSBkb24ndCBrbm93IGhvdyB3ZSdkIGZpeCBjb3JydXB0ZWQgb2JqZWN0cyB0aGVuLiBQZXJoYXBzIGRlbGV0ZSB0aGVtXG4gIC8vIG9uIHJlYWQ/XG4gIGlmICghKGF3YWl0IGZzLmV4aXN0cyhmaWxlcGF0aCkpKSBhd2FpdCBmcy53cml0ZShmaWxlcGF0aCwgb2JqZWN0KTtcbn1cblxuLyogZXNsaW50LWVudiBub2RlLCBicm93c2VyICovXG5cbmxldCBzdXBwb3J0c0NvbXByZXNzaW9uU3RyZWFtID0gbnVsbDtcblxuYXN5bmMgZnVuY3Rpb24gZGVmbGF0ZShidWZmZXIpIHtcbiAgaWYgKHN1cHBvcnRzQ29tcHJlc3Npb25TdHJlYW0gPT09IG51bGwpIHtcbiAgICBzdXBwb3J0c0NvbXByZXNzaW9uU3RyZWFtID0gdGVzdENvbXByZXNzaW9uU3RyZWFtKCk7XG4gIH1cbiAgcmV0dXJuIHN1cHBvcnRzQ29tcHJlc3Npb25TdHJlYW1cbiAgICA/IGJyb3dzZXJEZWZsYXRlKGJ1ZmZlcilcbiAgICA6IHBha28uZGVmbGF0ZShidWZmZXIpXG59XG5cbmFzeW5jIGZ1bmN0aW9uIGJyb3dzZXJEZWZsYXRlKGJ1ZmZlcikge1xuICBjb25zdCBjcyA9IG5ldyBDb21wcmVzc2lvblN0cmVhbSgnZGVmbGF0ZScpO1xuICBjb25zdCBjID0gbmV3IEJsb2IoW2J1ZmZlcl0pLnN0cmVhbSgpLnBpcGVUaHJvdWdoKGNzKTtcbiAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGF3YWl0IG5ldyBSZXNwb25zZShjKS5hcnJheUJ1ZmZlcigpKVxufVxuXG5mdW5jdGlvbiB0ZXN0Q29tcHJlc3Npb25TdHJlYW0oKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgY3MgPSBuZXcgQ29tcHJlc3Npb25TdHJlYW0oJ2RlZmxhdGUnKTtcbiAgICAvLyBUZXN0IGlmIGBCbG9iLnN0cmVhbWAgaXMgcHJlc2VudC4gUmVhY3QgTmF0aXZlIGRvZXMgbm90IGhhdmUgdGhlIGBzdHJlYW1gIG1ldGhvZFxuICAgIG5ldyBCbG9iKFtdKS5zdHJlYW0oKTtcbiAgICBpZiAoY3MpIHJldHVybiB0cnVlXG4gIH0gY2F0Y2ggKF8pIHtcbiAgICAvLyBubyBib3RoZXJcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuYXN5bmMgZnVuY3Rpb24gX3dyaXRlT2JqZWN0KHtcbiAgZnMsXG4gIGdpdGRpcixcbiAgdHlwZSxcbiAgb2JqZWN0LFxuICBmb3JtYXQgPSAnY29udGVudCcsXG4gIG9pZCA9IHVuZGVmaW5lZCxcbiAgZHJ5UnVuID0gZmFsc2UsXG59KSB7XG4gIGlmIChmb3JtYXQgIT09ICdkZWZsYXRlZCcpIHtcbiAgICBpZiAoZm9ybWF0ICE9PSAnd3JhcHBlZCcpIHtcbiAgICAgIG9iamVjdCA9IEdpdE9iamVjdC53cmFwKHsgdHlwZSwgb2JqZWN0IH0pO1xuICAgIH1cbiAgICBvaWQgPSBhd2FpdCBzaGFzdW0ob2JqZWN0KTtcbiAgICBvYmplY3QgPSBCdWZmZXIuZnJvbShhd2FpdCBkZWZsYXRlKG9iamVjdCkpO1xuICB9XG4gIGlmICghZHJ5UnVuKSB7XG4gICAgYXdhaXQgd3JpdGVPYmplY3RMb29zZSh7IGZzLCBnaXRkaXIsIG9iamVjdCwgZm9ybWF0OiAnZGVmbGF0ZWQnLCBvaWQgfSk7XG4gIH1cbiAgcmV0dXJuIG9pZFxufVxuXG5mdW5jdGlvbiBhc3NlcnRQYXJhbWV0ZXIobmFtZSwgdmFsdWUpIHtcbiAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgTWlzc2luZ1BhcmFtZXRlckVycm9yKG5hbWUpXG4gIH1cbn1cblxuLy8gQHRzLWNoZWNrXG5cbi8qKlxuICogQWRkIGEgZmlsZSB0byB0aGUgZ2l0IGluZGV4IChha2Egc3RhZ2luZyBhcmVhKVxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBhcmdzXG4gKiBAcGFyYW0ge0ZzQ2xpZW50fSBhcmdzLmZzIC0gYSBmaWxlIHN5c3RlbSBpbXBsZW1lbnRhdGlvblxuICogQHBhcmFtIHtzdHJpbmd9IGFyZ3MuZGlyIC0gVGhlIFt3b3JraW5nIHRyZWVdKGRpci12cy1naXRkaXIubWQpIGRpcmVjdG9yeSBwYXRoXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MuZ2l0ZGlyPWpvaW4oZGlyLCAnLmdpdCcpXSAtIFtyZXF1aXJlZF0gVGhlIFtnaXQgZGlyZWN0b3J5XShkaXItdnMtZ2l0ZGlyLm1kKSBwYXRoXG4gKiBAcGFyYW0ge3N0cmluZ30gYXJncy5maWxlcGF0aCAtIFRoZSBwYXRoIHRvIHRoZSBmaWxlIHRvIGFkZCB0byB0aGUgaW5kZXhcbiAqIEBwYXJhbSB7b2JqZWN0fSBbYXJncy5jYWNoZV0gLSBhIFtjYWNoZV0oY2FjaGUubWQpIG9iamVjdFxuICpcbiAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fSBSZXNvbHZlcyBzdWNjZXNzZnVsbHkgb25jZSB0aGUgZ2l0IGluZGV4IGhhcyBiZWVuIHVwZGF0ZWRcbiAqXG4gKiBAZXhhbXBsZVxuICogYXdhaXQgZnMucHJvbWlzZXMud3JpdGVGaWxlKCcvdHV0b3JpYWwvUkVBRE1FLm1kJywgYCMgVEVTVGApXG4gKiBhd2FpdCBnaXQuYWRkKHsgZnMsIGRpcjogJy90dXRvcmlhbCcsIGZpbGVwYXRoOiAnUkVBRE1FLm1kJyB9KVxuICogY29uc29sZS5sb2coJ2RvbmUnKVxuICpcbiAqL1xuYXN5bmMgZnVuY3Rpb24gYWRkKHtcbiAgZnM6IF9mcyxcbiAgZGlyLFxuICBnaXRkaXIgPSBqb2luKGRpciwgJy5naXQnKSxcbiAgZmlsZXBhdGgsXG4gIGNhY2hlID0ge30sXG59KSB7XG4gIHRyeSB7XG4gICAgYXNzZXJ0UGFyYW1ldGVyKCdmcycsIF9mcyk7XG4gICAgYXNzZXJ0UGFyYW1ldGVyKCdkaXInLCBkaXIpO1xuICAgIGFzc2VydFBhcmFtZXRlcignZ2l0ZGlyJywgZ2l0ZGlyKTtcbiAgICBhc3NlcnRQYXJhbWV0ZXIoJ2ZpbGVwYXRoJywgZmlsZXBhdGgpO1xuXG4gICAgY29uc3QgZnMgPSBuZXcgRmlsZVN5c3RlbShfZnMpO1xuICAgIGF3YWl0IEdpdEluZGV4TWFuYWdlci5hY3F1aXJlKHsgZnMsIGdpdGRpciwgY2FjaGUgfSwgYXN5bmMgZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgIGF3YWl0IGFkZFRvSW5kZXgoeyBkaXIsIGdpdGRpciwgZnMsIGZpbGVwYXRoLCBpbmRleCB9KTtcbiAgICB9KTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZXJyLmNhbGxlciA9ICdnaXQuYWRkJztcbiAgICB0aHJvdyBlcnJcbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBhZGRUb0luZGV4KHsgZGlyLCBnaXRkaXIsIGZzLCBmaWxlcGF0aCwgaW5kZXggfSkge1xuICAvLyBUT0RPOiBTaG91bGQgaWdub3JlIFVOTEVTUyBpdCdzIGFscmVhZHkgaW4gdGhlIGluZGV4LlxuICBjb25zdCBpZ25vcmVkID0gYXdhaXQgR2l0SWdub3JlTWFuYWdlci5pc0lnbm9yZWQoe1xuICAgIGZzLFxuICAgIGRpcixcbiAgICBnaXRkaXIsXG4gICAgZmlsZXBhdGgsXG4gIH0pO1xuICBpZiAoaWdub3JlZCkgcmV0dXJuXG4gIGNvbnN0IHN0YXRzID0gYXdhaXQgZnMubHN0YXQoam9pbihkaXIsIGZpbGVwYXRoKSk7XG4gIGlmICghc3RhdHMpIHRocm93IG5ldyBOb3RGb3VuZEVycm9yKGZpbGVwYXRoKVxuICBpZiAoc3RhdHMuaXNEaXJlY3RvcnkoKSkge1xuICAgIGNvbnN0IGNoaWxkcmVuID0gYXdhaXQgZnMucmVhZGRpcihqb2luKGRpciwgZmlsZXBhdGgpKTtcbiAgICBjb25zdCBwcm9taXNlcyA9IGNoaWxkcmVuLm1hcChjaGlsZCA9PlxuICAgICAgYWRkVG9JbmRleCh7IGRpciwgZ2l0ZGlyLCBmcywgZmlsZXBhdGg6IGpvaW4oZmlsZXBhdGgsIGNoaWxkKSwgaW5kZXggfSlcbiAgICApO1xuICAgIGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBvYmplY3QgPSBzdGF0cy5pc1N5bWJvbGljTGluaygpXG4gICAgICA/IGF3YWl0IGZzLnJlYWRsaW5rKGpvaW4oZGlyLCBmaWxlcGF0aCkpXG4gICAgICA6IGF3YWl0IGZzLnJlYWQoam9pbihkaXIsIGZpbGVwYXRoKSk7XG4gICAgaWYgKG9iamVjdCA9PT0gbnVsbCkgdGhyb3cgbmV3IE5vdEZvdW5kRXJyb3IoZmlsZXBhdGgpXG4gICAgY29uc3Qgb2lkID0gYXdhaXQgX3dyaXRlT2JqZWN0KHsgZnMsIGdpdGRpciwgdHlwZTogJ2Jsb2InLCBvYmplY3QgfSk7XG4gICAgaW5kZXguaW5zZXJ0KHsgZmlsZXBhdGgsIHN0YXRzLCBvaWQgfSk7XG4gIH1cbn1cblxuLy8gQHRzLWNoZWNrXG5cbi8qKlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vbW9kZWxzL0ZpbGVTeXN0ZW0uanMnKS5GaWxlU3lzdGVtfSBhcmdzLmZzXG4gKiBAcGFyYW0ge29iamVjdH0gYXJncy5jYWNoZVxuICogQHBhcmFtIHtTaWduQ2FsbGJhY2t9IFthcmdzLm9uU2lnbl1cbiAqIEBwYXJhbSB7c3RyaW5nfSBhcmdzLmdpdGRpclxuICogQHBhcmFtIHtzdHJpbmd9IGFyZ3MubWVzc2FnZVxuICogQHBhcmFtIHtPYmplY3R9IGFyZ3MuYXV0aG9yXG4gKiBAcGFyYW0ge3N0cmluZ30gYXJncy5hdXRob3IubmFtZVxuICogQHBhcmFtIHtzdHJpbmd9IGFyZ3MuYXV0aG9yLmVtYWlsXG4gKiBAcGFyYW0ge251bWJlcn0gYXJncy5hdXRob3IudGltZXN0YW1wXG4gKiBAcGFyYW0ge251bWJlcn0gYXJncy5hdXRob3IudGltZXpvbmVPZmZzZXRcbiAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzLmNvbW1pdHRlclxuICogQHBhcmFtIHtzdHJpbmd9IGFyZ3MuY29tbWl0dGVyLm5hbWVcbiAqIEBwYXJhbSB7c3RyaW5nfSBhcmdzLmNvbW1pdHRlci5lbWFpbFxuICogQHBhcmFtIHtudW1iZXJ9IGFyZ3MuY29tbWl0dGVyLnRpbWVzdGFtcFxuICogQHBhcmFtIHtudW1iZXJ9IGFyZ3MuY29tbWl0dGVyLnRpbWV6b25lT2Zmc2V0XG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3Muc2lnbmluZ0tleV1cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2FyZ3MuZHJ5UnVuID0gZmFsc2VdXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFthcmdzLm5vVXBkYXRlQnJhbmNoID0gZmFsc2VdXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MucmVmXVxuICogQHBhcmFtIHtzdHJpbmdbXX0gW2FyZ3MucGFyZW50XVxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLnRyZWVdXG4gKlxuICogQHJldHVybnMge1Byb21pc2U8c3RyaW5nPn0gUmVzb2x2ZXMgc3VjY2Vzc2Z1bGx5IHdpdGggdGhlIFNIQS0xIG9iamVjdCBpZCBvZiB0aGUgbmV3bHkgY3JlYXRlZCBjb21taXQuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIF9jb21taXQoe1xuICBmcyxcbiAgY2FjaGUsXG4gIG9uU2lnbixcbiAgZ2l0ZGlyLFxuICBtZXNzYWdlLFxuICBhdXRob3IsXG4gIGNvbW1pdHRlcixcbiAgc2lnbmluZ0tleSxcbiAgZHJ5UnVuID0gZmFsc2UsXG4gIG5vVXBkYXRlQnJhbmNoID0gZmFsc2UsXG4gIHJlZixcbiAgcGFyZW50LFxuICB0cmVlLFxufSkge1xuICBpZiAoIXJlZikge1xuICAgIHJlZiA9IGF3YWl0IEdpdFJlZk1hbmFnZXIucmVzb2x2ZSh7XG4gICAgICBmcyxcbiAgICAgIGdpdGRpcixcbiAgICAgIHJlZjogJ0hFQUQnLFxuICAgICAgZGVwdGg6IDIsXG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gR2l0SW5kZXhNYW5hZ2VyLmFjcXVpcmUoeyBmcywgZ2l0ZGlyLCBjYWNoZSB9LCBhc3luYyBmdW5jdGlvbihpbmRleCkge1xuICAgIGNvbnN0IGlub2RlcyA9IGZsYXRGaWxlTGlzdFRvRGlyZWN0b3J5U3RydWN0dXJlKGluZGV4LmVudHJpZXMpO1xuICAgIGNvbnN0IGlub2RlID0gaW5vZGVzLmdldCgnLicpO1xuICAgIGlmICghdHJlZSkge1xuICAgICAgdHJlZSA9IGF3YWl0IGNvbnN0cnVjdFRyZWUoeyBmcywgZ2l0ZGlyLCBpbm9kZSwgZHJ5UnVuIH0pO1xuICAgIH1cbiAgICBpZiAoIXBhcmVudCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcGFyZW50ID0gW1xuICAgICAgICAgIGF3YWl0IEdpdFJlZk1hbmFnZXIucmVzb2x2ZSh7XG4gICAgICAgICAgICBmcyxcbiAgICAgICAgICAgIGdpdGRpcixcbiAgICAgICAgICAgIHJlZixcbiAgICAgICAgICB9KSxcbiAgICAgICAgXTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAvLyBQcm9iYWJseSBhbiBpbml0aWFsIGNvbW1pdFxuICAgICAgICBwYXJlbnQgPSBbXTtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IGNvbW0gPSBHaXRDb21taXQuZnJvbSh7XG4gICAgICB0cmVlLFxuICAgICAgcGFyZW50LFxuICAgICAgYXV0aG9yLFxuICAgICAgY29tbWl0dGVyLFxuICAgICAgbWVzc2FnZSxcbiAgICB9KTtcbiAgICBpZiAoc2lnbmluZ0tleSkge1xuICAgICAgY29tbSA9IGF3YWl0IEdpdENvbW1pdC5zaWduKGNvbW0sIG9uU2lnbiwgc2lnbmluZ0tleSk7XG4gICAgfVxuICAgIGNvbnN0IG9pZCA9IGF3YWl0IF93cml0ZU9iamVjdCh7XG4gICAgICBmcyxcbiAgICAgIGdpdGRpcixcbiAgICAgIHR5cGU6ICdjb21taXQnLFxuICAgICAgb2JqZWN0OiBjb21tLnRvT2JqZWN0KCksXG4gICAgICBkcnlSdW4sXG4gICAgfSk7XG4gICAgaWYgKCFub1VwZGF0ZUJyYW5jaCAmJiAhZHJ5UnVuKSB7XG4gICAgICAvLyBVcGRhdGUgYnJhbmNoIHBvaW50ZXJcbiAgICAgIGF3YWl0IEdpdFJlZk1hbmFnZXIud3JpdGVSZWYoe1xuICAgICAgICBmcyxcbiAgICAgICAgZ2l0ZGlyLFxuICAgICAgICByZWYsXG4gICAgICAgIHZhbHVlOiBvaWQsXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG9pZFxuICB9KVxufVxuXG5hc3luYyBmdW5jdGlvbiBjb25zdHJ1Y3RUcmVlKHsgZnMsIGdpdGRpciwgaW5vZGUsIGRyeVJ1biB9KSB7XG4gIC8vIHVzZSBkZXB0aCBmaXJzdCB0cmF2ZXJzYWxcbiAgY29uc3QgY2hpbGRyZW4gPSBpbm9kZS5jaGlsZHJlbjtcbiAgZm9yIChjb25zdCBpbm9kZSBvZiBjaGlsZHJlbikge1xuICAgIGlmIChpbm9kZS50eXBlID09PSAndHJlZScpIHtcbiAgICAgIGlub2RlLm1ldGFkYXRhLm1vZGUgPSAnMDQwMDAwJztcbiAgICAgIGlub2RlLm1ldGFkYXRhLm9pZCA9IGF3YWl0IGNvbnN0cnVjdFRyZWUoeyBmcywgZ2l0ZGlyLCBpbm9kZSwgZHJ5UnVuIH0pO1xuICAgIH1cbiAgfVxuICBjb25zdCBlbnRyaWVzID0gY2hpbGRyZW4ubWFwKGlub2RlID0+ICh7XG4gICAgbW9kZTogaW5vZGUubWV0YWRhdGEubW9kZSxcbiAgICBwYXRoOiBpbm9kZS5iYXNlbmFtZSxcbiAgICBvaWQ6IGlub2RlLm1ldGFkYXRhLm9pZCxcbiAgICB0eXBlOiBpbm9kZS50eXBlLFxuICB9KSk7XG4gIGNvbnN0IHRyZWUgPSBHaXRUcmVlLmZyb20oZW50cmllcyk7XG4gIGNvbnN0IG9pZCA9IGF3YWl0IF93cml0ZU9iamVjdCh7XG4gICAgZnMsXG4gICAgZ2l0ZGlyLFxuICAgIHR5cGU6ICd0cmVlJyxcbiAgICBvYmplY3Q6IHRyZWUudG9PYmplY3QoKSxcbiAgICBkcnlSdW4sXG4gIH0pO1xuICByZXR1cm4gb2lkXG59XG5cbi8vIEB0cy1jaGVja1xuXG5hc3luYyBmdW5jdGlvbiByZXNvbHZlRmlsZXBhdGgoeyBmcywgY2FjaGUsIGdpdGRpciwgb2lkLCBmaWxlcGF0aCB9KSB7XG4gIC8vIEVuc3VyZSB0aGVyZSBhcmUgbm8gbGVhZGluZyBvciB0cmFpbGluZyBkaXJlY3Rvcnkgc2VwYXJhdG9ycy5cbiAgLy8gSSB3YXMgZ29pbmcgdG8gZG8gdGhpcyBhdXRvbWF0aWNhbGx5LCBidXQgdGhlbiBmb3VuZCB0aGF0IHRoZSBHaXQgVGVybWluYWwgZm9yIFdpbmRvd3NcbiAgLy8gYXV0by1leHBhbmRzIC0tZmlsZXBhdGg9L3NyYy91dGlscyB0byAtLWZpbGVwYXRoPUM6L1VzZXJzL1dpbGwvQXBwRGF0YS9Mb2NhbC9Qcm9ncmFtcy9HaXQvc3JjL3V0aWxzXG4gIC8vIHNvIEkgZmlndXJlZCBpdCB3b3VsZCBiZSB3aXNlIHRvIHByb21vdGUgdGhlIGJlaGF2aW9yIGluIHRoZSBhcHBsaWNhdGlvbiBsYXllciBub3QganVzdCB0aGUgbGlicmFyeSBsYXllci5cbiAgaWYgKGZpbGVwYXRoLnN0YXJ0c1dpdGgoJy8nKSkge1xuICAgIHRocm93IG5ldyBJbnZhbGlkRmlsZXBhdGhFcnJvcignbGVhZGluZy1zbGFzaCcpXG4gIH0gZWxzZSBpZiAoZmlsZXBhdGguZW5kc1dpdGgoJy8nKSkge1xuICAgIHRocm93IG5ldyBJbnZhbGlkRmlsZXBhdGhFcnJvcigndHJhaWxpbmctc2xhc2gnKVxuICB9XG4gIGNvbnN0IF9vaWQgPSBvaWQ7XG4gIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc29sdmVUcmVlKHsgZnMsIGNhY2hlLCBnaXRkaXIsIG9pZCB9KTtcbiAgY29uc3QgdHJlZSA9IHJlc3VsdC50cmVlO1xuICBpZiAoZmlsZXBhdGggPT09ICcnKSB7XG4gICAgb2lkID0gcmVzdWx0Lm9pZDtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBwYXRoQXJyYXkgPSBmaWxlcGF0aC5zcGxpdCgnLycpO1xuICAgIG9pZCA9IGF3YWl0IF9yZXNvbHZlRmlsZXBhdGgoe1xuICAgICAgZnMsXG4gICAgICBjYWNoZSxcbiAgICAgIGdpdGRpcixcbiAgICAgIHRyZWUsXG4gICAgICBwYXRoQXJyYXksXG4gICAgICBvaWQ6IF9vaWQsXG4gICAgICBmaWxlcGF0aCxcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gb2lkXG59XG5cbmFzeW5jIGZ1bmN0aW9uIF9yZXNvbHZlRmlsZXBhdGgoe1xuICBmcyxcbiAgY2FjaGUsXG4gIGdpdGRpcixcbiAgdHJlZSxcbiAgcGF0aEFycmF5LFxuICBvaWQsXG4gIGZpbGVwYXRoLFxufSkge1xuICBjb25zdCBuYW1lID0gcGF0aEFycmF5LnNoaWZ0KCk7XG4gIGZvciAoY29uc3QgZW50cnkgb2YgdHJlZSkge1xuICAgIGlmIChlbnRyeS5wYXRoID09PSBuYW1lKSB7XG4gICAgICBpZiAocGF0aEFycmF5Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gZW50cnkub2lkXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB7IHR5cGUsIG9iamVjdCB9ID0gYXdhaXQgX3JlYWRPYmplY3Qoe1xuICAgICAgICAgIGZzLFxuICAgICAgICAgIGNhY2hlLFxuICAgICAgICAgIGdpdGRpcixcbiAgICAgICAgICBvaWQ6IGVudHJ5Lm9pZCxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0eXBlICE9PSAndHJlZScpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgT2JqZWN0VHlwZUVycm9yKG9pZCwgdHlwZSwgJ2Jsb2InLCBmaWxlcGF0aClcbiAgICAgICAgfVxuICAgICAgICB0cmVlID0gR2l0VHJlZS5mcm9tKG9iamVjdCk7XG4gICAgICAgIHJldHVybiBfcmVzb2x2ZUZpbGVwYXRoKHtcbiAgICAgICAgICBmcyxcbiAgICAgICAgICBjYWNoZSxcbiAgICAgICAgICBnaXRkaXIsXG4gICAgICAgICAgdHJlZSxcbiAgICAgICAgICBwYXRoQXJyYXksXG4gICAgICAgICAgb2lkLFxuICAgICAgICAgIGZpbGVwYXRoLFxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH1cbiAgfVxuICB0aHJvdyBuZXcgTm90Rm91bmRFcnJvcihgZmlsZSBvciBkaXJlY3RvcnkgZm91bmQgYXQgXCIke29pZH06JHtmaWxlcGF0aH1cImApXG59XG5cbi8vIEB0cy1jaGVja1xuXG4vKipcbiAqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBSZWFkVHJlZVJlc3VsdCAtIFRoZSBvYmplY3QgcmV0dXJuZWQgaGFzIHRoZSBmb2xsb3dpbmcgc2NoZW1hOlxuICogQHByb3BlcnR5IHtzdHJpbmd9IG9pZCAtIFNIQS0xIG9iamVjdCBpZCBvZiB0aGlzIHRyZWVcbiAqIEBwcm9wZXJ0eSB7VHJlZU9iamVjdH0gdHJlZSAtIHRoZSBwYXJzZWQgdHJlZSBvYmplY3RcbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBhcmdzXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vbW9kZWxzL0ZpbGVTeXN0ZW0uanMnKS5GaWxlU3lzdGVtfSBhcmdzLmZzXG4gKiBAcGFyYW0ge2FueX0gYXJncy5jYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGFyZ3MuZ2l0ZGlyXG4gKiBAcGFyYW0ge3N0cmluZ30gYXJncy5vaWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5maWxlcGF0aF1cbiAqXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxSZWFkVHJlZVJlc3VsdD59XG4gKi9cbmFzeW5jIGZ1bmN0aW9uIF9yZWFkVHJlZSh7XG4gIGZzLFxuICBjYWNoZSxcbiAgZ2l0ZGlyLFxuICBvaWQsXG4gIGZpbGVwYXRoID0gdW5kZWZpbmVkLFxufSkge1xuICBpZiAoZmlsZXBhdGggIT09IHVuZGVmaW5lZCkge1xuICAgIG9pZCA9IGF3YWl0IHJlc29sdmVGaWxlcGF0aCh7IGZzLCBjYWNoZSwgZ2l0ZGlyLCBvaWQsIGZpbGVwYXRoIH0pO1xuICB9XG4gIGNvbnN0IHsgdHJlZSwgb2lkOiB0cmVlT2lkIH0gPSBhd2FpdCByZXNvbHZlVHJlZSh7IGZzLCBjYWNoZSwgZ2l0ZGlyLCBvaWQgfSk7XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICBvaWQ6IHRyZWVPaWQsXG4gICAgdHJlZTogdHJlZS5lbnRyaWVzKCksXG4gIH07XG4gIHJldHVybiByZXN1bHRcbn1cblxuLy8gQHRzLWNoZWNrXG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGFyZ3NcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9tb2RlbHMvRmlsZVN5c3RlbS5qcycpLkZpbGVTeXN0ZW19IGFyZ3MuZnNcbiAqIEBwYXJhbSB7c3RyaW5nfSBhcmdzLmdpdGRpclxuICogQHBhcmFtIHtUcmVlT2JqZWN0fSBhcmdzLnRyZWVcbiAqXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxzdHJpbmc+fVxuICovXG5hc3luYyBmdW5jdGlvbiBfd3JpdGVUcmVlKHsgZnMsIGdpdGRpciwgdHJlZSB9KSB7XG4gIC8vIENvbnZlcnQgb2JqZWN0IHRvIGJ1ZmZlclxuICBjb25zdCBvYmplY3QgPSBHaXRUcmVlLmZyb20odHJlZSkudG9PYmplY3QoKTtcbiAgY29uc3Qgb2lkID0gYXdhaXQgX3dyaXRlT2JqZWN0KHtcbiAgICBmcyxcbiAgICBnaXRkaXIsXG4gICAgdHlwZTogJ3RyZWUnLFxuICAgIG9iamVjdCxcbiAgICBmb3JtYXQ6ICdjb250ZW50JyxcbiAgfSk7XG4gIHJldHVybiBvaWRcbn1cblxuLy8gQHRzLWNoZWNrXG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGFyZ3NcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9tb2RlbHMvRmlsZVN5c3RlbS5qcycpLkZpbGVTeXN0ZW19IGFyZ3MuZnNcbiAqIEBwYXJhbSB7b2JqZWN0fSBhcmdzLmNhY2hlXG4gKiBAcGFyYW0ge1NpZ25DYWxsYmFja30gW2FyZ3Mub25TaWduXVxuICogQHBhcmFtIHtzdHJpbmd9IGFyZ3MuZ2l0ZGlyXG4gKiBAcGFyYW0ge3N0cmluZ30gYXJncy5yZWZcbiAqIEBwYXJhbSB7c3RyaW5nfSBhcmdzLm9pZFxuICogQHBhcmFtIHtzdHJpbmd8VWludDhBcnJheX0gYXJncy5ub3RlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFthcmdzLmZvcmNlXVxuICogQHBhcmFtIHtPYmplY3R9IGFyZ3MuYXV0aG9yXG4gKiBAcGFyYW0ge3N0cmluZ30gYXJncy5hdXRob3IubmFtZVxuICogQHBhcmFtIHtzdHJpbmd9IGFyZ3MuYXV0aG9yLmVtYWlsXG4gKiBAcGFyYW0ge251bWJlcn0gYXJncy5hdXRob3IudGltZXN0YW1wXG4gKiBAcGFyYW0ge251bWJlcn0gYXJncy5hdXRob3IudGltZXpvbmVPZmZzZXRcbiAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzLmNvbW1pdHRlclxuICogQHBhcmFtIHtzdHJpbmd9IGFyZ3MuY29tbWl0dGVyLm5hbWVcbiAqIEBwYXJhbSB7c3RyaW5nfSBhcmdzLmNvbW1pdHRlci5lbWFpbFxuICogQHBhcmFtIHtudW1iZXJ9IGFyZ3MuY29tbWl0dGVyLnRpbWVzdGFtcFxuICogQHBhcmFtIHtudW1iZXJ9IGFyZ3MuY29tbWl0dGVyLnRpbWV6b25lT2Zmc2V0XG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3Muc2lnbmluZ0tleV1cbiAqXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxzdHJpbmc+fVxuICovXG5cbmFzeW5jIGZ1bmN0aW9uIF9hZGROb3RlKHtcbiAgZnMsXG4gIGNhY2hlLFxuICBvblNpZ24sXG4gIGdpdGRpcixcbiAgcmVmLFxuICBvaWQsXG4gIG5vdGUsXG4gIGZvcmNlLFxuICBhdXRob3IsXG4gIGNvbW1pdHRlcixcbiAgc2lnbmluZ0tleSxcbn0pIHtcbiAgLy8gR2V0IHRoZSBjdXJyZW50IG5vdGUgY29tbWl0XG4gIGxldCBwYXJlbnQ7XG4gIHRyeSB7XG4gICAgcGFyZW50ID0gYXdhaXQgR2l0UmVmTWFuYWdlci5yZXNvbHZlKHsgZ2l0ZGlyLCBmcywgcmVmIH0pO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBpZiAoIShlcnIgaW5zdGFuY2VvZiBOb3RGb3VuZEVycm9yKSkge1xuICAgICAgdGhyb3cgZXJyXG4gICAgfVxuICB9XG5cbiAgLy8gSSdtIHVzaW5nIHRoZSBcImVtcHR5IHRyZWVcIiBtYWdpYyBudW1iZXIgaGVyZSBmb3IgYnJldml0eVxuICBjb25zdCByZXN1bHQgPSBhd2FpdCBfcmVhZFRyZWUoe1xuICAgIGZzLFxuICAgIGNhY2hlLFxuICAgIGdpdGRpcixcbiAgICBvaWQ6IHBhcmVudCB8fCAnNGI4MjVkYzY0MmNiNmViOWEwNjBlNTRiZjhkNjkyODhmYmVlNDkwNCcsXG4gIH0pO1xuICBsZXQgdHJlZSA9IHJlc3VsdC50cmVlO1xuXG4gIC8vIEhhbmRsZSB0aGUgY2FzZSB3aGVyZSBhIG5vdGUgYWxyZWFkeSBleGlzdHNcbiAgaWYgKGZvcmNlKSB7XG4gICAgdHJlZSA9IHRyZWUuZmlsdGVyKGVudHJ5ID0+IGVudHJ5LnBhdGggIT09IG9pZCk7XG4gIH0gZWxzZSB7XG4gICAgZm9yIChjb25zdCBlbnRyeSBvZiB0cmVlKSB7XG4gICAgICBpZiAoZW50cnkucGF0aCA9PT0gb2lkKSB7XG4gICAgICAgIHRocm93IG5ldyBBbHJlYWR5RXhpc3RzRXJyb3IoJ25vdGUnLCBvaWQpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gQ3JlYXRlIHRoZSBub3RlIGJsb2JcbiAgaWYgKHR5cGVvZiBub3RlID09PSAnc3RyaW5nJykge1xuICAgIG5vdGUgPSBCdWZmZXIuZnJvbShub3RlLCAndXRmOCcpO1xuICB9XG4gIGNvbnN0IG5vdGVPaWQgPSBhd2FpdCBfd3JpdGVPYmplY3Qoe1xuICAgIGZzLFxuICAgIGdpdGRpcixcbiAgICB0eXBlOiAnYmxvYicsXG4gICAgb2JqZWN0OiBub3RlLFxuICAgIGZvcm1hdDogJ2NvbnRlbnQnLFxuICB9KTtcblxuICAvLyBDcmVhdGUgdGhlIG5ldyBub3RlIHRyZWVcbiAgdHJlZS5wdXNoKHsgbW9kZTogJzEwMDY0NCcsIHBhdGg6IG9pZCwgb2lkOiBub3RlT2lkLCB0eXBlOiAnYmxvYicgfSk7XG4gIGNvbnN0IHRyZWVPaWQgPSBhd2FpdCBfd3JpdGVUcmVlKHtcbiAgICBmcyxcbiAgICBnaXRkaXIsXG4gICAgdHJlZSxcbiAgfSk7XG5cbiAgLy8gQ3JlYXRlIHRoZSBuZXcgbm90ZSBjb21taXRcbiAgY29uc3QgY29tbWl0T2lkID0gYXdhaXQgX2NvbW1pdCh7XG4gICAgZnMsXG4gICAgY2FjaGUsXG4gICAgb25TaWduLFxuICAgIGdpdGRpcixcbiAgICByZWYsXG4gICAgdHJlZTogdHJlZU9pZCxcbiAgICBwYXJlbnQ6IHBhcmVudCAmJiBbcGFyZW50XSxcbiAgICBtZXNzYWdlOiBgTm90ZSBhZGRlZCBieSAnaXNvbW9ycGhpYy1naXQgYWRkTm90ZSdcXG5gLFxuICAgIGF1dGhvcixcbiAgICBjb21taXR0ZXIsXG4gICAgc2lnbmluZ0tleSxcbiAgfSk7XG5cbiAgcmV0dXJuIGNvbW1pdE9pZFxufVxuXG4vLyBAdHMtY2hlY2tcblxuLyoqXG4gKiBAcGFyYW0ge09iamVjdH0gYXJnc1xuICogQHBhcmFtIHtpbXBvcnQoJy4uL21vZGVscy9GaWxlU3lzdGVtLmpzJykuRmlsZVN5c3RlbX0gYXJncy5mc1xuICogQHBhcmFtIHtzdHJpbmd9IGFyZ3MuZ2l0ZGlyXG4gKiBAcGFyYW0ge3N0cmluZ30gYXJncy5wYXRoXG4gKlxuICogQHJldHVybnMge1Byb21pc2U8YW55Pn0gUmVzb2x2ZXMgd2l0aCB0aGUgY29uZmlnIHZhbHVlXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFJlYWQgY29uZmlnIHZhbHVlXG4gKiBsZXQgdmFsdWUgPSBhd2FpdCBnaXQuZ2V0Q29uZmlnKHtcbiAqICAgZGlyOiAnJGlucHV0KCgvKSknLFxuICogICBwYXRoOiAnJGlucHV0KCh1c2VyLm5hbWUpKSdcbiAqIH0pXG4gKiBjb25zb2xlLmxvZyh2YWx1ZSlcbiAqXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIF9nZXRDb25maWcoeyBmcywgZ2l0ZGlyLCBwYXRoIH0pIHtcbiAgY29uc3QgY29uZmlnID0gYXdhaXQgR2l0Q29uZmlnTWFuYWdlci5nZXQoeyBmcywgZ2l0ZGlyIH0pO1xuICByZXR1cm4gY29uZmlnLmdldChwYXRoKVxufVxuXG4vKipcbiAqXG4gKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkIHwge25hbWU6IHN0cmluZywgZW1haWw6IHN0cmluZywgZGF0ZTogRGF0ZSwgdGltZXN0YW1wOiBudW1iZXIsIHRpbWV6b25lT2Zmc2V0OiBudW1iZXIgfT59XG4gKi9cbmFzeW5jIGZ1bmN0aW9uIG5vcm1hbGl6ZUF1dGhvck9iamVjdCh7IGZzLCBnaXRkaXIsIGF1dGhvciA9IHt9IH0pIHtcbiAgbGV0IHsgbmFtZSwgZW1haWwsIHRpbWVzdGFtcCwgdGltZXpvbmVPZmZzZXQgfSA9IGF1dGhvcjtcbiAgbmFtZSA9IG5hbWUgfHwgKGF3YWl0IF9nZXRDb25maWcoeyBmcywgZ2l0ZGlyLCBwYXRoOiAndXNlci5uYW1lJyB9KSk7XG4gIGVtYWlsID0gZW1haWwgfHwgKGF3YWl0IF9nZXRDb25maWcoeyBmcywgZ2l0ZGlyLCBwYXRoOiAndXNlci5lbWFpbCcgfSkpIHx8ICcnO1xuXG4gIGlmIChuYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkXG4gIH1cblxuICB0aW1lc3RhbXAgPSB0aW1lc3RhbXAgIT0gbnVsbCA/IHRpbWVzdGFtcCA6IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDEwMDApO1xuICB0aW1lem9uZU9mZnNldCA9XG4gICAgdGltZXpvbmVPZmZzZXQgIT0gbnVsbFxuICAgICAgPyB0aW1lem9uZU9mZnNldFxuICAgICAgOiBuZXcgRGF0ZSh0aW1lc3RhbXAgKiAxMDAwKS5nZXRUaW1lem9uZU9mZnNldCgpO1xuXG4gIHJldHVybiB7IG5hbWUsIGVtYWlsLCB0aW1lc3RhbXAsIHRpbWV6b25lT2Zmc2V0IH1cbn1cblxuLyoqXG4gKlxuICogQHJldHVybnMge1Byb21pc2U8dm9pZCB8IHtuYW1lOiBzdHJpbmcsIGVtYWlsOiBzdHJpbmcsIHRpbWVzdGFtcDogbnVtYmVyLCB0aW1lem9uZU9mZnNldDogbnVtYmVyIH0+fVxuICovXG5hc3luYyBmdW5jdGlvbiBub3JtYWxpemVDb21taXR0ZXJPYmplY3Qoe1xuICBmcyxcbiAgZ2l0ZGlyLFxuICBhdXRob3IsXG4gIGNvbW1pdHRlcixcbn0pIHtcbiAgY29tbWl0dGVyID0gT2JqZWN0LmFzc2lnbih7fSwgY29tbWl0dGVyIHx8IGF1dGhvcik7XG4gIC8vIE1hdGNoIGNvbW1pdHRlcidzIGRhdGUgdG8gYXV0aG9yJ3Mgb25lLCBpZiBvbWl0dGVkXG4gIGlmIChhdXRob3IpIHtcbiAgICBjb21taXR0ZXIudGltZXN0YW1wID0gY29tbWl0dGVyLnRpbWVzdGFtcCB8fCBhdXRob3IudGltZXN0YW1wO1xuICAgIGNvbW1pdHRlci50aW1lem9uZU9mZnNldCA9IGNvbW1pdHRlci50aW1lem9uZU9mZnNldCB8fCBhdXRob3IudGltZXpvbmVPZmZzZXQ7XG4gIH1cbiAgY29tbWl0dGVyID0gYXdhaXQgbm9ybWFsaXplQXV0aG9yT2JqZWN0KHsgZnMsIGdpdGRpciwgYXV0aG9yOiBjb21taXR0ZXIgfSk7XG4gIHJldHVybiBjb21taXR0ZXJcbn1cblxuLy8gQHRzLWNoZWNrXG5cbi8qKlxuICogQWRkIG9yIHVwZGF0ZSBhbiBvYmplY3Qgbm90ZVxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBhcmdzXG4gKiBAcGFyYW0ge0ZzQ2xpZW50fSBhcmdzLmZzIC0gYSBmaWxlIHN5c3RlbSBpbXBsZW1lbnRhdGlvblxuICogQHBhcmFtIHtTaWduQ2FsbGJhY2t9IFthcmdzLm9uU2lnbl0gLSBhIFBHUCBzaWduaW5nIGltcGxlbWVudGF0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MuZGlyXSAtIFRoZSBbd29ya2luZyB0cmVlXShkaXItdnMtZ2l0ZGlyLm1kKSBkaXJlY3RvcnkgcGF0aFxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLmdpdGRpcj1qb2luKGRpciwnLmdpdCcpXSAtIFtyZXF1aXJlZF0gVGhlIFtnaXQgZGlyZWN0b3J5XShkaXItdnMtZ2l0ZGlyLm1kKSBwYXRoXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MucmVmXSAtIFRoZSBub3RlcyByZWYgdG8gbG9vayB1bmRlclxuICogQHBhcmFtIHtzdHJpbmd9IGFyZ3Mub2lkIC0gVGhlIFNIQS0xIG9iamVjdCBpZCBvZiB0aGUgb2JqZWN0IHRvIGFkZCB0aGUgbm90ZSB0by5cbiAqIEBwYXJhbSB7c3RyaW5nfFVpbnQ4QXJyYXl9IGFyZ3Mubm90ZSAtIFRoZSBub3RlIHRvIGFkZFxuICogQHBhcmFtIHtib29sZWFufSBbYXJncy5mb3JjZV0gLSBPdmVyLXdyaXRlIG5vdGUgaWYgaXQgYWxyZWFkeSBleGlzdHMuXG4gKiBAcGFyYW0ge09iamVjdH0gW2FyZ3MuYXV0aG9yXSAtIFRoZSBkZXRhaWxzIGFib3V0IHRoZSBhdXRob3IuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MuYXV0aG9yLm5hbWVdIC0gRGVmYXVsdCBpcyBgdXNlci5uYW1lYCBjb25maWcuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MuYXV0aG9yLmVtYWlsXSAtIERlZmF1bHQgaXMgYHVzZXIuZW1haWxgIGNvbmZpZy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbYXJncy5hdXRob3IudGltZXN0YW1wPU1hdGguZmxvb3IoRGF0ZS5ub3coKS8xMDAwKV0gLSBTZXQgdGhlIGF1dGhvciB0aW1lc3RhbXAgZmllbGQuIFRoaXMgaXMgdGhlIGludGVnZXIgbnVtYmVyIG9mIHNlY29uZHMgc2luY2UgdGhlIFVuaXggZXBvY2ggKDE5NzAtMDEtMDEgMDA6MDA6MDApLlxuICogQHBhcmFtIHtudW1iZXJ9IFthcmdzLmF1dGhvci50aW1lem9uZU9mZnNldF0gLSBTZXQgdGhlIGF1dGhvciB0aW1lem9uZSBvZmZzZXQgZmllbGQuIFRoaXMgaXMgdGhlIGRpZmZlcmVuY2UsIGluIG1pbnV0ZXMsIGZyb20gdGhlIGN1cnJlbnQgdGltZXpvbmUgdG8gVVRDLiBEZWZhdWx0IGlzIGAobmV3IERhdGUoKSkuZ2V0VGltZXpvbmVPZmZzZXQoKWAuXG4gKiBAcGFyYW0ge09iamVjdH0gW2FyZ3MuY29tbWl0dGVyID0gYXV0aG9yXSAtIFRoZSBkZXRhaWxzIGFib3V0IHRoZSBub3RlIGNvbW1pdHRlciwgaW4gdGhlIHNhbWUgZm9ybWF0IGFzIHRoZSBhdXRob3IgcGFyYW1ldGVyLiBJZiBub3Qgc3BlY2lmaWVkLCB0aGUgYXV0aG9yIGRldGFpbHMgYXJlIHVzZWQuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MuY29tbWl0dGVyLm5hbWVdIC0gRGVmYXVsdCBpcyBgdXNlci5uYW1lYCBjb25maWcuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MuY29tbWl0dGVyLmVtYWlsXSAtIERlZmF1bHQgaXMgYHVzZXIuZW1haWxgIGNvbmZpZy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbYXJncy5jb21taXR0ZXIudGltZXN0YW1wPU1hdGguZmxvb3IoRGF0ZS5ub3coKS8xMDAwKV0gLSBTZXQgdGhlIGNvbW1pdHRlciB0aW1lc3RhbXAgZmllbGQuIFRoaXMgaXMgdGhlIGludGVnZXIgbnVtYmVyIG9mIHNlY29uZHMgc2luY2UgdGhlIFVuaXggZXBvY2ggKDE5NzAtMDEtMDEgMDA6MDA6MDApLlxuICogQHBhcmFtIHtudW1iZXJ9IFthcmdzLmNvbW1pdHRlci50aW1lem9uZU9mZnNldF0gLSBTZXQgdGhlIGNvbW1pdHRlciB0aW1lem9uZSBvZmZzZXQgZmllbGQuIFRoaXMgaXMgdGhlIGRpZmZlcmVuY2UsIGluIG1pbnV0ZXMsIGZyb20gdGhlIGN1cnJlbnQgdGltZXpvbmUgdG8gVVRDLiBEZWZhdWx0IGlzIGAobmV3IERhdGUoKSkuZ2V0VGltZXpvbmVPZmZzZXQoKWAuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3Muc2lnbmluZ0tleV0gLSBTaWduIHRoZSBub3RlIGNvbW1pdCB1c2luZyB0aGlzIHByaXZhdGUgUEdQIGtleS5cbiAqIEBwYXJhbSB7b2JqZWN0fSBbYXJncy5jYWNoZV0gLSBhIFtjYWNoZV0oY2FjaGUubWQpIG9iamVjdFxuICpcbiAqIEByZXR1cm5zIHtQcm9taXNlPHN0cmluZz59IFJlc29sdmVzIHN1Y2Nlc3NmdWxseSB3aXRoIHRoZSBTSEEtMSBvYmplY3QgaWQgb2YgdGhlIGNvbW1pdCBvYmplY3QgZm9yIHRoZSBhZGRlZCBub3RlLlxuICovXG5cbmFzeW5jIGZ1bmN0aW9uIGFkZE5vdGUoe1xuICBmczogX2ZzLFxuICBvblNpZ24sXG4gIGRpcixcbiAgZ2l0ZGlyID0gam9pbihkaXIsICcuZ2l0JyksXG4gIHJlZiA9ICdyZWZzL25vdGVzL2NvbW1pdHMnLFxuICBvaWQsXG4gIG5vdGUsXG4gIGZvcmNlLFxuICBhdXRob3I6IF9hdXRob3IsXG4gIGNvbW1pdHRlcjogX2NvbW1pdHRlcixcbiAgc2lnbmluZ0tleSxcbiAgY2FjaGUgPSB7fSxcbn0pIHtcbiAgdHJ5IHtcbiAgICBhc3NlcnRQYXJhbWV0ZXIoJ2ZzJywgX2ZzKTtcbiAgICBhc3NlcnRQYXJhbWV0ZXIoJ2dpdGRpcicsIGdpdGRpcik7XG4gICAgYXNzZXJ0UGFyYW1ldGVyKCdvaWQnLCBvaWQpO1xuICAgIGFzc2VydFBhcmFtZXRlcignbm90ZScsIG5vdGUpO1xuICAgIGlmIChzaWduaW5nS2V5KSB7XG4gICAgICBhc3NlcnRQYXJhbWV0ZXIoJ29uU2lnbicsIG9uU2lnbik7XG4gICAgfVxuICAgIGNvbnN0IGZzID0gbmV3IEZpbGVTeXN0ZW0oX2ZzKTtcblxuICAgIGNvbnN0IGF1dGhvciA9IGF3YWl0IG5vcm1hbGl6ZUF1dGhvck9iamVjdCh7IGZzLCBnaXRkaXIsIGF1dGhvcjogX2F1dGhvciB9KTtcbiAgICBpZiAoIWF1dGhvcikgdGhyb3cgbmV3IE1pc3NpbmdOYW1lRXJyb3IoJ2F1dGhvcicpXG5cbiAgICBjb25zdCBjb21taXR0ZXIgPSBhd2FpdCBub3JtYWxpemVDb21taXR0ZXJPYmplY3Qoe1xuICAgICAgZnMsXG4gICAgICBnaXRkaXIsXG4gICAgICBhdXRob3IsXG4gICAgICBjb21taXR0ZXI6IF9jb21taXR0ZXIsXG4gICAgfSk7XG4gICAgaWYgKCFjb21taXR0ZXIpIHRocm93IG5ldyBNaXNzaW5nTmFtZUVycm9yKCdjb21taXR0ZXInKVxuXG4gICAgcmV0dXJuIGF3YWl0IF9hZGROb3RlKHtcbiAgICAgIGZzOiBuZXcgRmlsZVN5c3RlbShmcyksXG4gICAgICBjYWNoZSxcbiAgICAgIG9uU2lnbixcbiAgICAgIGdpdGRpcixcbiAgICAgIHJlZixcbiAgICAgIG9pZCxcbiAgICAgIG5vdGUsXG4gICAgICBmb3JjZSxcbiAgICAgIGF1dGhvcixcbiAgICAgIGNvbW1pdHRlcixcbiAgICAgIHNpZ25pbmdLZXksXG4gICAgfSlcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZXJyLmNhbGxlciA9ICdnaXQuYWRkTm90ZSc7XG4gICAgdGhyb3cgZXJyXG4gIH1cbn1cblxuLy8gQHRzLWNoZWNrXG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGFyZ3NcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9tb2RlbHMvRmlsZVN5c3RlbS5qcycpLkZpbGVTeXN0ZW19IGFyZ3MuZnNcbiAqIEBwYXJhbSB7c3RyaW5nfSBhcmdzLmdpdGRpclxuICogQHBhcmFtIHtzdHJpbmd9IGFyZ3MucmVtb3RlXG4gKiBAcGFyYW0ge3N0cmluZ30gYXJncy51cmxcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gYXJncy5mb3JjZVxuICpcbiAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICpcbiAqL1xuYXN5bmMgZnVuY3Rpb24gX2FkZFJlbW90ZSh7IGZzLCBnaXRkaXIsIHJlbW90ZSwgdXJsLCBmb3JjZSB9KSB7XG4gIGlmIChyZW1vdGUgIT09IGNsZWFuR2l0UmVmLmNsZWFuKHJlbW90ZSkpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZFJlZk5hbWVFcnJvcihyZW1vdGUsIGNsZWFuR2l0UmVmLmNsZWFuKHJlbW90ZSkpXG4gIH1cbiAgY29uc3QgY29uZmlnID0gYXdhaXQgR2l0Q29uZmlnTWFuYWdlci5nZXQoeyBmcywgZ2l0ZGlyIH0pO1xuICBpZiAoIWZvcmNlKSB7XG4gICAgLy8gQ2hlY2sgdGhhdCBzZXR0aW5nIGl0IHdvdWxkbid0IG92ZXJ3cml0ZS5cbiAgICBjb25zdCByZW1vdGVOYW1lcyA9IGF3YWl0IGNvbmZpZy5nZXRTdWJzZWN0aW9ucygncmVtb3RlJyk7XG4gICAgaWYgKHJlbW90ZU5hbWVzLmluY2x1ZGVzKHJlbW90ZSkpIHtcbiAgICAgIC8vIFRocm93IGFuIGVycm9yIGlmIGl0IHdvdWxkIG92ZXJ3cml0ZSBhbiBleGlzdGluZyByZW1vdGUsXG4gICAgICAvLyBidXQgbm90IGlmIGl0J3Mgc2ltcGx5IHNldHRpbmcgdGhlIHNhbWUgdmFsdWUgYWdhaW4uXG4gICAgICBpZiAodXJsICE9PSAoYXdhaXQgY29uZmlnLmdldChgcmVtb3RlLiR7cmVtb3RlfS51cmxgKSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEFscmVhZHlFeGlzdHNFcnJvcigncmVtb3RlJywgcmVtb3RlKVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBhd2FpdCBjb25maWcuc2V0KGByZW1vdGUuJHtyZW1vdGV9LnVybGAsIHVybCk7XG4gIGF3YWl0IGNvbmZpZy5zZXQoXG4gICAgYHJlbW90ZS4ke3JlbW90ZX0uZmV0Y2hgLFxuICAgIGArcmVmcy9oZWFkcy8qOnJlZnMvcmVtb3Rlcy8ke3JlbW90ZX0vKmBcbiAgKTtcbiAgYXdhaXQgR2l0Q29uZmlnTWFuYWdlci5zYXZlKHsgZnMsIGdpdGRpciwgY29uZmlnIH0pO1xufVxuXG4vLyBAdHMtY2hlY2tcblxuLyoqXG4gKiBBZGQgb3IgdXBkYXRlIGEgcmVtb3RlXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGFyZ3NcbiAqIEBwYXJhbSB7RnNDbGllbnR9IGFyZ3MuZnMgLSBhIGZpbGUgc3lzdGVtIGltcGxlbWVudGF0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MuZGlyXSAtIFRoZSBbd29ya2luZyB0cmVlXShkaXItdnMtZ2l0ZGlyLm1kKSBkaXJlY3RvcnkgcGF0aFxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLmdpdGRpcl0gLSBbcmVxdWlyZWRdIFRoZSBbZ2l0IGRpcmVjdG9yeV0oZGlyLXZzLWdpdGRpci5tZCkgcGF0aFxuICogQHBhcmFtIHtzdHJpbmd9IGFyZ3MucmVtb3RlIC0gVGhlIG5hbWUgb2YgdGhlIHJlbW90ZVxuICogQHBhcmFtIHtzdHJpbmd9IGFyZ3MudXJsIC0gVGhlIFVSTCBvZiB0aGUgcmVtb3RlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFthcmdzLmZvcmNlID0gZmFsc2VdIC0gSW5zdGVhZCBvZiB0aHJvd2luZyBhbiBlcnJvciBpZiBhIHJlbW90ZSBuYW1lZCBgcmVtb3RlYCBhbHJlYWR5IGV4aXN0cywgb3ZlcndyaXRlIHRoZSBleGlzdGluZyByZW1vdGUuXG4gKlxuICogQHJldHVybnMge1Byb21pc2U8dm9pZD59IFJlc29sdmVzIHN1Y2Nlc3NmdWxseSB3aGVuIGZpbGVzeXN0ZW0gb3BlcmF0aW9ucyBhcmUgY29tcGxldGVcbiAqXG4gKiBAZXhhbXBsZVxuICogYXdhaXQgZ2l0LmFkZFJlbW90ZSh7XG4gKiAgIGZzLFxuICogICBkaXI6ICcvdHV0b3JpYWwnLFxuICogICByZW1vdGU6ICd1cHN0cmVhbScsXG4gKiAgIHVybDogJ2h0dHBzOi8vZ2l0aHViLmNvbS9pc29tb3JwaGljLWdpdC9pc29tb3JwaGljLWdpdCdcbiAqIH0pXG4gKiBjb25zb2xlLmxvZygnZG9uZScpXG4gKlxuICovXG5hc3luYyBmdW5jdGlvbiBhZGRSZW1vdGUoe1xuICBmcyxcbiAgZGlyLFxuICBnaXRkaXIgPSBqb2luKGRpciwgJy5naXQnKSxcbiAgcmVtb3RlLFxuICB1cmwsXG4gIGZvcmNlID0gZmFsc2UsXG59KSB7XG4gIHRyeSB7XG4gICAgYXNzZXJ0UGFyYW1ldGVyKCdmcycsIGZzKTtcbiAgICBhc3NlcnRQYXJhbWV0ZXIoJ2dpdGRpcicsIGdpdGRpcik7XG4gICAgYXNzZXJ0UGFyYW1ldGVyKCdyZW1vdGUnLCByZW1vdGUpO1xuICAgIGFzc2VydFBhcmFtZXRlcigndXJsJywgdXJsKTtcbiAgICByZXR1cm4gYXdhaXQgX2FkZFJlbW90ZSh7XG4gICAgICBmczogbmV3IEZpbGVTeXN0ZW0oZnMpLFxuICAgICAgZ2l0ZGlyLFxuICAgICAgcmVtb3RlLFxuICAgICAgdXJsLFxuICAgICAgZm9yY2UsXG4gICAgfSlcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZXJyLmNhbGxlciA9ICdnaXQuYWRkUmVtb3RlJztcbiAgICB0aHJvdyBlcnJcbiAgfVxufVxuXG4vLyBAdHMtY2hlY2tcblxuLyoqXG4gKiBDcmVhdGUgYW4gYW5ub3RhdGVkIHRhZy5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gYXJnc1xuICogQHBhcmFtIHtpbXBvcnQoJy4uL21vZGVscy9GaWxlU3lzdGVtLmpzJykuRmlsZVN5c3RlbX0gYXJncy5mc1xuICogQHBhcmFtIHthbnl9IGFyZ3MuY2FjaGVcbiAqIEBwYXJhbSB7U2lnbkNhbGxiYWNrfSBbYXJncy5vblNpZ25dXG4gKiBAcGFyYW0ge3N0cmluZ30gYXJncy5naXRkaXJcbiAqIEBwYXJhbSB7c3RyaW5nfSBhcmdzLnJlZlxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLm1lc3NhZ2UgPSByZWZdXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3Mub2JqZWN0ID0gJ0hFQUQnXVxuICogQHBhcmFtIHtvYmplY3R9IFthcmdzLnRhZ2dlcl1cbiAqIEBwYXJhbSB7c3RyaW5nfSBhcmdzLnRhZ2dlci5uYW1lXG4gKiBAcGFyYW0ge3N0cmluZ30gYXJncy50YWdnZXIuZW1haWxcbiAqIEBwYXJhbSB7bnVtYmVyfSBhcmdzLnRhZ2dlci50aW1lc3RhbXBcbiAqIEBwYXJhbSB7bnVtYmVyfSBhcmdzLnRhZ2dlci50aW1lem9uZU9mZnNldFxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLmdwZ3NpZ11cbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5zaWduaW5nS2V5XVxuICogQHBhcmFtIHtib29sZWFufSBbYXJncy5mb3JjZSA9IGZhbHNlXVxuICpcbiAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fSBSZXNvbHZlcyBzdWNjZXNzZnVsbHkgd2hlbiBmaWxlc3lzdGVtIG9wZXJhdGlvbnMgYXJlIGNvbXBsZXRlXG4gKlxuICogQGV4YW1wbGVcbiAqIGF3YWl0IGdpdC5hbm5vdGF0ZWRUYWcoe1xuICogICBkaXI6ICckaW5wdXQoKC8pKScsXG4gKiAgIHJlZjogJyRpbnB1dCgodGVzdC10YWcpKScsXG4gKiAgIG1lc3NhZ2U6ICckaW5wdXQoKFRoaXMgY29tbWl0IGlzIGF3ZXNvbWUpKScsXG4gKiAgIHRhZ2dlcjoge1xuICogICAgIG5hbWU6ICckaW5wdXQoKE1yLiBUZXN0KSknLFxuICogICAgIGVtYWlsOiAnJGlucHV0KChtcnRlc3RAZXhhbXBsZS5jb20pKSdcbiAqICAgfVxuICogfSlcbiAqIGNvbnNvbGUubG9nKCdkb25lJylcbiAqXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIF9hbm5vdGF0ZWRUYWcoe1xuICBmcyxcbiAgY2FjaGUsXG4gIG9uU2lnbixcbiAgZ2l0ZGlyLFxuICByZWYsXG4gIHRhZ2dlcixcbiAgbWVzc2FnZSA9IHJlZixcbiAgZ3Bnc2lnLFxuICBvYmplY3QsXG4gIHNpZ25pbmdLZXksXG4gIGZvcmNlID0gZmFsc2UsXG59KSB7XG4gIHJlZiA9IHJlZi5zdGFydHNXaXRoKCdyZWZzL3RhZ3MvJykgPyByZWYgOiBgcmVmcy90YWdzLyR7cmVmfWA7XG5cbiAgaWYgKCFmb3JjZSAmJiAoYXdhaXQgR2l0UmVmTWFuYWdlci5leGlzdHMoeyBmcywgZ2l0ZGlyLCByZWYgfSkpKSB7XG4gICAgdGhyb3cgbmV3IEFscmVhZHlFeGlzdHNFcnJvcigndGFnJywgcmVmKVxuICB9XG5cbiAgLy8gUmVzb2x2ZSBwYXNzZWQgdmFsdWVcbiAgY29uc3Qgb2lkID0gYXdhaXQgR2l0UmVmTWFuYWdlci5yZXNvbHZlKHtcbiAgICBmcyxcbiAgICBnaXRkaXIsXG4gICAgcmVmOiBvYmplY3QgfHwgJ0hFQUQnLFxuICB9KTtcblxuICBjb25zdCB7IHR5cGUgfSA9IGF3YWl0IF9yZWFkT2JqZWN0KHsgZnMsIGNhY2hlLCBnaXRkaXIsIG9pZCB9KTtcbiAgbGV0IHRhZ09iamVjdCA9IEdpdEFubm90YXRlZFRhZy5mcm9tKHtcbiAgICBvYmplY3Q6IG9pZCxcbiAgICB0eXBlLFxuICAgIHRhZzogcmVmLnJlcGxhY2UoJ3JlZnMvdGFncy8nLCAnJyksXG4gICAgdGFnZ2VyLFxuICAgIG1lc3NhZ2UsXG4gICAgZ3Bnc2lnLFxuICB9KTtcbiAgaWYgKHNpZ25pbmdLZXkpIHtcbiAgICB0YWdPYmplY3QgPSBhd2FpdCBHaXRBbm5vdGF0ZWRUYWcuc2lnbih0YWdPYmplY3QsIG9uU2lnbiwgc2lnbmluZ0tleSk7XG4gIH1cbiAgY29uc3QgdmFsdWUgPSBhd2FpdCBfd3JpdGVPYmplY3Qoe1xuICAgIGZzLFxuICAgIGdpdGRpcixcbiAgICB0eXBlOiAndGFnJyxcbiAgICBvYmplY3Q6IHRhZ09iamVjdC50b09iamVjdCgpLFxuICB9KTtcblxuICBhd2FpdCBHaXRSZWZNYW5hZ2VyLndyaXRlUmVmKHsgZnMsIGdpdGRpciwgcmVmLCB2YWx1ZSB9KTtcbn1cblxuLy8gQHRzLWNoZWNrXG5cbi8qKlxuICogQ3JlYXRlIGFuIGFubm90YXRlZCB0YWcuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGFyZ3NcbiAqIEBwYXJhbSB7RnNDbGllbnR9IGFyZ3MuZnMgLSBhIGZpbGUgc3lzdGVtIGltcGxlbWVudGF0aW9uXG4gKiBAcGFyYW0ge1NpZ25DYWxsYmFja30gW2FyZ3Mub25TaWduXSAtIGEgUEdQIHNpZ25pbmcgaW1wbGVtZW50YXRpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5kaXJdIC0gVGhlIFt3b3JraW5nIHRyZWVdKGRpci12cy1naXRkaXIubWQpIGRpcmVjdG9yeSBwYXRoXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MuZ2l0ZGlyPWpvaW4oZGlyLCcuZ2l0JyldIC0gW3JlcXVpcmVkXSBUaGUgW2dpdCBkaXJlY3RvcnldKGRpci12cy1naXRkaXIubWQpIHBhdGhcbiAqIEBwYXJhbSB7c3RyaW5nfSBhcmdzLnJlZiAtIFdoYXQgdG8gbmFtZSB0aGUgdGFnXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MubWVzc2FnZSA9IHJlZl0gLSBUaGUgdGFnIG1lc3NhZ2UgdG8gdXNlLlxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLm9iamVjdCA9ICdIRUFEJ10gLSBUaGUgU0hBLTEgb2JqZWN0IGlkIHRoZSB0YWcgcG9pbnRzIHRvLiAoV2lsbCByZXNvbHZlIHRvIGEgU0hBLTEgb2JqZWN0IGlkIGlmIHZhbHVlIGlzIGEgcmVmLikgQnkgZGVmYXVsdCwgdGhlIGNvbW1pdCBvYmplY3Qgd2hpY2ggaXMgcmVmZXJyZWQgYnkgdGhlIGN1cnJlbnQgYEhFQURgIGlzIHVzZWQuXG4gKiBAcGFyYW0ge29iamVjdH0gW2FyZ3MudGFnZ2VyXSAtIFRoZSBkZXRhaWxzIGFib3V0IHRoZSB0YWdnZXIuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MudGFnZ2VyLm5hbWVdIC0gRGVmYXVsdCBpcyBgdXNlci5uYW1lYCBjb25maWcuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MudGFnZ2VyLmVtYWlsXSAtIERlZmF1bHQgaXMgYHVzZXIuZW1haWxgIGNvbmZpZy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbYXJncy50YWdnZXIudGltZXN0YW1wPU1hdGguZmxvb3IoRGF0ZS5ub3coKS8xMDAwKV0gLSBTZXQgdGhlIHRhZ2dlciB0aW1lc3RhbXAgZmllbGQuIFRoaXMgaXMgdGhlIGludGVnZXIgbnVtYmVyIG9mIHNlY29uZHMgc2luY2UgdGhlIFVuaXggZXBvY2ggKDE5NzAtMDEtMDEgMDA6MDA6MDApLlxuICogQHBhcmFtIHtudW1iZXJ9IFthcmdzLnRhZ2dlci50aW1lem9uZU9mZnNldF0gLSBTZXQgdGhlIHRhZ2dlciB0aW1lem9uZSBvZmZzZXQgZmllbGQuIFRoaXMgaXMgdGhlIGRpZmZlcmVuY2UsIGluIG1pbnV0ZXMsIGZyb20gdGhlIGN1cnJlbnQgdGltZXpvbmUgdG8gVVRDLiBEZWZhdWx0IGlzIGAobmV3IERhdGUoKSkuZ2V0VGltZXpvbmVPZmZzZXQoKWAuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MuZ3Bnc2lnXSAtIFRoZSBncGdzaWcgYXR0YXRjaGVkIHRvIHRoZSB0YWcgb2JqZWN0LiAoTXV0dWFsbHkgZXhjbHVzaXZlIHdpdGggdGhlIGBzaWduaW5nS2V5YCBvcHRpb24uKVxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLnNpZ25pbmdLZXldIC0gU2lnbiB0aGUgdGFnIG9iamVjdCB1c2luZyB0aGlzIHByaXZhdGUgUEdQIGtleS4gKE11dHVhbGx5IGV4Y2x1c2l2ZSB3aXRoIHRoZSBgZ3Bnc2lnYCBvcHRpb24uKVxuICogQHBhcmFtIHtib29sZWFufSBbYXJncy5mb3JjZSA9IGZhbHNlXSAtIEluc3RlYWQgb2YgdGhyb3dpbmcgYW4gZXJyb3IgaWYgYSB0YWcgbmFtZWQgYHJlZmAgYWxyZWFkeSBleGlzdHMsIG92ZXJ3cml0ZSB0aGUgZXhpc3RpbmcgdGFnLiBOb3RlIHRoYXQgdGhpcyBvcHRpb24gZG9lcyBub3QgbW9kaWZ5IHRoZSBvcmlnaW5hbCB0YWcgb2JqZWN0IGl0c2VsZi5cbiAqIEBwYXJhbSB7b2JqZWN0fSBbYXJncy5jYWNoZV0gLSBhIFtjYWNoZV0oY2FjaGUubWQpIG9iamVjdFxuICpcbiAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fSBSZXNvbHZlcyBzdWNjZXNzZnVsbHkgd2hlbiBmaWxlc3lzdGVtIG9wZXJhdGlvbnMgYXJlIGNvbXBsZXRlXG4gKlxuICogQGV4YW1wbGVcbiAqIGF3YWl0IGdpdC5hbm5vdGF0ZWRUYWcoe1xuICogICBmcyxcbiAqICAgZGlyOiAnL3R1dG9yaWFsJyxcbiAqICAgcmVmOiAndGVzdC10YWcnLFxuICogICBtZXNzYWdlOiAnVGhpcyBjb21taXQgaXMgYXdlc29tZScsXG4gKiAgIHRhZ2dlcjoge1xuICogICAgIG5hbWU6ICdNci4gVGVzdCcsXG4gKiAgICAgZW1haWw6ICdtcnRlc3RAZXhhbXBsZS5jb20nXG4gKiAgIH1cbiAqIH0pXG4gKiBjb25zb2xlLmxvZygnZG9uZScpXG4gKlxuICovXG5hc3luYyBmdW5jdGlvbiBhbm5vdGF0ZWRUYWcoe1xuICBmczogX2ZzLFxuICBvblNpZ24sXG4gIGRpcixcbiAgZ2l0ZGlyID0gam9pbihkaXIsICcuZ2l0JyksXG4gIHJlZixcbiAgdGFnZ2VyOiBfdGFnZ2VyLFxuICBtZXNzYWdlID0gcmVmLFxuICBncGdzaWcsXG4gIG9iamVjdCxcbiAgc2lnbmluZ0tleSxcbiAgZm9yY2UgPSBmYWxzZSxcbiAgY2FjaGUgPSB7fSxcbn0pIHtcbiAgdHJ5IHtcbiAgICBhc3NlcnRQYXJhbWV0ZXIoJ2ZzJywgX2ZzKTtcbiAgICBhc3NlcnRQYXJhbWV0ZXIoJ2dpdGRpcicsIGdpdGRpcik7XG4gICAgYXNzZXJ0UGFyYW1ldGVyKCdyZWYnLCByZWYpO1xuICAgIGlmIChzaWduaW5nS2V5KSB7XG4gICAgICBhc3NlcnRQYXJhbWV0ZXIoJ29uU2lnbicsIG9uU2lnbik7XG4gICAgfVxuICAgIGNvbnN0IGZzID0gbmV3IEZpbGVTeXN0ZW0oX2ZzKTtcblxuICAgIC8vIEZpbGwgaW4gbWlzc2luZyBhcmd1bWVudHMgd2l0aCBkZWZhdWx0IHZhbHVlc1xuICAgIGNvbnN0IHRhZ2dlciA9IGF3YWl0IG5vcm1hbGl6ZUF1dGhvck9iamVjdCh7IGZzLCBnaXRkaXIsIGF1dGhvcjogX3RhZ2dlciB9KTtcbiAgICBpZiAoIXRhZ2dlcikgdGhyb3cgbmV3IE1pc3NpbmdOYW1lRXJyb3IoJ3RhZ2dlcicpXG5cbiAgICByZXR1cm4gYXdhaXQgX2Fubm90YXRlZFRhZyh7XG4gICAgICBmcyxcbiAgICAgIGNhY2hlLFxuICAgICAgb25TaWduLFxuICAgICAgZ2l0ZGlyLFxuICAgICAgcmVmLFxuICAgICAgdGFnZ2VyLFxuICAgICAgbWVzc2FnZSxcbiAgICAgIGdwZ3NpZyxcbiAgICAgIG9iamVjdCxcbiAgICAgIHNpZ25pbmdLZXksXG4gICAgICBmb3JjZSxcbiAgICB9KVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBlcnIuY2FsbGVyID0gJ2dpdC5hbm5vdGF0ZWRUYWcnO1xuICAgIHRocm93IGVyclxuICB9XG59XG5cbi8vIEB0cy1jaGVja1xuXG4vKipcbiAqIENyZWF0ZSBhIGJyYW5jaFxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBhcmdzXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vbW9kZWxzL0ZpbGVTeXN0ZW0uanMnKS5GaWxlU3lzdGVtfSBhcmdzLmZzXG4gKiBAcGFyYW0ge3N0cmluZ30gYXJncy5naXRkaXJcbiAqIEBwYXJhbSB7c3RyaW5nfSBhcmdzLnJlZlxuICogQHBhcmFtIHtib29sZWFufSBbYXJncy5jaGVja291dCA9IGZhbHNlXVxuICpcbiAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fSBSZXNvbHZlcyBzdWNjZXNzZnVsbHkgd2hlbiBmaWxlc3lzdGVtIG9wZXJhdGlvbnMgYXJlIGNvbXBsZXRlXG4gKlxuICogQGV4YW1wbGVcbiAqIGF3YWl0IGdpdC5icmFuY2goeyBkaXI6ICckaW5wdXQoKC8pKScsIHJlZjogJyRpbnB1dCgoZGV2ZWxvcCkpJyB9KVxuICogY29uc29sZS5sb2coJ2RvbmUnKVxuICpcbiAqL1xuYXN5bmMgZnVuY3Rpb24gX2JyYW5jaCh7IGZzLCBnaXRkaXIsIHJlZiwgY2hlY2tvdXQgPSBmYWxzZSB9KSB7XG4gIGlmIChyZWYgIT09IGNsZWFuR2l0UmVmLmNsZWFuKHJlZikpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZFJlZk5hbWVFcnJvcihyZWYsIGNsZWFuR2l0UmVmLmNsZWFuKHJlZikpXG4gIH1cblxuICBjb25zdCBmdWxscmVmID0gYHJlZnMvaGVhZHMvJHtyZWZ9YDtcblxuICBjb25zdCBleGlzdCA9IGF3YWl0IEdpdFJlZk1hbmFnZXIuZXhpc3RzKHsgZnMsIGdpdGRpciwgcmVmOiBmdWxscmVmIH0pO1xuICBpZiAoZXhpc3QpIHtcbiAgICB0aHJvdyBuZXcgQWxyZWFkeUV4aXN0c0Vycm9yKCdicmFuY2gnLCByZWYsIGZhbHNlKVxuICB9XG5cbiAgLy8gR2V0IGN1cnJlbnQgSEVBRCB0cmVlIG9pZFxuICBsZXQgb2lkO1xuICB0cnkge1xuICAgIG9pZCA9IGF3YWl0IEdpdFJlZk1hbmFnZXIucmVzb2x2ZSh7IGZzLCBnaXRkaXIsIHJlZjogJ0hFQUQnIH0pO1xuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gUHJvYmFibHkgYW4gZW1wdHkgcmVwb1xuICB9XG5cbiAgLy8gQ3JlYXRlIGEgbmV3IHJlZiB0aGF0IHBvaW50cyBhdCB0aGUgY3VycmVudCBjb21taXRcbiAgaWYgKG9pZCkge1xuICAgIGF3YWl0IEdpdFJlZk1hbmFnZXIud3JpdGVSZWYoeyBmcywgZ2l0ZGlyLCByZWY6IGZ1bGxyZWYsIHZhbHVlOiBvaWQgfSk7XG4gIH1cblxuICBpZiAoY2hlY2tvdXQpIHtcbiAgICAvLyBVcGRhdGUgSEVBRFxuICAgIGF3YWl0IEdpdFJlZk1hbmFnZXIud3JpdGVTeW1ib2xpY1JlZih7XG4gICAgICBmcyxcbiAgICAgIGdpdGRpcixcbiAgICAgIHJlZjogJ0hFQUQnLFxuICAgICAgdmFsdWU6IGZ1bGxyZWYsXG4gICAgfSk7XG4gIH1cbn1cblxuLy8gQHRzLWNoZWNrXG5cbi8qKlxuICogQ3JlYXRlIGEgYnJhbmNoXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGFyZ3NcbiAqIEBwYXJhbSB7RnNDbGllbnR9IGFyZ3MuZnMgLSBhIGZpbGUgc3lzdGVtIGltcGxlbWVudGF0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MuZGlyXSAtIFRoZSBbd29ya2luZyB0cmVlXShkaXItdnMtZ2l0ZGlyLm1kKSBkaXJlY3RvcnkgcGF0aFxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLmdpdGRpcj1qb2luKGRpciwnLmdpdCcpXSAtIFtyZXF1aXJlZF0gVGhlIFtnaXQgZGlyZWN0b3J5XShkaXItdnMtZ2l0ZGlyLm1kKSBwYXRoXG4gKiBAcGFyYW0ge3N0cmluZ30gYXJncy5yZWYgLSBXaGF0IHRvIG5hbWUgdGhlIGJyYW5jaFxuICogQHBhcmFtIHtib29sZWFufSBbYXJncy5jaGVja291dCA9IGZhbHNlXSAtIFVwZGF0ZSBgSEVBRGAgdG8gcG9pbnQgYXQgdGhlIG5ld2x5IGNyZWF0ZWQgYnJhbmNoXG4gKlxuICogQHJldHVybnMge1Byb21pc2U8dm9pZD59IFJlc29sdmVzIHN1Y2Nlc3NmdWxseSB3aGVuIGZpbGVzeXN0ZW0gb3BlcmF0aW9ucyBhcmUgY29tcGxldGVcbiAqXG4gKiBAZXhhbXBsZVxuICogYXdhaXQgZ2l0LmJyYW5jaCh7IGZzLCBkaXI6ICcvdHV0b3JpYWwnLCByZWY6ICdkZXZlbG9wJyB9KVxuICogY29uc29sZS5sb2coJ2RvbmUnKVxuICpcbiAqL1xuYXN5bmMgZnVuY3Rpb24gYnJhbmNoKHtcbiAgZnMsXG4gIGRpcixcbiAgZ2l0ZGlyID0gam9pbihkaXIsICcuZ2l0JyksXG4gIHJlZixcbiAgY2hlY2tvdXQgPSBmYWxzZSxcbn0pIHtcbiAgdHJ5IHtcbiAgICBhc3NlcnRQYXJhbWV0ZXIoJ2ZzJywgZnMpO1xuICAgIGFzc2VydFBhcmFtZXRlcignZ2l0ZGlyJywgZ2l0ZGlyKTtcbiAgICBhc3NlcnRQYXJhbWV0ZXIoJ3JlZicsIHJlZik7XG4gICAgcmV0dXJuIGF3YWl0IF9icmFuY2goe1xuICAgICAgZnM6IG5ldyBGaWxlU3lzdGVtKGZzKSxcbiAgICAgIGdpdGRpcixcbiAgICAgIHJlZixcbiAgICAgIGNoZWNrb3V0LFxuICAgIH0pXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGVyci5jYWxsZXIgPSAnZ2l0LmJyYW5jaCc7XG4gICAgdGhyb3cgZXJyXG4gIH1cbn1cblxuLy8gaHR0cHM6Ly9kZXYudG8vbmFtaXJzYWIvY29tbWVudC8yMDUwXG5mdW5jdGlvbiBhcnJheVJhbmdlKHN0YXJ0LCBlbmQpIHtcbiAgY29uc3QgbGVuZ3RoID0gZW5kIC0gc3RhcnQ7XG4gIHJldHVybiBBcnJheS5mcm9tKHsgbGVuZ3RoIH0sIChfLCBpKSA9PiBzdGFydCArIGkpXG59XG5cbi8vIFRPRE86IFNob3VsZCBJIGp1c3QgcG9seWZpbGwgQXJyYXkuZmxhdD9cbmNvbnN0IGZsYXQgPVxuICB0eXBlb2YgQXJyYXkucHJvdG90eXBlLmZsYXQgPT09ICd1bmRlZmluZWQnXG4gICAgPyBlbnRyaWVzID0+IGVudHJpZXMucmVkdWNlKChhY2MsIHgpID0+IGFjYy5jb25jYXQoeCksIFtdKVxuICAgIDogZW50cmllcyA9PiBlbnRyaWVzLmZsYXQoKTtcblxuLy8gVGhpcyBpcyBjb252ZW5pZW50IGZvciBjb21wdXRpbmcgdW5pb25zL2pvaW5zIG9mIHNvcnRlZCBsaXN0cy5cbmNsYXNzIFJ1bm5pbmdNaW5pbXVtIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgLy8gVXNpbmcgYSBnZXR0ZXIgZm9yICd2YWx1ZScgd291bGQganVzdCBibG9hdCB0aGUgY29kZS5cbiAgICAvLyBZb3Uga25vdyBiZXR0ZXIgdGhhbiB0byBzZXQgaXQgZGlyZWN0bHkgcmlnaHQ/XG4gICAgdGhpcy52YWx1ZSA9IG51bGw7XG4gIH1cblxuICBjb25zaWRlcih2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSByZXR1cm5cbiAgICBpZiAodGhpcy52YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH0gZWxzZSBpZiAodmFsdWUgPCB0aGlzLnZhbHVlKSB7XG4gICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxuICB9XG5cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy52YWx1ZSA9IG51bGw7XG4gIH1cbn1cblxuLy8gVGFrZSBhbiBhcnJheSBvZiBsZW5ndGggTiBvZlxuLy8gICBpdGVyYXRvcnMgb2YgbGVuZ3RoIFFfblxuLy8gICAgIG9mIHN0cmluZ3Ncbi8vIGFuZCByZXR1cm4gYW4gaXRlcmF0b3Igb2YgbGVuZ3RoIG1heChRX24pIGZvciBhbGwgblxuLy8gICBvZiBhcnJheXMgb2YgbGVuZ3RoIE5cbi8vICAgICBvZiBzdHJpbmd8bnVsbCB3aG8gYWxsIGhhdmUgdGhlIHNhbWUgc3RyaW5nIHZhbHVlXG5mdW5jdGlvbiogdW5pb25PZkl0ZXJhdG9ycyhzZXRzKSB7XG4gIC8qIE5PVEU6IFdlIGNhbiBhc3N1bWUgYWxsIGFycmF5cyBhcmUgc29ydGVkLlxuICAgKiBJbmRleGVzIGFyZSBzb3J0ZWQgYmVjYXVzZSB0aGV5IGFyZSBkZWZpbmVkIHRoYXQgd2F5OlxuICAgKlxuICAgKiA+IEluZGV4IGVudHJpZXMgYXJlIHNvcnRlZCBpbiBhc2NlbmRpbmcgb3JkZXIgb24gdGhlIG5hbWUgZmllbGQsXG4gICAqID4gaW50ZXJwcmV0ZWQgYXMgYSBzdHJpbmcgb2YgdW5zaWduZWQgYnl0ZXMgKGkuZS4gbWVtY21wKCkgb3JkZXIsIG5vXG4gICAqID4gbG9jYWxpemF0aW9uLCBubyBzcGVjaWFsIGNhc2luZyBvZiBkaXJlY3Rvcnkgc2VwYXJhdG9yICcvJykuIEVudHJpZXNcbiAgICogPiB3aXRoIHRoZSBzYW1lIG5hbWUgYXJlIHNvcnRlZCBieSB0aGVpciBzdGFnZSBmaWVsZC5cbiAgICpcbiAgICogVHJlZXMgc2hvdWxkIGJlIHNvcnRlZCBiZWNhdXNlIHRoZXkgYXJlIGNyZWF0ZWQgZGlyZWN0bHkgZnJvbSBpbmRleGVzLlxuICAgKiBUaGV5IGRlZmluaXRlbHkgc2hvdWxkIGJlIHNvcnRlZCwgb3IgZWxzZSB0aGV5IHdvdWxkbid0IGhhdmUgYSB1bmlxdWUgU0hBMS5cbiAgICogU28gdGhhdCB3b3VsZCBiZSB2ZXJ5IG5hdWdodHkgb24gdGhlIHBhcnQgb2YgdGhlIHRyZWUtY3JlYXRvci5cbiAgICpcbiAgICogTGFzdGx5LCB0aGUgd29ya2luZyBkaXIgZW50cmllcyBhcmUgc29ydGVkIGJlY2F1c2UgSSBjaG9vc2UgdG8gc29ydCB0aGVtXG4gICAqIGluIG15IEZpbGVTeXN0ZW0ucmVhZGRpcigpIGltcGxlbWVudGF0aW9uLlxuICAgKi9cblxuICAvLyBJbml0XG4gIGNvbnN0IG1pbiA9IG5ldyBSdW5uaW5nTWluaW11bSgpO1xuICBsZXQgbWluaW11bTtcbiAgY29uc3QgaGVhZHMgPSBbXTtcbiAgY29uc3QgbnVtc2V0cyA9IHNldHMubGVuZ3RoO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG51bXNldHM7IGkrKykge1xuICAgIC8vIEFidXNlIHRoZSBmYWN0IHRoYXQgaXRlcmF0b3JzIGNvbnRpbnVlIHRvIHJldHVybiAndW5kZWZpbmVkJyBmb3IgdmFsdWVcbiAgICAvLyBvbmNlIHRoZXkgYXJlIGRvbmVcbiAgICBoZWFkc1tpXSA9IHNldHNbaV0ubmV4dCgpLnZhbHVlO1xuICAgIGlmIChoZWFkc1tpXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBtaW4uY29uc2lkZXIoaGVhZHNbaV0pO1xuICAgIH1cbiAgfVxuICBpZiAobWluLnZhbHVlID09PSBudWxsKSByZXR1cm5cbiAgLy8gSXRlcmF0ZVxuICB3aGlsZSAodHJ1ZSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIG1pbmltdW0gPSBtaW4udmFsdWU7XG4gICAgbWluLnJlc2V0KCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1zZXRzOyBpKyspIHtcbiAgICAgIGlmIChoZWFkc1tpXSAhPT0gdW5kZWZpbmVkICYmIGhlYWRzW2ldID09PSBtaW5pbXVtKSB7XG4gICAgICAgIHJlc3VsdFtpXSA9IGhlYWRzW2ldO1xuICAgICAgICBoZWFkc1tpXSA9IHNldHNbaV0ubmV4dCgpLnZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQSBsaXR0bGUgaGFja3ksIGJ1dCBlaFxuICAgICAgICByZXN1bHRbaV0gPSBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKGhlYWRzW2ldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbWluLmNvbnNpZGVyKGhlYWRzW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgeWllbGQgcmVzdWx0O1xuICAgIGlmIChtaW4udmFsdWUgPT09IG51bGwpIHJldHVyblxuICB9XG59XG5cbi8vIEB0cy1jaGVja1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBhcmdzXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vbW9kZWxzL0ZpbGVTeXN0ZW0uanMnKS5GaWxlU3lzdGVtfSBhcmdzLmZzXG4gKiBAcGFyYW0ge29iamVjdH0gYXJncy5jYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLmRpcl1cbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5naXRkaXI9am9pbihkaXIsJy5naXQnKV1cbiAqIEBwYXJhbSB7V2Fsa2VyW119IGFyZ3MudHJlZXNcbiAqIEBwYXJhbSB7V2Fsa2VyTWFwfSBbYXJncy5tYXBdXG4gKiBAcGFyYW0ge1dhbGtlclJlZHVjZX0gW2FyZ3MucmVkdWNlXVxuICogQHBhcmFtIHtXYWxrZXJJdGVyYXRlfSBbYXJncy5pdGVyYXRlXVxuICpcbiAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59IFRoZSBmaW5pc2hlZCB0cmVlLXdhbGtpbmcgcmVzdWx0XG4gKlxuICogQHNlZSB7V2Fsa2VyTWFwfVxuICpcbiAqL1xuYXN5bmMgZnVuY3Rpb24gX3dhbGsoe1xuICBmcyxcbiAgY2FjaGUsXG4gIGRpcixcbiAgZ2l0ZGlyLFxuICB0cmVlcyxcbiAgLy8gQHRzLWlnbm9yZVxuICBtYXAgPSBhc3luYyAoXywgZW50cnkpID0+IGVudHJ5LFxuICAvLyBUaGUgZGVmYXVsdCByZWR1Y2VyIGlzIGEgZmxhdG1hcCB0aGF0IGZpbHRlcnMgb3V0IHVuZGVmaW5lZHMuXG4gIHJlZHVjZSA9IGFzeW5jIChwYXJlbnQsIGNoaWxkcmVuKSA9PiB7XG4gICAgY29uc3QgZmxhdHRlbiA9IGZsYXQoY2hpbGRyZW4pO1xuICAgIGlmIChwYXJlbnQgIT09IHVuZGVmaW5lZCkgZmxhdHRlbi51bnNoaWZ0KHBhcmVudCk7XG4gICAgcmV0dXJuIGZsYXR0ZW5cbiAgfSxcbiAgLy8gVGhlIGRlZmF1bHQgaXRlcmF0ZSBmdW5jdGlvbiB3YWxrcyBhbGwgY2hpbGRyZW4gY29uY3VycmVudGx5XG4gIGl0ZXJhdGUgPSAod2FsaywgY2hpbGRyZW4pID0+IFByb21pc2UuYWxsKFsuLi5jaGlsZHJlbl0ubWFwKHdhbGspKSxcbn0pIHtcbiAgY29uc3Qgd2Fsa2VycyA9IHRyZWVzLm1hcChwcm94eSA9PlxuICAgIHByb3h5W0dpdFdhbGtTeW1ib2xdKHsgZnMsIGRpciwgZ2l0ZGlyLCBjYWNoZSB9KVxuICApO1xuXG4gIGNvbnN0IHJvb3QgPSBuZXcgQXJyYXkod2Fsa2Vycy5sZW5ndGgpLmZpbGwoJy4nKTtcbiAgY29uc3QgcmFuZ2UgPSBhcnJheVJhbmdlKDAsIHdhbGtlcnMubGVuZ3RoKTtcbiAgY29uc3QgdW5pb25XYWxrZXJGcm9tUmVhZGRpciA9IGFzeW5jIGVudHJpZXMgPT4ge1xuICAgIHJhbmdlLm1hcChpID0+IHtcbiAgICAgIGVudHJpZXNbaV0gPSBlbnRyaWVzW2ldICYmIG5ldyB3YWxrZXJzW2ldLkNvbnN0cnVjdEVudHJ5KGVudHJpZXNbaV0pO1xuICAgIH0pO1xuICAgIGNvbnN0IHN1YmRpcnMgPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgIHJhbmdlLm1hcChpID0+IChlbnRyaWVzW2ldID8gd2Fsa2Vyc1tpXS5yZWFkZGlyKGVudHJpZXNbaV0pIDogW10pKVxuICAgICk7XG4gICAgLy8gTm93IHByb2Nlc3MgY2hpbGQgZGlyZWN0b3JpZXNcbiAgICBjb25zdCBpdGVyYXRvcnMgPSBzdWJkaXJzXG4gICAgICAubWFwKGFycmF5ID0+IChhcnJheSA9PT0gbnVsbCA/IFtdIDogYXJyYXkpKVxuICAgICAgLm1hcChhcnJheSA9PiBhcnJheVtTeW1ib2wuaXRlcmF0b3JdKCkpO1xuICAgIHJldHVybiB7XG4gICAgICBlbnRyaWVzLFxuICAgICAgY2hpbGRyZW46IHVuaW9uT2ZJdGVyYXRvcnMoaXRlcmF0b3JzKSxcbiAgICB9XG4gIH07XG5cbiAgY29uc3Qgd2FsayA9IGFzeW5jIHJvb3QgPT4ge1xuICAgIGNvbnN0IHsgZW50cmllcywgY2hpbGRyZW4gfSA9IGF3YWl0IHVuaW9uV2Fsa2VyRnJvbVJlYWRkaXIocm9vdCk7XG4gICAgY29uc3QgZnVsbHBhdGggPSBlbnRyaWVzLmZpbmQoZW50cnkgPT4gZW50cnkgJiYgZW50cnkuX2Z1bGxwYXRoKS5fZnVsbHBhdGg7XG4gICAgY29uc3QgcGFyZW50ID0gYXdhaXQgbWFwKGZ1bGxwYXRoLCBlbnRyaWVzKTtcbiAgICBpZiAocGFyZW50ICE9PSBudWxsKSB7XG4gICAgICBsZXQgd2Fsa2VkQ2hpbGRyZW4gPSBhd2FpdCBpdGVyYXRlKHdhbGssIGNoaWxkcmVuKTtcbiAgICAgIHdhbGtlZENoaWxkcmVuID0gd2Fsa2VkQ2hpbGRyZW4uZmlsdGVyKHggPT4geCAhPT0gdW5kZWZpbmVkKTtcbiAgICAgIHJldHVybiByZWR1Y2UocGFyZW50LCB3YWxrZWRDaGlsZHJlbilcbiAgICB9XG4gIH07XG4gIHJldHVybiB3YWxrKHJvb3QpXG59XG5cbmNvbnN0IHdvcnRoV2Fsa2luZyA9IChmaWxlcGF0aCwgcm9vdCkgPT4ge1xuICBpZiAoZmlsZXBhdGggPT09ICcuJyB8fCByb290ID09IG51bGwgfHwgcm9vdC5sZW5ndGggPT09IDAgfHwgcm9vdCA9PT0gJy4nKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICBpZiAocm9vdC5sZW5ndGggPj0gZmlsZXBhdGgubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHJvb3Quc3RhcnRzV2l0aChmaWxlcGF0aClcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmlsZXBhdGguc3RhcnRzV2l0aChyb290KVxuICB9XG59O1xuXG4vLyBAdHMtY2hlY2tcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gYXJnc1xuICogQHBhcmFtIHtpbXBvcnQoJy4uL21vZGVscy9GaWxlU3lzdGVtLmpzJykuRmlsZVN5c3RlbX0gYXJncy5mc1xuICogQHBhcmFtIHthbnl9IGFyZ3MuY2FjaGVcbiAqIEBwYXJhbSB7UHJvZ3Jlc3NDYWxsYmFja30gW2FyZ3Mub25Qcm9ncmVzc11cbiAqIEBwYXJhbSB7c3RyaW5nfSBhcmdzLmRpclxuICogQHBhcmFtIHtzdHJpbmd9IGFyZ3MuZ2l0ZGlyXG4gKiBAcGFyYW0ge3N0cmluZ30gYXJncy5yZWZcbiAqIEBwYXJhbSB7c3RyaW5nW119IFthcmdzLmZpbGVwYXRoc11cbiAqIEBwYXJhbSB7c3RyaW5nfSBhcmdzLnJlbW90ZVxuICogQHBhcmFtIHtib29sZWFufSBhcmdzLm5vQ2hlY2tvdXRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2FyZ3Mubm9VcGRhdGVIZWFkXVxuICogQHBhcmFtIHtib29sZWFufSBbYXJncy5kcnlSdW5dXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFthcmdzLmZvcmNlXVxuICpcbiAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fSBSZXNvbHZlcyBzdWNjZXNzZnVsbHkgd2hlbiBmaWxlc3lzdGVtIG9wZXJhdGlvbnMgYXJlIGNvbXBsZXRlXG4gKlxuICovXG5hc3luYyBmdW5jdGlvbiBfY2hlY2tvdXQoe1xuICBmcyxcbiAgY2FjaGUsXG4gIG9uUHJvZ3Jlc3MsXG4gIGRpcixcbiAgZ2l0ZGlyLFxuICByZW1vdGUsXG4gIHJlZixcbiAgZmlsZXBhdGhzLFxuICBub0NoZWNrb3V0LFxuICBub1VwZGF0ZUhlYWQsXG4gIGRyeVJ1bixcbiAgZm9yY2UsXG59KSB7XG4gIC8vIEdldCB0cmVlIG9pZFxuICBsZXQgb2lkO1xuICB0cnkge1xuICAgIG9pZCA9IGF3YWl0IEdpdFJlZk1hbmFnZXIucmVzb2x2ZSh7IGZzLCBnaXRkaXIsIHJlZiB9KTtcbiAgICAvLyBUT0RPOiBGaWd1cmUgb3V0IHdoYXQgdG8gZG8gaWYgYm90aCAncmVmJyBhbmQgJ3JlbW90ZScgYXJlIHNwZWNpZmllZCwgcmVmIGFscmVhZHkgZXhpc3RzLFxuICAgIC8vIGFuZCBpcyBjb25maWd1cmVkIHRvIHRyYWNrIGEgZGlmZmVyZW50IHJlbW90ZS5cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaWYgKHJlZiA9PT0gJ0hFQUQnKSB0aHJvdyBlcnJcbiAgICAvLyBJZiBgcmVmYCBkb2Vzbid0IGV4aXN0LCBjcmVhdGUgYSBuZXcgcmVtb3RlIHRyYWNraW5nIGJyYW5jaFxuICAgIC8vIEZpZ3VyZSBvdXQgdGhlIGNvbW1pdCB0byBjaGVja291dFxuICAgIGNvbnN0IHJlbW90ZVJlZiA9IGAke3JlbW90ZX0vJHtyZWZ9YDtcbiAgICBvaWQgPSBhd2FpdCBHaXRSZWZNYW5hZ2VyLnJlc29sdmUoe1xuICAgICAgZnMsXG4gICAgICBnaXRkaXIsXG4gICAgICByZWY6IHJlbW90ZVJlZixcbiAgICB9KTtcbiAgICAvLyBTZXQgdXAgcmVtb3RlIHRyYWNraW5nIGJyYW5jaFxuICAgIGNvbnN0IGNvbmZpZyA9IGF3YWl0IEdpdENvbmZpZ01hbmFnZXIuZ2V0KHsgZnMsIGdpdGRpciB9KTtcbiAgICBhd2FpdCBjb25maWcuc2V0KGBicmFuY2guJHtyZWZ9LnJlbW90ZWAsIHJlbW90ZSk7XG4gICAgYXdhaXQgY29uZmlnLnNldChgYnJhbmNoLiR7cmVmfS5tZXJnZWAsIGByZWZzL2hlYWRzLyR7cmVmfWApO1xuICAgIGF3YWl0IEdpdENvbmZpZ01hbmFnZXIuc2F2ZSh7IGZzLCBnaXRkaXIsIGNvbmZpZyB9KTtcbiAgICAvLyBDcmVhdGUgYSBuZXcgYnJhbmNoIHRoYXQgcG9pbnRzIGF0IHRoYXQgc2FtZSBjb21taXRcbiAgICBhd2FpdCBHaXRSZWZNYW5hZ2VyLndyaXRlUmVmKHtcbiAgICAgIGZzLFxuICAgICAgZ2l0ZGlyLFxuICAgICAgcmVmOiBgcmVmcy9oZWFkcy8ke3JlZn1gLFxuICAgICAgdmFsdWU6IG9pZCxcbiAgICB9KTtcbiAgfVxuXG4gIC8vIFVwZGF0ZSB3b3JraW5nIGRpclxuICBpZiAoIW5vQ2hlY2tvdXQpIHtcbiAgICBsZXQgb3BzO1xuICAgIC8vIEZpcnN0IHBhc3MgLSBqdXN0IGFuYWx5emUgZmlsZXMgKG5vdCBkaXJlY3RvcmllcykgYW5kIGZpZ3VyZSBvdXQgd2hhdCBuZWVkcyB0byBiZSBkb25lXG4gICAgdHJ5IHtcbiAgICAgIG9wcyA9IGF3YWl0IGFuYWx5emUoe1xuICAgICAgICBmcyxcbiAgICAgICAgY2FjaGUsXG4gICAgICAgIG9uUHJvZ3Jlc3MsXG4gICAgICAgIGRpcixcbiAgICAgICAgZ2l0ZGlyLFxuICAgICAgICByZWYsXG4gICAgICAgIGZvcmNlLFxuICAgICAgICBmaWxlcGF0aHMsXG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIC8vIFRocm93IGEgbW9yZSBoZWxwZnVsIGVycm9yIG1lc3NhZ2UgZm9yIHRoaXMgY29tbW9uIG1pc3Rha2UuXG4gICAgICBpZiAoZXJyIGluc3RhbmNlb2YgTm90Rm91bmRFcnJvciAmJiBlcnIuZGF0YS53aGF0ID09PSBvaWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IENvbW1pdE5vdEZldGNoZWRFcnJvcihyZWYsIG9pZClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGVyclxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJlcG9ydCBjb25mbGljdHNcbiAgICBjb25zdCBjb25mbGljdHMgPSBvcHNcbiAgICAgIC5maWx0ZXIoKFttZXRob2RdKSA9PiBtZXRob2QgPT09ICdjb25mbGljdCcpXG4gICAgICAubWFwKChbbWV0aG9kLCBmdWxscGF0aF0pID0+IGZ1bGxwYXRoKTtcbiAgICBpZiAoY29uZmxpY3RzLmxlbmd0aCA+IDApIHtcbiAgICAgIHRocm93IG5ldyBDaGVja291dENvbmZsaWN0RXJyb3IoY29uZmxpY3RzKVxuICAgIH1cblxuICAgIC8vIENvbGxlY3QgZXJyb3JzXG4gICAgY29uc3QgZXJyb3JzID0gb3BzXG4gICAgICAuZmlsdGVyKChbbWV0aG9kXSkgPT4gbWV0aG9kID09PSAnZXJyb3InKVxuICAgICAgLm1hcCgoW21ldGhvZCwgZnVsbHBhdGhdKSA9PiBmdWxscGF0aCk7XG4gICAgaWYgKGVycm9ycy5sZW5ndGggPiAwKSB7XG4gICAgICB0aHJvdyBuZXcgSW50ZXJuYWxFcnJvcihlcnJvcnMuam9pbignLCAnKSlcbiAgICB9XG5cbiAgICBpZiAoZHJ5UnVuKSB7XG4gICAgICAvLyBTaW5jZSB0aGUgZm9ybWF0IG9mICdvcHMnIGlzIGluIGZsdXgsIEkgcmVhbGx5IHdvdWxkIHJhdGhlciBmb2xrIGJlc2lkZXMgbXlzZWxmIG5vdCBzdGFydCByZWx5aW5nIG9uIGl0XG4gICAgICAvLyByZXR1cm4gb3BzXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBTZWNvbmQgcGFzcyAtIGV4ZWN1dGUgcGxhbm5lZCBjaGFuZ2VzXG4gICAgLy8gVGhlIGNoZWFwZXN0IHNlbWktcGFyYWxsZWwgc29sdXRpb24gd2l0aG91dCBjb21wdXRpbmcgYSBmdWxsIGRlcGVuZGVuY3kgZ3JhcGggd2lsbCBiZVxuICAgIC8vIHRvIGp1c3QgZG8gb3BzIGluIDQgZHVtYiBwaGFzZXM6IGRlbGV0ZSBmaWxlcywgZGVsZXRlIGRpcnMsIGNyZWF0ZSBkaXJzLCB3cml0ZSBmaWxlc1xuXG4gICAgbGV0IGNvdW50ID0gMDtcbiAgICBjb25zdCB0b3RhbCA9IG9wcy5sZW5ndGg7XG4gICAgYXdhaXQgR2l0SW5kZXhNYW5hZ2VyLmFjcXVpcmUoeyBmcywgZ2l0ZGlyLCBjYWNoZSB9LCBhc3luYyBmdW5jdGlvbihpbmRleCkge1xuICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICAgIG9wc1xuICAgICAgICAgIC5maWx0ZXIoXG4gICAgICAgICAgICAoW21ldGhvZF0pID0+IG1ldGhvZCA9PT0gJ2RlbGV0ZScgfHwgbWV0aG9kID09PSAnZGVsZXRlLWluZGV4J1xuICAgICAgICAgIClcbiAgICAgICAgICAubWFwKGFzeW5jIGZ1bmN0aW9uKFttZXRob2QsIGZ1bGxwYXRoXSkge1xuICAgICAgICAgICAgY29uc3QgZmlsZXBhdGggPSBgJHtkaXJ9LyR7ZnVsbHBhdGh9YDtcbiAgICAgICAgICAgIGlmIChtZXRob2QgPT09ICdkZWxldGUnKSB7XG4gICAgICAgICAgICAgIGF3YWl0IGZzLnJtKGZpbGVwYXRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGluZGV4LmRlbGV0ZSh7IGZpbGVwYXRoOiBmdWxscGF0aCB9KTtcbiAgICAgICAgICAgIGlmIChvblByb2dyZXNzKSB7XG4gICAgICAgICAgICAgIGF3YWl0IG9uUHJvZ3Jlc3Moe1xuICAgICAgICAgICAgICAgIHBoYXNlOiAnVXBkYXRpbmcgd29ya2RpcicsXG4gICAgICAgICAgICAgICAgbG9hZGVkOiArK2NvdW50LFxuICAgICAgICAgICAgICAgIHRvdGFsLFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIC8vIE5vdGU6IHRoaXMgaXMgY2Fubm90IGJlIGRvbmUgbmFpdmVseSBpbiBwYXJhbGxlbFxuICAgIGF3YWl0IEdpdEluZGV4TWFuYWdlci5hY3F1aXJlKHsgZnMsIGdpdGRpciwgY2FjaGUgfSwgYXN5bmMgZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgIGZvciAoY29uc3QgW21ldGhvZCwgZnVsbHBhdGhdIG9mIG9wcykge1xuICAgICAgICBpZiAobWV0aG9kID09PSAncm1kaXInIHx8IG1ldGhvZCA9PT0gJ3JtZGlyLWluZGV4Jykge1xuICAgICAgICAgIGNvbnN0IGZpbGVwYXRoID0gYCR7ZGlyfS8ke2Z1bGxwYXRofWA7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChtZXRob2QgPT09ICdybWRpci1pbmRleCcpIHtcbiAgICAgICAgICAgICAgaW5kZXguZGVsZXRlKHsgZmlsZXBhdGg6IGZ1bGxwYXRoIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXdhaXQgZnMucm1kaXIoZmlsZXBhdGgpO1xuICAgICAgICAgICAgaWYgKG9uUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgICAgYXdhaXQgb25Qcm9ncmVzcyh7XG4gICAgICAgICAgICAgICAgcGhhc2U6ICdVcGRhdGluZyB3b3JrZGlyJyxcbiAgICAgICAgICAgICAgICBsb2FkZWQ6ICsrY291bnQsXG4gICAgICAgICAgICAgICAgdG90YWwsXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlmIChlLmNvZGUgPT09ICdFTk9URU1QVFknKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgICAgICAgIGBEaWQgbm90IGRlbGV0ZSAke2Z1bGxwYXRofSBiZWNhdXNlIGRpcmVjdG9yeSBpcyBub3QgZW1wdHlgXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aHJvdyBlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgIG9wc1xuICAgICAgICAuZmlsdGVyKChbbWV0aG9kXSkgPT4gbWV0aG9kID09PSAnbWtkaXInIHx8IG1ldGhvZCA9PT0gJ21rZGlyLWluZGV4JylcbiAgICAgICAgLm1hcChhc3luYyBmdW5jdGlvbihbXywgZnVsbHBhdGhdKSB7XG4gICAgICAgICAgY29uc3QgZmlsZXBhdGggPSBgJHtkaXJ9LyR7ZnVsbHBhdGh9YDtcbiAgICAgICAgICBhd2FpdCBmcy5ta2RpcihmaWxlcGF0aCk7XG4gICAgICAgICAgaWYgKG9uUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgIGF3YWl0IG9uUHJvZ3Jlc3Moe1xuICAgICAgICAgICAgICBwaGFzZTogJ1VwZGF0aW5nIHdvcmtkaXInLFxuICAgICAgICAgICAgICBsb2FkZWQ6ICsrY291bnQsXG4gICAgICAgICAgICAgIHRvdGFsLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICk7XG5cbiAgICBhd2FpdCBHaXRJbmRleE1hbmFnZXIuYWNxdWlyZSh7IGZzLCBnaXRkaXIsIGNhY2hlIH0sIGFzeW5jIGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgICAgb3BzXG4gICAgICAgICAgLmZpbHRlcihcbiAgICAgICAgICAgIChbbWV0aG9kXSkgPT5cbiAgICAgICAgICAgICAgbWV0aG9kID09PSAnY3JlYXRlJyB8fFxuICAgICAgICAgICAgICBtZXRob2QgPT09ICdjcmVhdGUtaW5kZXgnIHx8XG4gICAgICAgICAgICAgIG1ldGhvZCA9PT0gJ3VwZGF0ZScgfHxcbiAgICAgICAgICAgICAgbWV0aG9kID09PSAnbWtkaXItaW5kZXgnXG4gICAgICAgICAgKVxuICAgICAgICAgIC5tYXAoYXN5bmMgZnVuY3Rpb24oW21ldGhvZCwgZnVsbHBhdGgsIG9pZCwgbW9kZSwgY2htb2RdKSB7XG4gICAgICAgICAgICBjb25zdCBmaWxlcGF0aCA9IGAke2Rpcn0vJHtmdWxscGF0aH1gO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgaWYgKG1ldGhvZCAhPT0gJ2NyZWF0ZS1pbmRleCcgJiYgbWV0aG9kICE9PSAnbWtkaXItaW5kZXgnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBvYmplY3QgfSA9IGF3YWl0IF9yZWFkT2JqZWN0KHsgZnMsIGNhY2hlLCBnaXRkaXIsIG9pZCB9KTtcbiAgICAgICAgICAgICAgICBpZiAoY2htb2QpIHtcbiAgICAgICAgICAgICAgICAgIC8vIE5vdGU6IHRoZSBtb2RlIG9wdGlvbiBvZiBmcy53cml0ZSBvbmx5IHdvcmtzIHdoZW4gY3JlYXRpbmcgZmlsZXMsXG4gICAgICAgICAgICAgICAgICAvLyBub3QgdXBkYXRpbmcgdGhlbS4gU2luY2UgdGhlIGBmc2AgcGx1Z2luIGRvZXNuJ3QgZXhwb3NlIGBjaG1vZGAgdGhpc1xuICAgICAgICAgICAgICAgICAgLy8gaXMgb3VyIG9ubHkgb3B0aW9uLlxuICAgICAgICAgICAgICAgICAgYXdhaXQgZnMucm0oZmlsZXBhdGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobW9kZSA9PT0gMG8xMDA2NDQpIHtcbiAgICAgICAgICAgICAgICAgIC8vIHJlZ3VsYXIgZmlsZVxuICAgICAgICAgICAgICAgICAgYXdhaXQgZnMud3JpdGUoZmlsZXBhdGgsIG9iamVjdCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChtb2RlID09PSAwbzEwMDc1NSkge1xuICAgICAgICAgICAgICAgICAgLy8gZXhlY3V0YWJsZSBmaWxlXG4gICAgICAgICAgICAgICAgICBhd2FpdCBmcy53cml0ZShmaWxlcGF0aCwgb2JqZWN0LCB7IG1vZGU6IDBvNzc3IH0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobW9kZSA9PT0gMG8xMjAwMDApIHtcbiAgICAgICAgICAgICAgICAgIC8vIHN5bWxpbmtcbiAgICAgICAgICAgICAgICAgIGF3YWl0IGZzLndyaXRlbGluayhmaWxlcGF0aCwgb2JqZWN0KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEludGVybmFsRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIGBJbnZhbGlkIG1vZGUgMG8ke21vZGUudG9TdHJpbmcoOCl9IGRldGVjdGVkIGluIGJsb2IgJHtvaWR9YFxuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGNvbnN0IHN0YXRzID0gYXdhaXQgZnMubHN0YXQoZmlsZXBhdGgpO1xuICAgICAgICAgICAgICAvLyBXZSBjYW4ndCB0cnVzdCB0aGUgZXhlY3V0YWJsZSBiaXQgcmV0dXJuZWQgYnkgbHN0YXQgb24gV2luZG93cyxcbiAgICAgICAgICAgICAgLy8gc28gd2UgbmVlZCB0byBwcmVzZXJ2ZSB0aGlzIHZhbHVlIGZyb20gdGhlIFRSRUUuXG4gICAgICAgICAgICAgIC8vIFRPRE86IEZpZ3VyZSBvdXQgaG93IGdpdCBoYW5kbGVzIHRoaXMgaW50ZXJuYWxseS5cbiAgICAgICAgICAgICAgaWYgKG1vZGUgPT09IDBvMTAwNzU1KSB7XG4gICAgICAgICAgICAgICAgc3RhdHMubW9kZSA9IDBvNzU1O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIFN1Ym1vZHVsZXMgYXJlIHByZXNlbnQgaW4gdGhlIGdpdCBpbmRleCBidXQgdXNlIGEgdW5pcXVlIG1vZGUgZGlmZmVyZW50IGZyb20gdHJlZXNcbiAgICAgICAgICAgICAgaWYgKG1ldGhvZCA9PT0gJ21rZGlyLWluZGV4Jykge1xuICAgICAgICAgICAgICAgIHN0YXRzLm1vZGUgPSAwbzE2MDAwMDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpbmRleC5pbnNlcnQoe1xuICAgICAgICAgICAgICAgIGZpbGVwYXRoOiBmdWxscGF0aCxcbiAgICAgICAgICAgICAgICBzdGF0cyxcbiAgICAgICAgICAgICAgICBvaWQsXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBpZiAob25Qcm9ncmVzcykge1xuICAgICAgICAgICAgICAgIGF3YWl0IG9uUHJvZ3Jlc3Moe1xuICAgICAgICAgICAgICAgICAgcGhhc2U6ICdVcGRhdGluZyB3b3JrZGlyJyxcbiAgICAgICAgICAgICAgICAgIGxvYWRlZDogKytjb3VudCxcbiAgICAgICAgICAgICAgICAgIHRvdGFsLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICApO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gVXBkYXRlIEhFQURcbiAgaWYgKCFub1VwZGF0ZUhlYWQpIHtcbiAgICBjb25zdCBmdWxsUmVmID0gYXdhaXQgR2l0UmVmTWFuYWdlci5leHBhbmQoeyBmcywgZ2l0ZGlyLCByZWYgfSk7XG4gICAgaWYgKGZ1bGxSZWYuc3RhcnRzV2l0aCgncmVmcy9oZWFkcycpKSB7XG4gICAgICBhd2FpdCBHaXRSZWZNYW5hZ2VyLndyaXRlU3ltYm9saWNSZWYoe1xuICAgICAgICBmcyxcbiAgICAgICAgZ2l0ZGlyLFxuICAgICAgICByZWY6ICdIRUFEJyxcbiAgICAgICAgdmFsdWU6IGZ1bGxSZWYsXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZGV0YWNoZWQgaGVhZFxuICAgICAgYXdhaXQgR2l0UmVmTWFuYWdlci53cml0ZVJlZih7IGZzLCBnaXRkaXIsIHJlZjogJ0hFQUQnLCB2YWx1ZTogb2lkIH0pO1xuICAgIH1cbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBhbmFseXplKHtcbiAgZnMsXG4gIGNhY2hlLFxuICBvblByb2dyZXNzLFxuICBkaXIsXG4gIGdpdGRpcixcbiAgcmVmLFxuICBmb3JjZSxcbiAgZmlsZXBhdGhzLFxufSkge1xuICBsZXQgY291bnQgPSAwO1xuICByZXR1cm4gX3dhbGsoe1xuICAgIGZzLFxuICAgIGNhY2hlLFxuICAgIGRpcixcbiAgICBnaXRkaXIsXG4gICAgdHJlZXM6IFtUUkVFKHsgcmVmIH0pLCBXT1JLRElSKCksIFNUQUdFKCldLFxuICAgIG1hcDogYXN5bmMgZnVuY3Rpb24oZnVsbHBhdGgsIFtjb21taXQsIHdvcmtkaXIsIHN0YWdlXSkge1xuICAgICAgaWYgKGZ1bGxwYXRoID09PSAnLicpIHJldHVyblxuICAgICAgLy8gbWF0Y2ggYWdhaW5zdCBiYXNlIHBhdGhzXG4gICAgICBpZiAoZmlsZXBhdGhzICYmICFmaWxlcGF0aHMuc29tZShiYXNlID0+IHdvcnRoV2Fsa2luZyhmdWxscGF0aCwgYmFzZSkpKSB7XG4gICAgICAgIHJldHVybiBudWxsXG4gICAgICB9XG4gICAgICAvLyBFbWl0IHByb2dyZXNzIGV2ZW50XG4gICAgICBpZiAob25Qcm9ncmVzcykge1xuICAgICAgICBhd2FpdCBvblByb2dyZXNzKHsgcGhhc2U6ICdBbmFseXppbmcgd29ya2RpcicsIGxvYWRlZDogKytjb3VudCB9KTtcbiAgICAgIH1cblxuICAgICAgLy8gVGhpcyBpcyBhIGtpbmQgb2Ygc2lsbHkgcGF0dGVybiBidXQgaXQgd29ya2VkIHNvIHdlbGwgZm9yIG1lIGluIHRoZSBwYXN0XG4gICAgICAvLyBhbmQgaXQgbWFrZXMgaW50dWl0aXZlbHkgZGVtb25zdHJhdGluZyBleGhhdXN0aXZlbmVzcyBzbyAqZWFzeSouXG4gICAgICAvLyBUaGlzIGNoZWNrcyBmb3IgdGhlIHByZXNlbnNlIGFuZC9vciBhYnNlbnNlIG9mIGVhY2ggb2YgdGhlIDMgZW50cmllcyxcbiAgICAgIC8vIGNvbnZlcnRzIHRoYXQgdG8gYSAzLWJpdCBiaW5hcnkgcmVwcmVzZW50YXRpb24sIGFuZCB0aGVuIGhhbmRsZXNcbiAgICAgIC8vIGV2ZXJ5IHBvc3NpYmxlIGNvbWJpbmF0aW9uICgyXjMgb3IgOCBjYXNlcykgd2l0aCBhIGxvb2t1cCB0YWJsZS5cbiAgICAgIGNvbnN0IGtleSA9IFshIXN0YWdlLCAhIWNvbW1pdCwgISF3b3JrZGlyXS5tYXAoTnVtYmVyKS5qb2luKCcnKTtcbiAgICAgIHN3aXRjaCAoa2V5KSB7XG4gICAgICAgIC8vIEltcG9zc2libGUgY2FzZS5cbiAgICAgICAgY2FzZSAnMDAwJzpcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgLy8gSWdub3JlIHdvcmtkaXIgZmlsZXMgdGhhdCBhcmUgbm90IHRyYWNrZWQgYW5kIG5vdCBwYXJ0IG9mIHRoZSBuZXcgY29tbWl0LlxuICAgICAgICBjYXNlICcwMDEnOlxuICAgICAgICAgIC8vIE9LLCBtYWtlIGFuIGV4Y2VwdGlvbiBmb3IgZXhwbGljaXRseSBuYW1lZCBmaWxlcy5cbiAgICAgICAgICBpZiAoZm9yY2UgJiYgZmlsZXBhdGhzICYmIGZpbGVwYXRocy5pbmNsdWRlcyhmdWxscGF0aCkpIHtcbiAgICAgICAgICAgIHJldHVybiBbJ2RlbGV0ZScsIGZ1bGxwYXRoXVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgLy8gTmV3IGVudHJpZXNcbiAgICAgICAgY2FzZSAnMDEwJzoge1xuICAgICAgICAgIHN3aXRjaCAoYXdhaXQgY29tbWl0LnR5cGUoKSkge1xuICAgICAgICAgICAgY2FzZSAndHJlZSc6IHtcbiAgICAgICAgICAgICAgcmV0dXJuIFsnbWtkaXInLCBmdWxscGF0aF1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ2Jsb2InOiB7XG4gICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgJ2NyZWF0ZScsXG4gICAgICAgICAgICAgICAgZnVsbHBhdGgsXG4gICAgICAgICAgICAgICAgYXdhaXQgY29tbWl0Lm9pZCgpLFxuICAgICAgICAgICAgICAgIGF3YWl0IGNvbW1pdC5tb2RlKCksXG4gICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ2NvbW1pdCc6IHtcbiAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAnbWtkaXItaW5kZXgnLFxuICAgICAgICAgICAgICAgIGZ1bGxwYXRoLFxuICAgICAgICAgICAgICAgIGF3YWl0IGNvbW1pdC5vaWQoKSxcbiAgICAgICAgICAgICAgICBhd2FpdCBjb21taXQubW9kZSgpLFxuICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgJ2Vycm9yJyxcbiAgICAgICAgICAgICAgICBgbmV3IGVudHJ5IFVuaGFuZGxlZCB0eXBlICR7YXdhaXQgY29tbWl0LnR5cGUoKX1gLFxuICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIE5ldyBlbnRyaWVzIGJ1dCB0aGVyZSBpcyBhbHJlYWR5IHNvbWV0aGluZyBpbiB0aGUgd29ya2RpciB0aGVyZS5cbiAgICAgICAgY2FzZSAnMDExJzoge1xuICAgICAgICAgIHN3aXRjaCAoYCR7YXdhaXQgY29tbWl0LnR5cGUoKX0tJHthd2FpdCB3b3JrZGlyLnR5cGUoKX1gKSB7XG4gICAgICAgICAgICBjYXNlICd0cmVlLXRyZWUnOiB7XG4gICAgICAgICAgICAgIHJldHVybiAvLyBub29wXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICd0cmVlLWJsb2InOlxuICAgICAgICAgICAgY2FzZSAnYmxvYi10cmVlJzoge1xuICAgICAgICAgICAgICByZXR1cm4gWydjb25mbGljdCcsIGZ1bGxwYXRoXVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnYmxvYi1ibG9iJzoge1xuICAgICAgICAgICAgICAvLyBJcyB0aGUgaW5jb21pbmcgZmlsZSBkaWZmZXJlbnQ/XG4gICAgICAgICAgICAgIGlmICgoYXdhaXQgY29tbWl0Lm9pZCgpKSAhPT0gKGF3YWl0IHdvcmtkaXIub2lkKCkpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZvcmNlKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAndXBkYXRlJyxcbiAgICAgICAgICAgICAgICAgICAgZnVsbHBhdGgsXG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IGNvbW1pdC5vaWQoKSxcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgY29tbWl0Lm1vZGUoKSxcbiAgICAgICAgICAgICAgICAgICAgKGF3YWl0IGNvbW1pdC5tb2RlKCkpICE9PSAoYXdhaXQgd29ya2Rpci5tb2RlKCkpLFxuICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gWydjb25mbGljdCcsIGZ1bGxwYXRoXVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBJcyB0aGUgaW5jb21pbmcgZmlsZSBhIGRpZmZlcmVudCBtb2RlP1xuICAgICAgICAgICAgICAgIGlmICgoYXdhaXQgY29tbWl0Lm1vZGUoKSkgIT09IChhd2FpdCB3b3JrZGlyLm1vZGUoKSkpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChmb3JjZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICd1cGRhdGUnLFxuICAgICAgICAgICAgICAgICAgICAgIGZ1bGxwYXRoLFxuICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IGNvbW1pdC5vaWQoKSxcbiAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBjb21taXQubW9kZSgpLFxuICAgICAgICAgICAgICAgICAgICAgIHRydWUsXG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbJ2NvbmZsaWN0JywgZnVsbHBhdGhdXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICdjcmVhdGUtaW5kZXgnLFxuICAgICAgICAgICAgICAgICAgICBmdWxscGF0aCxcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgY29tbWl0Lm9pZCgpLFxuICAgICAgICAgICAgICAgICAgICBhd2FpdCBjb21taXQubW9kZSgpLFxuICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnY29tbWl0LXRyZWUnOiB7XG4gICAgICAgICAgICAgIC8vIFRPRE86IHN1Ym1vZHVsZVxuICAgICAgICAgICAgICAvLyBXZSdsbCBpZ25vcmUgc3VibW9kdWxlIGRpcmVjdG9yaWVzIGZvciBub3cuXG4gICAgICAgICAgICAgIC8vIFVzZXJzIHByZWZlciB3ZSBub3QgdGhyb3cgYW4gZXJyb3IgZm9yIGxhY2sgb2Ygc3VibW9kdWxlIHN1cHBvcnQuXG4gICAgICAgICAgICAgIC8vIGdpdGxpbmtzXG4gICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnY29tbWl0LWJsb2InOiB7XG4gICAgICAgICAgICAgIC8vIFRPRE86IHN1Ym1vZHVsZVxuICAgICAgICAgICAgICAvLyBCdXQuLi4gd2UnbGwgY29tcGxhaW4gaWYgdGhlcmUgaXMgYSAqZmlsZSogd2hlcmUgd2Ugd291bGRcbiAgICAgICAgICAgICAgLy8gcHV0IGEgc3VibW9kdWxlIGlmIHdlIGhhZCBzdWJtb2R1bGUgc3VwcG9ydC5cbiAgICAgICAgICAgICAgcmV0dXJuIFsnY29uZmxpY3QnLCBmdWxscGF0aF1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgcmV0dXJuIFsnZXJyb3InLCBgbmV3IGVudHJ5IFVuaGFuZGxlZCB0eXBlICR7Y29tbWl0LnR5cGV9YF1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gU29tZXRoaW5nIGluIHN0YWdlIGJ1dCBub3QgaW4gdGhlIGNvbW1pdCBPUiB0aGUgd29ya2Rpci5cbiAgICAgICAgLy8gTm90ZTogSSB2ZXJpZmllZCB0aGlzIGJlaGF2aW9yIGFnYWluc3QgY2Fub25pY2FsIGdpdC5cbiAgICAgICAgY2FzZSAnMTAwJzoge1xuICAgICAgICAgIHJldHVybiBbJ2RlbGV0ZS1pbmRleCcsIGZ1bGxwYXRoXVxuICAgICAgICB9XG4gICAgICAgIC8vIERlbGV0ZWQgZW50cmllc1xuICAgICAgICAvLyBUT0RPOiBIb3cgdG8gaGFuZGxlIGlmIHN0YWdlIHR5cGUgYW5kIHdvcmtkaXIgdHlwZSBtaXNtYXRjaD9cbiAgICAgICAgY2FzZSAnMTAxJzoge1xuICAgICAgICAgIHN3aXRjaCAoYXdhaXQgc3RhZ2UudHlwZSgpKSB7XG4gICAgICAgICAgICBjYXNlICd0cmVlJzoge1xuICAgICAgICAgICAgICByZXR1cm4gWydybWRpcicsIGZ1bGxwYXRoXVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnYmxvYic6IHtcbiAgICAgICAgICAgICAgLy8gR2l0IGNoZWNrcyB0aGF0IHRoZSB3b3JrZGlyLm9pZCA9PT0gc3RhZ2Uub2lkIGJlZm9yZSBkZWxldGluZyBmaWxlXG4gICAgICAgICAgICAgIGlmICgoYXdhaXQgc3RhZ2Uub2lkKCkpICE9PSAoYXdhaXQgd29ya2Rpci5vaWQoKSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoZm9yY2UpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBbJ2RlbGV0ZScsIGZ1bGxwYXRoXVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gWydjb25mbGljdCcsIGZ1bGxwYXRoXVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWydkZWxldGUnLCBmdWxscGF0aF1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnY29tbWl0Jzoge1xuICAgICAgICAgICAgICByZXR1cm4gWydybWRpci1pbmRleCcsIGZ1bGxwYXRoXVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICdlcnJvcicsXG4gICAgICAgICAgICAgICAgYGRlbGV0ZSBlbnRyeSBVbmhhbmRsZWQgdHlwZSAke2F3YWl0IHN0YWdlLnR5cGUoKX1gLFxuICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWZhbGx0aHJvdWdoICovXG4gICAgICAgIC8vIEZpbGUgbWlzc2luZyBmcm9tIHdvcmtkaXJcbiAgICAgICAgY2FzZSAnMTEwJzpcbiAgICAgICAgLy8gUG9zc2libHkgbW9kaWZpZWQgZW50cmllc1xuICAgICAgICBjYXNlICcxMTEnOiB7XG4gICAgICAgICAgLyogZXNsaW50LWVuYWJsZSBuby1mYWxsdGhyb3VnaCAqL1xuICAgICAgICAgIHN3aXRjaCAoYCR7YXdhaXQgc3RhZ2UudHlwZSgpfS0ke2F3YWl0IGNvbW1pdC50eXBlKCl9YCkge1xuICAgICAgICAgICAgY2FzZSAndHJlZS10cmVlJzoge1xuICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ2Jsb2ItYmxvYic6IHtcbiAgICAgICAgICAgICAgLy8gSWYgdGhlIGZpbGUgaGFzbid0IGNoYW5nZWQsIHRoZXJlIGlzIG5vIG5lZWQgdG8gZG8gYW55dGhpbmcuXG4gICAgICAgICAgICAgIC8vIEV4aXN0aW5nIGZpbGUgbW9kaWZpY2F0aW9ucyBpbiB0aGUgd29ya2RpciBjYW4gYmUgYmUgbGVmdCBhcyBpcy5cbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIChhd2FpdCBzdGFnZS5vaWQoKSkgPT09IChhd2FpdCBjb21taXQub2lkKCkpICYmXG4gICAgICAgICAgICAgICAgKGF3YWl0IHN0YWdlLm1vZGUoKSkgPT09IChhd2FpdCBjb21taXQubW9kZSgpKSAmJlxuICAgICAgICAgICAgICAgICFmb3JjZVxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vIENoZWNrIGZvciBsb2NhbCBjaGFuZ2VzIHRoYXQgd291bGQgYmUgbG9zdFxuICAgICAgICAgICAgICBpZiAod29ya2Rpcikge1xuICAgICAgICAgICAgICAgIC8vIE5vdGU6IGNhbm9uaWNhbCBnaXQgb25seSBjb21wYXJlcyB3aXRoIHRoZSBzdGFnZS4gQnV0IHdlJ3JlIHNtYXJ0IGVub3VnaFxuICAgICAgICAgICAgICAgIC8vIHRvIGNvbXBhcmUgdG8gdGhlIHN0YWdlIEFORCB0aGUgaW5jb21pbmcgY29tbWl0LlxuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgIChhd2FpdCB3b3JrZGlyLm9pZCgpKSAhPT0gKGF3YWl0IHN0YWdlLm9pZCgpKSAmJlxuICAgICAgICAgICAgICAgICAgKGF3YWl0IHdvcmtkaXIub2lkKCkpICE9PSAoYXdhaXQgY29tbWl0Lm9pZCgpKVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgaWYgKGZvcmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgJ3VwZGF0ZScsXG4gICAgICAgICAgICAgICAgICAgICAgZnVsbHBhdGgsXG4gICAgICAgICAgICAgICAgICAgICAgYXdhaXQgY29tbWl0Lm9pZCgpLFxuICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IGNvbW1pdC5tb2RlKCksXG4gICAgICAgICAgICAgICAgICAgICAgKGF3YWl0IGNvbW1pdC5tb2RlKCkpICE9PSAoYXdhaXQgd29ya2Rpci5tb2RlKCkpLFxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWydjb25mbGljdCcsIGZ1bGxwYXRoXVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChmb3JjZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAndXBkYXRlJyxcbiAgICAgICAgICAgICAgICAgIGZ1bGxwYXRoLFxuICAgICAgICAgICAgICAgICAgYXdhaXQgY29tbWl0Lm9pZCgpLFxuICAgICAgICAgICAgICAgICAgYXdhaXQgY29tbWl0Lm1vZGUoKSxcbiAgICAgICAgICAgICAgICAgIChhd2FpdCBjb21taXQubW9kZSgpKSAhPT0gKGF3YWl0IHN0YWdlLm1vZGUoKSksXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIEhhcyBmaWxlIG1vZGUgY2hhbmdlZD9cbiAgICAgICAgICAgICAgaWYgKChhd2FpdCBjb21taXQubW9kZSgpKSAhPT0gKGF3YWl0IHN0YWdlLm1vZGUoKSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgJ3VwZGF0ZScsXG4gICAgICAgICAgICAgICAgICBmdWxscGF0aCxcbiAgICAgICAgICAgICAgICAgIGF3YWl0IGNvbW1pdC5vaWQoKSxcbiAgICAgICAgICAgICAgICAgIGF3YWl0IGNvbW1pdC5tb2RlKCksXG4gICAgICAgICAgICAgICAgICB0cnVlLFxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyBUT0RPOiBIQU5ETEUgU1lNTElOS1NcbiAgICAgICAgICAgICAgLy8gSGFzIHRoZSBmaWxlIGNvbnRlbnQgY2hhbmdlZD9cbiAgICAgICAgICAgICAgaWYgKChhd2FpdCBjb21taXQub2lkKCkpICE9PSAoYXdhaXQgc3RhZ2Uub2lkKCkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICd1cGRhdGUnLFxuICAgICAgICAgICAgICAgICAgZnVsbHBhdGgsXG4gICAgICAgICAgICAgICAgICBhd2FpdCBjb21taXQub2lkKCksXG4gICAgICAgICAgICAgICAgICBhd2FpdCBjb21taXQubW9kZSgpLFxuICAgICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICd0cmVlLWJsb2InOiB7XG4gICAgICAgICAgICAgIHJldHVybiBbJ3VwZGF0ZS1kaXItdG8tYmxvYicsIGZ1bGxwYXRoLCBhd2FpdCBjb21taXQub2lkKCldXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdibG9iLXRyZWUnOiB7XG4gICAgICAgICAgICAgIHJldHVybiBbJ3VwZGF0ZS1ibG9iLXRvLXRyZWUnLCBmdWxscGF0aF1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ2NvbW1pdC1jb21taXQnOiB7XG4gICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgJ21rZGlyLWluZGV4JyxcbiAgICAgICAgICAgICAgICBmdWxscGF0aCxcbiAgICAgICAgICAgICAgICBhd2FpdCBjb21taXQub2lkKCksXG4gICAgICAgICAgICAgICAgYXdhaXQgY29tbWl0Lm1vZGUoKSxcbiAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICdlcnJvcicsXG4gICAgICAgICAgICAgICAgYHVwZGF0ZSBlbnRyeSBVbmhhbmRsZWQgdHlwZSAke2F3YWl0IHN0YWdlLnR5cGUoKX0tJHthd2FpdCBjb21taXQudHlwZSgpfWAsXG4gICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIC8vIE1vZGlmeSB0aGUgZGVmYXVsdCBmbGF0IG1hcHBpbmdcbiAgICByZWR1Y2U6IGFzeW5jIGZ1bmN0aW9uKHBhcmVudCwgY2hpbGRyZW4pIHtcbiAgICAgIGNoaWxkcmVuID0gZmxhdChjaGlsZHJlbik7XG4gICAgICBpZiAoIXBhcmVudCkge1xuICAgICAgICByZXR1cm4gY2hpbGRyZW5cbiAgICAgIH0gZWxzZSBpZiAocGFyZW50ICYmIHBhcmVudFswXSA9PT0gJ3JtZGlyJykge1xuICAgICAgICBjaGlsZHJlbi5wdXNoKHBhcmVudCk7XG4gICAgICAgIHJldHVybiBjaGlsZHJlblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2hpbGRyZW4udW5zaGlmdChwYXJlbnQpO1xuICAgICAgICByZXR1cm4gY2hpbGRyZW5cbiAgICAgIH1cbiAgICB9LFxuICB9KVxufVxuXG4vLyBAdHMtY2hlY2tcblxuLyoqXG4gKiBDaGVja291dCBhIGJyYW5jaFxuICpcbiAqIElmIHRoZSBicmFuY2ggYWxyZWFkeSBleGlzdHMgaXQgd2lsbCBjaGVjayBvdXQgdGhhdCBicmFuY2guIE90aGVyd2lzZSwgaXQgd2lsbCBjcmVhdGUgYSBuZXcgcmVtb3RlIHRyYWNraW5nIGJyYW5jaCBzZXQgdG8gdHJhY2sgdGhlIHJlbW90ZSBicmFuY2ggb2YgdGhhdCBuYW1lLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBhcmdzXG4gKiBAcGFyYW0ge0ZzQ2xpZW50fSBhcmdzLmZzIC0gYSBmaWxlIHN5c3RlbSBpbXBsZW1lbnRhdGlvblxuICogQHBhcmFtIHtQcm9ncmVzc0NhbGxiYWNrfSBbYXJncy5vblByb2dyZXNzXSAtIG9wdGlvbmFsIHByb2dyZXNzIGV2ZW50IGNhbGxiYWNrXG4gKiBAcGFyYW0ge3N0cmluZ30gYXJncy5kaXIgLSBUaGUgW3dvcmtpbmcgdHJlZV0oZGlyLXZzLWdpdGRpci5tZCkgZGlyZWN0b3J5IHBhdGhcbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5naXRkaXI9am9pbihkaXIsJy5naXQnKV0gLSBbcmVxdWlyZWRdIFRoZSBbZ2l0IGRpcmVjdG9yeV0oZGlyLXZzLWdpdGRpci5tZCkgcGF0aFxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLnJlZiA9ICdIRUFEJ10gLSBTb3VyY2UgdG8gY2hlY2tvdXQgZmlsZXMgZnJvbVxuICogQHBhcmFtIHtzdHJpbmdbXX0gW2FyZ3MuZmlsZXBhdGhzXSAtIExpbWl0IHRoZSBjaGVja291dCB0byB0aGUgZ2l2ZW4gZmlsZXMgYW5kIGRpcmVjdG9yaWVzXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MucmVtb3RlID0gJ29yaWdpbiddIC0gV2hpY2ggcmVtb3RlIHJlcG9zaXRvcnkgdG8gdXNlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFthcmdzLm5vQ2hlY2tvdXQgPSBmYWxzZV0gLSBJZiB0cnVlLCB3aWxsIHVwZGF0ZSBIRUFEIGJ1dCB3b24ndCB1cGRhdGUgdGhlIHdvcmtpbmcgZGlyZWN0b3J5XG4gKiBAcGFyYW0ge2Jvb2xlYW59IFthcmdzLm5vVXBkYXRlSGVhZF0gLSBJZiB0cnVlLCB3aWxsIHVwZGF0ZSB0aGUgd29ya2luZyBkaXJlY3RvcnkgYnV0IHdvbid0IHVwZGF0ZSBIRUFELiBEZWZhdWx0cyB0byBgZmFsc2VgIHdoZW4gYHJlZmAgaXMgcHJvdmlkZWQsIGFuZCBgdHJ1ZWAgaWYgYHJlZmAgaXMgbm90IHByb3ZpZGVkLlxuICogQHBhcmFtIHtib29sZWFufSBbYXJncy5kcnlSdW4gPSBmYWxzZV0gLSBJZiB0cnVlLCBzaW11bGF0ZXMgYSBjaGVja291dCBzbyB5b3UgY2FuIHRlc3Qgd2hldGhlciBpdCB3b3VsZCBzdWNjZWVkLlxuICogQHBhcmFtIHtib29sZWFufSBbYXJncy5mb3JjZSA9IGZhbHNlXSAtIElmIHRydWUsIGNvbmZsaWN0cyB3aWxsIGJlIGlnbm9yZWQgYW5kIGZpbGVzIHdpbGwgYmUgb3ZlcndyaXR0ZW4gcmVnYXJkbGVzcyBvZiBsb2NhbCBjaGFuZ2VzLlxuICogQHBhcmFtIHtvYmplY3R9IFthcmdzLmNhY2hlXSAtIGEgW2NhY2hlXShjYWNoZS5tZCkgb2JqZWN0XG4gKlxuICogQHJldHVybnMge1Byb21pc2U8dm9pZD59IFJlc29sdmVzIHN1Y2Nlc3NmdWxseSB3aGVuIGZpbGVzeXN0ZW0gb3BlcmF0aW9ucyBhcmUgY29tcGxldGVcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gc3dpdGNoIHRvIHRoZSBtYWluIGJyYW5jaFxuICogYXdhaXQgZ2l0LmNoZWNrb3V0KHtcbiAqICAgZnMsXG4gKiAgIGRpcjogJy90dXRvcmlhbCcsXG4gKiAgIHJlZjogJ21haW4nXG4gKiB9KVxuICogY29uc29sZS5sb2coJ2RvbmUnKVxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyByZXN0b3JlIHRoZSAnZG9jcycgYW5kICdzcmMvZG9jcycgZm9sZGVycyB0byB0aGUgd2F5IHRoZXkgd2VyZSwgb3ZlcndyaXRpbmcgYW55IGNoYW5nZXNcbiAqIGF3YWl0IGdpdC5jaGVja291dCh7XG4gKiAgIGZzLFxuICogICBkaXI6ICcvdHV0b3JpYWwnLFxuICogICBmb3JjZTogdHJ1ZSxcbiAqICAgZmlsZXBhdGhzOiBbJ2RvY3MnLCAnc3JjL2RvY3MnXVxuICogfSlcbiAqIGNvbnNvbGUubG9nKCdkb25lJylcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gcmVzdG9yZSB0aGUgJ2RvY3MnIGFuZCAnc3JjL2RvY3MnIGZvbGRlcnMgdG8gdGhlIHdheSB0aGV5IGFyZSBpbiB0aGUgJ2RldmVsb3AnIGJyYW5jaCwgb3ZlcndyaXRpbmcgYW55IGNoYW5nZXNcbiAqIGF3YWl0IGdpdC5jaGVja291dCh7XG4gKiAgIGZzLFxuICogICBkaXI6ICcvdHV0b3JpYWwnLFxuICogICByZWY6ICdkZXZlbG9wJyxcbiAqICAgbm9VcGRhdGVIZWFkOiB0cnVlLFxuICogICBmb3JjZTogdHJ1ZSxcbiAqICAgZmlsZXBhdGhzOiBbJ2RvY3MnLCAnc3JjL2RvY3MnXVxuICogfSlcbiAqIGNvbnNvbGUubG9nKCdkb25lJylcbiAqL1xuYXN5bmMgZnVuY3Rpb24gY2hlY2tvdXQoe1xuICBmcyxcbiAgb25Qcm9ncmVzcyxcbiAgZGlyLFxuICBnaXRkaXIgPSBqb2luKGRpciwgJy5naXQnKSxcbiAgcmVtb3RlID0gJ29yaWdpbicsXG4gIHJlZjogX3JlZixcbiAgZmlsZXBhdGhzLFxuICBub0NoZWNrb3V0ID0gZmFsc2UsXG4gIG5vVXBkYXRlSGVhZCA9IF9yZWYgPT09IHVuZGVmaW5lZCxcbiAgZHJ5UnVuID0gZmFsc2UsXG4gIGZvcmNlID0gZmFsc2UsXG4gIGNhY2hlID0ge30sXG59KSB7XG4gIHRyeSB7XG4gICAgYXNzZXJ0UGFyYW1ldGVyKCdmcycsIGZzKTtcbiAgICBhc3NlcnRQYXJhbWV0ZXIoJ2RpcicsIGRpcik7XG4gICAgYXNzZXJ0UGFyYW1ldGVyKCdnaXRkaXInLCBnaXRkaXIpO1xuXG4gICAgY29uc3QgcmVmID0gX3JlZiB8fCAnSEVBRCc7XG4gICAgcmV0dXJuIGF3YWl0IF9jaGVja291dCh7XG4gICAgICBmczogbmV3IEZpbGVTeXN0ZW0oZnMpLFxuICAgICAgY2FjaGUsXG4gICAgICBvblByb2dyZXNzLFxuICAgICAgZGlyLFxuICAgICAgZ2l0ZGlyLFxuICAgICAgcmVtb3RlLFxuICAgICAgcmVmLFxuICAgICAgZmlsZXBhdGhzLFxuICAgICAgbm9DaGVja291dCxcbiAgICAgIG5vVXBkYXRlSGVhZCxcbiAgICAgIGRyeVJ1bixcbiAgICAgIGZvcmNlLFxuICAgIH0pXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGVyci5jYWxsZXIgPSAnZ2l0LmNoZWNrb3V0JztcbiAgICB0aHJvdyBlcnJcbiAgfVxufVxuXG4vLyBAc2VlIGh0dHBzOi8vZ2l0LXNjbS5jb20vZG9jcy9naXQtcmV2LXBhcnNlLmh0bWwjX3NwZWNpZnlpbmdfcmV2aXNpb25zXG5jb25zdCBhYmJyZXZpYXRlUnggPSBuZXcgUmVnRXhwKCdecmVmcy8oaGVhZHMvfHRhZ3MvfHJlbW90ZXMvKT8oLiopJyk7XG5cbmZ1bmN0aW9uIGFiYnJldmlhdGVSZWYocmVmKSB7XG4gIGNvbnN0IG1hdGNoID0gYWJicmV2aWF0ZVJ4LmV4ZWMocmVmKTtcbiAgaWYgKG1hdGNoKSB7XG4gICAgaWYgKG1hdGNoWzFdID09PSAncmVtb3Rlcy8nICYmIHJlZi5lbmRzV2l0aCgnL0hFQUQnKSkge1xuICAgICAgcmV0dXJuIG1hdGNoWzJdLnNsaWNlKDAsIC01KVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbWF0Y2hbMl1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlZlxufVxuXG4vLyBAdHMtY2hlY2tcblxuLyoqXG4gKiBAcGFyYW0ge09iamVjdH0gYXJnc1xuICogQHBhcmFtIHtpbXBvcnQoJy4uL21vZGVscy9GaWxlU3lzdGVtLmpzJykuRmlsZVN5c3RlbX0gYXJncy5mc1xuICogQHBhcmFtIHtzdHJpbmd9IGFyZ3MuZ2l0ZGlyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFthcmdzLmZ1bGxuYW1lID0gZmFsc2VdIC0gUmV0dXJuIHRoZSBmdWxsIHBhdGggKGUuZy4gXCJyZWZzL2hlYWRzL21haW5cIikgaW5zdGVhZCBvZiB0aGUgYWJicmV2aWF0ZWQgZm9ybS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2FyZ3MudGVzdCA9IGZhbHNlXSAtIElmIHRoZSBjdXJyZW50IGJyYW5jaCBkb2Vzbid0IGFjdHVhbGx5IGV4aXN0IChzdWNoIGFzIHJpZ2h0IGFmdGVyIGdpdCBpbml0KSB0aGVuIHJldHVybiBgdW5kZWZpbmVkYC5cbiAqXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxzdHJpbmd8dm9pZD59IFRoZSBuYW1lIG9mIHRoZSBjdXJyZW50IGJyYW5jaCBvciB1bmRlZmluZWQgaWYgdGhlIEhFQUQgaXMgZGV0YWNoZWQuXG4gKlxuICovXG5hc3luYyBmdW5jdGlvbiBfY3VycmVudEJyYW5jaCh7XG4gIGZzLFxuICBnaXRkaXIsXG4gIGZ1bGxuYW1lID0gZmFsc2UsXG4gIHRlc3QgPSBmYWxzZSxcbn0pIHtcbiAgY29uc3QgcmVmID0gYXdhaXQgR2l0UmVmTWFuYWdlci5yZXNvbHZlKHtcbiAgICBmcyxcbiAgICBnaXRkaXIsXG4gICAgcmVmOiAnSEVBRCcsXG4gICAgZGVwdGg6IDIsXG4gIH0pO1xuICBpZiAodGVzdCkge1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCBHaXRSZWZNYW5hZ2VyLnJlc29sdmUoeyBmcywgZ2l0ZGlyLCByZWYgfSk7XG4gICAgfSBjYXRjaCAoXykge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICB9XG4gIC8vIFJldHVybiBgdW5kZWZpbmVkYCBmb3IgZGV0YWNoZWQgSEVBRFxuICBpZiAoIXJlZi5zdGFydHNXaXRoKCdyZWZzLycpKSByZXR1cm5cbiAgcmV0dXJuIGZ1bGxuYW1lID8gcmVmIDogYWJicmV2aWF0ZVJlZihyZWYpXG59XG5cbmZ1bmN0aW9uIHRyYW5zbGF0ZVNTSHRvSFRUUCh1cmwpIHtcbiAgLy8gaGFuZGxlIFwic2hvcnRlciBzY3AtbGlrZSBzeW50YXhcIlxuICB1cmwgPSB1cmwucmVwbGFjZSgvXmdpdEAoW146XSspOi8sICdodHRwczovLyQxLycpO1xuICAvLyBoYW5kbGUgcHJvcGVyIFNTSCBVUkxzXG4gIHVybCA9IHVybC5yZXBsYWNlKC9ec3NoOlxcL1xcLy8sICdodHRwczovLycpO1xuICByZXR1cm4gdXJsXG59XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZUJhc2ljQXV0aEhlYWRlcih7IHVzZXJuYW1lID0gJycsIHBhc3N3b3JkID0gJycgfSkge1xuICByZXR1cm4gYEJhc2ljICR7QnVmZmVyLmZyb20oYCR7dXNlcm5hbWV9OiR7cGFzc3dvcmR9YCkudG9TdHJpbmcoJ2Jhc2U2NCcpfWBcbn1cblxuLy8gQ3VycmVudGx5ICdmb3IgYXdhaXQnIHVwc2V0cyBteSBsaW50ZXJzLlxuYXN5bmMgZnVuY3Rpb24gZm9yQXdhaXQoaXRlcmFibGUsIGNiKSB7XG4gIGNvbnN0IGl0ZXIgPSBnZXRJdGVyYXRvcihpdGVyYWJsZSk7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgY29uc3QgeyB2YWx1ZSwgZG9uZSB9ID0gYXdhaXQgaXRlci5uZXh0KCk7XG4gICAgaWYgKHZhbHVlKSBhd2FpdCBjYih2YWx1ZSk7XG4gICAgaWYgKGRvbmUpIGJyZWFrXG4gIH1cbiAgaWYgKGl0ZXIucmV0dXJuKSBpdGVyLnJldHVybigpO1xufVxuXG5hc3luYyBmdW5jdGlvbiBjb2xsZWN0KGl0ZXJhYmxlKSB7XG4gIGxldCBzaXplID0gMDtcbiAgY29uc3QgYnVmZmVycyA9IFtdO1xuICAvLyBUaGlzIHdpbGwgYmUgZWFzaWVyIG9uY2UgYGZvciBhd2FpdCAuLi4gb2ZgIGxvb3BzIGFyZSBhdmFpbGFibGUuXG4gIGF3YWl0IGZvckF3YWl0KGl0ZXJhYmxlLCB2YWx1ZSA9PiB7XG4gICAgYnVmZmVycy5wdXNoKHZhbHVlKTtcbiAgICBzaXplICs9IHZhbHVlLmJ5dGVMZW5ndGg7XG4gIH0pO1xuICBjb25zdCByZXN1bHQgPSBuZXcgVWludDhBcnJheShzaXplKTtcbiAgbGV0IG5leHRJbmRleCA9IDA7XG4gIGZvciAoY29uc3QgYnVmZmVyIG9mIGJ1ZmZlcnMpIHtcbiAgICByZXN1bHQuc2V0KGJ1ZmZlciwgbmV4dEluZGV4KTtcbiAgICBuZXh0SW5kZXggKz0gYnVmZmVyLmJ5dGVMZW5ndGg7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5mdW5jdGlvbiBleHRyYWN0QXV0aEZyb21VcmwodXJsKSB7XG4gIC8vIEZvciB3aGF0ZXZlciByZWFzb24sIHRoZSBgZmV0Y2hgIEFQSSBkb2VzIG5vdCBjb252ZXJ0IGNyZWRlbnRpYWxzIGVtYmVkZGVkIGluIHRoZSBVUkxcbiAgLy8gaW50byBCYXNpYyBBdXRoZW50aWNhdGlvbiBoZWFkZXJzIGF1dG9tYXRpY2FsbHkuIEluc3RlYWQgaXQgdGhyb3dzIGFuIGVycm9yIVxuICAvLyBTbyB3ZSBtdXN0IG1hbnVhbGx5IHBhcnNlIHRoZSBVUkwsIHJpcCBvdXQgdGhlIHVzZXI6cGFzc3dvcmQgcG9ydGlvbiBpZiBpdCBpcyBwcmVzZW50XG4gIC8vIGFuZCBjb21wdXRlIHRoZSBBdXRob3JpemF0aW9uIGhlYWRlci5cbiAgLy8gTm90ZTogSSB0cmllZCB1c2luZyBuZXcgVVJMKHVybCkgYnV0IHRoYXQgdGhyb3dzIGEgc2VjdXJpdHkgZXhjZXB0aW9uIGluIEVkZ2UuIDpyb2xsZXllczpcbiAgbGV0IHVzZXJwYXNzID0gdXJsLm1hdGNoKC9eaHR0cHM/OlxcL1xcLyhbXi9dKylALyk7XG4gIC8vIE5vIGNyZWRlbnRpYWxzLCByZXR1cm4gdGhlIHVybCB1bm1vZGlmaWVkIGFuZCBhbiBlbXB0eSBhdXRoIG9iamVjdFxuICBpZiAodXNlcnBhc3MgPT0gbnVsbCkgcmV0dXJuIHsgdXJsLCBhdXRoOiB7fSB9XG4gIHVzZXJwYXNzID0gdXNlcnBhc3NbMV07XG4gIGNvbnN0IFt1c2VybmFtZSwgcGFzc3dvcmRdID0gdXNlcnBhc3Muc3BsaXQoJzonKTtcbiAgLy8gUmVtb3ZlIGNyZWRlbnRpYWxzIGZyb20gVVJMXG4gIHVybCA9IHVybC5yZXBsYWNlKGAke3VzZXJwYXNzfUBgLCAnJyk7XG4gIC8vIEhhcyBjcmVkZW50aWFscywgcmV0dXJuIHRoZSBmZXRjaC1zYWZlIFVSTCBhbmQgdGhlIHBhcnNlZCBjcmVkZW50aWFsc1xuICByZXR1cm4geyB1cmwsIGF1dGg6IHsgdXNlcm5hbWUsIHBhc3N3b3JkIH0gfVxufVxuXG5mdW5jdGlvbiBwYWRIZXgoYiwgbikge1xuICBjb25zdCBzID0gbi50b1N0cmluZygxNik7XG4gIHJldHVybiAnMCcucmVwZWF0KGIgLSBzLmxlbmd0aCkgKyBzXG59XG5cbi8qKlxucGt0LWxpbmUgRm9ybWF0XG4tLS0tLS0tLS0tLS0tLS1cblxuTXVjaCAoYnV0IG5vdCBhbGwpIG9mIHRoZSBwYXlsb2FkIGlzIGRlc2NyaWJlZCBhcm91bmQgcGt0LWxpbmVzLlxuXG5BIHBrdC1saW5lIGlzIGEgdmFyaWFibGUgbGVuZ3RoIGJpbmFyeSBzdHJpbmcuICBUaGUgZmlyc3QgZm91ciBieXRlc1xub2YgdGhlIGxpbmUsIHRoZSBwa3QtbGVuLCBpbmRpY2F0ZXMgdGhlIHRvdGFsIGxlbmd0aCBvZiB0aGUgbGluZSxcbmluIGhleGFkZWNpbWFsLiAgVGhlIHBrdC1sZW4gaW5jbHVkZXMgdGhlIDQgYnl0ZXMgdXNlZCB0byBjb250YWluXG50aGUgbGVuZ3RoJ3MgaGV4YWRlY2ltYWwgcmVwcmVzZW50YXRpb24uXG5cbkEgcGt0LWxpbmUgTUFZIGNvbnRhaW4gYmluYXJ5IGRhdGEsIHNvIGltcGxlbWVudG9ycyBNVVNUIGVuc3VyZVxucGt0LWxpbmUgcGFyc2luZy9mb3JtYXR0aW5nIHJvdXRpbmVzIGFyZSA4LWJpdCBjbGVhbi5cblxuQSBub24tYmluYXJ5IGxpbmUgU0hPVUxEIEJFIHRlcm1pbmF0ZWQgYnkgYW4gTEYsIHdoaWNoIGlmIHByZXNlbnRcbk1VU1QgYmUgaW5jbHVkZWQgaW4gdGhlIHRvdGFsIGxlbmd0aC4gUmVjZWl2ZXJzIE1VU1QgdHJlYXQgcGt0LWxpbmVzXG53aXRoIG5vbi1iaW5hcnkgZGF0YSB0aGUgc2FtZSB3aGV0aGVyIG9yIG5vdCB0aGV5IGNvbnRhaW4gdGhlIHRyYWlsaW5nXG5MRiAoc3RyaXBwaW5nIHRoZSBMRiBpZiBwcmVzZW50LCBhbmQgbm90IGNvbXBsYWluaW5nIHdoZW4gaXQgaXNcbm1pc3NpbmcpLlxuXG5UaGUgbWF4aW11bSBsZW5ndGggb2YgYSBwa3QtbGluZSdzIGRhdGEgY29tcG9uZW50IGlzIDY1NTE2IGJ5dGVzLlxuSW1wbGVtZW50YXRpb25zIE1VU1QgTk9UIHNlbmQgcGt0LWxpbmUgd2hvc2UgbGVuZ3RoIGV4Y2VlZHMgNjU1MjBcbig2NTUxNiBieXRlcyBvZiBwYXlsb2FkICsgNCBieXRlcyBvZiBsZW5ndGggZGF0YSkuXG5cbkltcGxlbWVudGF0aW9ucyBTSE9VTEQgTk9UIHNlbmQgYW4gZW1wdHkgcGt0LWxpbmUgKFwiMDAwNFwiKS5cblxuQSBwa3QtbGluZSB3aXRoIGEgbGVuZ3RoIGZpZWxkIG9mIDAgKFwiMDAwMFwiKSwgY2FsbGVkIGEgZmx1c2gtcGt0LFxuaXMgYSBzcGVjaWFsIGNhc2UgYW5kIE1VU1QgYmUgaGFuZGxlZCBkaWZmZXJlbnRseSB0aGFuIGFuIGVtcHR5XG5wa3QtbGluZSAoXCIwMDA0XCIpLlxuXG4tLS0tXG4gIHBrdC1saW5lICAgICA9ICBkYXRhLXBrdCAvIGZsdXNoLXBrdFxuXG4gIGRhdGEtcGt0ICAgICA9ICBwa3QtbGVuIHBrdC1wYXlsb2FkXG4gIHBrdC1sZW4gICAgICA9ICA0KihIRVhESUcpXG4gIHBrdC1wYXlsb2FkICA9ICAocGt0LWxlbiAtIDQpKihPQ1RFVClcblxuICBmbHVzaC1wa3QgICAgPSBcIjAwMDBcIlxuLS0tLVxuXG5FeGFtcGxlcyAoYXMgQy1zdHlsZSBzdHJpbmdzKTpcblxuLS0tLVxuICBwa3QtbGluZSAgICAgICAgICBhY3R1YWwgdmFsdWVcbiAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIFwiMDAwNmFcXG5cIiAgICAgICAgIFwiYVxcblwiXG4gIFwiMDAwNWFcIiAgICAgICAgICAgXCJhXCJcbiAgXCIwMDBiZm9vYmFyXFxuXCIgICAgXCJmb29iYXJcXG5cIlxuICBcIjAwMDRcIiAgICAgICAgICAgIFwiXCJcbi0tLS1cbiovXG5cbi8vIEknbSByZWFsbHkgdXNpbmcgdGhpcyBtb3JlIGFzIGEgbmFtZXNwYWNlLlxuLy8gVGhlcmUncyBub3QgYSBsb3Qgb2YgXCJzdGF0ZVwiIGluIGEgcGt0LWxpbmVcblxuY2xhc3MgR2l0UGt0TGluZSB7XG4gIHN0YXRpYyBmbHVzaCgpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oJzAwMDAnLCAndXRmOCcpXG4gIH1cblxuICBzdGF0aWMgZGVsaW0oKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKCcwMDAxJywgJ3V0ZjgnKVxuICB9XG5cbiAgc3RhdGljIGVuY29kZShsaW5lKSB7XG4gICAgaWYgKHR5cGVvZiBsaW5lID09PSAnc3RyaW5nJykge1xuICAgICAgbGluZSA9IEJ1ZmZlci5mcm9tKGxpbmUpO1xuICAgIH1cbiAgICBjb25zdCBsZW5ndGggPSBsaW5lLmxlbmd0aCArIDQ7XG4gICAgY29uc3QgaGV4bGVuZ3RoID0gcGFkSGV4KDQsIGxlbmd0aCk7XG4gICAgcmV0dXJuIEJ1ZmZlci5jb25jYXQoW0J1ZmZlci5mcm9tKGhleGxlbmd0aCwgJ3V0ZjgnKSwgbGluZV0pXG4gIH1cblxuICBzdGF0aWMgc3RyZWFtUmVhZGVyKHN0cmVhbSkge1xuICAgIGNvbnN0IHJlYWRlciA9IG5ldyBTdHJlYW1SZWFkZXIoc3RyZWFtKTtcbiAgICByZXR1cm4gYXN5bmMgZnVuY3Rpb24gcmVhZCgpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGxldCBsZW5ndGggPSBhd2FpdCByZWFkZXIucmVhZCg0KTtcbiAgICAgICAgaWYgKGxlbmd0aCA9PSBudWxsKSByZXR1cm4gdHJ1ZVxuICAgICAgICBsZW5ndGggPSBwYXJzZUludChsZW5ndGgudG9TdHJpbmcoJ3V0ZjgnKSwgMTYpO1xuICAgICAgICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm4gbnVsbFxuICAgICAgICBpZiAobGVuZ3RoID09PSAxKSByZXR1cm4gbnVsbCAvLyBkZWxpbSBwYWNrZXRzXG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IGF3YWl0IHJlYWRlci5yZWFkKGxlbmd0aCAtIDQpO1xuICAgICAgICBpZiAoYnVmZmVyID09IG51bGwpIHJldHVybiB0cnVlXG4gICAgICAgIHJldHVybiBidWZmZXJcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zb2xlLmxvZygnZXJyb3InLCBlcnIpO1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vLyBAdHMtY2hlY2tcblxuLyoqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSByZWFkXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHBhcnNlQ2FwYWJpbGl0aWVzVjIocmVhZCkge1xuICAvKiogQHR5cGUge09iamVjdDxzdHJpbmcsIHN0cmluZyB8IHRydWU+fSAqL1xuICBjb25zdCBjYXBhYmlsaXRpZXMyID0ge307XG5cbiAgbGV0IGxpbmU7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgbGluZSA9IGF3YWl0IHJlYWQoKTtcbiAgICBpZiAobGluZSA9PT0gdHJ1ZSkgYnJlYWtcbiAgICBpZiAobGluZSA9PT0gbnVsbCkgY29udGludWVcbiAgICBsaW5lID0gbGluZS50b1N0cmluZygndXRmOCcpLnJlcGxhY2UoL1xcbiQvLCAnJyk7XG4gICAgY29uc3QgaSA9IGxpbmUuaW5kZXhPZignPScpO1xuICAgIGlmIChpID4gLTEpIHtcbiAgICAgIGNvbnN0IGtleSA9IGxpbmUuc2xpY2UoMCwgaSk7XG4gICAgICBjb25zdCB2YWx1ZSA9IGxpbmUuc2xpY2UoaSArIDEpO1xuICAgICAgY2FwYWJpbGl0aWVzMltrZXldID0gdmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhcGFiaWxpdGllczJbbGluZV0gPSB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4geyBwcm90b2NvbFZlcnNpb246IDIsIGNhcGFiaWxpdGllczIgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBwYXJzZVJlZnNBZFJlc3BvbnNlKHN0cmVhbSwgeyBzZXJ2aWNlIH0pIHtcbiAgY29uc3QgY2FwYWJpbGl0aWVzID0gbmV3IFNldCgpO1xuICBjb25zdCByZWZzID0gbmV3IE1hcCgpO1xuICBjb25zdCBzeW1yZWZzID0gbmV3IE1hcCgpO1xuXG4gIC8vIFRoZXJlIGlzIHByb2JhYmx5IGEgYmV0dGVyIHdheSB0byBkbyB0aGlzLCBidXQgZm9yIG5vd1xuICAvLyBsZXQncyBqdXN0IHRocm93IHRoZSByZXN1bHQgcGFyc2VyIGlubGluZSBoZXJlLlxuICBjb25zdCByZWFkID0gR2l0UGt0TGluZS5zdHJlYW1SZWFkZXIoc3RyZWFtKTtcbiAgbGV0IGxpbmVPbmUgPSBhd2FpdCByZWFkKCk7XG4gIC8vIHNraXAgcGFzdCBhbnkgZmx1c2hlc1xuICB3aGlsZSAobGluZU9uZSA9PT0gbnVsbCkgbGluZU9uZSA9IGF3YWl0IHJlYWQoKTtcbiAgaWYgKGxpbmVPbmUgPT09IHRydWUpIHRocm93IG5ldyBFbXB0eVNlcnZlclJlc3BvbnNlRXJyb3IoKVxuICAvLyBDbGllbnRzIE1VU1QgaWdub3JlIGFuIExGIGF0IHRoZSBlbmQgb2YgdGhlIGxpbmUuXG4gIGlmIChsaW5lT25lLnRvU3RyaW5nKCd1dGY4JykucmVwbGFjZSgvXFxuJC8sICcnKSAhPT0gYCMgc2VydmljZT0ke3NlcnZpY2V9YCkge1xuICAgIHRocm93IG5ldyBQYXJzZUVycm9yKGAjIHNlcnZpY2U9JHtzZXJ2aWNlfVxcXFxuYCwgbGluZU9uZS50b1N0cmluZygndXRmOCcpKVxuICB9XG4gIGxldCBsaW5lVHdvID0gYXdhaXQgcmVhZCgpO1xuICAvLyBza2lwIHBhc3QgYW55IGZsdXNoZXNcbiAgd2hpbGUgKGxpbmVUd28gPT09IG51bGwpIGxpbmVUd28gPSBhd2FpdCByZWFkKCk7XG4gIC8vIEluIHRoZSBlZGdlIGNhc2Ugb2YgYSBicmFuZCBuZXcgcmVwbywgemVybyByZWZzIChhbmQgemVybyBjYXBhYmlsaXRpZXMpXG4gIC8vIGFyZSByZXR1cm5lZC5cbiAgaWYgKGxpbmVUd28gPT09IHRydWUpIHJldHVybiB7IGNhcGFiaWxpdGllcywgcmVmcywgc3ltcmVmcyB9XG4gIGxpbmVUd28gPSBsaW5lVHdvLnRvU3RyaW5nKCd1dGY4Jyk7XG4gIC8vIEhhbmRsZSBwcm90b2NvbCB2MiByZXNwb25zZXNcbiAgaWYgKGxpbmVUd28uaW5jbHVkZXMoJ3ZlcnNpb24gMicpKSB7XG4gICAgcmV0dXJuIHBhcnNlQ2FwYWJpbGl0aWVzVjIocmVhZClcbiAgfVxuICBjb25zdCBbZmlyc3RSZWYsIGNhcGFiaWxpdGllc0xpbmVdID0gc3BsaXRBbmRBc3NlcnQobGluZVR3bywgJ1xceDAwJywgJ1xcXFx4MDAnKTtcbiAgY2FwYWJpbGl0aWVzTGluZS5zcGxpdCgnICcpLm1hcCh4ID0+IGNhcGFiaWxpdGllcy5hZGQoeCkpO1xuICBjb25zdCBbcmVmLCBuYW1lXSA9IHNwbGl0QW5kQXNzZXJ0KGZpcnN0UmVmLCAnICcsICcgJyk7XG4gIHJlZnMuc2V0KG5hbWUsIHJlZik7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgY29uc3QgbGluZSA9IGF3YWl0IHJlYWQoKTtcbiAgICBpZiAobGluZSA9PT0gdHJ1ZSkgYnJlYWtcbiAgICBpZiAobGluZSAhPT0gbnVsbCkge1xuICAgICAgY29uc3QgW3JlZiwgbmFtZV0gPSBzcGxpdEFuZEFzc2VydChsaW5lLnRvU3RyaW5nKCd1dGY4JyksICcgJywgJyAnKTtcbiAgICAgIHJlZnMuc2V0KG5hbWUsIHJlZik7XG4gICAgfVxuICB9XG4gIC8vIFN5bXJlZnMgYXJlIHRocm93biBpbnRvIHRoZSBcImNhcGFiaWxpdGllc1wiIHVuZm9ydHVuYXRlbHkuXG4gIGZvciAoY29uc3QgY2FwIG9mIGNhcGFiaWxpdGllcykge1xuICAgIGlmIChjYXAuc3RhcnRzV2l0aCgnc3ltcmVmPScpKSB7XG4gICAgICBjb25zdCBtID0gY2FwLm1hdGNoKC9zeW1yZWY9KFteOl0rKTooLiopLyk7XG4gICAgICBpZiAobS5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgc3ltcmVmcy5zZXQobVsxXSwgbVsyXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB7IHByb3RvY29sVmVyc2lvbjogMSwgY2FwYWJpbGl0aWVzLCByZWZzLCBzeW1yZWZzIH1cbn1cblxuZnVuY3Rpb24gc3BsaXRBbmRBc3NlcnQobGluZSwgc2VwLCBleHBlY3RlZCkge1xuICBjb25zdCBzcGxpdCA9IGxpbmUudHJpbSgpLnNwbGl0KHNlcCk7XG4gIGlmIChzcGxpdC5sZW5ndGggIT09IDIpIHtcbiAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcbiAgICAgIGBUd28gc3RyaW5ncyBzZXBhcmF0ZWQgYnkgJyR7ZXhwZWN0ZWR9J2AsXG4gICAgICBsaW5lLnRvU3RyaW5nKCd1dGY4JylcbiAgICApXG4gIH1cbiAgcmV0dXJuIHNwbGl0XG59XG5cbi8vIFRyeSB0byBhY2NvbW9kYXRlIGtub3duIENPUlMgcHJveHkgaW1wbGVtZW50YXRpb25zOlxuLy8gLSBodHRwczovL2pjdWJpYy5wbC9wcm94eS5waHA/ICA8LS0gdXNlcyBxdWVyeSBzdHJpbmdcbi8vIC0gaHR0cHM6Ly9jb3JzLmlzb21vcnBoaWMtZ2l0Lm9yZyAgPC0tIHVzZXMgcGF0aFxuY29uc3QgY29yc1Byb3hpZnkgPSAoY29yc1Byb3h5LCB1cmwpID0+XG4gIGNvcnNQcm94eS5lbmRzV2l0aCgnPycpXG4gICAgPyBgJHtjb3JzUHJveHl9JHt1cmx9YFxuICAgIDogYCR7Y29yc1Byb3h5fS8ke3VybC5yZXBsYWNlKC9eaHR0cHM/OlxcL1xcLy8sICcnKX1gO1xuXG5jb25zdCB1cGRhdGVIZWFkZXJzID0gKGhlYWRlcnMsIGF1dGgpID0+IHtcbiAgLy8gVXBkYXRlIHRoZSBiYXNpYyBhdXRoIGhlYWRlclxuICBpZiAoYXV0aC51c2VybmFtZSB8fCBhdXRoLnBhc3N3b3JkKSB7XG4gICAgaGVhZGVycy5BdXRob3JpemF0aW9uID0gY2FsY3VsYXRlQmFzaWNBdXRoSGVhZGVyKGF1dGgpO1xuICB9XG4gIC8vIGJ1dCBhbnkgbWFudWFsbHkgcHJvdmlkZWQgaGVhZGVycyB0YWtlIHByZWNlZGVuY2VcbiAgaWYgKGF1dGguaGVhZGVycykge1xuICAgIE9iamVjdC5hc3NpZ24oaGVhZGVycywgYXV0aC5oZWFkZXJzKTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge0dpdEh0dHBSZXNwb25zZX0gcmVzXG4gKlxuICogQHJldHVybnMge3sgcHJldmlldzogc3RyaW5nLCByZXNwb25zZTogc3RyaW5nLCBkYXRhOiBCdWZmZXIgfX1cbiAqL1xuY29uc3Qgc3RyaW5naWZ5Qm9keSA9IGFzeW5jIHJlcyA9PiB7XG4gIHRyeSB7XG4gICAgLy8gU29tZSBzZXJ2aWNlcyBwcm92aWRlIGEgbWVhbmluZ2Z1bCBlcnJvciBtZXNzYWdlIGluIHRoZSBib2R5IG9mIDQwM3MgbGlrZSBcInRva2VuIGxhY2tzIHRoZSBzY29wZXMgbmVjZXNzYXJ5IHRvIHBlcmZvcm0gdGhpcyBhY3Rpb25cIlxuICAgIGNvbnN0IGRhdGEgPSBCdWZmZXIuZnJvbShhd2FpdCBjb2xsZWN0KHJlcy5ib2R5KSk7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBkYXRhLnRvU3RyaW5nKCd1dGY4Jyk7XG4gICAgY29uc3QgcHJldmlldyA9XG4gICAgICByZXNwb25zZS5sZW5ndGggPCAyNTYgPyByZXNwb25zZSA6IHJlc3BvbnNlLnNsaWNlKDAsIDI1NikgKyAnLi4uJztcbiAgICByZXR1cm4geyBwcmV2aWV3LCByZXNwb25zZSwgZGF0YSB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4ge31cbiAgfVxufTtcblxuY2xhc3MgR2l0UmVtb3RlSFRUUCB7XG4gIHN0YXRpYyBhc3luYyBjYXBhYmlsaXRpZXMoKSB7XG4gICAgcmV0dXJuIFsnZGlzY292ZXInLCAnY29ubmVjdCddXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGFyZ3NcbiAgICogQHBhcmFtIHtIdHRwQ2xpZW50fSBhcmdzLmh0dHBcbiAgICogQHBhcmFtIHtQcm9ncmVzc0NhbGxiYWNrfSBbYXJncy5vblByb2dyZXNzXVxuICAgKiBAcGFyYW0ge0F1dGhDYWxsYmFja30gW2FyZ3Mub25BdXRoXVxuICAgKiBAcGFyYW0ge0F1dGhGYWlsdXJlQ2FsbGJhY2t9IFthcmdzLm9uQXV0aEZhaWx1cmVdXG4gICAqIEBwYXJhbSB7QXV0aFN1Y2Nlc3NDYWxsYmFja30gW2FyZ3Mub25BdXRoU3VjY2Vzc11cbiAgICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLmNvcnNQcm94eV1cbiAgICogQHBhcmFtIHtzdHJpbmd9IGFyZ3Muc2VydmljZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gYXJncy51cmxcbiAgICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLCBzdHJpbmc+fSBhcmdzLmhlYWRlcnNcbiAgICogQHBhcmFtIHsxIHwgMn0gYXJncy5wcm90b2NvbFZlcnNpb24gLSBHaXQgUHJvdG9jb2wgVmVyc2lvblxuICAgKi9cbiAgc3RhdGljIGFzeW5jIGRpc2NvdmVyKHtcbiAgICBodHRwLFxuICAgIG9uUHJvZ3Jlc3MsXG4gICAgb25BdXRoLFxuICAgIG9uQXV0aFN1Y2Nlc3MsXG4gICAgb25BdXRoRmFpbHVyZSxcbiAgICBjb3JzUHJveHksXG4gICAgc2VydmljZSxcbiAgICB1cmw6IF9vcmlnVXJsLFxuICAgIGhlYWRlcnMsXG4gICAgcHJvdG9jb2xWZXJzaW9uLFxuICB9KSB7XG4gICAgbGV0IHsgdXJsLCBhdXRoIH0gPSBleHRyYWN0QXV0aEZyb21VcmwoX29yaWdVcmwpO1xuICAgIGNvbnN0IHByb3hpZmllZFVSTCA9IGNvcnNQcm94eSA/IGNvcnNQcm94aWZ5KGNvcnNQcm94eSwgdXJsKSA6IHVybDtcbiAgICBpZiAoYXV0aC51c2VybmFtZSB8fCBhdXRoLnBhc3N3b3JkKSB7XG4gICAgICBoZWFkZXJzLkF1dGhvcml6YXRpb24gPSBjYWxjdWxhdGVCYXNpY0F1dGhIZWFkZXIoYXV0aCk7XG4gICAgfVxuICAgIGlmIChwcm90b2NvbFZlcnNpb24gPT09IDIpIHtcbiAgICAgIGhlYWRlcnNbJ0dpdC1Qcm90b2NvbCddID0gJ3ZlcnNpb249Mic7XG4gICAgfVxuXG4gICAgbGV0IHJlcztcbiAgICBsZXQgdHJ5QWdhaW47XG4gICAgbGV0IHByb3ZpZGVkQXV0aEJlZm9yZSA9IGZhbHNlO1xuICAgIGRvIHtcbiAgICAgIHJlcyA9IGF3YWl0IGh0dHAucmVxdWVzdCh7XG4gICAgICAgIG9uUHJvZ3Jlc3MsXG4gICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgIHVybDogYCR7cHJveGlmaWVkVVJMfS9pbmZvL3JlZnM/c2VydmljZT0ke3NlcnZpY2V9YCxcbiAgICAgICAgaGVhZGVycyxcbiAgICAgIH0pO1xuXG4gICAgICAvLyB0aGUgZGVmYXVsdCBsb29wIGJlaGF2aW9yXG4gICAgICB0cnlBZ2FpbiA9IGZhbHNlO1xuXG4gICAgICAvLyA0MDEgaXMgdGhlIFwiY29ycmVjdFwiIHJlc3BvbnNlIGZvciBhY2Nlc3MgZGVuaWVkLiAyMDMgaXMgTm9uLUF1dGhvcml0YXRpdmUgSW5mb3JtYXRpb24gYW5kIGNvbWVzIGZyb20gQXp1cmUgRGV2T3BzLCB3aGljaFxuICAgICAgLy8gYXBwYXJlbnRseSBkb2Vzbid0IHJlYWxpemUgdGhpcyBpcyBhIGdpdCByZXF1ZXN0IGFuZCBpcyByZXR1cm5pbmcgdGhlIEhUTUwgZm9yIHRoZSBcIkF6dXJlIERldk9wcyBTZXJ2aWNlcyB8IFNpZ24gSW5cIiBwYWdlLlxuICAgICAgaWYgKHJlcy5zdGF0dXNDb2RlID09PSA0MDEgfHwgcmVzLnN0YXR1c0NvZGUgPT09IDIwMykge1xuICAgICAgICAvLyBPbiBzdWJzZXF1ZW50IDQwMXMsIGNhbGwgYG9uQXV0aEZhaWx1cmVgIGluc3RlYWQgb2YgYG9uQXV0aGAuXG4gICAgICAgIC8vIFRoaXMgaXMgc28gdGhhdCBuYWl2ZSBgb25BdXRoYCBjYWxsYmFja3MgdGhhdCByZXR1cm4gYSBmaXhlZCB2YWx1ZSBkb24ndCBjcmVhdGUgYW4gaW5maW5pdGUgbG9vcCBvZiByZXRyeWluZy5cbiAgICAgICAgY29uc3QgZ2V0QXV0aCA9IHByb3ZpZGVkQXV0aEJlZm9yZSA/IG9uQXV0aEZhaWx1cmUgOiBvbkF1dGg7XG4gICAgICAgIGlmIChnZXRBdXRoKSB7XG4gICAgICAgICAgLy8gQWNxdWlyZSBjcmVkZW50aWFscyBhbmQgdHJ5IGFnYWluXG4gICAgICAgICAgLy8gVE9ETzogcmVhZCBgdXNlSHR0cFBhdGhgIHZhbHVlIGZyb20gZ2l0IGNvbmZpZyBhbmQgcGFzcyBhbG9uZz9cbiAgICAgICAgICBhdXRoID0gYXdhaXQgZ2V0QXV0aCh1cmwsIHtcbiAgICAgICAgICAgIC4uLmF1dGgsXG4gICAgICAgICAgICBoZWFkZXJzOiB7IC4uLmhlYWRlcnMgfSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAoYXV0aCAmJiBhdXRoLmNhbmNlbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFVzZXJDYW5jZWxlZEVycm9yKClcbiAgICAgICAgICB9IGVsc2UgaWYgKGF1dGgpIHtcbiAgICAgICAgICAgIHVwZGF0ZUhlYWRlcnMoaGVhZGVycywgYXV0aCk7XG4gICAgICAgICAgICBwcm92aWRlZEF1dGhCZWZvcmUgPSB0cnVlO1xuICAgICAgICAgICAgdHJ5QWdhaW4gPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgcmVzLnN0YXR1c0NvZGUgPT09IDIwMCAmJlxuICAgICAgICBwcm92aWRlZEF1dGhCZWZvcmUgJiZcbiAgICAgICAgb25BdXRoU3VjY2Vzc1xuICAgICAgKSB7XG4gICAgICAgIGF3YWl0IG9uQXV0aFN1Y2Nlc3ModXJsLCBhdXRoKTtcbiAgICAgIH1cbiAgICB9IHdoaWxlICh0cnlBZ2FpbilcblxuICAgIGlmIChyZXMuc3RhdHVzQ29kZSAhPT0gMjAwKSB7XG4gICAgICBjb25zdCB7IHJlc3BvbnNlIH0gPSBhd2FpdCBzdHJpbmdpZnlCb2R5KHJlcyk7XG4gICAgICB0aHJvdyBuZXcgSHR0cEVycm9yKHJlcy5zdGF0dXNDb2RlLCByZXMuc3RhdHVzTWVzc2FnZSwgcmVzcG9uc2UpXG4gICAgfVxuICAgIC8vIEdpdCBcInNtYXJ0XCIgSFRUUCBzZXJ2ZXJzIHNob3VsZCByZXNwb25kIHdpdGggdGhlIGNvcnJlY3QgQ29udGVudC1UeXBlIGhlYWRlci5cbiAgICBpZiAoXG4gICAgICByZXMuaGVhZGVyc1snY29udGVudC10eXBlJ10gPT09IGBhcHBsaWNhdGlvbi94LSR7c2VydmljZX0tYWR2ZXJ0aXNlbWVudGBcbiAgICApIHtcbiAgICAgIGNvbnN0IHJlbW90ZUhUVFAgPSBhd2FpdCBwYXJzZVJlZnNBZFJlc3BvbnNlKHJlcy5ib2R5LCB7IHNlcnZpY2UgfSk7XG4gICAgICByZW1vdGVIVFRQLmF1dGggPSBhdXRoO1xuICAgICAgcmV0dXJuIHJlbW90ZUhUVFBcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgdGhleSBkb24ndCBzZW5kIHRoZSBjb3JyZWN0IGNvbnRlbnQtdHlwZSBoZWFkZXIsIHRoYXQncyBhIGdvb2QgaW5kaWNhdG9yIGl0IGlzIGVpdGhlciBhIFwiZHVtYlwiIEhUVFBcbiAgICAgIC8vIHNlcnZlciwgb3IgdGhlIHVzZXIgc3BlY2lmaWVkIGFuIGluY29ycmVjdCByZW1vdGUgVVJMIGFuZCB0aGUgcmVzcG9uc2UgaXMgYWN0dWFsbHkgYW4gSFRNTCBwYWdlLlxuICAgICAgLy8gSW4gdGhpcyBjYXNlLCB3ZSBzYXZlIHRoZSByZXNwb25zZSBhcyBwbGFpbiB0ZXh0IHNvIHdlIGNhbiBnZW5lcmF0ZSBhIGJldHRlciBlcnJvciBtZXNzYWdlIGlmIG5lZWRlZC5cbiAgICAgIGNvbnN0IHsgcHJldmlldywgcmVzcG9uc2UsIGRhdGEgfSA9IGF3YWl0IHN0cmluZ2lmeUJvZHkocmVzKTtcbiAgICAgIC8vIEZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSwgdHJ5IHRvIHBhcnNlIGl0IGFueXdheS5cbiAgICAgIC8vIFRPRE86IG1heWJlIGp1c3QgdGhyb3cgaW5zdGVhZCBvZiB0cnlpbmc/XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByZW1vdGVIVFRQID0gYXdhaXQgcGFyc2VSZWZzQWRSZXNwb25zZShbZGF0YV0sIHsgc2VydmljZSB9KTtcbiAgICAgICAgcmVtb3RlSFRUUC5hdXRoID0gYXV0aDtcbiAgICAgICAgcmV0dXJuIHJlbW90ZUhUVFBcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IFNtYXJ0SHR0cEVycm9yKHByZXZpZXcsIHJlc3BvbnNlKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gYXJnc1xuICAgKiBAcGFyYW0ge0h0dHBDbGllbnR9IGFyZ3MuaHR0cFxuICAgKiBAcGFyYW0ge1Byb2dyZXNzQ2FsbGJhY2t9IFthcmdzLm9uUHJvZ3Jlc3NdXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5jb3JzUHJveHldXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhcmdzLnNlcnZpY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IGFyZ3MudXJsXG4gICAqIEBwYXJhbSB7T2JqZWN0PHN0cmluZywgc3RyaW5nPn0gW2FyZ3MuaGVhZGVyc11cbiAgICogQHBhcmFtIHthbnl9IGFyZ3MuYm9keVxuICAgKiBAcGFyYW0ge2FueX0gYXJncy5hdXRoXG4gICAqL1xuICBzdGF0aWMgYXN5bmMgY29ubmVjdCh7XG4gICAgaHR0cCxcbiAgICBvblByb2dyZXNzLFxuICAgIGNvcnNQcm94eSxcbiAgICBzZXJ2aWNlLFxuICAgIHVybCxcbiAgICBhdXRoLFxuICAgIGJvZHksXG4gICAgaGVhZGVycyxcbiAgfSkge1xuICAgIC8vIFdlIGFscmVhZHkgaGF2ZSB0aGUgXCJjb3JyZWN0XCIgYXV0aCB2YWx1ZSBhdCB0aGlzIHBvaW50LCBidXRcbiAgICAvLyB3ZSBuZWVkIHRvIHN0cmlwIG91dCB0aGUgdXNlcm5hbWUvcGFzc3dvcmQgZnJvbSB0aGUgVVJMIHlldCBhZ2Fpbi5cbiAgICBjb25zdCB1cmxBdXRoID0gZXh0cmFjdEF1dGhGcm9tVXJsKHVybCk7XG4gICAgaWYgKHVybEF1dGgpIHVybCA9IHVybEF1dGgudXJsO1xuXG4gICAgaWYgKGNvcnNQcm94eSkgdXJsID0gY29yc1Byb3hpZnkoY29yc1Byb3h5LCB1cmwpO1xuXG4gICAgaGVhZGVyc1snY29udGVudC10eXBlJ10gPSBgYXBwbGljYXRpb24veC0ke3NlcnZpY2V9LXJlcXVlc3RgO1xuICAgIGhlYWRlcnMuYWNjZXB0ID0gYGFwcGxpY2F0aW9uL3gtJHtzZXJ2aWNlfS1yZXN1bHRgO1xuICAgIHVwZGF0ZUhlYWRlcnMoaGVhZGVycywgYXV0aCk7XG5cbiAgICBjb25zdCByZXMgPSBhd2FpdCBodHRwLnJlcXVlc3Qoe1xuICAgICAgb25Qcm9ncmVzcyxcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgdXJsOiBgJHt1cmx9LyR7c2VydmljZX1gLFxuICAgICAgYm9keSxcbiAgICAgIGhlYWRlcnMsXG4gICAgfSk7XG4gICAgaWYgKHJlcy5zdGF0dXNDb2RlICE9PSAyMDApIHtcbiAgICAgIGNvbnN0IHsgcmVzcG9uc2UgfSA9IHN0cmluZ2lmeUJvZHkocmVzKTtcbiAgICAgIHRocm93IG5ldyBIdHRwRXJyb3IocmVzLnN0YXR1c0NvZGUsIHJlcy5zdGF0dXNNZXNzYWdlLCByZXNwb25zZSlcbiAgICB9XG4gICAgcmV0dXJuIHJlc1xuICB9XG59XG5cbmZ1bmN0aW9uIHBhcnNlUmVtb3RlVXJsKHsgdXJsIH0pIHtcbiAgLy8gdGhlIHN0dXBpZCBcInNob3J0ZXIgc2NwLWxpa2Ugc3ludGF4XCJcbiAgaWYgKHVybC5zdGFydHNXaXRoKCdnaXRAJykpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHJhbnNwb3J0OiAnc3NoJyxcbiAgICAgIGFkZHJlc3M6IHVybCxcbiAgICB9XG4gIH1cbiAgY29uc3QgbWF0Y2hlcyA9IHVybC5tYXRjaCgvKFxcdyspKDpcXC9cXC98OjopKC4qKS8pO1xuICBpZiAobWF0Y2hlcyA9PT0gbnVsbCkgcmV0dXJuXG4gIC8qXG4gICAqIFdoZW4gZ2l0IGVuY291bnRlcnMgYSBVUkwgb2YgdGhlIGZvcm0gPHRyYW5zcG9ydD46Ly88YWRkcmVzcz4sIHdoZXJlIDx0cmFuc3BvcnQ+IGlzXG4gICAqIGEgcHJvdG9jb2wgdGhhdCBpdCBjYW5ub3QgaGFuZGxlIG5hdGl2ZWx5LCBpdCBhdXRvbWF0aWNhbGx5IGludm9rZXMgZ2l0IHJlbW90ZS08dHJhbnNwb3J0PlxuICAgKiB3aXRoIHRoZSBmdWxsIFVSTCBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50LlxuICAgKlxuICAgKiBAc2VlIGh0dHBzOi8vZ2l0LXNjbS5jb20vZG9jcy9naXQtcmVtb3RlLWhlbHBlcnNcbiAgICovXG4gIGlmIChtYXRjaGVzWzJdID09PSAnOi8vJykge1xuICAgIHJldHVybiB7XG4gICAgICB0cmFuc3BvcnQ6IG1hdGNoZXNbMV0sXG4gICAgICBhZGRyZXNzOiBtYXRjaGVzWzBdLFxuICAgIH1cbiAgfVxuICAvKlxuICAgKiBBIFVSTCBvZiB0aGUgZm9ybSA8dHJhbnNwb3J0Pjo6PGFkZHJlc3M+IGV4cGxpY2l0bHkgaW5zdHJ1Y3RzIGdpdCB0byBpbnZva2VcbiAgICogZ2l0IHJlbW90ZS08dHJhbnNwb3J0PiB3aXRoIDxhZGRyZXNzPiBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50LlxuICAgKlxuICAgKiBAc2VlIGh0dHBzOi8vZ2l0LXNjbS5jb20vZG9jcy9naXQtcmVtb3RlLWhlbHBlcnNcbiAgICovXG4gIGlmIChtYXRjaGVzWzJdID09PSAnOjonKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRyYW5zcG9ydDogbWF0Y2hlc1sxXSxcbiAgICAgIGFkZHJlc3M6IG1hdGNoZXNbM10sXG4gICAgfVxuICB9XG59XG5cbmNsYXNzIEdpdFJlbW90ZU1hbmFnZXIge1xuICBzdGF0aWMgZ2V0UmVtb3RlSGVscGVyRm9yKHsgdXJsIH0pIHtcbiAgICAvLyBUT0RPOiBjbGVhbiB1cCB0aGUgcmVtb3RlSGVscGVyIEFQSSBhbmQgbW92ZSBpbnRvIFBsdWdpbkNvcmVcbiAgICBjb25zdCByZW1vdGVIZWxwZXJzID0gbmV3IE1hcCgpO1xuICAgIHJlbW90ZUhlbHBlcnMuc2V0KCdodHRwJywgR2l0UmVtb3RlSFRUUCk7XG4gICAgcmVtb3RlSGVscGVycy5zZXQoJ2h0dHBzJywgR2l0UmVtb3RlSFRUUCk7XG5cbiAgICBjb25zdCBwYXJ0cyA9IHBhcnNlUmVtb3RlVXJsKHsgdXJsIH0pO1xuICAgIGlmICghcGFydHMpIHtcbiAgICAgIHRocm93IG5ldyBVcmxQYXJzZUVycm9yKHVybClcbiAgICB9XG4gICAgaWYgKHJlbW90ZUhlbHBlcnMuaGFzKHBhcnRzLnRyYW5zcG9ydCkpIHtcbiAgICAgIHJldHVybiByZW1vdGVIZWxwZXJzLmdldChwYXJ0cy50cmFuc3BvcnQpXG4gICAgfVxuICAgIHRocm93IG5ldyBVbmtub3duVHJhbnNwb3J0RXJyb3IoXG4gICAgICB1cmwsXG4gICAgICBwYXJ0cy50cmFuc3BvcnQsXG4gICAgICBwYXJ0cy50cmFuc3BvcnQgPT09ICdzc2gnID8gdHJhbnNsYXRlU1NIdG9IVFRQKHVybCkgOiB1bmRlZmluZWRcbiAgICApXG4gIH1cbn1cblxubGV0IGxvY2skMSA9IG51bGw7XG5cbmNsYXNzIEdpdFNoYWxsb3dNYW5hZ2VyIHtcbiAgc3RhdGljIGFzeW5jIHJlYWQoeyBmcywgZ2l0ZGlyIH0pIHtcbiAgICBpZiAobG9jayQxID09PSBudWxsKSBsb2NrJDEgPSBuZXcgQXN5bmNMb2NrKCk7XG4gICAgY29uc3QgZmlsZXBhdGggPSBqb2luKGdpdGRpciwgJ3NoYWxsb3cnKTtcbiAgICBjb25zdCBvaWRzID0gbmV3IFNldCgpO1xuICAgIGF3YWl0IGxvY2skMS5hY3F1aXJlKGZpbGVwYXRoLCBhc3luYyBmdW5jdGlvbigpIHtcbiAgICAgIGNvbnN0IHRleHQgPSBhd2FpdCBmcy5yZWFkKGZpbGVwYXRoLCB7IGVuY29kaW5nOiAndXRmOCcgfSk7XG4gICAgICBpZiAodGV4dCA9PT0gbnVsbCkgcmV0dXJuIG9pZHMgLy8gbm8gZmlsZVxuICAgICAgaWYgKHRleHQudHJpbSgpID09PSAnJykgcmV0dXJuIG9pZHMgLy8gZW1wdHkgZmlsZVxuICAgICAgdGV4dFxuICAgICAgICAudHJpbSgpXG4gICAgICAgIC5zcGxpdCgnXFxuJylcbiAgICAgICAgLm1hcChvaWQgPT4gb2lkcy5hZGQob2lkKSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIG9pZHNcbiAgfVxuXG4gIHN0YXRpYyBhc3luYyB3cml0ZSh7IGZzLCBnaXRkaXIsIG9pZHMgfSkge1xuICAgIGlmIChsb2NrJDEgPT09IG51bGwpIGxvY2skMSA9IG5ldyBBc3luY0xvY2soKTtcbiAgICBjb25zdCBmaWxlcGF0aCA9IGpvaW4oZ2l0ZGlyLCAnc2hhbGxvdycpO1xuICAgIGlmIChvaWRzLnNpemUgPiAwKSB7XG4gICAgICBjb25zdCB0ZXh0ID0gWy4uLm9pZHNdLmpvaW4oJ1xcbicpICsgJ1xcbic7XG4gICAgICBhd2FpdCBsb2NrJDEuYWNxdWlyZShmaWxlcGF0aCwgYXN5bmMgZnVuY3Rpb24oKSB7XG4gICAgICAgIGF3YWl0IGZzLndyaXRlKGZpbGVwYXRoLCB0ZXh0LCB7XG4gICAgICAgICAgZW5jb2Rpbmc6ICd1dGY4JyxcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTm8gc2hhbGxvd3NcbiAgICAgIGF3YWl0IGxvY2skMS5hY3F1aXJlKGZpbGVwYXRoLCBhc3luYyBmdW5jdGlvbigpIHtcbiAgICAgICAgYXdhaXQgZnMucm0oZmlsZXBhdGgpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGhhc09iamVjdExvb3NlKHsgZnMsIGdpdGRpciwgb2lkIH0pIHtcbiAgY29uc3Qgc291cmNlID0gYG9iamVjdHMvJHtvaWQuc2xpY2UoMCwgMil9LyR7b2lkLnNsaWNlKDIpfWA7XG4gIHJldHVybiBmcy5leGlzdHMoYCR7Z2l0ZGlyfS8ke3NvdXJjZX1gKVxufVxuXG5hc3luYyBmdW5jdGlvbiBoYXNPYmplY3RQYWNrZWQoe1xuICBmcyxcbiAgY2FjaGUsXG4gIGdpdGRpcixcbiAgb2lkLFxuICBnZXRFeHRlcm5hbFJlZkRlbHRhLFxufSkge1xuICAvLyBDaGVjayB0byBzZWUgaWYgaXQncyBpbiBhIHBhY2tmaWxlLlxuICAvLyBJdGVyYXRlIHRocm91Z2ggYWxsIHRoZSAuaWR4IGZpbGVzXG4gIGxldCBsaXN0ID0gYXdhaXQgZnMucmVhZGRpcihqb2luKGdpdGRpciwgJ29iamVjdHMvcGFjaycpKTtcbiAgbGlzdCA9IGxpc3QuZmlsdGVyKHggPT4geC5lbmRzV2l0aCgnLmlkeCcpKTtcbiAgZm9yIChjb25zdCBmaWxlbmFtZSBvZiBsaXN0KSB7XG4gICAgY29uc3QgaW5kZXhGaWxlID0gYCR7Z2l0ZGlyfS9vYmplY3RzL3BhY2svJHtmaWxlbmFtZX1gO1xuICAgIGNvbnN0IHAgPSBhd2FpdCByZWFkUGFja0luZGV4KHtcbiAgICAgIGZzLFxuICAgICAgY2FjaGUsXG4gICAgICBmaWxlbmFtZTogaW5kZXhGaWxlLFxuICAgICAgZ2V0RXh0ZXJuYWxSZWZEZWx0YSxcbiAgICB9KTtcbiAgICBpZiAocC5lcnJvcikgdGhyb3cgbmV3IEludGVybmFsRXJyb3IocC5lcnJvcilcbiAgICAvLyBJZiB0aGUgcGFja2ZpbGUgRE9FUyBoYXZlIHRoZSBvaWQgd2UncmUgbG9va2luZyBmb3IuLi5cbiAgICBpZiAocC5vZmZzZXRzLmhhcyhvaWQpKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuICAvLyBGYWlsZWQgdG8gZmluZCBpdFxuICByZXR1cm4gZmFsc2Vcbn1cblxuYXN5bmMgZnVuY3Rpb24gaGFzT2JqZWN0KHtcbiAgZnMsXG4gIGNhY2hlLFxuICBnaXRkaXIsXG4gIG9pZCxcbiAgZm9ybWF0ID0gJ2NvbnRlbnQnLFxufSkge1xuICAvLyBDdXJyeSB0aGUgY3VycmVudCByZWFkIG1ldGhvZCBzbyB0aGF0IHRoZSBwYWNrZmlsZSB1bi1kZWx0aWZpY2F0aW9uXG4gIC8vIHByb2Nlc3MgY2FuIGFjcXVpcmUgZXh0ZXJuYWwgcmVmLWRlbHRhcy5cbiAgY29uc3QgZ2V0RXh0ZXJuYWxSZWZEZWx0YSA9IG9pZCA9PiBfcmVhZE9iamVjdCh7IGZzLCBjYWNoZSwgZ2l0ZGlyLCBvaWQgfSk7XG5cbiAgLy8gTG9vayBmb3IgaXQgaW4gdGhlIGxvb3NlIG9iamVjdCBkaXJlY3RvcnkuXG4gIGxldCByZXN1bHQgPSBhd2FpdCBoYXNPYmplY3RMb29zZSh7IGZzLCBnaXRkaXIsIG9pZCB9KTtcbiAgLy8gQ2hlY2sgdG8gc2VlIGlmIGl0J3MgaW4gYSBwYWNrZmlsZS5cbiAgaWYgKCFyZXN1bHQpIHtcbiAgICByZXN1bHQgPSBhd2FpdCBoYXNPYmplY3RQYWNrZWQoe1xuICAgICAgZnMsXG4gICAgICBjYWNoZSxcbiAgICAgIGdpdGRpcixcbiAgICAgIG9pZCxcbiAgICAgIGdldEV4dGVybmFsUmVmRGVsdGEsXG4gICAgfSk7XG4gIH1cbiAgLy8gRmluYWxseVxuICByZXR1cm4gcmVzdWx0XG59XG5cbi8vIFRPRE86IG1ha2UgYSBmdW5jdGlvbiB0aGF0IGp1c3QgcmV0dXJucyBvYkNvdW50LiB0aGVuIGVtcHR5UGFja2ZpbGUgPSAoKSA9PiBzaXplUGFjayhwYWNrKSA9PT0gMFxuZnVuY3Rpb24gZW1wdHlQYWNrZmlsZShwYWNrKSB7XG4gIGNvbnN0IHBoZWFkZXIgPSAnNTA0MTQzNGInO1xuICBjb25zdCB2ZXJzaW9uID0gJzAwMDAwMDAyJztcbiAgY29uc3Qgb2JDb3VudCA9ICcwMDAwMDAwMCc7XG4gIGNvbnN0IGhlYWRlciA9IHBoZWFkZXIgKyB2ZXJzaW9uICsgb2JDb3VudDtcbiAgcmV0dXJuIHBhY2suc2xpY2UoMCwgMTIpLnRvU3RyaW5nKCdoZXgnKSA9PT0gaGVhZGVyXG59XG5cbmZ1bmN0aW9uIGZpbHRlckNhcGFiaWxpdGllcyhzZXJ2ZXIsIGNsaWVudCkge1xuICBjb25zdCBzZXJ2ZXJOYW1lcyA9IHNlcnZlci5tYXAoY2FwID0+IGNhcC5zcGxpdCgnPScsIDEpWzBdKTtcbiAgcmV0dXJuIGNsaWVudC5maWx0ZXIoY2FwID0+IHtcbiAgICBjb25zdCBuYW1lID0gY2FwLnNwbGl0KCc9JywgMSlbMF07XG4gICAgcmV0dXJuIHNlcnZlck5hbWVzLmluY2x1ZGVzKG5hbWUpXG4gIH0pXG59XG5cbmNvbnN0IHBrZyA9IHtcbiAgbmFtZTogJ2lzb21vcnBoaWMtZ2l0JyxcbiAgdmVyc2lvbjogJzEuOC4xJyxcbiAgYWdlbnQ6ICdnaXQvaXNvbW9ycGhpYy1naXRAMS44LjEnLFxufTtcblxuY2xhc3MgRklGTyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX3F1ZXVlID0gW107XG4gIH1cblxuICB3cml0ZShjaHVuaykge1xuICAgIGlmICh0aGlzLl9lbmRlZCkge1xuICAgICAgdGhyb3cgRXJyb3IoJ1lvdSBjYW5ub3Qgd3JpdGUgdG8gYSBGSUZPIHRoYXQgaGFzIGFscmVhZHkgYmVlbiBlbmRlZCEnKVxuICAgIH1cbiAgICBpZiAodGhpcy5fd2FpdGluZykge1xuICAgICAgY29uc3QgcmVzb2x2ZSA9IHRoaXMuX3dhaXRpbmc7XG4gICAgICB0aGlzLl93YWl0aW5nID0gbnVsbDtcbiAgICAgIHJlc29sdmUoeyB2YWx1ZTogY2h1bmsgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3F1ZXVlLnB1c2goY2h1bmspO1xuICAgIH1cbiAgfVxuXG4gIGVuZCgpIHtcbiAgICB0aGlzLl9lbmRlZCA9IHRydWU7XG4gICAgaWYgKHRoaXMuX3dhaXRpbmcpIHtcbiAgICAgIGNvbnN0IHJlc29sdmUgPSB0aGlzLl93YWl0aW5nO1xuICAgICAgdGhpcy5fd2FpdGluZyA9IG51bGw7XG4gICAgICByZXNvbHZlKHsgZG9uZTogdHJ1ZSB9KTtcbiAgICB9XG4gIH1cblxuICBkZXN0cm95KGVycikge1xuICAgIHRoaXMuX2VuZGVkID0gdHJ1ZTtcbiAgICB0aGlzLmVycm9yID0gZXJyO1xuICB9XG5cbiAgYXN5bmMgbmV4dCgpIHtcbiAgICBpZiAodGhpcy5fcXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgcmV0dXJuIHsgdmFsdWU6IHRoaXMuX3F1ZXVlLnNoaWZ0KCkgfVxuICAgIH1cbiAgICBpZiAodGhpcy5fZW5kZWQpIHtcbiAgICAgIHJldHVybiB7IGRvbmU6IHRydWUgfVxuICAgIH1cbiAgICBpZiAodGhpcy5fd2FpdGluZykge1xuICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICdZb3UgY2Fubm90IGNhbGwgcmVhZCB1bnRpbCB0aGUgcHJldmlvdXMgY2FsbCB0byByZWFkIGhhcyByZXR1cm5lZCEnXG4gICAgICApXG4gICAgfVxuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIHRoaXMuX3dhaXRpbmcgPSByZXNvbHZlO1xuICAgIH0pXG4gIH1cbn1cblxuLy8gTm90ZTogcHJvZ3Jlc3MgbWVzc2FnZXMgYXJlIGRlc2lnbmVkIHRvIGJlIHdyaXR0ZW4gZGlyZWN0bHkgdG8gdGhlIHRlcm1pbmFsLFxuLy8gc28gdGhleSBhcmUgb2Z0ZW4gc2VudCB3aXRoIGp1c3QgYSBjYXJyaWFnZSByZXR1cm4gdG8gb3ZlcndyaXRlIHRoZSBsYXN0IGxpbmUgb2Ygb3V0cHV0LlxuLy8gQnV0IHRoZXJlIGFyZSBhbHNvIG1lc3NhZ2VzIGRlbGltaXRlZCB3aXRoIG5ld2xpbmVzLlxuLy8gSSBhbHNvIGluY2x1ZGUgQ1JMRiBqdXN0IGluIGNhc2UuXG5mdW5jdGlvbiBmaW5kU3BsaXQoc3RyKSB7XG4gIGNvbnN0IHIgPSBzdHIuaW5kZXhPZignXFxyJyk7XG4gIGNvbnN0IG4gPSBzdHIuaW5kZXhPZignXFxuJyk7XG4gIGlmIChyID09PSAtMSAmJiBuID09PSAtMSkgcmV0dXJuIC0xXG4gIGlmIChyID09PSAtMSkgcmV0dXJuIG4gKyAxIC8vIFxcblxuICBpZiAobiA9PT0gLTEpIHJldHVybiByICsgMSAvLyBcXHJcbiAgaWYgKG4gPT09IHIgKyAxKSByZXR1cm4gbiArIDEgLy8gXFxyXFxuXG4gIHJldHVybiBNYXRoLm1pbihyLCBuKSArIDEgLy8gXFxyIG9yIFxcblxufVxuXG5mdW5jdGlvbiBzcGxpdExpbmVzKGlucHV0KSB7XG4gIGNvbnN0IG91dHB1dCA9IG5ldyBGSUZPKCk7XG4gIGxldCB0bXAgPSAnJ1xuICA7KGFzeW5jICgpID0+IHtcbiAgICBhd2FpdCBmb3JBd2FpdChpbnB1dCwgY2h1bmsgPT4ge1xuICAgICAgY2h1bmsgPSBjaHVuay50b1N0cmluZygndXRmOCcpO1xuICAgICAgdG1wICs9IGNodW5rO1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgY29uc3QgaSA9IGZpbmRTcGxpdCh0bXApO1xuICAgICAgICBpZiAoaSA9PT0gLTEpIGJyZWFrXG4gICAgICAgIG91dHB1dC53cml0ZSh0bXAuc2xpY2UoMCwgaSkpO1xuICAgICAgICB0bXAgPSB0bXAuc2xpY2UoaSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKHRtcC5sZW5ndGggPiAwKSB7XG4gICAgICBvdXRwdXQud3JpdGUodG1wKTtcbiAgICB9XG4gICAgb3V0cHV0LmVuZCgpO1xuICB9KSgpO1xuICByZXR1cm4gb3V0cHV0XG59XG5cbi8qXG5JZiAnc2lkZS1iYW5kJyBvciAnc2lkZS1iYW5kLTY0aycgY2FwYWJpbGl0aWVzIGhhdmUgYmVlbiBzcGVjaWZpZWQgYnlcbnRoZSBjbGllbnQsIHRoZSBzZXJ2ZXIgd2lsbCBzZW5kIHRoZSBwYWNrZmlsZSBkYXRhIG11bHRpcGxleGVkLlxuXG5FYWNoIHBhY2tldCBzdGFydGluZyB3aXRoIHRoZSBwYWNrZXQtbGluZSBsZW5ndGggb2YgdGhlIGFtb3VudCBvZiBkYXRhXG50aGF0IGZvbGxvd3MsIGZvbGxvd2VkIGJ5IGEgc2luZ2xlIGJ5dGUgc3BlY2lmeWluZyB0aGUgc2lkZWJhbmQgdGhlXG5mb2xsb3dpbmcgZGF0YSBpcyBjb21pbmcgaW4gb24uXG5cbkluICdzaWRlLWJhbmQnIG1vZGUsIGl0IHdpbGwgc2VuZCB1cCB0byA5OTkgZGF0YSBieXRlcyBwbHVzIDEgY29udHJvbFxuY29kZSwgZm9yIGEgdG90YWwgb2YgdXAgdG8gMTAwMCBieXRlcyBpbiBhIHBrdC1saW5lLiAgSW4gJ3NpZGUtYmFuZC02NGsnXG5tb2RlIGl0IHdpbGwgc2VuZCB1cCB0byA2NTUxOSBkYXRhIGJ5dGVzIHBsdXMgMSBjb250cm9sIGNvZGUsIGZvciBhXG50b3RhbCBvZiB1cCB0byA2NTUyMCBieXRlcyBpbiBhIHBrdC1saW5lLlxuXG5UaGUgc2lkZWJhbmQgYnl0ZSB3aWxsIGJlIGEgJzEnLCAnMicgb3IgYSAnMycuIFNpZGViYW5kICcxJyB3aWxsIGNvbnRhaW5cbnBhY2tmaWxlIGRhdGEsIHNpZGViYW5kICcyJyB3aWxsIGJlIHVzZWQgZm9yIHByb2dyZXNzIGluZm9ybWF0aW9uIHRoYXQgdGhlXG5jbGllbnQgd2lsbCBnZW5lcmFsbHkgcHJpbnQgdG8gc3RkZXJyIGFuZCBzaWRlYmFuZCAnMycgaXMgdXNlZCBmb3IgZXJyb3JcbmluZm9ybWF0aW9uLlxuXG5JZiBubyAnc2lkZS1iYW5kJyBjYXBhYmlsaXR5IHdhcyBzcGVjaWZpZWQsIHRoZSBzZXJ2ZXIgd2lsbCBzdHJlYW0gdGhlXG5lbnRpcmUgcGFja2ZpbGUgd2l0aG91dCBtdWx0aXBsZXhpbmcuXG4qL1xuXG5jbGFzcyBHaXRTaWRlQmFuZCB7XG4gIHN0YXRpYyBkZW11eChpbnB1dCkge1xuICAgIGNvbnN0IHJlYWQgPSBHaXRQa3RMaW5lLnN0cmVhbVJlYWRlcihpbnB1dCk7XG4gICAgLy8gQW5kIG5vdyBmb3IgdGhlIHJpZGljdWxvdXMgc2lkZS1iYW5kIG9yIHNpZGUtYmFuZC02NGsgcHJvdG9jb2xcbiAgICBjb25zdCBwYWNrZXRsaW5lcyA9IG5ldyBGSUZPKCk7XG4gICAgY29uc3QgcGFja2ZpbGUgPSBuZXcgRklGTygpO1xuICAgIGNvbnN0IHByb2dyZXNzID0gbmV3IEZJRk8oKTtcbiAgICAvLyBUT0RPOiBVc2UgYSBwcm9wZXIgdGhyb3VnaCBzdHJlYW0/XG4gICAgY29uc3QgbmV4dEJpdCA9IGFzeW5jIGZ1bmN0aW9uKCkge1xuICAgICAgY29uc3QgbGluZSA9IGF3YWl0IHJlYWQoKTtcbiAgICAgIC8vIFNraXAgb3ZlciBmbHVzaCBwYWNrZXRzXG4gICAgICBpZiAobGluZSA9PT0gbnVsbCkgcmV0dXJuIG5leHRCaXQoKVxuICAgICAgLy8gQSBtYWRlIHVwIGNvbnZlbnRpb24gdG8gc2lnbmFsIHRoZXJlJ3Mgbm8gbW9yZSB0byByZWFkLlxuICAgICAgaWYgKGxpbmUgPT09IHRydWUpIHtcbiAgICAgICAgcGFja2V0bGluZXMuZW5kKCk7XG4gICAgICAgIHByb2dyZXNzLmVuZCgpO1xuICAgICAgICBwYWNrZmlsZS5lbmQoKTtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICAvLyBFeGFtaW5lIGZpcnN0IGJ5dGUgdG8gZGV0ZXJtaW5lIHdoaWNoIG91dHB1dCBcInN0cmVhbVwiIHRvIHVzZVxuICAgICAgc3dpdGNoIChsaW5lWzBdKSB7XG4gICAgICAgIGNhc2UgMToge1xuICAgICAgICAgIC8vIHBhY2sgZGF0YVxuICAgICAgICAgIHBhY2tmaWxlLndyaXRlKGxpbmUuc2xpY2UoMSkpO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAyOiB7XG4gICAgICAgICAgLy8gcHJvZ3Jlc3MgbWVzc2FnZVxuICAgICAgICAgIHByb2dyZXNzLndyaXRlKGxpbmUuc2xpY2UoMSkpO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAzOiB7XG4gICAgICAgICAgLy8gZmF0YWwgZXJyb3IgbWVzc2FnZSBqdXN0IGJlZm9yZSBzdHJlYW0gYWJvcnRzXG4gICAgICAgICAgY29uc3QgZXJyb3IgPSBsaW5lLnNsaWNlKDEpO1xuICAgICAgICAgIHByb2dyZXNzLndyaXRlKGVycm9yKTtcbiAgICAgICAgICBwYWNrZmlsZS5kZXN0cm95KG5ldyBFcnJvcihlcnJvci50b1N0cmluZygndXRmOCcpKSk7XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgIC8vIE5vdCBwYXJ0IG9mIHRoZSBzaWRlLWJhbmQtNjRrIHByb3RvY29sXG4gICAgICAgICAgcGFja2V0bGluZXMud3JpdGUobGluZS5zbGljZSgwKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIENhcmVmdWwgbm90IHRvIGJsb3cgdXAgdGhlIHN0YWNrLlxuICAgICAgLy8gSSB0aGluayBQcm9taXNlcyBpbiBhIHRhaWwtY2FsbCBwb3NpdGlvbiBzaG91bGQgYmUgT0suXG4gICAgICBuZXh0Qml0KCk7XG4gICAgfTtcbiAgICBuZXh0Qml0KCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBhY2tldGxpbmVzLFxuICAgICAgcGFja2ZpbGUsXG4gICAgICBwcm9ncmVzcyxcbiAgICB9XG4gIH1cbiAgLy8gc3RhdGljIG11eCAoe1xuICAvLyAgIHByb3RvY29sLCAvLyAnc2lkZS1iYW5kJyBvciAnc2lkZS1iYW5kLTY0aydcbiAgLy8gICBwYWNrZXRsaW5lcyxcbiAgLy8gICBwYWNrZmlsZSxcbiAgLy8gICBwcm9ncmVzcyxcbiAgLy8gICBlcnJvclxuICAvLyB9KSB7XG4gIC8vICAgY29uc3QgTUFYX1BBQ0tFVF9MRU5HVEggPSBwcm90b2NvbCA9PT0gJ3NpZGUtYmFuZC02NGsnID8gOTk5IDogNjU1MTlcbiAgLy8gICBsZXQgb3V0cHV0ID0gbmV3IFBhc3NUaHJvdWdoKClcbiAgLy8gICBwYWNrZXRsaW5lcy5vbignZGF0YScsIGRhdGEgPT4ge1xuICAvLyAgICAgaWYgKGRhdGEgPT09IG51bGwpIHtcbiAgLy8gICAgICAgb3V0cHV0LndyaXRlKEdpdFBrdExpbmUuZmx1c2goKSlcbiAgLy8gICAgIH0gZWxzZSB7XG4gIC8vICAgICAgIG91dHB1dC53cml0ZShHaXRQa3RMaW5lLmVuY29kZShkYXRhKSlcbiAgLy8gICAgIH1cbiAgLy8gICB9KVxuICAvLyAgIGxldCBwYWNrZmlsZVdhc0VtcHR5ID0gdHJ1ZVxuICAvLyAgIGxldCBwYWNrZmlsZUVuZGVkID0gZmFsc2VcbiAgLy8gICBsZXQgcHJvZ3Jlc3NFbmRlZCA9IGZhbHNlXG4gIC8vICAgbGV0IGVycm9yRW5kZWQgPSBmYWxzZVxuICAvLyAgIGxldCBnb29kYnllID0gQnVmZmVyLmNvbmNhdChbXG4gIC8vICAgICBHaXRQa3RMaW5lLmVuY29kZShCdWZmZXIuZnJvbSgnMDEwQScsICdoZXgnKSksXG4gIC8vICAgICBHaXRQa3RMaW5lLmZsdXNoKClcbiAgLy8gICBdKVxuICAvLyAgIHBhY2tmaWxlXG4gIC8vICAgICAub24oJ2RhdGEnLCBkYXRhID0+IHtcbiAgLy8gICAgICAgcGFja2ZpbGVXYXNFbXB0eSA9IGZhbHNlXG4gIC8vICAgICAgIGNvbnN0IGJ1ZmZlcnMgPSBzcGxpdEJ1ZmZlcihkYXRhLCBNQVhfUEFDS0VUX0xFTkdUSClcbiAgLy8gICAgICAgZm9yIChjb25zdCBidWZmZXIgb2YgYnVmZmVycykge1xuICAvLyAgICAgICAgIG91dHB1dC53cml0ZShcbiAgLy8gICAgICAgICAgIEdpdFBrdExpbmUuZW5jb2RlKEJ1ZmZlci5jb25jYXQoW0J1ZmZlci5mcm9tKCcwMScsICdoZXgnKSwgYnVmZmVyXSkpXG4gIC8vICAgICAgICAgKVxuICAvLyAgICAgICB9XG4gIC8vICAgICB9KVxuICAvLyAgICAgLm9uKCdlbmQnLCAoKSA9PiB7XG4gIC8vICAgICAgIHBhY2tmaWxlRW5kZWQgPSB0cnVlXG4gIC8vICAgICAgIGlmICghcGFja2ZpbGVXYXNFbXB0eSkgb3V0cHV0LndyaXRlKGdvb2RieWUpXG4gIC8vICAgICAgIGlmIChwcm9ncmVzc0VuZGVkICYmIGVycm9yRW5kZWQpIG91dHB1dC5lbmQoKVxuICAvLyAgICAgfSlcbiAgLy8gICBwcm9ncmVzc1xuICAvLyAgICAgLm9uKCdkYXRhJywgZGF0YSA9PiB7XG4gIC8vICAgICAgIGNvbnN0IGJ1ZmZlcnMgPSBzcGxpdEJ1ZmZlcihkYXRhLCBNQVhfUEFDS0VUX0xFTkdUSClcbiAgLy8gICAgICAgZm9yIChjb25zdCBidWZmZXIgb2YgYnVmZmVycykge1xuICAvLyAgICAgICAgIG91dHB1dC53cml0ZShcbiAgLy8gICAgICAgICAgIEdpdFBrdExpbmUuZW5jb2RlKEJ1ZmZlci5jb25jYXQoW0J1ZmZlci5mcm9tKCcwMicsICdoZXgnKSwgYnVmZmVyXSkpXG4gIC8vICAgICAgICAgKVxuICAvLyAgICAgICB9XG4gIC8vICAgICB9KVxuICAvLyAgICAgLm9uKCdlbmQnLCAoKSA9PiB7XG4gIC8vICAgICAgIHByb2dyZXNzRW5kZWQgPSB0cnVlXG4gIC8vICAgICAgIGlmIChwYWNrZmlsZUVuZGVkICYmIGVycm9yRW5kZWQpIG91dHB1dC5lbmQoKVxuICAvLyAgICAgfSlcbiAgLy8gICBlcnJvclxuICAvLyAgICAgLm9uKCdkYXRhJywgZGF0YSA9PiB7XG4gIC8vICAgICAgIGNvbnN0IGJ1ZmZlcnMgPSBzcGxpdEJ1ZmZlcihkYXRhLCBNQVhfUEFDS0VUX0xFTkdUSClcbiAgLy8gICAgICAgZm9yIChjb25zdCBidWZmZXIgb2YgYnVmZmVycykge1xuICAvLyAgICAgICAgIG91dHB1dC53cml0ZShcbiAgLy8gICAgICAgICAgIEdpdFBrdExpbmUuZW5jb2RlKEJ1ZmZlci5jb25jYXQoW0J1ZmZlci5mcm9tKCcwMycsICdoZXgnKSwgYnVmZmVyXSkpXG4gIC8vICAgICAgICAgKVxuICAvLyAgICAgICB9XG4gIC8vICAgICB9KVxuICAvLyAgICAgLm9uKCdlbmQnLCAoKSA9PiB7XG4gIC8vICAgICAgIGVycm9yRW5kZWQgPSB0cnVlXG4gIC8vICAgICAgIGlmIChwcm9ncmVzc0VuZGVkICYmIHBhY2tmaWxlRW5kZWQpIG91dHB1dC5lbmQoKVxuICAvLyAgICAgfSlcbiAgLy8gICByZXR1cm4gb3V0cHV0XG4gIC8vIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gcGFyc2VVcGxvYWRQYWNrUmVzcG9uc2Uoc3RyZWFtKSB7XG4gIGNvbnN0IHsgcGFja2V0bGluZXMsIHBhY2tmaWxlLCBwcm9ncmVzcyB9ID0gR2l0U2lkZUJhbmQuZGVtdXgoc3RyZWFtKTtcbiAgY29uc3Qgc2hhbGxvd3MgPSBbXTtcbiAgY29uc3QgdW5zaGFsbG93cyA9IFtdO1xuICBjb25zdCBhY2tzID0gW107XG4gIGxldCBuYWsgPSBmYWxzZTtcbiAgbGV0IGRvbmUgPSBmYWxzZTtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAvLyBQYXJzZSB0aGUgcmVzcG9uc2VcbiAgICBmb3JBd2FpdChwYWNrZXRsaW5lcywgZGF0YSA9PiB7XG4gICAgICBjb25zdCBsaW5lID0gZGF0YS50b1N0cmluZygndXRmOCcpLnRyaW0oKTtcbiAgICAgIGlmIChsaW5lLnN0YXJ0c1dpdGgoJ3NoYWxsb3cnKSkge1xuICAgICAgICBjb25zdCBvaWQgPSBsaW5lLnNsaWNlKC00MSkudHJpbSgpO1xuICAgICAgICBpZiAob2lkLmxlbmd0aCAhPT0gNDApIHtcbiAgICAgICAgICByZWplY3QobmV3IEludmFsaWRPaWRFcnJvcihvaWQpKTtcbiAgICAgICAgfVxuICAgICAgICBzaGFsbG93cy5wdXNoKG9pZCk7XG4gICAgICB9IGVsc2UgaWYgKGxpbmUuc3RhcnRzV2l0aCgndW5zaGFsbG93JykpIHtcbiAgICAgICAgY29uc3Qgb2lkID0gbGluZS5zbGljZSgtNDEpLnRyaW0oKTtcbiAgICAgICAgaWYgKG9pZC5sZW5ndGggIT09IDQwKSB7XG4gICAgICAgICAgcmVqZWN0KG5ldyBJbnZhbGlkT2lkRXJyb3Iob2lkKSk7XG4gICAgICAgIH1cbiAgICAgICAgdW5zaGFsbG93cy5wdXNoKG9pZCk7XG4gICAgICB9IGVsc2UgaWYgKGxpbmUuc3RhcnRzV2l0aCgnQUNLJykpIHtcbiAgICAgICAgY29uc3QgWywgb2lkLCBzdGF0dXNdID0gbGluZS5zcGxpdCgnICcpO1xuICAgICAgICBhY2tzLnB1c2goeyBvaWQsIHN0YXR1cyB9KTtcbiAgICAgICAgaWYgKCFzdGF0dXMpIGRvbmUgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChsaW5lLnN0YXJ0c1dpdGgoJ05BSycpKSB7XG4gICAgICAgIG5hayA9IHRydWU7XG4gICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgcmVzb2x2ZSh7IHNoYWxsb3dzLCB1bnNoYWxsb3dzLCBhY2tzLCBuYWssIHBhY2tmaWxlLCBwcm9ncmVzcyB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSlcbn1cblxuZnVuY3Rpb24gd3JpdGVVcGxvYWRQYWNrUmVxdWVzdCh7XG4gIGNhcGFiaWxpdGllcyA9IFtdLFxuICB3YW50cyA9IFtdLFxuICBoYXZlcyA9IFtdLFxuICBzaGFsbG93cyA9IFtdLFxuICBkZXB0aCA9IG51bGwsXG4gIHNpbmNlID0gbnVsbCxcbiAgZXhjbHVkZSA9IFtdLFxufSkge1xuICBjb25zdCBwYWNrc3RyZWFtID0gW107XG4gIHdhbnRzID0gWy4uLm5ldyBTZXQod2FudHMpXTsgLy8gcmVtb3ZlIGR1cGxpY2F0ZXNcbiAgbGV0IGZpcnN0TGluZUNhcGFiaWxpdGllcyA9IGAgJHtjYXBhYmlsaXRpZXMuam9pbignICcpfWA7XG4gIGZvciAoY29uc3Qgb2lkIG9mIHdhbnRzKSB7XG4gICAgcGFja3N0cmVhbS5wdXNoKEdpdFBrdExpbmUuZW5jb2RlKGB3YW50ICR7b2lkfSR7Zmlyc3RMaW5lQ2FwYWJpbGl0aWVzfVxcbmApKTtcbiAgICBmaXJzdExpbmVDYXBhYmlsaXRpZXMgPSAnJztcbiAgfVxuICBmb3IgKGNvbnN0IG9pZCBvZiBzaGFsbG93cykge1xuICAgIHBhY2tzdHJlYW0ucHVzaChHaXRQa3RMaW5lLmVuY29kZShgc2hhbGxvdyAke29pZH1cXG5gKSk7XG4gIH1cbiAgaWYgKGRlcHRoICE9PSBudWxsKSB7XG4gICAgcGFja3N0cmVhbS5wdXNoKEdpdFBrdExpbmUuZW5jb2RlKGBkZWVwZW4gJHtkZXB0aH1cXG5gKSk7XG4gIH1cbiAgaWYgKHNpbmNlICE9PSBudWxsKSB7XG4gICAgcGFja3N0cmVhbS5wdXNoKFxuICAgICAgR2l0UGt0TGluZS5lbmNvZGUoYGRlZXBlbi1zaW5jZSAke01hdGguZmxvb3Ioc2luY2UudmFsdWVPZigpIC8gMTAwMCl9XFxuYClcbiAgICApO1xuICB9XG4gIGZvciAoY29uc3Qgb2lkIG9mIGV4Y2x1ZGUpIHtcbiAgICBwYWNrc3RyZWFtLnB1c2goR2l0UGt0TGluZS5lbmNvZGUoYGRlZXBlbi1ub3QgJHtvaWR9XFxuYCkpO1xuICB9XG4gIHBhY2tzdHJlYW0ucHVzaChHaXRQa3RMaW5lLmZsdXNoKCkpO1xuICBmb3IgKGNvbnN0IG9pZCBvZiBoYXZlcykge1xuICAgIHBhY2tzdHJlYW0ucHVzaChHaXRQa3RMaW5lLmVuY29kZShgaGF2ZSAke29pZH1cXG5gKSk7XG4gIH1cbiAgcGFja3N0cmVhbS5wdXNoKEdpdFBrdExpbmUuZW5jb2RlKGBkb25lXFxuYCkpO1xuICByZXR1cm4gcGFja3N0cmVhbVxufVxuXG4vLyBAdHMtY2hlY2tcblxuLyoqXG4gKlxuICogQHR5cGVkZWYge29iamVjdH0gRmV0Y2hSZXN1bHQgLSBUaGUgb2JqZWN0IHJldHVybmVkIGhhcyB0aGUgZm9sbG93aW5nIHNjaGVtYTpcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nIHwgbnVsbH0gZGVmYXVsdEJyYW5jaCAtIFRoZSBicmFuY2ggdGhhdCBpcyBjbG9uZWQgaWYgbm8gYnJhbmNoIGlzIHNwZWNpZmllZFxuICogQHByb3BlcnR5IHtzdHJpbmcgfCBudWxsfSBmZXRjaEhlYWQgLSBUaGUgU0hBLTEgb2JqZWN0IGlkIG9mIHRoZSBmZXRjaGVkIGhlYWQgY29tbWl0XG4gKiBAcHJvcGVydHkge3N0cmluZyB8IG51bGx9IGZldGNoSGVhZERlc2NyaXB0aW9uIC0gYSB0ZXh0dWFsIGRlc2NyaXB0aW9uIG9mIHRoZSBicmFuY2ggdGhhdCB3YXMgZmV0Y2hlZFxuICogQHByb3BlcnR5IHtPYmplY3Q8c3RyaW5nLCBzdHJpbmc+fSBbaGVhZGVyc10gLSBUaGUgSFRUUCByZXNwb25zZSBoZWFkZXJzIHJldHVybmVkIGJ5IHRoZSBnaXQgc2VydmVyXG4gKiBAcHJvcGVydHkge3N0cmluZ1tdfSBbcHJ1bmVkXSAtIEEgbGlzdCBvZiBicmFuY2hlcyB0aGF0IHdlcmUgcHJ1bmVkLCBpZiB5b3UgcHJvdmlkZWQgdGhlIGBwcnVuZWAgcGFyYW1ldGVyXG4gKlxuICovXG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGFyZ3NcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9tb2RlbHMvRmlsZVN5c3RlbS5qcycpLkZpbGVTeXN0ZW19IGFyZ3MuZnNcbiAqIEBwYXJhbSB7YW55fSBhcmdzLmNhY2hlXG4gKiBAcGFyYW0ge0h0dHBDbGllbnR9IGFyZ3MuaHR0cFxuICogQHBhcmFtIHtQcm9ncmVzc0NhbGxiYWNrfSBbYXJncy5vblByb2dyZXNzXVxuICogQHBhcmFtIHtNZXNzYWdlQ2FsbGJhY2t9IFthcmdzLm9uTWVzc2FnZV1cbiAqIEBwYXJhbSB7QXV0aENhbGxiYWNrfSBbYXJncy5vbkF1dGhdXG4gKiBAcGFyYW0ge0F1dGhGYWlsdXJlQ2FsbGJhY2t9IFthcmdzLm9uQXV0aEZhaWx1cmVdXG4gKiBAcGFyYW0ge0F1dGhTdWNjZXNzQ2FsbGJhY2t9IFthcmdzLm9uQXV0aFN1Y2Nlc3NdXG4gKiBAcGFyYW0ge3N0cmluZ30gYXJncy5naXRkaXJcbiAqIEBwYXJhbSB7c3RyaW5nfHZvaWR9IFthcmdzLnVybF1cbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5jb3JzUHJveHldXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MucmVmXVxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLnJlbW90ZVJlZl1cbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5yZW1vdGVdXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFthcmdzLnNpbmdsZUJyYW5jaCA9IGZhbHNlXVxuICogQHBhcmFtIHtib29sZWFufSBbYXJncy50YWdzID0gZmFsc2VdXG4gKiBAcGFyYW0ge251bWJlcn0gW2FyZ3MuZGVwdGhdXG4gKiBAcGFyYW0ge0RhdGV9IFthcmdzLnNpbmNlXVxuICogQHBhcmFtIHtzdHJpbmdbXX0gW2FyZ3MuZXhjbHVkZSA9IFtdXVxuICogQHBhcmFtIHtib29sZWFufSBbYXJncy5yZWxhdGl2ZSA9IGZhbHNlXVxuICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLCBzdHJpbmc+fSBbYXJncy5oZWFkZXJzXVxuICogQHBhcmFtIHtib29sZWFufSBbYXJncy5wcnVuZV1cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2FyZ3MucHJ1bmVUYWdzXVxuICpcbiAqIEByZXR1cm5zIHtQcm9taXNlPEZldGNoUmVzdWx0Pn1cbiAqIEBzZWUgRmV0Y2hSZXN1bHRcbiAqL1xuYXN5bmMgZnVuY3Rpb24gX2ZldGNoKHtcbiAgZnMsXG4gIGNhY2hlLFxuICBodHRwLFxuICBvblByb2dyZXNzLFxuICBvbk1lc3NhZ2UsXG4gIG9uQXV0aCxcbiAgb25BdXRoU3VjY2VzcyxcbiAgb25BdXRoRmFpbHVyZSxcbiAgZ2l0ZGlyLFxuICByZWY6IF9yZWYsXG4gIHJlbW90ZVJlZjogX3JlbW90ZVJlZixcbiAgcmVtb3RlOiBfcmVtb3RlLFxuICB1cmw6IF91cmwsXG4gIGNvcnNQcm94eSxcbiAgZGVwdGggPSBudWxsLFxuICBzaW5jZSA9IG51bGwsXG4gIGV4Y2x1ZGUgPSBbXSxcbiAgcmVsYXRpdmUgPSBmYWxzZSxcbiAgdGFncyA9IGZhbHNlLFxuICBzaW5nbGVCcmFuY2ggPSBmYWxzZSxcbiAgaGVhZGVycyA9IHt9LFxuICBwcnVuZSA9IGZhbHNlLFxuICBwcnVuZVRhZ3MgPSBmYWxzZSxcbn0pIHtcbiAgY29uc3QgcmVmID0gX3JlZiB8fCAoYXdhaXQgX2N1cnJlbnRCcmFuY2goeyBmcywgZ2l0ZGlyLCB0ZXN0OiB0cnVlIH0pKTtcbiAgY29uc3QgY29uZmlnID0gYXdhaXQgR2l0Q29uZmlnTWFuYWdlci5nZXQoeyBmcywgZ2l0ZGlyIH0pO1xuICAvLyBGaWd1cmUgb3V0IHdoYXQgcmVtb3RlIHRvIHVzZS5cbiAgY29uc3QgcmVtb3RlID1cbiAgICBfcmVtb3RlIHx8IChyZWYgJiYgKGF3YWl0IGNvbmZpZy5nZXQoYGJyYW5jaC4ke3JlZn0ucmVtb3RlYCkpKSB8fCAnb3JpZ2luJztcbiAgLy8gTG9va3VwIHRoZSBVUkwgZm9yIHRoZSBnaXZlbiByZW1vdGUuXG4gIGNvbnN0IHVybCA9IF91cmwgfHwgKGF3YWl0IGNvbmZpZy5nZXQoYHJlbW90ZS4ke3JlbW90ZX0udXJsYCkpO1xuICBpZiAodHlwZW9mIHVybCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB0aHJvdyBuZXcgTWlzc2luZ1BhcmFtZXRlckVycm9yKCdyZW1vdGUgT1IgdXJsJylcbiAgfVxuICAvLyBGaWd1cmUgb3V0IHdoYXQgcmVtb3RlIHJlZiB0byB1c2UuXG4gIGNvbnN0IHJlbW90ZVJlZiA9XG4gICAgX3JlbW90ZVJlZiB8fFxuICAgIChyZWYgJiYgKGF3YWl0IGNvbmZpZy5nZXQoYGJyYW5jaC4ke3JlZn0ubWVyZ2VgKSkpIHx8XG4gICAgX3JlZiB8fFxuICAgICdIRUFEJztcblxuICBpZiAoY29yc1Byb3h5ID09PSB1bmRlZmluZWQpIHtcbiAgICBjb3JzUHJveHkgPSBhd2FpdCBjb25maWcuZ2V0KCdodHRwLmNvcnNQcm94eScpO1xuICB9XG5cbiAgY29uc3QgR2l0UmVtb3RlSFRUUCA9IEdpdFJlbW90ZU1hbmFnZXIuZ2V0UmVtb3RlSGVscGVyRm9yKHsgdXJsIH0pO1xuICBjb25zdCByZW1vdGVIVFRQID0gYXdhaXQgR2l0UmVtb3RlSFRUUC5kaXNjb3Zlcih7XG4gICAgaHR0cCxcbiAgICBvbkF1dGgsXG4gICAgb25BdXRoU3VjY2VzcyxcbiAgICBvbkF1dGhGYWlsdXJlLFxuICAgIGNvcnNQcm94eSxcbiAgICBzZXJ2aWNlOiAnZ2l0LXVwbG9hZC1wYWNrJyxcbiAgICB1cmwsXG4gICAgaGVhZGVycyxcbiAgICBwcm90b2NvbFZlcnNpb246IDEsXG4gIH0pO1xuICBjb25zdCBhdXRoID0gcmVtb3RlSFRUUC5hdXRoOyAvLyBoYWNrIHRvIGdldCBuZXcgY3JlZGVudGlhbHMgZnJvbSBDcmVkZW50aWFsTWFuYWdlciBBUElcbiAgY29uc3QgcmVtb3RlUmVmcyA9IHJlbW90ZUhUVFAucmVmcztcbiAgLy8gRm9yIHRoZSBzcGVjaWFsIGNhc2Ugb2YgYW4gZW1wdHkgcmVwb3NpdG9yeSB3aXRoIG5vIHJlZnMsIHJldHVybiBudWxsLlxuICBpZiAocmVtb3RlUmVmcy5zaXplID09PSAwKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRlZmF1bHRCcmFuY2g6IG51bGwsXG4gICAgICBmZXRjaEhlYWQ6IG51bGwsXG4gICAgICBmZXRjaEhlYWREZXNjcmlwdGlvbjogbnVsbCxcbiAgICB9XG4gIH1cbiAgLy8gQ2hlY2sgdGhhdCB0aGUgcmVtb3RlIHN1cHBvcnRzIHRoZSByZXF1ZXN0ZWQgZmVhdHVyZXNcbiAgaWYgKGRlcHRoICE9PSBudWxsICYmICFyZW1vdGVIVFRQLmNhcGFiaWxpdGllcy5oYXMoJ3NoYWxsb3cnKSkge1xuICAgIHRocm93IG5ldyBSZW1vdGVDYXBhYmlsaXR5RXJyb3IoJ3NoYWxsb3cnLCAnZGVwdGgnKVxuICB9XG4gIGlmIChzaW5jZSAhPT0gbnVsbCAmJiAhcmVtb3RlSFRUUC5jYXBhYmlsaXRpZXMuaGFzKCdkZWVwZW4tc2luY2UnKSkge1xuICAgIHRocm93IG5ldyBSZW1vdGVDYXBhYmlsaXR5RXJyb3IoJ2RlZXBlbi1zaW5jZScsICdzaW5jZScpXG4gIH1cbiAgaWYgKGV4Y2x1ZGUubGVuZ3RoID4gMCAmJiAhcmVtb3RlSFRUUC5jYXBhYmlsaXRpZXMuaGFzKCdkZWVwZW4tbm90JykpIHtcbiAgICB0aHJvdyBuZXcgUmVtb3RlQ2FwYWJpbGl0eUVycm9yKCdkZWVwZW4tbm90JywgJ2V4Y2x1ZGUnKVxuICB9XG4gIGlmIChyZWxhdGl2ZSA9PT0gdHJ1ZSAmJiAhcmVtb3RlSFRUUC5jYXBhYmlsaXRpZXMuaGFzKCdkZWVwZW4tcmVsYXRpdmUnKSkge1xuICAgIHRocm93IG5ldyBSZW1vdGVDYXBhYmlsaXR5RXJyb3IoJ2RlZXBlbi1yZWxhdGl2ZScsICdyZWxhdGl2ZScpXG4gIH1cbiAgLy8gRmlndXJlIG91dCB0aGUgU0hBIGZvciB0aGUgcmVxdWVzdGVkIHJlZlxuICBjb25zdCB7IG9pZCwgZnVsbHJlZiB9ID0gR2l0UmVmTWFuYWdlci5yZXNvbHZlQWdhaW5zdE1hcCh7XG4gICAgcmVmOiByZW1vdGVSZWYsXG4gICAgbWFwOiByZW1vdGVSZWZzLFxuICB9KTtcbiAgLy8gRmlsdGVyIG91dCByZWZzIHdlIHdhbnQgdG8gaWdub3JlOiBvbmx5IGtlZXAgcmVmIHdlJ3JlIGNsb25pbmcsIEhFQUQsIGJyYW5jaGVzLCBhbmQgdGFncyAoaWYgd2UncmUga2VlcGluZyB0aGVtKVxuICBmb3IgKGNvbnN0IHJlbW90ZVJlZiBvZiByZW1vdGVSZWZzLmtleXMoKSkge1xuICAgIGlmIChcbiAgICAgIHJlbW90ZVJlZiA9PT0gZnVsbHJlZiB8fFxuICAgICAgcmVtb3RlUmVmID09PSAnSEVBRCcgfHxcbiAgICAgIHJlbW90ZVJlZi5zdGFydHNXaXRoKCdyZWZzL2hlYWRzLycpIHx8XG4gICAgICAodGFncyAmJiByZW1vdGVSZWYuc3RhcnRzV2l0aCgncmVmcy90YWdzLycpKVxuICAgICkge1xuICAgICAgY29udGludWVcbiAgICB9XG4gICAgcmVtb3RlUmVmcy5kZWxldGUocmVtb3RlUmVmKTtcbiAgfVxuICAvLyBBc3NlbWJsZSB0aGUgYXBwbGljYXRpb24veC1naXQtdXBsb2FkLXBhY2stcmVxdWVzdFxuICBjb25zdCBjYXBhYmlsaXRpZXMgPSBmaWx0ZXJDYXBhYmlsaXRpZXMoXG4gICAgWy4uLnJlbW90ZUhUVFAuY2FwYWJpbGl0aWVzXSxcbiAgICBbXG4gICAgICAnbXVsdGlfYWNrX2RldGFpbGVkJyxcbiAgICAgICduby1kb25lJyxcbiAgICAgICdzaWRlLWJhbmQtNjRrJyxcbiAgICAgIC8vIE5vdGU6IEkgcmVtb3ZlZCAndGhpbi1wYWNrJyBvcHRpb24gc2luY2Ugb3VyIGNvZGUgZG9lc24ndCBcImZhdHRlblwiIHBhY2tmaWxlcyxcbiAgICAgIC8vIHdoaWNoIGlzIG5lY2Vzc2FyeSBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIGdpdC4gSXQgd2FzIHRoZSBjYXVzZSBvZiBteXN0ZXJpb3VzXG4gICAgICAvLyAnZmF0YWw6IHBhY2sgaGFzIFt4XSB1bnJlc29sdmVkIGRlbHRhcycgZXJyb3JzIHRoYXQgcGxhZ3VlZCB1cyBmb3Igc29tZSB0aW1lLlxuICAgICAgLy8gaXNvbW9ycGhpYy1naXQgaXMgcGVyZmVjdGx5IGhhcHB5IHdpdGggdGhpbiBwYWNrZmlsZXMgaW4gLmdpdC9vYmplY3RzL3BhY2sgYnV0XG4gICAgICAvLyBjYW5vbmljYWwgZ2l0IGl0IHR1cm5zIG91dCBpcyBOT1QuXG4gICAgICAnb2ZzLWRlbHRhJyxcbiAgICAgIGBhZ2VudD0ke3BrZy5hZ2VudH1gLFxuICAgIF1cbiAgKTtcbiAgaWYgKHJlbGF0aXZlKSBjYXBhYmlsaXRpZXMucHVzaCgnZGVlcGVuLXJlbGF0aXZlJyk7XG4gIC8vIFN0YXJ0IGZpZ3VyaW5nIG91dCB3aGljaCBvaWRzIGZyb20gdGhlIHJlbW90ZSB3ZSB3YW50IHRvIHJlcXVlc3RcbiAgY29uc3Qgd2FudHMgPSBzaW5nbGVCcmFuY2ggPyBbb2lkXSA6IHJlbW90ZVJlZnMudmFsdWVzKCk7XG4gIC8vIENvbWUgdXAgd2l0aCBhIHJlYXNvbmFibGUgbGlzdCBvZiBvaWRzIHRvIHRlbGwgdGhlIHJlbW90ZSB3ZSBhbHJlYWR5IGhhdmVcbiAgLy8gKHByZWZlcmFibHkgb2lkcyB0aGF0IGFyZSBjbG9zZSBhbmNlc3RvcnMgb2YgdGhlIGJyYW5jaCBoZWFkcyB3ZSdyZSBmZXRjaGluZylcbiAgY29uc3QgaGF2ZVJlZnMgPSBzaW5nbGVCcmFuY2hcbiAgICA/IFtyZWZdXG4gICAgOiBhd2FpdCBHaXRSZWZNYW5hZ2VyLmxpc3RSZWZzKHtcbiAgICAgICAgZnMsXG4gICAgICAgIGdpdGRpcixcbiAgICAgICAgZmlsZXBhdGg6IGByZWZzYCxcbiAgICAgIH0pO1xuICBsZXQgaGF2ZXMgPSBbXTtcbiAgZm9yIChsZXQgcmVmIG9mIGhhdmVSZWZzKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJlZiA9IGF3YWl0IEdpdFJlZk1hbmFnZXIuZXhwYW5kKHsgZnMsIGdpdGRpciwgcmVmIH0pO1xuICAgICAgY29uc3Qgb2lkID0gYXdhaXQgR2l0UmVmTWFuYWdlci5yZXNvbHZlKHsgZnMsIGdpdGRpciwgcmVmIH0pO1xuICAgICAgaWYgKGF3YWl0IGhhc09iamVjdCh7IGZzLCBjYWNoZSwgZ2l0ZGlyLCBvaWQgfSkpIHtcbiAgICAgICAgaGF2ZXMucHVzaChvaWQpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge31cbiAgfVxuICBoYXZlcyA9IFsuLi5uZXcgU2V0KGhhdmVzKV07XG4gIGNvbnN0IG9pZHMgPSBhd2FpdCBHaXRTaGFsbG93TWFuYWdlci5yZWFkKHsgZnMsIGdpdGRpciB9KTtcbiAgY29uc3Qgc2hhbGxvd3MgPSByZW1vdGVIVFRQLmNhcGFiaWxpdGllcy5oYXMoJ3NoYWxsb3cnKSA/IFsuLi5vaWRzXSA6IFtdO1xuICBjb25zdCBwYWNrc3RyZWFtID0gd3JpdGVVcGxvYWRQYWNrUmVxdWVzdCh7XG4gICAgY2FwYWJpbGl0aWVzLFxuICAgIHdhbnRzLFxuICAgIGhhdmVzLFxuICAgIHNoYWxsb3dzLFxuICAgIGRlcHRoLFxuICAgIHNpbmNlLFxuICAgIGV4Y2x1ZGUsXG4gIH0pO1xuICAvLyBDb2RlQ29tbWl0IHdpbGwgaGFuZyB1cCBpZiB3ZSBkb24ndCBzZW5kIGEgQ29udGVudC1MZW5ndGggaGVhZGVyXG4gIC8vIHNvIHdlIGNhbid0IHN0cmVhbSB0aGUgYm9keS5cbiAgY29uc3QgcGFja2J1ZmZlciA9IEJ1ZmZlci5mcm9tKGF3YWl0IGNvbGxlY3QocGFja3N0cmVhbSkpO1xuICBjb25zdCByYXcgPSBhd2FpdCBHaXRSZW1vdGVIVFRQLmNvbm5lY3Qoe1xuICAgIGh0dHAsXG4gICAgb25Qcm9ncmVzcyxcbiAgICBjb3JzUHJveHksXG4gICAgc2VydmljZTogJ2dpdC11cGxvYWQtcGFjaycsXG4gICAgdXJsLFxuICAgIGF1dGgsXG4gICAgYm9keTogW3BhY2tidWZmZXJdLFxuICAgIGhlYWRlcnMsXG4gIH0pO1xuICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHBhcnNlVXBsb2FkUGFja1Jlc3BvbnNlKHJhdy5ib2R5KTtcbiAgaWYgKHJhdy5oZWFkZXJzKSB7XG4gICAgcmVzcG9uc2UuaGVhZGVycyA9IHJhdy5oZWFkZXJzO1xuICB9XG4gIC8vIEFwcGx5IGFsbCB0aGUgJ3NoYWxsb3cnIGFuZCAndW5zaGFsbG93JyBjb21tYW5kc1xuICBmb3IgKGNvbnN0IG9pZCBvZiByZXNwb25zZS5zaGFsbG93cykge1xuICAgIGlmICghb2lkcy5oYXMob2lkKSkge1xuICAgICAgLy8gdGhpcyBpcyBpbiBhIHRyeS9jYXRjaCBtb3N0bHkgYmVjYXVzZSBteSBvbGQgdGVzdCBmaXh0dXJlcyBhcmUgbWlzc2luZyBvYmplY3RzXG4gICAgICB0cnkge1xuICAgICAgICAvLyBzZXJ2ZXIgc2F5cyBpdCdzIHNoYWxsb3csIGJ1dCBkbyB3ZSBoYXZlIHRoZSBwYXJlbnRzP1xuICAgICAgICBjb25zdCB7IG9iamVjdCB9ID0gYXdhaXQgX3JlYWRPYmplY3QoeyBmcywgY2FjaGUsIGdpdGRpciwgb2lkIH0pO1xuICAgICAgICBjb25zdCBjb21taXQgPSBuZXcgR2l0Q29tbWl0KG9iamVjdCk7XG4gICAgICAgIGNvbnN0IGhhc1BhcmVudHMgPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgICAgICBjb21taXRcbiAgICAgICAgICAgIC5oZWFkZXJzKClcbiAgICAgICAgICAgIC5wYXJlbnQubWFwKG9pZCA9PiBoYXNPYmplY3QoeyBmcywgY2FjaGUsIGdpdGRpciwgb2lkIH0pKVxuICAgICAgICApO1xuICAgICAgICBjb25zdCBoYXZlQWxsUGFyZW50cyA9XG4gICAgICAgICAgaGFzUGFyZW50cy5sZW5ndGggPT09IDAgfHwgaGFzUGFyZW50cy5ldmVyeShoYXMgPT4gaGFzKTtcbiAgICAgICAgaWYgKCFoYXZlQWxsUGFyZW50cykge1xuICAgICAgICAgIG9pZHMuYWRkKG9pZCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBvaWRzLmFkZChvaWQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmb3IgKGNvbnN0IG9pZCBvZiByZXNwb25zZS51bnNoYWxsb3dzKSB7XG4gICAgb2lkcy5kZWxldGUob2lkKTtcbiAgfVxuICBhd2FpdCBHaXRTaGFsbG93TWFuYWdlci53cml0ZSh7IGZzLCBnaXRkaXIsIG9pZHMgfSk7XG4gIC8vIFVwZGF0ZSBsb2NhbCByZW1vdGUgcmVmc1xuICBpZiAoc2luZ2xlQnJhbmNoKSB7XG4gICAgY29uc3QgcmVmcyA9IG5ldyBNYXAoW1tmdWxscmVmLCBvaWRdXSk7XG4gICAgLy8gQnV0IHdhaXQsIG1heWJlIGl0IHdhcyBhIHN5bXJlZiwgbGlrZSAnSEVBRCchXG4gICAgLy8gV2UgbmVlZCB0byBzYXZlIGFsbCB0aGUgcmVmcyBpbiB0aGUgc3ltcmVmIGNoYWluIChzaWdoKS5cbiAgICBjb25zdCBzeW1yZWZzID0gbmV3IE1hcCgpO1xuICAgIGxldCBiYWlsID0gMTA7XG4gICAgbGV0IGtleSA9IGZ1bGxyZWY7XG4gICAgd2hpbGUgKGJhaWwtLSkge1xuICAgICAgY29uc3QgdmFsdWUgPSByZW1vdGVIVFRQLnN5bXJlZnMuZ2V0KGtleSk7XG4gICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkgYnJlYWtcbiAgICAgIHN5bXJlZnMuc2V0KGtleSwgdmFsdWUpO1xuICAgICAga2V5ID0gdmFsdWU7XG4gICAgfVxuICAgIC8vIGZpbmFsIHZhbHVlIG11c3Qgbm90IGJlIGEgc3ltcmVmIGJ1dCBhIHJlYWwgcmVmXG4gICAgY29uc3QgcmVhbFJlZiA9IHJlbW90ZVJlZnMuZ2V0KGtleSk7XG4gICAgLy8gVGhlcmUgbWF5IGJlIG5vIHJlZiBhdCBhbGwgaWYgd2UndmUgZmV0Y2hlZCBhIHNwZWNpZmljIGNvbW1pdCBoYXNoXG4gICAgaWYgKHJlYWxSZWYpIHtcbiAgICAgIHJlZnMuc2V0KGtleSwgcmVhbFJlZik7XG4gICAgfVxuICAgIGNvbnN0IHsgcHJ1bmVkIH0gPSBhd2FpdCBHaXRSZWZNYW5hZ2VyLnVwZGF0ZVJlbW90ZVJlZnMoe1xuICAgICAgZnMsXG4gICAgICBnaXRkaXIsXG4gICAgICByZW1vdGUsXG4gICAgICByZWZzLFxuICAgICAgc3ltcmVmcyxcbiAgICAgIHRhZ3MsXG4gICAgICBwcnVuZSxcbiAgICB9KTtcbiAgICBpZiAocHJ1bmUpIHtcbiAgICAgIHJlc3BvbnNlLnBydW5lZCA9IHBydW5lZDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgeyBwcnVuZWQgfSA9IGF3YWl0IEdpdFJlZk1hbmFnZXIudXBkYXRlUmVtb3RlUmVmcyh7XG4gICAgICBmcyxcbiAgICAgIGdpdGRpcixcbiAgICAgIHJlbW90ZSxcbiAgICAgIHJlZnM6IHJlbW90ZVJlZnMsXG4gICAgICBzeW1yZWZzOiByZW1vdGVIVFRQLnN5bXJlZnMsXG4gICAgICB0YWdzLFxuICAgICAgcHJ1bmUsXG4gICAgICBwcnVuZVRhZ3MsXG4gICAgfSk7XG4gICAgaWYgKHBydW5lKSB7XG4gICAgICByZXNwb25zZS5wcnVuZWQgPSBwcnVuZWQ7XG4gICAgfVxuICB9XG4gIC8vIFdlIG5lZWQgdGhpcyB2YWx1ZSBsYXRlciBmb3IgdGhlIGBjbG9uZWAgY29tbWFuZC5cbiAgcmVzcG9uc2UuSEVBRCA9IHJlbW90ZUhUVFAuc3ltcmVmcy5nZXQoJ0hFQUQnKTtcbiAgLy8gQVdTIENvZGVDb21taXQgZG9lc24ndCBsaXN0IEhFQUQgYXMgYSBzeW1yZWYsIGJ1dCB3ZSBjYW4gcmV2ZXJzZSBlbmdpbmVlciBpdFxuICAvLyBGaW5kIHRoZSBTSEEgb2YgdGhlIGJyYW5jaCBjYWxsZWQgSEVBRFxuICBpZiAocmVzcG9uc2UuSEVBRCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgY29uc3QgeyBvaWQgfSA9IEdpdFJlZk1hbmFnZXIucmVzb2x2ZUFnYWluc3RNYXAoe1xuICAgICAgcmVmOiAnSEVBRCcsXG4gICAgICBtYXA6IHJlbW90ZVJlZnMsXG4gICAgfSk7XG4gICAgLy8gVXNlIHRoZSBuYW1lIG9mIHRoZSBmaXJzdCBicmFuY2ggdGhhdCdzIG5vdCBjYWxsZWQgSEVBRCB0aGF0IGhhc1xuICAgIC8vIHRoZSBzYW1lIFNIQSBhcyB0aGUgYnJhbmNoIGNhbGxlZCBIRUFELlxuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHJlbW90ZVJlZnMuZW50cmllcygpKSB7XG4gICAgICBpZiAoa2V5ICE9PSAnSEVBRCcgJiYgdmFsdWUgPT09IG9pZCkge1xuICAgICAgICByZXNwb25zZS5IRUFEID0ga2V5O1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjb25zdCBub3VuID0gZnVsbHJlZi5zdGFydHNXaXRoKCdyZWZzL3RhZ3MnKSA/ICd0YWcnIDogJ2JyYW5jaCc7XG4gIHJlc3BvbnNlLkZFVENIX0hFQUQgPSB7XG4gICAgb2lkLFxuICAgIGRlc2NyaXB0aW9uOiBgJHtub3VufSAnJHthYmJyZXZpYXRlUmVmKGZ1bGxyZWYpfScgb2YgJHt1cmx9YCxcbiAgfTtcblxuICBpZiAob25Qcm9ncmVzcyB8fCBvbk1lc3NhZ2UpIHtcbiAgICBjb25zdCBsaW5lcyA9IHNwbGl0TGluZXMocmVzcG9uc2UucHJvZ3Jlc3MpO1xuICAgIGZvckF3YWl0KGxpbmVzLCBhc3luYyBsaW5lID0+IHtcbiAgICAgIGlmIChvbk1lc3NhZ2UpIGF3YWl0IG9uTWVzc2FnZShsaW5lKTtcbiAgICAgIGlmIChvblByb2dyZXNzKSB7XG4gICAgICAgIGNvbnN0IG1hdGNoZXMgPSBsaW5lLm1hdGNoKC8oW146XSopLipcXCgoXFxkKz8pXFwvKFxcZCs/KVxcKS8pO1xuICAgICAgICBpZiAobWF0Y2hlcykge1xuICAgICAgICAgIGF3YWl0IG9uUHJvZ3Jlc3Moe1xuICAgICAgICAgICAgcGhhc2U6IG1hdGNoZXNbMV0udHJpbSgpLFxuICAgICAgICAgICAgbG9hZGVkOiBwYXJzZUludChtYXRjaGVzWzJdLCAxMCksXG4gICAgICAgICAgICB0b3RhbDogcGFyc2VJbnQobWF0Y2hlc1szXSwgMTApLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgY29uc3QgcGFja2ZpbGUgPSBCdWZmZXIuZnJvbShhd2FpdCBjb2xsZWN0KHJlc3BvbnNlLnBhY2tmaWxlKSk7XG4gIGNvbnN0IHBhY2tmaWxlU2hhID0gcGFja2ZpbGUuc2xpY2UoLTIwKS50b1N0cmluZygnaGV4Jyk7XG4gIGNvbnN0IHJlcyA9IHtcbiAgICBkZWZhdWx0QnJhbmNoOiByZXNwb25zZS5IRUFELFxuICAgIGZldGNoSGVhZDogcmVzcG9uc2UuRkVUQ0hfSEVBRC5vaWQsXG4gICAgZmV0Y2hIZWFkRGVzY3JpcHRpb246IHJlc3BvbnNlLkZFVENIX0hFQUQuZGVzY3JpcHRpb24sXG4gIH07XG4gIGlmIChyZXNwb25zZS5oZWFkZXJzKSB7XG4gICAgcmVzLmhlYWRlcnMgPSByZXNwb25zZS5oZWFkZXJzO1xuICB9XG4gIGlmIChwcnVuZSkge1xuICAgIHJlcy5wcnVuZWQgPSByZXNwb25zZS5wcnVuZWQ7XG4gIH1cbiAgLy8gVGhpcyBpcyBhIHF1aWNrIGZpeCBmb3IgdGhlIGVtcHR5IC5naXQvb2JqZWN0cy9wYWNrL3BhY2stLnBhY2sgZmlsZSBlcnJvcixcbiAgLy8gd2hpY2ggZHVlIHRvIHRoZSB3YXkgYGdpdC1saXN0LXBhY2tgIHdvcmtzIGNhdXNlcyB0aGUgcHJvZ3JhbSB0byBoYW5nIHdoZW4gaXQgdHJpZXMgdG8gcmVhZCBpdC5cbiAgLy8gVE9ETzogTG9uZ2VyIHRlcm0sIHdlIHNob3VsZCBhY3R1YWxseTpcbiAgLy8gYSkgTk9UIGNvbmNhdGVuYXRlIHRoZSBlbnRpcmUgcGFja2ZpbGUgaW50byBtZW1vcnkgKGxpbmUgNzgpLFxuICAvLyBiKSBjb21wdXRlIHRoZSBTSEEgb2YgdGhlIHN0cmVhbSBleGNlcHQgZm9yIHRoZSBsYXN0IDIwIGJ5dGVzLCB1c2luZyB0aGUgc2FtZSBsaWJyYXJ5IHVzZWQgaW4gcHVzaC5qcywgYW5kXG4gIC8vIGMpIGNvbXBhcmUgdGhlIGNvbXB1dGVkIFNIQSB3aXRoIHRoZSBsYXN0IDIwIGJ5dGVzIG9mIHRoZSBzdHJlYW0gYmVmb3JlIHNhdmluZyB0byBkaXNrLCBhbmQgdGhyb3dpbmcgYSBcInBhY2tmaWxlIGdvdCBjb3JydXB0ZWQgZHVyaW5nIGRvd25sb2FkXCIgZXJyb3IgaWYgdGhlIFNIQSBkb2Vzbid0IG1hdGNoLlxuICBpZiAocGFja2ZpbGVTaGEgIT09ICcnICYmICFlbXB0eVBhY2tmaWxlKHBhY2tmaWxlKSkge1xuICAgIHJlcy5wYWNrZmlsZSA9IGBvYmplY3RzL3BhY2svcGFjay0ke3BhY2tmaWxlU2hhfS5wYWNrYDtcbiAgICBjb25zdCBmdWxscGF0aCA9IGpvaW4oZ2l0ZGlyLCByZXMucGFja2ZpbGUpO1xuICAgIGF3YWl0IGZzLndyaXRlKGZ1bGxwYXRoLCBwYWNrZmlsZSk7XG4gICAgY29uc3QgZ2V0RXh0ZXJuYWxSZWZEZWx0YSA9IG9pZCA9PiBfcmVhZE9iamVjdCh7IGZzLCBjYWNoZSwgZ2l0ZGlyLCBvaWQgfSk7XG4gICAgY29uc3QgaWR4ID0gYXdhaXQgR2l0UGFja0luZGV4LmZyb21QYWNrKHtcbiAgICAgIHBhY2s6IHBhY2tmaWxlLFxuICAgICAgZ2V0RXh0ZXJuYWxSZWZEZWx0YSxcbiAgICAgIG9uUHJvZ3Jlc3MsXG4gICAgfSk7XG4gICAgYXdhaXQgZnMud3JpdGUoZnVsbHBhdGgucmVwbGFjZSgvXFwucGFjayQvLCAnLmlkeCcpLCBhd2FpdCBpZHgudG9CdWZmZXIoKSk7XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vLyBAdHMtY2hlY2tcblxuLyoqXG4gKiBJbml0aWFsaXplIGEgbmV3IHJlcG9zaXRvcnlcbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gYXJnc1xuICogQHBhcmFtIHtpbXBvcnQoJy4uL21vZGVscy9GaWxlU3lzdGVtLmpzJykuRmlsZVN5c3RlbX0gYXJncy5mc1xuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLmRpcl1cbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5naXRkaXJdXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFthcmdzLmJhcmUgPSBmYWxzZV1cbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5kZWZhdWx0QnJhbmNoID0gJ21hc3RlciddXG4gKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAqL1xuYXN5bmMgZnVuY3Rpb24gX2luaXQoe1xuICBmcyxcbiAgYmFyZSA9IGZhbHNlLFxuICBkaXIsXG4gIGdpdGRpciA9IGJhcmUgPyBkaXIgOiBqb2luKGRpciwgJy5naXQnKSxcbiAgZGVmYXVsdEJyYW5jaCA9ICdtYXN0ZXInLFxufSkge1xuICAvLyBEb24ndCBvdmVyd3JpdGUgYW4gZXhpc3RpbmcgY29uZmlnXG4gIGlmIChhd2FpdCBmcy5leGlzdHMoZ2l0ZGlyICsgJy9jb25maWcnKSkgcmV0dXJuXG5cbiAgbGV0IGZvbGRlcnMgPSBbXG4gICAgJ2hvb2tzJyxcbiAgICAnaW5mbycsXG4gICAgJ29iamVjdHMvaW5mbycsXG4gICAgJ29iamVjdHMvcGFjaycsXG4gICAgJ3JlZnMvaGVhZHMnLFxuICAgICdyZWZzL3RhZ3MnLFxuICBdO1xuICBmb2xkZXJzID0gZm9sZGVycy5tYXAoZGlyID0+IGdpdGRpciArICcvJyArIGRpcik7XG4gIGZvciAoY29uc3QgZm9sZGVyIG9mIGZvbGRlcnMpIHtcbiAgICBhd2FpdCBmcy5ta2Rpcihmb2xkZXIpO1xuICB9XG5cbiAgYXdhaXQgZnMud3JpdGUoXG4gICAgZ2l0ZGlyICsgJy9jb25maWcnLFxuICAgICdbY29yZV1cXG4nICtcbiAgICAgICdcXHRyZXBvc2l0b3J5Zm9ybWF0dmVyc2lvbiA9IDBcXG4nICtcbiAgICAgICdcXHRmaWxlbW9kZSA9IGZhbHNlXFxuJyArXG4gICAgICBgXFx0YmFyZSA9ICR7YmFyZX1cXG5gICtcbiAgICAgIChiYXJlID8gJycgOiAnXFx0bG9nYWxscmVmdXBkYXRlcyA9IHRydWVcXG4nKSArXG4gICAgICAnXFx0c3ltbGlua3MgPSBmYWxzZVxcbicgK1xuICAgICAgJ1xcdGlnbm9yZWNhc2UgPSB0cnVlXFxuJ1xuICApO1xuICBhd2FpdCBmcy53cml0ZShnaXRkaXIgKyAnL0hFQUQnLCBgcmVmOiByZWZzL2hlYWRzLyR7ZGVmYXVsdEJyYW5jaH1cXG5gKTtcbn1cblxuLy8gQHRzLWNoZWNrXG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGFyZ3NcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9tb2RlbHMvRmlsZVN5c3RlbS5qcycpLkZpbGVTeXN0ZW19IGFyZ3MuZnNcbiAqIEBwYXJhbSB7b2JqZWN0fSBhcmdzLmNhY2hlXG4gKiBAcGFyYW0ge0h0dHBDbGllbnR9IGFyZ3MuaHR0cFxuICogQHBhcmFtIHtQcm9ncmVzc0NhbGxiYWNrfSBbYXJncy5vblByb2dyZXNzXVxuICogQHBhcmFtIHtNZXNzYWdlQ2FsbGJhY2t9IFthcmdzLm9uTWVzc2FnZV1cbiAqIEBwYXJhbSB7QXV0aENhbGxiYWNrfSBbYXJncy5vbkF1dGhdXG4gKiBAcGFyYW0ge0F1dGhGYWlsdXJlQ2FsbGJhY2t9IFthcmdzLm9uQXV0aEZhaWx1cmVdXG4gKiBAcGFyYW0ge0F1dGhTdWNjZXNzQ2FsbGJhY2t9IFthcmdzLm9uQXV0aFN1Y2Nlc3NdXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MuZGlyXVxuICogQHBhcmFtIHtzdHJpbmd9IGFyZ3MuZ2l0ZGlyXG4gKiBAcGFyYW0ge3N0cmluZ30gYXJncy51cmxcbiAqIEBwYXJhbSB7c3RyaW5nfSBhcmdzLmNvcnNQcm94eVxuICogQHBhcmFtIHtzdHJpbmd9IGFyZ3MucmVmXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGFyZ3Muc2luZ2xlQnJhbmNoXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGFyZ3Mubm9DaGVja291dFxuICogQHBhcmFtIHtib29sZWFufSBhcmdzLm5vVGFnc1xuICogQHBhcmFtIHtzdHJpbmd9IGFyZ3MucmVtb3RlXG4gKiBAcGFyYW0ge251bWJlcn0gYXJncy5kZXB0aFxuICogQHBhcmFtIHtEYXRlfSBhcmdzLnNpbmNlXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBhcmdzLmV4Y2x1ZGVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gYXJncy5yZWxhdGl2ZVxuICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLCBzdHJpbmc+fSBhcmdzLmhlYWRlcnNcbiAqXG4gKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn0gUmVzb2x2ZXMgc3VjY2Vzc2Z1bGx5IHdoZW4gY2xvbmUgY29tcGxldGVzXG4gKlxuICovXG5hc3luYyBmdW5jdGlvbiBfY2xvbmUoe1xuICBmcyxcbiAgY2FjaGUsXG4gIGh0dHAsXG4gIG9uUHJvZ3Jlc3MsXG4gIG9uTWVzc2FnZSxcbiAgb25BdXRoLFxuICBvbkF1dGhTdWNjZXNzLFxuICBvbkF1dGhGYWlsdXJlLFxuICBkaXIsXG4gIGdpdGRpcixcbiAgdXJsLFxuICBjb3JzUHJveHksXG4gIHJlZixcbiAgcmVtb3RlLFxuICBkZXB0aCxcbiAgc2luY2UsXG4gIGV4Y2x1ZGUsXG4gIHJlbGF0aXZlLFxuICBzaW5nbGVCcmFuY2gsXG4gIG5vQ2hlY2tvdXQsXG4gIG5vVGFncyxcbiAgaGVhZGVycyxcbn0pIHtcbiAgYXdhaXQgX2luaXQoeyBmcywgZ2l0ZGlyIH0pO1xuICBhd2FpdCBfYWRkUmVtb3RlKHsgZnMsIGdpdGRpciwgcmVtb3RlLCB1cmwsIGZvcmNlOiBmYWxzZSB9KTtcbiAgaWYgKGNvcnNQcm94eSkge1xuICAgIGNvbnN0IGNvbmZpZyA9IGF3YWl0IEdpdENvbmZpZ01hbmFnZXIuZ2V0KHsgZnMsIGdpdGRpciB9KTtcbiAgICBhd2FpdCBjb25maWcuc2V0KGBodHRwLmNvcnNQcm94eWAsIGNvcnNQcm94eSk7XG4gICAgYXdhaXQgR2l0Q29uZmlnTWFuYWdlci5zYXZlKHsgZnMsIGdpdGRpciwgY29uZmlnIH0pO1xuICB9XG4gIGNvbnN0IHsgZGVmYXVsdEJyYW5jaCwgZmV0Y2hIZWFkIH0gPSBhd2FpdCBfZmV0Y2goe1xuICAgIGZzLFxuICAgIGNhY2hlLFxuICAgIGh0dHAsXG4gICAgb25Qcm9ncmVzcyxcbiAgICBvbk1lc3NhZ2UsXG4gICAgb25BdXRoLFxuICAgIG9uQXV0aFN1Y2Nlc3MsXG4gICAgb25BdXRoRmFpbHVyZSxcbiAgICBnaXRkaXIsXG4gICAgcmVmLFxuICAgIHJlbW90ZSxcbiAgICBkZXB0aCxcbiAgICBzaW5jZSxcbiAgICBleGNsdWRlLFxuICAgIHJlbGF0aXZlLFxuICAgIHNpbmdsZUJyYW5jaCxcbiAgICBoZWFkZXJzLFxuICAgIHRhZ3M6ICFub1RhZ3MsXG4gIH0pO1xuICBpZiAoZmV0Y2hIZWFkID09PSBudWxsKSByZXR1cm5cbiAgcmVmID0gcmVmIHx8IGRlZmF1bHRCcmFuY2g7XG4gIHJlZiA9IHJlZi5yZXBsYWNlKCdyZWZzL2hlYWRzLycsICcnKTtcbiAgLy8gQ2hlY2tvdXQgdGhhdCBicmFuY2hcbiAgYXdhaXQgX2NoZWNrb3V0KHtcbiAgICBmcyxcbiAgICBjYWNoZSxcbiAgICBvblByb2dyZXNzLFxuICAgIGRpcixcbiAgICBnaXRkaXIsXG4gICAgcmVmLFxuICAgIHJlbW90ZSxcbiAgICBub0NoZWNrb3V0LFxuICB9KTtcbn1cblxuLy8gQHRzLWNoZWNrXG5cbi8qKlxuICogQ2xvbmUgYSByZXBvc2l0b3J5XG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGFyZ3NcbiAqIEBwYXJhbSB7RnNDbGllbnR9IGFyZ3MuZnMgLSBhIGZpbGUgc3lzdGVtIGltcGxlbWVudGF0aW9uXG4gKiBAcGFyYW0ge0h0dHBDbGllbnR9IGFyZ3MuaHR0cCAtIGFuIEhUVFAgY2xpZW50XG4gKiBAcGFyYW0ge1Byb2dyZXNzQ2FsbGJhY2t9IFthcmdzLm9uUHJvZ3Jlc3NdIC0gb3B0aW9uYWwgcHJvZ3Jlc3MgZXZlbnQgY2FsbGJhY2tcbiAqIEBwYXJhbSB7TWVzc2FnZUNhbGxiYWNrfSBbYXJncy5vbk1lc3NhZ2VdIC0gb3B0aW9uYWwgbWVzc2FnZSBldmVudCBjYWxsYmFja1xuICogQHBhcmFtIHtBdXRoQ2FsbGJhY2t9IFthcmdzLm9uQXV0aF0gLSBvcHRpb25hbCBhdXRoIGZpbGwgY2FsbGJhY2tcbiAqIEBwYXJhbSB7QXV0aEZhaWx1cmVDYWxsYmFja30gW2FyZ3Mub25BdXRoRmFpbHVyZV0gLSBvcHRpb25hbCBhdXRoIHJlamVjdGVkIGNhbGxiYWNrXG4gKiBAcGFyYW0ge0F1dGhTdWNjZXNzQ2FsbGJhY2t9IFthcmdzLm9uQXV0aFN1Y2Nlc3NdIC0gb3B0aW9uYWwgYXV0aCBhcHByb3ZlZCBjYWxsYmFja1xuICogQHBhcmFtIHtzdHJpbmd9IGFyZ3MuZGlyIC0gVGhlIFt3b3JraW5nIHRyZWVdKGRpci12cy1naXRkaXIubWQpIGRpcmVjdG9yeSBwYXRoXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MuZ2l0ZGlyPWpvaW4oZGlyLCcuZ2l0JyldIC0gW3JlcXVpcmVkXSBUaGUgW2dpdCBkaXJlY3RvcnldKGRpci12cy1naXRkaXIubWQpIHBhdGhcbiAqIEBwYXJhbSB7c3RyaW5nfSBhcmdzLnVybCAtIFRoZSBVUkwgb2YgdGhlIHJlbW90ZSByZXBvc2l0b3J5XG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MuY29yc1Byb3h5XSAtIE9wdGlvbmFsIFtDT1JTIHByb3h5XShodHRwczovL3d3dy5ucG1qcy5jb20vJTQwaXNvbW9ycGhpYy1naXQvY29ycy1wcm94eSkuIFZhbHVlIGlzIHN0b3JlZCBpbiB0aGUgZ2l0IGNvbmZpZyBmaWxlIGZvciB0aGF0IHJlcG8uXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MucmVmXSAtIFdoaWNoIGJyYW5jaCB0byBjaGVja291dC4gQnkgZGVmYXVsdCB0aGlzIGlzIHRoZSBkZXNpZ25hdGVkIFwibWFpbiBicmFuY2hcIiBvZiB0aGUgcmVwb3NpdG9yeS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2FyZ3Muc2luZ2xlQnJhbmNoID0gZmFsc2VdIC0gSW5zdGVhZCBvZiB0aGUgZGVmYXVsdCBiZWhhdmlvciBvZiBmZXRjaGluZyBhbGwgdGhlIGJyYW5jaGVzLCBvbmx5IGZldGNoIGEgc2luZ2xlIGJyYW5jaC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2FyZ3Mubm9DaGVja291dCA9IGZhbHNlXSAtIElmIHRydWUsIGNsb25lIHdpbGwgb25seSBmZXRjaCB0aGUgcmVwbywgbm90IGNoZWNrIG91dCBhIGJyYW5jaC4gU2tpcHBpbmcgY2hlY2tvdXQgY2FuIHNhdmUgYSBsb3Qgb2YgdGltZSBub3JtYWxseSBzcGVudCB3cml0aW5nIGZpbGVzIHRvIGRpc2suXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFthcmdzLm5vVGFncyA9IGZhbHNlXSAtIEJ5IGRlZmF1bHQgY2xvbmUgd2lsbCBmZXRjaCBhbGwgdGFncy4gYG5vVGFnc2AgZGlzYWJsZXMgdGhhdCBiZWhhdmlvci5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5yZW1vdGUgPSAnb3JpZ2luJ10gLSBXaGF0IHRvIG5hbWUgdGhlIHJlbW90ZSB0aGF0IGlzIGNyZWF0ZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gW2FyZ3MuZGVwdGhdIC0gSW50ZWdlci4gRGV0ZXJtaW5lcyBob3cgbXVjaCBvZiB0aGUgZ2l0IHJlcG9zaXRvcnkncyBoaXN0b3J5IHRvIHJldHJpZXZlXG4gKiBAcGFyYW0ge0RhdGV9IFthcmdzLnNpbmNlXSAtIE9ubHkgZmV0Y2ggY29tbWl0cyBjcmVhdGVkIGFmdGVyIHRoZSBnaXZlbiBkYXRlLiBNdXR1YWxseSBleGNsdXNpdmUgd2l0aCBgZGVwdGhgLlxuICogQHBhcmFtIHtzdHJpbmdbXX0gW2FyZ3MuZXhjbHVkZSA9IFtdXSAtIEEgbGlzdCBvZiBicmFuY2hlcyBvciB0YWdzLiBJbnN0cnVjdHMgdGhlIHJlbW90ZSBzZXJ2ZXIgbm90IHRvIHNlbmQgdXMgYW55IGNvbW1pdHMgcmVhY2hhYmxlIGZyb20gdGhlc2UgcmVmcy5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2FyZ3MucmVsYXRpdmUgPSBmYWxzZV0gLSBDaGFuZ2VzIHRoZSBtZWFuaW5nIG9mIGBkZXB0aGAgdG8gYmUgbWVhc3VyZWQgZnJvbSB0aGUgY3VycmVudCBzaGFsbG93IGRlcHRoIHJhdGhlciB0aGFuIGZyb20gdGhlIGJyYW5jaCB0aXAuXG4gKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsIHN0cmluZz59IFthcmdzLmhlYWRlcnMgPSB7fV0gLSBBZGRpdGlvbmFsIGhlYWRlcnMgdG8gaW5jbHVkZSBpbiBIVFRQIHJlcXVlc3RzLCBzaW1pbGFyIHRvIGdpdCdzIGBleHRyYUhlYWRlcmAgY29uZmlnXG4gKiBAcGFyYW0ge29iamVjdH0gW2FyZ3MuY2FjaGVdIC0gYSBbY2FjaGVdKGNhY2hlLm1kKSBvYmplY3RcbiAqXG4gKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn0gUmVzb2x2ZXMgc3VjY2Vzc2Z1bGx5IHdoZW4gY2xvbmUgY29tcGxldGVzXG4gKlxuICogQGV4YW1wbGVcbiAqIGF3YWl0IGdpdC5jbG9uZSh7XG4gKiAgIGZzLFxuICogICBodHRwLFxuICogICBkaXI6ICcvdHV0b3JpYWwnLFxuICogICBjb3JzUHJveHk6ICdodHRwczovL2NvcnMuaXNvbW9ycGhpYy1naXQub3JnJyxcbiAqICAgdXJsOiAnaHR0cHM6Ly9naXRodWIuY29tL2lzb21vcnBoaWMtZ2l0L2lzb21vcnBoaWMtZ2l0JyxcbiAqICAgc2luZ2xlQnJhbmNoOiB0cnVlLFxuICogICBkZXB0aDogMVxuICogfSlcbiAqIGNvbnNvbGUubG9nKCdkb25lJylcbiAqXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGNsb25lKHtcbiAgZnMsXG4gIGh0dHAsXG4gIG9uUHJvZ3Jlc3MsXG4gIG9uTWVzc2FnZSxcbiAgb25BdXRoLFxuICBvbkF1dGhTdWNjZXNzLFxuICBvbkF1dGhGYWlsdXJlLFxuICBkaXIsXG4gIGdpdGRpciA9IGpvaW4oZGlyLCAnLmdpdCcpLFxuICB1cmwsXG4gIGNvcnNQcm94eSA9IHVuZGVmaW5lZCxcbiAgcmVmID0gdW5kZWZpbmVkLFxuICByZW1vdGUgPSAnb3JpZ2luJyxcbiAgZGVwdGggPSB1bmRlZmluZWQsXG4gIHNpbmNlID0gdW5kZWZpbmVkLFxuICBleGNsdWRlID0gW10sXG4gIHJlbGF0aXZlID0gZmFsc2UsXG4gIHNpbmdsZUJyYW5jaCA9IGZhbHNlLFxuICBub0NoZWNrb3V0ID0gZmFsc2UsXG4gIG5vVGFncyA9IGZhbHNlLFxuICBoZWFkZXJzID0ge30sXG4gIGNhY2hlID0ge30sXG59KSB7XG4gIHRyeSB7XG4gICAgYXNzZXJ0UGFyYW1ldGVyKCdmcycsIGZzKTtcbiAgICBhc3NlcnRQYXJhbWV0ZXIoJ2h0dHAnLCBodHRwKTtcbiAgICBhc3NlcnRQYXJhbWV0ZXIoJ2dpdGRpcicsIGdpdGRpcik7XG4gICAgaWYgKCFub0NoZWNrb3V0KSB7XG4gICAgICBhc3NlcnRQYXJhbWV0ZXIoJ2RpcicsIGRpcik7XG4gICAgfVxuICAgIGFzc2VydFBhcmFtZXRlcigndXJsJywgdXJsKTtcblxuICAgIHJldHVybiBhd2FpdCBfY2xvbmUoe1xuICAgICAgZnM6IG5ldyBGaWxlU3lzdGVtKGZzKSxcbiAgICAgIGNhY2hlLFxuICAgICAgaHR0cCxcbiAgICAgIG9uUHJvZ3Jlc3MsXG4gICAgICBvbk1lc3NhZ2UsXG4gICAgICBvbkF1dGgsXG4gICAgICBvbkF1dGhTdWNjZXNzLFxuICAgICAgb25BdXRoRmFpbHVyZSxcbiAgICAgIGRpcixcbiAgICAgIGdpdGRpcixcbiAgICAgIHVybCxcbiAgICAgIGNvcnNQcm94eSxcbiAgICAgIHJlZixcbiAgICAgIHJlbW90ZSxcbiAgICAgIGRlcHRoLFxuICAgICAgc2luY2UsXG4gICAgICBleGNsdWRlLFxuICAgICAgcmVsYXRpdmUsXG4gICAgICBzaW5nbGVCcmFuY2gsXG4gICAgICBub0NoZWNrb3V0LFxuICAgICAgbm9UYWdzLFxuICAgICAgaGVhZGVycyxcbiAgICB9KVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBlcnIuY2FsbGVyID0gJ2dpdC5jbG9uZSc7XG4gICAgdGhyb3cgZXJyXG4gIH1cbn1cblxuLy8gQHRzLWNoZWNrXG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IGNvbW1pdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzXG4gKiBAcGFyYW0ge0ZzQ2xpZW50fSBhcmdzLmZzIC0gYSBmaWxlIHN5c3RlbSBpbXBsZW1lbnRhdGlvblxuICogQHBhcmFtIHtTaWduQ2FsbGJhY2t9IFthcmdzLm9uU2lnbl0gLSBhIFBHUCBzaWduaW5nIGltcGxlbWVudGF0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MuZGlyXSAtIFRoZSBbd29ya2luZyB0cmVlXShkaXItdnMtZ2l0ZGlyLm1kKSBkaXJlY3RvcnkgcGF0aFxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLmdpdGRpcj1qb2luKGRpciwnLmdpdCcpXSAtIFtyZXF1aXJlZF0gVGhlIFtnaXQgZGlyZWN0b3J5XShkaXItdnMtZ2l0ZGlyLm1kKSBwYXRoXG4gKiBAcGFyYW0ge3N0cmluZ30gYXJncy5tZXNzYWdlIC0gVGhlIGNvbW1pdCBtZXNzYWdlIHRvIHVzZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbYXJncy5hdXRob3JdIC0gVGhlIGRldGFpbHMgYWJvdXQgdGhlIGF1dGhvci5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5hdXRob3IubmFtZV0gLSBEZWZhdWx0IGlzIGB1c2VyLm5hbWVgIGNvbmZpZy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5hdXRob3IuZW1haWxdIC0gRGVmYXVsdCBpcyBgdXNlci5lbWFpbGAgY29uZmlnLlxuICogQHBhcmFtIHtudW1iZXJ9IFthcmdzLmF1dGhvci50aW1lc3RhbXA9TWF0aC5mbG9vcihEYXRlLm5vdygpLzEwMDApXSAtIFNldCB0aGUgYXV0aG9yIHRpbWVzdGFtcCBmaWVsZC4gVGhpcyBpcyB0aGUgaW50ZWdlciBudW1iZXIgb2Ygc2Vjb25kcyBzaW5jZSB0aGUgVW5peCBlcG9jaCAoMTk3MC0wMS0wMSAwMDowMDowMCkuXG4gKiBAcGFyYW0ge251bWJlcn0gW2FyZ3MuYXV0aG9yLnRpbWV6b25lT2Zmc2V0XSAtIFNldCB0aGUgYXV0aG9yIHRpbWV6b25lIG9mZnNldCBmaWVsZC4gVGhpcyBpcyB0aGUgZGlmZmVyZW5jZSwgaW4gbWludXRlcywgZnJvbSB0aGUgY3VycmVudCB0aW1lem9uZSB0byBVVEMuIERlZmF1bHQgaXMgYChuZXcgRGF0ZSgpKS5nZXRUaW1lem9uZU9mZnNldCgpYC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbYXJncy5jb21taXR0ZXIgPSBhdXRob3JdIC0gVGhlIGRldGFpbHMgYWJvdXQgdGhlIGNvbW1pdCBjb21taXR0ZXIsIGluIHRoZSBzYW1lIGZvcm1hdCBhcyB0aGUgYXV0aG9yIHBhcmFtZXRlci4gSWYgbm90IHNwZWNpZmllZCwgdGhlIGF1dGhvciBkZXRhaWxzIGFyZSB1c2VkLlxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLmNvbW1pdHRlci5uYW1lXSAtIERlZmF1bHQgaXMgYHVzZXIubmFtZWAgY29uZmlnLlxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLmNvbW1pdHRlci5lbWFpbF0gLSBEZWZhdWx0IGlzIGB1c2VyLmVtYWlsYCBjb25maWcuXG4gKiBAcGFyYW0ge251bWJlcn0gW2FyZ3MuY29tbWl0dGVyLnRpbWVzdGFtcD1NYXRoLmZsb29yKERhdGUubm93KCkvMTAwMCldIC0gU2V0IHRoZSBjb21taXR0ZXIgdGltZXN0YW1wIGZpZWxkLiBUaGlzIGlzIHRoZSBpbnRlZ2VyIG51bWJlciBvZiBzZWNvbmRzIHNpbmNlIHRoZSBVbml4IGVwb2NoICgxOTcwLTAxLTAxIDAwOjAwOjAwKS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbYXJncy5jb21taXR0ZXIudGltZXpvbmVPZmZzZXRdIC0gU2V0IHRoZSBjb21taXR0ZXIgdGltZXpvbmUgb2Zmc2V0IGZpZWxkLiBUaGlzIGlzIHRoZSBkaWZmZXJlbmNlLCBpbiBtaW51dGVzLCBmcm9tIHRoZSBjdXJyZW50IHRpbWV6b25lIHRvIFVUQy4gRGVmYXVsdCBpcyBgKG5ldyBEYXRlKCkpLmdldFRpbWV6b25lT2Zmc2V0KClgLlxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLnNpZ25pbmdLZXldIC0gU2lnbiB0aGUgdGFnIG9iamVjdCB1c2luZyB0aGlzIHByaXZhdGUgUEdQIGtleS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2FyZ3MuZHJ5UnVuID0gZmFsc2VdIC0gSWYgdHJ1ZSwgc2ltdWxhdGVzIG1ha2luZyBhIGNvbW1pdCBzbyB5b3UgY2FuIHRlc3Qgd2hldGhlciBpdCB3b3VsZCBzdWNjZWVkLiBJbXBsaWVzIGBub1VwZGF0ZUJyYW5jaGAuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFthcmdzLm5vVXBkYXRlQnJhbmNoID0gZmFsc2VdIC0gSWYgdHJ1ZSwgZG9lcyBub3QgdXBkYXRlIHRoZSBicmFuY2ggcG9pbnRlciBhZnRlciBjcmVhdGluZyB0aGUgY29tbWl0LlxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLnJlZl0gLSBUaGUgZnVsbHkgZXhwYW5kZWQgbmFtZSBvZiB0aGUgYnJhbmNoIHRvIGNvbW1pdCB0by4gRGVmYXVsdCBpcyB0aGUgY3VycmVudCBicmFuY2ggcG9pbnRlZCB0byBieSBIRUFELiAoVE9ETzogZml4IGl0IHNvIGl0IGNhbiBleHBhbmQgYnJhbmNoIG5hbWVzIHdpdGhvdXQgdGhyb3dpbmcgaWYgdGhlIGJyYW5jaCBkb2Vzbid0IGV4aXN0IHlldC4pXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBbYXJncy5wYXJlbnRdIC0gVGhlIFNIQS0xIG9iamVjdCBpZHMgb2YgdGhlIGNvbW1pdHMgdG8gdXNlIGFzIHBhcmVudHMuIElmIG5vdCBzcGVjaWZpZWQsIHRoZSBjb21taXQgcG9pbnRlZCB0byBieSBgcmVmYCBpcyB1c2VkLlxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLnRyZWVdIC0gVGhlIFNIQS0xIG9iamVjdCBpZCBvZiB0aGUgdHJlZSB0byB1c2UuIElmIG5vdCBzcGVjaWZpZWQsIGEgbmV3IHRyZWUgb2JqZWN0IGlzIGNyZWF0ZWQgZnJvbSB0aGUgY3VycmVudCBnaXQgaW5kZXguXG4gKiBAcGFyYW0ge29iamVjdH0gW2FyZ3MuY2FjaGVdIC0gYSBbY2FjaGVdKGNhY2hlLm1kKSBvYmplY3RcbiAqXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxzdHJpbmc+fSBSZXNvbHZlcyBzdWNjZXNzZnVsbHkgd2l0aCB0aGUgU0hBLTEgb2JqZWN0IGlkIG9mIHRoZSBuZXdseSBjcmVhdGVkIGNvbW1pdC5cbiAqXG4gKiBAZXhhbXBsZVxuICogbGV0IHNoYSA9IGF3YWl0IGdpdC5jb21taXQoe1xuICogICBmcyxcbiAqICAgZGlyOiAnL3R1dG9yaWFsJyxcbiAqICAgYXV0aG9yOiB7XG4gKiAgICAgbmFtZTogJ01yLiBUZXN0JyxcbiAqICAgICBlbWFpbDogJ21ydGVzdEBleGFtcGxlLmNvbScsXG4gKiAgIH0sXG4gKiAgIG1lc3NhZ2U6ICdBZGRlZCB0aGUgYS50eHQgZmlsZSdcbiAqIH0pXG4gKiBjb25zb2xlLmxvZyhzaGEpXG4gKlxuICovXG5hc3luYyBmdW5jdGlvbiBjb21taXQoe1xuICBmczogX2ZzLFxuICBvblNpZ24sXG4gIGRpcixcbiAgZ2l0ZGlyID0gam9pbihkaXIsICcuZ2l0JyksXG4gIG1lc3NhZ2UsXG4gIGF1dGhvcjogX2F1dGhvcixcbiAgY29tbWl0dGVyOiBfY29tbWl0dGVyLFxuICBzaWduaW5nS2V5LFxuICBkcnlSdW4gPSBmYWxzZSxcbiAgbm9VcGRhdGVCcmFuY2ggPSBmYWxzZSxcbiAgcmVmLFxuICBwYXJlbnQsXG4gIHRyZWUsXG4gIGNhY2hlID0ge30sXG59KSB7XG4gIHRyeSB7XG4gICAgYXNzZXJ0UGFyYW1ldGVyKCdmcycsIF9mcyk7XG4gICAgYXNzZXJ0UGFyYW1ldGVyKCdtZXNzYWdlJywgbWVzc2FnZSk7XG4gICAgaWYgKHNpZ25pbmdLZXkpIHtcbiAgICAgIGFzc2VydFBhcmFtZXRlcignb25TaWduJywgb25TaWduKTtcbiAgICB9XG4gICAgY29uc3QgZnMgPSBuZXcgRmlsZVN5c3RlbShfZnMpO1xuXG4gICAgY29uc3QgYXV0aG9yID0gYXdhaXQgbm9ybWFsaXplQXV0aG9yT2JqZWN0KHsgZnMsIGdpdGRpciwgYXV0aG9yOiBfYXV0aG9yIH0pO1xuICAgIGlmICghYXV0aG9yKSB0aHJvdyBuZXcgTWlzc2luZ05hbWVFcnJvcignYXV0aG9yJylcblxuICAgIGNvbnN0IGNvbW1pdHRlciA9IGF3YWl0IG5vcm1hbGl6ZUNvbW1pdHRlck9iamVjdCh7XG4gICAgICBmcyxcbiAgICAgIGdpdGRpcixcbiAgICAgIGF1dGhvcixcbiAgICAgIGNvbW1pdHRlcjogX2NvbW1pdHRlcixcbiAgICB9KTtcbiAgICBpZiAoIWNvbW1pdHRlcikgdGhyb3cgbmV3IE1pc3NpbmdOYW1lRXJyb3IoJ2NvbW1pdHRlcicpXG5cbiAgICByZXR1cm4gYXdhaXQgX2NvbW1pdCh7XG4gICAgICBmcyxcbiAgICAgIGNhY2hlLFxuICAgICAgb25TaWduLFxuICAgICAgZ2l0ZGlyLFxuICAgICAgbWVzc2FnZSxcbiAgICAgIGF1dGhvcixcbiAgICAgIGNvbW1pdHRlcixcbiAgICAgIHNpZ25pbmdLZXksXG4gICAgICBkcnlSdW4sXG4gICAgICBub1VwZGF0ZUJyYW5jaCxcbiAgICAgIHJlZixcbiAgICAgIHBhcmVudCxcbiAgICAgIHRyZWUsXG4gICAgfSlcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZXJyLmNhbGxlciA9ICdnaXQuY29tbWl0JztcbiAgICB0aHJvdyBlcnJcbiAgfVxufVxuXG4vLyBAdHMtY2hlY2tcblxuLyoqXG4gKiBHZXQgdGhlIG5hbWUgb2YgdGhlIGJyYW5jaCBjdXJyZW50bHkgcG9pbnRlZCB0byBieSAuZ2l0L0hFQURcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gYXJnc1xuICogQHBhcmFtIHtGc0NsaWVudH0gYXJncy5mcyAtIGEgZmlsZSBzeXN0ZW0gaW1wbGVtZW50YXRpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5kaXJdIC0gVGhlIFt3b3JraW5nIHRyZWVdKGRpci12cy1naXRkaXIubWQpIGRpcmVjdG9yeSBwYXRoXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MuZ2l0ZGlyPWpvaW4oZGlyLCcuZ2l0JyldIC0gW3JlcXVpcmVkXSBUaGUgW2dpdCBkaXJlY3RvcnldKGRpci12cy1naXRkaXIubWQpIHBhdGhcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2FyZ3MuZnVsbG5hbWUgPSBmYWxzZV0gLSBSZXR1cm4gdGhlIGZ1bGwgcGF0aCAoZS5nLiBcInJlZnMvaGVhZHMvbWFpblwiKSBpbnN0ZWFkIG9mIHRoZSBhYmJyZXZpYXRlZCBmb3JtLlxuICogQHBhcmFtIHtib29sZWFufSBbYXJncy50ZXN0ID0gZmFsc2VdIC0gSWYgdGhlIGN1cnJlbnQgYnJhbmNoIGRvZXNuJ3QgYWN0dWFsbHkgZXhpc3QgKHN1Y2ggYXMgcmlnaHQgYWZ0ZXIgZ2l0IGluaXQpIHRoZW4gcmV0dXJuIGB1bmRlZmluZWRgLlxuICpcbiAqIEByZXR1cm5zIHtQcm9taXNlPHN0cmluZ3x2b2lkPn0gVGhlIG5hbWUgb2YgdGhlIGN1cnJlbnQgYnJhbmNoIG9yIHVuZGVmaW5lZCBpZiB0aGUgSEVBRCBpcyBkZXRhY2hlZC5cbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gR2V0IHRoZSBjdXJyZW50IGJyYW5jaCBuYW1lXG4gKiBsZXQgYnJhbmNoID0gYXdhaXQgZ2l0LmN1cnJlbnRCcmFuY2goe1xuICogICBmcyxcbiAqICAgZGlyOiAnL3R1dG9yaWFsJyxcbiAqICAgZnVsbG5hbWU6IGZhbHNlXG4gKiB9KVxuICogY29uc29sZS5sb2coYnJhbmNoKVxuICpcbiAqL1xuYXN5bmMgZnVuY3Rpb24gY3VycmVudEJyYW5jaCh7XG4gIGZzLFxuICBkaXIsXG4gIGdpdGRpciA9IGpvaW4oZGlyLCAnLmdpdCcpLFxuICBmdWxsbmFtZSA9IGZhbHNlLFxuICB0ZXN0ID0gZmFsc2UsXG59KSB7XG4gIHRyeSB7XG4gICAgYXNzZXJ0UGFyYW1ldGVyKCdmcycsIGZzKTtcbiAgICBhc3NlcnRQYXJhbWV0ZXIoJ2dpdGRpcicsIGdpdGRpcik7XG4gICAgcmV0dXJuIGF3YWl0IF9jdXJyZW50QnJhbmNoKHtcbiAgICAgIGZzOiBuZXcgRmlsZVN5c3RlbShmcyksXG4gICAgICBnaXRkaXIsXG4gICAgICBmdWxsbmFtZSxcbiAgICAgIHRlc3QsXG4gICAgfSlcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZXJyLmNhbGxlciA9ICdnaXQuY3VycmVudEJyYW5jaCc7XG4gICAgdGhyb3cgZXJyXG4gIH1cbn1cblxuLy8gQHRzLWNoZWNrXG5cbi8qKlxuICogQHBhcmFtIHtPYmplY3R9IGFyZ3NcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9tb2RlbHMvRmlsZVN5c3RlbS5qcycpLkZpbGVTeXN0ZW19IGFyZ3MuZnNcbiAqIEBwYXJhbSB7c3RyaW5nfSBhcmdzLmdpdGRpclxuICogQHBhcmFtIHtzdHJpbmd9IGFyZ3MucmVmXG4gKlxuICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gKi9cbmFzeW5jIGZ1bmN0aW9uIF9kZWxldGVCcmFuY2goeyBmcywgZ2l0ZGlyLCByZWYgfSkge1xuICBjb25zdCBleGlzdCA9IGF3YWl0IEdpdFJlZk1hbmFnZXIuZXhpc3RzKHsgZnMsIGdpdGRpciwgcmVmIH0pO1xuICBpZiAoIWV4aXN0KSB7XG4gICAgdGhyb3cgbmV3IE5vdEZvdW5kRXJyb3IocmVmKVxuICB9XG5cbiAgY29uc3QgZnVsbFJlZiA9IGF3YWl0IEdpdFJlZk1hbmFnZXIuZXhwYW5kKHsgZnMsIGdpdGRpciwgcmVmIH0pO1xuICBjb25zdCBjdXJyZW50UmVmID0gYXdhaXQgX2N1cnJlbnRCcmFuY2goeyBmcywgZ2l0ZGlyLCBmdWxsbmFtZTogdHJ1ZSB9KTtcbiAgaWYgKGZ1bGxSZWYgPT09IGN1cnJlbnRSZWYpIHtcbiAgICAvLyBkZXRhY2ggSEVBRFxuICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgR2l0UmVmTWFuYWdlci5yZXNvbHZlKHsgZnMsIGdpdGRpciwgcmVmOiBmdWxsUmVmIH0pO1xuICAgIGF3YWl0IEdpdFJlZk1hbmFnZXIud3JpdGVSZWYoeyBmcywgZ2l0ZGlyLCByZWY6ICdIRUFEJywgdmFsdWUgfSk7XG4gIH1cblxuICAvLyBEZWxldGUgYSBzcGVjaWZpZWQgYnJhbmNoXG4gIGF3YWl0IEdpdFJlZk1hbmFnZXIuZGVsZXRlUmVmKHsgZnMsIGdpdGRpciwgcmVmOiBmdWxsUmVmIH0pO1xufVxuXG4vLyBAdHMtY2hlY2tcblxuLyoqXG4gKiBEZWxldGUgYSBsb2NhbCBicmFuY2hcbiAqXG4gKiA+IE5vdGU6IFRoaXMgb25seSBkZWxldGVzIGxvb3NlIGJyYW5jaGVzIC0gaXQgc2hvdWxkIGJlIGZpeGVkIGluIHRoZSBmdXR1cmUgdG8gZGVsZXRlIHBhY2tlZCBicmFuY2hlcyBhcyB3ZWxsLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzXG4gKiBAcGFyYW0ge0ZzQ2xpZW50fSBhcmdzLmZzIC0gYSBmaWxlIHN5c3RlbSBpbXBsZW1lbnRhdGlvblxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLmRpcl0gLSBUaGUgW3dvcmtpbmcgdHJlZV0oZGlyLXZzLWdpdGRpci5tZCkgZGlyZWN0b3J5IHBhdGhcbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5naXRkaXI9am9pbihkaXIsJy5naXQnKV0gLSBbcmVxdWlyZWRdIFRoZSBbZ2l0IGRpcmVjdG9yeV0oZGlyLXZzLWdpdGRpci5tZCkgcGF0aFxuICogQHBhcmFtIHtzdHJpbmd9IGFyZ3MucmVmIC0gVGhlIGJyYW5jaCB0byBkZWxldGVcbiAqXG4gKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn0gUmVzb2x2ZXMgc3VjY2Vzc2Z1bGx5IHdoZW4gZmlsZXN5c3RlbSBvcGVyYXRpb25zIGFyZSBjb21wbGV0ZVxuICpcbiAqIEBleGFtcGxlXG4gKiBhd2FpdCBnaXQuZGVsZXRlQnJhbmNoKHsgZnMsIGRpcjogJy90dXRvcmlhbCcsIHJlZjogJ2xvY2FsLWJyYW5jaCcgfSlcbiAqIGNvbnNvbGUubG9nKCdkb25lJylcbiAqXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGRlbGV0ZUJyYW5jaCh7XG4gIGZzLFxuICBkaXIsXG4gIGdpdGRpciA9IGpvaW4oZGlyLCAnLmdpdCcpLFxuICByZWYsXG59KSB7XG4gIHRyeSB7XG4gICAgYXNzZXJ0UGFyYW1ldGVyKCdmcycsIGZzKTtcbiAgICBhc3NlcnRQYXJhbWV0ZXIoJ3JlZicsIHJlZik7XG4gICAgcmV0dXJuIGF3YWl0IF9kZWxldGVCcmFuY2goe1xuICAgICAgZnM6IG5ldyBGaWxlU3lzdGVtKGZzKSxcbiAgICAgIGdpdGRpcixcbiAgICAgIHJlZixcbiAgICB9KVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBlcnIuY2FsbGVyID0gJ2dpdC5kZWxldGVCcmFuY2gnO1xuICAgIHRocm93IGVyclxuICB9XG59XG5cbi8vIEB0cy1jaGVja1xuXG4vKipcbiAqIERlbGV0ZSBhIGxvY2FsIHJlZlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzXG4gKiBAcGFyYW0ge0ZzQ2xpZW50fSBhcmdzLmZzIC0gYSBmaWxlIHN5c3RlbSBpbXBsZW1lbnRhdGlvblxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLmRpcl0gLSBUaGUgW3dvcmtpbmcgdHJlZV0oZGlyLXZzLWdpdGRpci5tZCkgZGlyZWN0b3J5IHBhdGhcbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5naXRkaXI9am9pbihkaXIsJy5naXQnKV0gLSBbcmVxdWlyZWRdIFRoZSBbZ2l0IGRpcmVjdG9yeV0oZGlyLXZzLWdpdGRpci5tZCkgcGF0aFxuICogQHBhcmFtIHtzdHJpbmd9IGFyZ3MucmVmIC0gVGhlIHJlZiB0byBkZWxldGVcbiAqXG4gKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn0gUmVzb2x2ZXMgc3VjY2Vzc2Z1bGx5IHdoZW4gZmlsZXN5c3RlbSBvcGVyYXRpb25zIGFyZSBjb21wbGV0ZVxuICpcbiAqIEBleGFtcGxlXG4gKiBhd2FpdCBnaXQuZGVsZXRlUmVmKHsgZnMsIGRpcjogJy90dXRvcmlhbCcsIHJlZjogJ3JlZnMvdGFncy90ZXN0LXRhZycgfSlcbiAqIGNvbnNvbGUubG9nKCdkb25lJylcbiAqXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGRlbGV0ZVJlZih7IGZzLCBkaXIsIGdpdGRpciA9IGpvaW4oZGlyLCAnLmdpdCcpLCByZWYgfSkge1xuICB0cnkge1xuICAgIGFzc2VydFBhcmFtZXRlcignZnMnLCBmcyk7XG4gICAgYXNzZXJ0UGFyYW1ldGVyKCdyZWYnLCByZWYpO1xuICAgIGF3YWl0IEdpdFJlZk1hbmFnZXIuZGVsZXRlUmVmKHsgZnM6IG5ldyBGaWxlU3lzdGVtKGZzKSwgZ2l0ZGlyLCByZWYgfSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGVyci5jYWxsZXIgPSAnZ2l0LmRlbGV0ZVJlZic7XG4gICAgdGhyb3cgZXJyXG4gIH1cbn1cblxuLy8gQHRzLWNoZWNrXG5cbi8qKlxuICogQHBhcmFtIHtPYmplY3R9IGFyZ3NcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9tb2RlbHMvRmlsZVN5c3RlbS5qcycpLkZpbGVTeXN0ZW19IGFyZ3MuZnNcbiAqIEBwYXJhbSB7c3RyaW5nfSBhcmdzLmdpdGRpclxuICogQHBhcmFtIHtzdHJpbmd9IGFyZ3MucmVtb3RlXG4gKlxuICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gKi9cbmFzeW5jIGZ1bmN0aW9uIF9kZWxldGVSZW1vdGUoeyBmcywgZ2l0ZGlyLCByZW1vdGUgfSkge1xuICBjb25zdCBjb25maWcgPSBhd2FpdCBHaXRDb25maWdNYW5hZ2VyLmdldCh7IGZzLCBnaXRkaXIgfSk7XG4gIGF3YWl0IGNvbmZpZy5kZWxldGVTZWN0aW9uKCdyZW1vdGUnLCByZW1vdGUpO1xuICBhd2FpdCBHaXRDb25maWdNYW5hZ2VyLnNhdmUoeyBmcywgZ2l0ZGlyLCBjb25maWcgfSk7XG59XG5cbi8vIEB0cy1jaGVja1xuXG4vKipcbiAqIFJlbW92ZXMgdGhlIGxvY2FsIGNvbmZpZyBlbnRyeSBmb3IgYSBnaXZlbiByZW1vdGVcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gYXJnc1xuICogQHBhcmFtIHtGc0NsaWVudH0gYXJncy5mcyAtIGEgZmlsZSBzeXN0ZW0gaW1wbGVtZW50YXRpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5kaXJdIC0gVGhlIFt3b3JraW5nIHRyZWVdKGRpci12cy1naXRkaXIubWQpIGRpcmVjdG9yeSBwYXRoXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MuZ2l0ZGlyPWpvaW4oZGlyLCcuZ2l0JyldIC0gW3JlcXVpcmVkXSBUaGUgW2dpdCBkaXJlY3RvcnldKGRpci12cy1naXRkaXIubWQpIHBhdGhcbiAqIEBwYXJhbSB7c3RyaW5nfSBhcmdzLnJlbW90ZSAtIFRoZSBuYW1lIG9mIHRoZSByZW1vdGUgdG8gZGVsZXRlXG4gKlxuICogQHJldHVybnMge1Byb21pc2U8dm9pZD59IFJlc29sdmVzIHN1Y2Nlc3NmdWxseSB3aGVuIGZpbGVzeXN0ZW0gb3BlcmF0aW9ucyBhcmUgY29tcGxldGVcbiAqXG4gKiBAZXhhbXBsZVxuICogYXdhaXQgZ2l0LmRlbGV0ZVJlbW90ZSh7IGZzLCBkaXI6ICcvdHV0b3JpYWwnLCByZW1vdGU6ICd1cHN0cmVhbScgfSlcbiAqIGNvbnNvbGUubG9nKCdkb25lJylcbiAqXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGRlbGV0ZVJlbW90ZSh7XG4gIGZzLFxuICBkaXIsXG4gIGdpdGRpciA9IGpvaW4oZGlyLCAnLmdpdCcpLFxuICByZW1vdGUsXG59KSB7XG4gIHRyeSB7XG4gICAgYXNzZXJ0UGFyYW1ldGVyKCdmcycsIGZzKTtcbiAgICBhc3NlcnRQYXJhbWV0ZXIoJ3JlbW90ZScsIHJlbW90ZSk7XG4gICAgcmV0dXJuIGF3YWl0IF9kZWxldGVSZW1vdGUoe1xuICAgICAgZnM6IG5ldyBGaWxlU3lzdGVtKGZzKSxcbiAgICAgIGdpdGRpcixcbiAgICAgIHJlbW90ZSxcbiAgICB9KVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBlcnIuY2FsbGVyID0gJ2dpdC5kZWxldGVSZW1vdGUnO1xuICAgIHRocm93IGVyclxuICB9XG59XG5cbi8vIEB0cy1jaGVja1xuXG4vKipcbiAqIERlbGV0ZSBhIGxvY2FsIHRhZyByZWZcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gYXJnc1xuICogQHBhcmFtIHtpbXBvcnQoJy4uL21vZGVscy9GaWxlU3lzdGVtLmpzJykuRmlsZVN5c3RlbX0gYXJncy5mc1xuICogQHBhcmFtIHtzdHJpbmd9IGFyZ3MuZ2l0ZGlyXG4gKiBAcGFyYW0ge3N0cmluZ30gYXJncy5yZWYgLSBUaGUgdGFnIHRvIGRlbGV0ZVxuICpcbiAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fSBSZXNvbHZlcyBzdWNjZXNzZnVsbHkgd2hlbiBmaWxlc3lzdGVtIG9wZXJhdGlvbnMgYXJlIGNvbXBsZXRlXG4gKlxuICogQGV4YW1wbGVcbiAqIGF3YWl0IGdpdC5kZWxldGVUYWcoeyBkaXI6ICckaW5wdXQoKC8pKScsIHJlZjogJyRpbnB1dCgodGVzdC10YWcpKScgfSlcbiAqIGNvbnNvbGUubG9nKCdkb25lJylcbiAqXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIF9kZWxldGVUYWcoeyBmcywgZ2l0ZGlyLCByZWYgfSkge1xuICByZWYgPSByZWYuc3RhcnRzV2l0aCgncmVmcy90YWdzLycpID8gcmVmIDogYHJlZnMvdGFncy8ke3JlZn1gO1xuICBhd2FpdCBHaXRSZWZNYW5hZ2VyLmRlbGV0ZVJlZih7IGZzLCBnaXRkaXIsIHJlZiB9KTtcbn1cblxuLy8gQHRzLWNoZWNrXG5cbi8qKlxuICogRGVsZXRlIGEgbG9jYWwgdGFnIHJlZlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzXG4gKiBAcGFyYW0ge0ZzQ2xpZW50fSBhcmdzLmZzIC0gYSBmaWxlIHN5c3RlbSBpbXBsZW1lbnRhdGlvblxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLmRpcl0gLSBUaGUgW3dvcmtpbmcgdHJlZV0oZGlyLXZzLWdpdGRpci5tZCkgZGlyZWN0b3J5IHBhdGhcbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5naXRkaXI9am9pbihkaXIsJy5naXQnKV0gLSBbcmVxdWlyZWRdIFRoZSBbZ2l0IGRpcmVjdG9yeV0oZGlyLXZzLWdpdGRpci5tZCkgcGF0aFxuICogQHBhcmFtIHtzdHJpbmd9IGFyZ3MucmVmIC0gVGhlIHRhZyB0byBkZWxldGVcbiAqXG4gKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn0gUmVzb2x2ZXMgc3VjY2Vzc2Z1bGx5IHdoZW4gZmlsZXN5c3RlbSBvcGVyYXRpb25zIGFyZSBjb21wbGV0ZVxuICpcbiAqIEBleGFtcGxlXG4gKiBhd2FpdCBnaXQuZGVsZXRlVGFnKHsgZnMsIGRpcjogJy90dXRvcmlhbCcsIHJlZjogJ3Rlc3QtdGFnJyB9KVxuICogY29uc29sZS5sb2coJ2RvbmUnKVxuICpcbiAqL1xuYXN5bmMgZnVuY3Rpb24gZGVsZXRlVGFnKHsgZnMsIGRpciwgZ2l0ZGlyID0gam9pbihkaXIsICcuZ2l0JyksIHJlZiB9KSB7XG4gIHRyeSB7XG4gICAgYXNzZXJ0UGFyYW1ldGVyKCdmcycsIGZzKTtcbiAgICBhc3NlcnRQYXJhbWV0ZXIoJ3JlZicsIHJlZik7XG4gICAgcmV0dXJuIGF3YWl0IF9kZWxldGVUYWcoe1xuICAgICAgZnM6IG5ldyBGaWxlU3lzdGVtKGZzKSxcbiAgICAgIGdpdGRpcixcbiAgICAgIHJlZixcbiAgICB9KVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBlcnIuY2FsbGVyID0gJ2dpdC5kZWxldGVUYWcnO1xuICAgIHRocm93IGVyclxuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGV4cGFuZE9pZExvb3NlKHsgZnMsIGdpdGRpciwgb2lkOiBzaG9ydCB9KSB7XG4gIGNvbnN0IHByZWZpeCA9IHNob3J0LnNsaWNlKDAsIDIpO1xuICBjb25zdCBvYmplY3RzU3VmZml4ZXMgPSBhd2FpdCBmcy5yZWFkZGlyKGAke2dpdGRpcn0vb2JqZWN0cy8ke3ByZWZpeH1gKTtcbiAgcmV0dXJuIG9iamVjdHNTdWZmaXhlc1xuICAgIC5tYXAoc3VmZml4ID0+IGAke3ByZWZpeH0ke3N1ZmZpeH1gKVxuICAgIC5maWx0ZXIoX29pZCA9PiBfb2lkLnN0YXJ0c1dpdGgoc2hvcnQpKVxufVxuXG5hc3luYyBmdW5jdGlvbiBleHBhbmRPaWRQYWNrZWQoe1xuICBmcyxcbiAgY2FjaGUsXG4gIGdpdGRpcixcbiAgb2lkOiBzaG9ydCxcbiAgZ2V0RXh0ZXJuYWxSZWZEZWx0YSxcbn0pIHtcbiAgLy8gSXRlcmF0ZSB0aHJvdWdoIGFsbCB0aGUgLnBhY2sgZmlsZXNcbiAgY29uc3QgcmVzdWx0cyA9IFtdO1xuICBsZXQgbGlzdCA9IGF3YWl0IGZzLnJlYWRkaXIoam9pbihnaXRkaXIsICdvYmplY3RzL3BhY2snKSk7XG4gIGxpc3QgPSBsaXN0LmZpbHRlcih4ID0+IHguZW5kc1dpdGgoJy5pZHgnKSk7XG4gIGZvciAoY29uc3QgZmlsZW5hbWUgb2YgbGlzdCkge1xuICAgIGNvbnN0IGluZGV4RmlsZSA9IGAke2dpdGRpcn0vb2JqZWN0cy9wYWNrLyR7ZmlsZW5hbWV9YDtcbiAgICBjb25zdCBwID0gYXdhaXQgcmVhZFBhY2tJbmRleCh7XG4gICAgICBmcyxcbiAgICAgIGNhY2hlLFxuICAgICAgZmlsZW5hbWU6IGluZGV4RmlsZSxcbiAgICAgIGdldEV4dGVybmFsUmVmRGVsdGEsXG4gICAgfSk7XG4gICAgaWYgKHAuZXJyb3IpIHRocm93IG5ldyBJbnRlcm5hbEVycm9yKHAuZXJyb3IpXG4gICAgLy8gU2VhcmNoIHRocm91Z2ggdGhlIGxpc3Qgb2Ygb2lkcyBpbiB0aGUgcGFja2ZpbGVcbiAgICBmb3IgKGNvbnN0IG9pZCBvZiBwLm9mZnNldHMua2V5cygpKSB7XG4gICAgICBpZiAob2lkLnN0YXJ0c1dpdGgoc2hvcnQpKSByZXN1bHRzLnB1c2gob2lkKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdHNcbn1cblxuYXN5bmMgZnVuY3Rpb24gX2V4cGFuZE9pZCh7IGZzLCBjYWNoZSwgZ2l0ZGlyLCBvaWQ6IHNob3J0IH0pIHtcbiAgLy8gQ3VycnkgdGhlIGN1cnJlbnQgcmVhZCBtZXRob2Qgc28gdGhhdCB0aGUgcGFja2ZpbGUgdW4tZGVsdGlmaWNhdGlvblxuICAvLyBwcm9jZXNzIGNhbiBhY3F1aXJlIGV4dGVybmFsIHJlZi1kZWx0YXMuXG4gIGNvbnN0IGdldEV4dGVybmFsUmVmRGVsdGEgPSBvaWQgPT4gX3JlYWRPYmplY3QoeyBmcywgY2FjaGUsIGdpdGRpciwgb2lkIH0pO1xuXG4gIGNvbnN0IHJlc3VsdHMxID0gYXdhaXQgZXhwYW5kT2lkTG9vc2UoeyBmcywgZ2l0ZGlyLCBvaWQ6IHNob3J0IH0pO1xuICBjb25zdCByZXN1bHRzMiA9IGF3YWl0IGV4cGFuZE9pZFBhY2tlZCh7XG4gICAgZnMsXG4gICAgY2FjaGUsXG4gICAgZ2l0ZGlyLFxuICAgIG9pZDogc2hvcnQsXG4gICAgZ2V0RXh0ZXJuYWxSZWZEZWx0YSxcbiAgfSk7XG4gIGNvbnN0IHJlc3VsdHMgPSByZXN1bHRzMS5jb25jYXQocmVzdWx0czIpO1xuXG4gIGlmIChyZXN1bHRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiByZXN1bHRzWzBdXG4gIH1cbiAgaWYgKHJlc3VsdHMubGVuZ3RoID4gMSkge1xuICAgIHRocm93IG5ldyBBbWJpZ3VvdXNFcnJvcignb2lkcycsIHNob3J0LCByZXN1bHRzKVxuICB9XG4gIHRocm93IG5ldyBOb3RGb3VuZEVycm9yKGBhbiBvYmplY3QgbWF0Y2hpbmcgXCIke3Nob3J0fVwiYClcbn1cblxuLy8gQHRzLWNoZWNrXG5cbi8qKlxuICogRXhwYW5kIGFuZCByZXNvbHZlIGEgc2hvcnQgb2lkIGludG8gYSBmdWxsIG9pZFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzXG4gKiBAcGFyYW0ge0ZzQ2xpZW50fSBhcmdzLmZzIC0gYSBmaWxlIHN5c3RlbSBpbXBsZW1lbnRhdGlvblxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLmRpcl0gLSBUaGUgW3dvcmtpbmcgdHJlZV0oZGlyLXZzLWdpdGRpci5tZCkgZGlyZWN0b3J5IHBhdGhcbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5naXRkaXI9am9pbihkaXIsJy5naXQnKV0gLSBbcmVxdWlyZWRdIFRoZSBbZ2l0IGRpcmVjdG9yeV0oZGlyLXZzLWdpdGRpci5tZCkgcGF0aFxuICogQHBhcmFtIHtzdHJpbmd9IGFyZ3Mub2lkIC0gVGhlIHNob3J0ZW5lZCBvaWQgcHJlZml4IHRvIGV4cGFuZCAobGlrZSBcIjA0MTRkMmFcIilcbiAqIEBwYXJhbSB7b2JqZWN0fSBbYXJncy5jYWNoZV0gLSBhIFtjYWNoZV0oY2FjaGUubWQpIG9iamVjdFxuICpcbiAqIEByZXR1cm5zIHtQcm9taXNlPHN0cmluZz59IFJlc29sdmVzIHN1Y2Nlc3NmdWxseSB3aXRoIHRoZSBmdWxsIG9pZCAobGlrZSBcIjA0MTRkMmEyODZkN2JiYzdhNGEzMjZhNjFjMWY5Zjg4OGE4YWI4N2ZcIilcbiAqXG4gKiBAZXhhbXBsZVxuICogbGV0IG9pZCA9IGF3YWl0IGdpdC5leHBhbmRPaWQoeyBmcywgZGlyOiAnL3R1dG9yaWFsJywgb2lkOiAnMDQxNGQyYSd9KVxuICogY29uc29sZS5sb2cob2lkKVxuICpcbiAqL1xuYXN5bmMgZnVuY3Rpb24gZXhwYW5kT2lkKHtcbiAgZnMsXG4gIGRpcixcbiAgZ2l0ZGlyID0gam9pbihkaXIsICcuZ2l0JyksXG4gIG9pZCxcbiAgY2FjaGUgPSB7fSxcbn0pIHtcbiAgdHJ5IHtcbiAgICBhc3NlcnRQYXJhbWV0ZXIoJ2ZzJywgZnMpO1xuICAgIGFzc2VydFBhcmFtZXRlcignZ2l0ZGlyJywgZ2l0ZGlyKTtcbiAgICBhc3NlcnRQYXJhbWV0ZXIoJ29pZCcsIG9pZCk7XG4gICAgcmV0dXJuIGF3YWl0IF9leHBhbmRPaWQoe1xuICAgICAgZnM6IG5ldyBGaWxlU3lzdGVtKGZzKSxcbiAgICAgIGNhY2hlLFxuICAgICAgZ2l0ZGlyLFxuICAgICAgb2lkLFxuICAgIH0pXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGVyci5jYWxsZXIgPSAnZ2l0LmV4cGFuZE9pZCc7XG4gICAgdGhyb3cgZXJyXG4gIH1cbn1cblxuLy8gQHRzLWNoZWNrXG5cbi8qKlxuICogRXhwYW5kIGFuIGFiYnJldmlhdGVkIHJlZiB0byBpdHMgZnVsbCBuYW1lXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGFyZ3NcbiAqIEBwYXJhbSB7RnNDbGllbnR9IGFyZ3MuZnMgLSBhIGZpbGUgc3lzdGVtIGltcGxlbWVudGF0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MuZGlyXSAtIFRoZSBbd29ya2luZyB0cmVlXShkaXItdnMtZ2l0ZGlyLm1kKSBkaXJlY3RvcnkgcGF0aFxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLmdpdGRpcj1qb2luKGRpciwnLmdpdCcpXSAtIFtyZXF1aXJlZF0gVGhlIFtnaXQgZGlyZWN0b3J5XShkaXItdnMtZ2l0ZGlyLm1kKSBwYXRoXG4gKiBAcGFyYW0ge3N0cmluZ30gYXJncy5yZWYgLSBUaGUgcmVmIHRvIGV4cGFuZCAobGlrZSBcInYxLjAuMFwiKVxuICpcbiAqIEByZXR1cm5zIHtQcm9taXNlPHN0cmluZz59IFJlc29sdmVzIHN1Y2Nlc3NmdWxseSB3aXRoIGEgZnVsbCByZWYgbmFtZSAoXCJyZWZzL3RhZ3MvdjEuMC4wXCIpXG4gKlxuICogQGV4YW1wbGVcbiAqIGxldCBmdWxsUmVmID0gYXdhaXQgZ2l0LmV4cGFuZFJlZih7IGZzLCBkaXI6ICcvdHV0b3JpYWwnLCByZWY6ICdtYWluJ30pXG4gKiBjb25zb2xlLmxvZyhmdWxsUmVmKVxuICpcbiAqL1xuYXN5bmMgZnVuY3Rpb24gZXhwYW5kUmVmKHsgZnMsIGRpciwgZ2l0ZGlyID0gam9pbihkaXIsICcuZ2l0JyksIHJlZiB9KSB7XG4gIHRyeSB7XG4gICAgYXNzZXJ0UGFyYW1ldGVyKCdmcycsIGZzKTtcbiAgICBhc3NlcnRQYXJhbWV0ZXIoJ2dpdGRpcicsIGdpdGRpcik7XG4gICAgYXNzZXJ0UGFyYW1ldGVyKCdyZWYnLCByZWYpO1xuICAgIHJldHVybiBhd2FpdCBHaXRSZWZNYW5hZ2VyLmV4cGFuZCh7XG4gICAgICBmczogbmV3IEZpbGVTeXN0ZW0oZnMpLFxuICAgICAgZ2l0ZGlyLFxuICAgICAgcmVmLFxuICAgIH0pXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGVyci5jYWxsZXIgPSAnZ2l0LmV4cGFuZFJlZic7XG4gICAgdGhyb3cgZXJyXG4gIH1cbn1cblxuLy8gQHRzLWNoZWNrXG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGFyZ3NcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9tb2RlbHMvRmlsZVN5c3RlbS5qcycpLkZpbGVTeXN0ZW19IGFyZ3MuZnNcbiAqIEBwYXJhbSB7YW55fSBhcmdzLmNhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30gYXJncy5naXRkaXJcbiAqIEBwYXJhbSB7c3RyaW5nW119IGFyZ3Mub2lkc1xuICpcbiAqL1xuYXN5bmMgZnVuY3Rpb24gX2ZpbmRNZXJnZUJhc2UoeyBmcywgY2FjaGUsIGdpdGRpciwgb2lkcyB9KSB7XG4gIC8vIE5vdGU6IHJpZ2h0IG5vdywgdGhlIHRlc3RzIGFyZSBnZWFyZWQgc28gdGhhdCB0aGUgb3V0cHV0IHNob3VsZCBtYXRjaCB0aGF0IG9mXG4gIC8vIGBnaXQgbWVyZ2UtYmFzZSAtLWFsbCAtLW9jdG9wdXNgXG4gIC8vIGJlY2F1c2Ugd2l0aG91dCB0aGUgLS1vY3RvcHVzIGZsYWcsIGdpdCdzIG91dHB1dCBzZWVtcyB0byBkZXBlbmQgb24gdGhlIE9SREVSIG9mIHRoZSBvaWRzLFxuICAvLyBhbmQgY29tcHV0aW5nIHZpcnR1YWwgbWVyZ2UgYmFzZXMgaXMganVzdCB0b28gbXVjaCBmb3IgbWUgdG8gZmF0aG9tIHJpZ2h0IG5vdy5cblxuICAvLyBJZiB3ZSBzdGFydCBOIGluZGVwZW5kZW50IHdhbGtlcnMsIG9uZSBhdCBlYWNoIG9mIHRoZSBnaXZlbiBgb2lkc2AsIGFuZCB3YWxrIGJhY2t3YXJkc1xuICAvLyB0aHJvdWdoIGFuY2VzdG9ycywgZXZlbnR1YWxseSB3ZSdsbCBkaXNjb3ZlciBhIGNvbW1pdCB3aGVyZSBlYWNoIG9uZSBvZiB0aGVzZSBOIHdhbGtlcnNcbiAgLy8gaGFzIHBhc3NlZCB0aHJvdWdoLiBTbyB3ZSBqdXN0IG5lZWQgdG8ga2VlcCB0cmFjayBvZiB3aGljaCB3YWxrZXJzIGhhdmUgdmlzaXRlZCBlYWNoIGNvbW1pdFxuICAvLyB1bnRpbCB3ZSBmaW5kIGEgY29tbWl0IHRoYXQgTiBkaXN0aW5jdCB3YWxrZXJzIGhhcyB2aXNpdGVkLlxuICBjb25zdCB2aXNpdHMgPSB7fTtcbiAgY29uc3QgcGFzc2VzID0gb2lkcy5sZW5ndGg7XG4gIGxldCBoZWFkcyA9IG9pZHMubWFwKChvaWQsIGluZGV4KSA9PiAoeyBpbmRleCwgb2lkIH0pKTtcbiAgd2hpbGUgKGhlYWRzLmxlbmd0aCkge1xuICAgIC8vIENvdW50IGhvdyBtYW55IHRpbWVzIHdlJ3ZlIHBhc3NlZCBlYWNoIGNvbW1pdFxuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBTZXQoKTtcbiAgICBmb3IgKGNvbnN0IHsgb2lkLCBpbmRleCB9IG9mIGhlYWRzKSB7XG4gICAgICBpZiAoIXZpc2l0c1tvaWRdKSB2aXNpdHNbb2lkXSA9IG5ldyBTZXQoKTtcbiAgICAgIHZpc2l0c1tvaWRdLmFkZChpbmRleCk7XG4gICAgICBpZiAodmlzaXRzW29pZF0uc2l6ZSA9PT0gcGFzc2VzKSB7XG4gICAgICAgIHJlc3VsdC5hZGQob2lkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHJlc3VsdC5zaXplID4gMCkge1xuICAgICAgcmV0dXJuIFsuLi5yZXN1bHRdXG4gICAgfVxuICAgIC8vIFdlIGhhdmVuJ3QgZm91bmQgYSBjb21tb24gYW5jZXN0b3IgeWV0XG4gICAgY29uc3QgbmV3aGVhZHMgPSBuZXcgTWFwKCk7XG4gICAgZm9yIChjb25zdCB7IG9pZCwgaW5kZXggfSBvZiBoZWFkcykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgeyBvYmplY3QgfSA9IGF3YWl0IF9yZWFkT2JqZWN0KHsgZnMsIGNhY2hlLCBnaXRkaXIsIG9pZCB9KTtcbiAgICAgICAgY29uc3QgY29tbWl0ID0gR2l0Q29tbWl0LmZyb20ob2JqZWN0KTtcbiAgICAgICAgY29uc3QgeyBwYXJlbnQgfSA9IGNvbW1pdC5wYXJzZUhlYWRlcnMoKTtcbiAgICAgICAgZm9yIChjb25zdCBvaWQgb2YgcGFyZW50KSB7XG4gICAgICAgICAgaWYgKCF2aXNpdHNbb2lkXSB8fCAhdmlzaXRzW29pZF0uaGFzKGluZGV4KSkge1xuICAgICAgICAgICAgbmV3aGVhZHMuc2V0KG9pZCArICc6JyArIGluZGV4LCB7IG9pZCwgaW5kZXggfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgLy8gZG8gbm90aGluZ1xuICAgICAgfVxuICAgIH1cbiAgICBoZWFkcyA9IEFycmF5LmZyb20obmV3aGVhZHMudmFsdWVzKCkpO1xuICB9XG4gIHJldHVybiBbXVxufVxuXG5jb25zdCBMSU5FQlJFQUtTID0gL14uKihcXHI/XFxufCQpL2dtO1xuXG5mdW5jdGlvbiBtZXJnZUZpbGUoe1xuICBvdXJDb250ZW50LFxuICBiYXNlQ29udGVudCxcbiAgdGhlaXJDb250ZW50LFxuICBvdXJOYW1lID0gJ291cnMnLFxuICBiYXNlTmFtZSA9ICdiYXNlJyxcbiAgdGhlaXJOYW1lID0gJ3RoZWlycycsXG4gIGZvcm1hdCA9ICdkaWZmJyxcbiAgbWFya2VyU2l6ZSA9IDcsXG59KSB7XG4gIGNvbnN0IG91cnMgPSBvdXJDb250ZW50Lm1hdGNoKExJTkVCUkVBS1MpO1xuICBjb25zdCBiYXNlID0gYmFzZUNvbnRlbnQubWF0Y2goTElORUJSRUFLUyk7XG4gIGNvbnN0IHRoZWlycyA9IHRoZWlyQ29udGVudC5tYXRjaChMSU5FQlJFQUtTKTtcblxuICAvLyBIZXJlIHdlIGxldCB0aGUgZGlmZjMgbGlicmFyeSBkbyB0aGUgaGVhdnkgbGlmdGluZy5cbiAgY29uc3QgcmVzdWx0ID0gZGlmZjNNZXJnZShvdXJzLCBiYXNlLCB0aGVpcnMpO1xuXG4gIC8vIEhlcmUgd2Ugbm90ZSB3aGV0aGVyIHRoZXJlIGFyZSBjb25mbGljdHMgYW5kIGZvcm1hdCB0aGUgcmVzdWx0c1xuICBsZXQgbWVyZ2VkVGV4dCA9ICcnO1xuICBsZXQgY2xlYW5NZXJnZSA9IHRydWU7XG4gIGZvciAoY29uc3QgaXRlbSBvZiByZXN1bHQpIHtcbiAgICBpZiAoaXRlbS5vaykge1xuICAgICAgbWVyZ2VkVGV4dCArPSBpdGVtLm9rLmpvaW4oJycpO1xuICAgIH1cbiAgICBpZiAoaXRlbS5jb25mbGljdCkge1xuICAgICAgY2xlYW5NZXJnZSA9IGZhbHNlO1xuICAgICAgbWVyZ2VkVGV4dCArPSBgJHsnPCcucmVwZWF0KG1hcmtlclNpemUpfSAke291ck5hbWV9XFxuYDtcbiAgICAgIG1lcmdlZFRleHQgKz0gaXRlbS5jb25mbGljdC5hLmpvaW4oJycpO1xuICAgICAgaWYgKGZvcm1hdCA9PT0gJ2RpZmYzJykge1xuICAgICAgICBtZXJnZWRUZXh0ICs9IGAkeyd8Jy5yZXBlYXQobWFya2VyU2l6ZSl9ICR7YmFzZU5hbWV9XFxuYDtcbiAgICAgICAgbWVyZ2VkVGV4dCArPSBpdGVtLmNvbmZsaWN0Lm8uam9pbignJyk7XG4gICAgICB9XG4gICAgICBtZXJnZWRUZXh0ICs9IGAkeyc9Jy5yZXBlYXQobWFya2VyU2l6ZSl9XFxuYDtcbiAgICAgIG1lcmdlZFRleHQgKz0gaXRlbS5jb25mbGljdC5iLmpvaW4oJycpO1xuICAgICAgbWVyZ2VkVGV4dCArPSBgJHsnPicucmVwZWF0KG1hcmtlclNpemUpfSAke3RoZWlyTmFtZX1cXG5gO1xuICAgIH1cbiAgfVxuICByZXR1cm4geyBjbGVhbk1lcmdlLCBtZXJnZWRUZXh0IH1cbn1cblxuLy8gQHRzLWNoZWNrXG5cbi8qKlxuICogQ3JlYXRlIGEgbWVyZ2VkIHRyZWVcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gYXJnc1xuICogQHBhcmFtIHtpbXBvcnQoJy4uL21vZGVscy9GaWxlU3lzdGVtLmpzJykuRmlsZVN5c3RlbX0gYXJncy5mc1xuICogQHBhcmFtIHtvYmplY3R9IGFyZ3MuY2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5kaXJdIC0gVGhlIFt3b3JraW5nIHRyZWVdKGRpci12cy1naXRkaXIubWQpIGRpcmVjdG9yeSBwYXRoXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MuZ2l0ZGlyPWpvaW4oZGlyLCcuZ2l0JyldIC0gW3JlcXVpcmVkXSBUaGUgW2dpdCBkaXJlY3RvcnldKGRpci12cy1naXRkaXIubWQpIHBhdGhcbiAqIEBwYXJhbSB7c3RyaW5nfSBhcmdzLm91ck9pZCAtIFRoZSBTSEEtMSBvYmplY3QgaWQgb2Ygb3VyIHRyZWVcbiAqIEBwYXJhbSB7c3RyaW5nfSBhcmdzLmJhc2VPaWQgLSBUaGUgU0hBLTEgb2JqZWN0IGlkIG9mIHRoZSBiYXNlIHRyZWVcbiAqIEBwYXJhbSB7c3RyaW5nfSBhcmdzLnRoZWlyT2lkIC0gVGhlIFNIQS0xIG9iamVjdCBpZCBvZiB0aGVpciB0cmVlXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3Mub3VyTmFtZT0nb3VycyddIC0gVGhlIG5hbWUgdG8gdXNlIGluIGNvbmZsaWN0ZWQgZmlsZXMgZm9yIG91ciBodW5rc1xuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLmJhc2VOYW1lPSdiYXNlJ10gLSBUaGUgbmFtZSB0byB1c2UgaW4gY29uZmxpY3RlZCBmaWxlcyAoaW4gZGlmZjMgZm9ybWF0KSBmb3IgdGhlIGJhc2UgaHVua3NcbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy50aGVpck5hbWU9J3RoZWlycyddIC0gVGhlIG5hbWUgdG8gdXNlIGluIGNvbmZsaWN0ZWQgZmlsZXMgZm9yIHRoZWlyIGh1bmtzXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFthcmdzLmRyeVJ1bj1mYWxzZV1cbiAqXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxzdHJpbmc+fSAtIFRoZSBTSEEtMSBvYmplY3QgaWQgb2YgdGhlIG1lcmdlZCB0cmVlXG4gKlxuICovXG5hc3luYyBmdW5jdGlvbiBtZXJnZVRyZWUoe1xuICBmcyxcbiAgY2FjaGUsXG4gIGRpcixcbiAgZ2l0ZGlyID0gam9pbihkaXIsICcuZ2l0JyksXG4gIG91ck9pZCxcbiAgYmFzZU9pZCxcbiAgdGhlaXJPaWQsXG4gIG91ck5hbWUgPSAnb3VycycsXG4gIGJhc2VOYW1lID0gJ2Jhc2UnLFxuICB0aGVpck5hbWUgPSAndGhlaXJzJyxcbiAgZHJ5UnVuID0gZmFsc2UsXG59KSB7XG4gIGNvbnN0IG91clRyZWUgPSBUUkVFKHsgcmVmOiBvdXJPaWQgfSk7XG4gIGNvbnN0IGJhc2VUcmVlID0gVFJFRSh7IHJlZjogYmFzZU9pZCB9KTtcbiAgY29uc3QgdGhlaXJUcmVlID0gVFJFRSh7IHJlZjogdGhlaXJPaWQgfSk7XG5cbiAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IF93YWxrKHtcbiAgICBmcyxcbiAgICBjYWNoZSxcbiAgICBkaXIsXG4gICAgZ2l0ZGlyLFxuICAgIHRyZWVzOiBbb3VyVHJlZSwgYmFzZVRyZWUsIHRoZWlyVHJlZV0sXG4gICAgbWFwOiBhc3luYyBmdW5jdGlvbihmaWxlcGF0aCwgW291cnMsIGJhc2UsIHRoZWlyc10pIHtcbiAgICAgIGNvbnN0IHBhdGggPSBiYXNlbmFtZShmaWxlcGF0aCk7XG4gICAgICAvLyBXaGF0IHdlIGRpZCwgd2hhdCB0aGV5IGRpZFxuICAgICAgY29uc3Qgb3VyQ2hhbmdlID0gYXdhaXQgbW9kaWZpZWQob3VycywgYmFzZSk7XG4gICAgICBjb25zdCB0aGVpckNoYW5nZSA9IGF3YWl0IG1vZGlmaWVkKHRoZWlycywgYmFzZSk7XG4gICAgICBzd2l0Y2ggKGAke291ckNoYW5nZX0tJHt0aGVpckNoYW5nZX1gKSB7XG4gICAgICAgIGNhc2UgJ2ZhbHNlLWZhbHNlJzoge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtb2RlOiBhd2FpdCBiYXNlLm1vZGUoKSxcbiAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICBvaWQ6IGF3YWl0IGJhc2Uub2lkKCksXG4gICAgICAgICAgICB0eXBlOiBhd2FpdCBiYXNlLnR5cGUoKSxcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnZmFsc2UtdHJ1ZSc6IHtcbiAgICAgICAgICByZXR1cm4gdGhlaXJzXG4gICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICBtb2RlOiBhd2FpdCB0aGVpcnMubW9kZSgpLFxuICAgICAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICAgICAgb2lkOiBhd2FpdCB0aGVpcnMub2lkKCksXG4gICAgICAgICAgICAgICAgdHlwZTogYXdhaXQgdGhlaXJzLnR5cGUoKSxcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiB1bmRlZmluZWRcbiAgICAgICAgfVxuICAgICAgICBjYXNlICd0cnVlLWZhbHNlJzoge1xuICAgICAgICAgIHJldHVybiBvdXJzXG4gICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICBtb2RlOiBhd2FpdCBvdXJzLm1vZGUoKSxcbiAgICAgICAgICAgICAgICBwYXRoLFxuICAgICAgICAgICAgICAgIG9pZDogYXdhaXQgb3Vycy5vaWQoKSxcbiAgICAgICAgICAgICAgICB0eXBlOiBhd2FpdCBvdXJzLnR5cGUoKSxcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiB1bmRlZmluZWRcbiAgICAgICAgfVxuICAgICAgICBjYXNlICd0cnVlLXRydWUnOiB7XG4gICAgICAgICAgLy8gTW9kaWZpY2F0aW9uc1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIG91cnMgJiZcbiAgICAgICAgICAgIGJhc2UgJiZcbiAgICAgICAgICAgIHRoZWlycyAmJlxuICAgICAgICAgICAgKGF3YWl0IG91cnMudHlwZSgpKSA9PT0gJ2Jsb2InICYmXG4gICAgICAgICAgICAoYXdhaXQgYmFzZS50eXBlKCkpID09PSAnYmxvYicgJiZcbiAgICAgICAgICAgIChhd2FpdCB0aGVpcnMudHlwZSgpKSA9PT0gJ2Jsb2InXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gbWVyZ2VCbG9icyh7XG4gICAgICAgICAgICAgIGZzLFxuICAgICAgICAgICAgICBnaXRkaXIsXG4gICAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICAgIG91cnMsXG4gICAgICAgICAgICAgIGJhc2UsXG4gICAgICAgICAgICAgIHRoZWlycyxcbiAgICAgICAgICAgICAgb3VyTmFtZSxcbiAgICAgICAgICAgICAgYmFzZU5hbWUsXG4gICAgICAgICAgICAgIHRoZWlyTmFtZSxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIGFsbCBvdGhlciB0eXBlcyBvZiBjb25mbGljdHMgZmFpbFxuICAgICAgICAgIHRocm93IG5ldyBNZXJnZU5vdFN1cHBvcnRlZEVycm9yKClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtUcmVlRW50cnl9IFtwYXJlbnRdXG4gICAgICogQHBhcmFtIHtBcnJheTxUcmVlRW50cnk+fSBjaGlsZHJlblxuICAgICAqL1xuICAgIHJlZHVjZTogYXN5bmMgKHBhcmVudCwgY2hpbGRyZW4pID0+IHtcbiAgICAgIGNvbnN0IGVudHJpZXMgPSBjaGlsZHJlbi5maWx0ZXIoQm9vbGVhbik7IC8vIHJlbW92ZSB1bmRlZmluZWRzXG5cbiAgICAgIC8vIGlmIHRoZSBwYXJlbnQgd2FzIGRlbGV0ZWQsIHRoZSBjaGlsZHJlbiBoYXZlIHRvIGdvXG4gICAgICBpZiAoIXBhcmVudCkgcmV0dXJuXG5cbiAgICAgIC8vIGF1dG9tYXRpY2FsbHkgZGVsZXRlIGRpcmVjdG9yaWVzIGlmIHRoZXkgaGF2ZSBiZWVuIGVtcHRpZWRcbiAgICAgIGlmIChwYXJlbnQgJiYgcGFyZW50LnR5cGUgPT09ICd0cmVlJyAmJiBlbnRyaWVzLmxlbmd0aCA9PT0gMCkgcmV0dXJuXG5cbiAgICAgIGlmIChlbnRyaWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3QgdHJlZSA9IG5ldyBHaXRUcmVlKGVudHJpZXMpO1xuICAgICAgICBjb25zdCBvYmplY3QgPSB0cmVlLnRvT2JqZWN0KCk7XG4gICAgICAgIGNvbnN0IG9pZCA9IGF3YWl0IF93cml0ZU9iamVjdCh7XG4gICAgICAgICAgZnMsXG4gICAgICAgICAgZ2l0ZGlyLFxuICAgICAgICAgIHR5cGU6ICd0cmVlJyxcbiAgICAgICAgICBvYmplY3QsXG4gICAgICAgICAgZHJ5UnVuLFxuICAgICAgICB9KTtcbiAgICAgICAgcGFyZW50Lm9pZCA9IG9pZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJlbnRcbiAgICB9LFxuICB9KTtcbiAgcmV0dXJuIHJlc3VsdHMub2lkXG59XG5cbi8qKlxuICpcbiAqIEBwYXJhbSB7V2Fsa2VyRW50cnl9IGVudHJ5XG4gKiBAcGFyYW0ge1dhbGtlckVudHJ5fSBiYXNlXG4gKlxuICovXG5hc3luYyBmdW5jdGlvbiBtb2RpZmllZChlbnRyeSwgYmFzZSkge1xuICBpZiAoIWVudHJ5ICYmICFiYXNlKSByZXR1cm4gZmFsc2VcbiAgaWYgKGVudHJ5ICYmICFiYXNlKSByZXR1cm4gdHJ1ZVxuICBpZiAoIWVudHJ5ICYmIGJhc2UpIHJldHVybiB0cnVlXG4gIGlmICgoYXdhaXQgZW50cnkudHlwZSgpKSA9PT0gJ3RyZWUnICYmIChhd2FpdCBiYXNlLnR5cGUoKSkgPT09ICd0cmVlJykge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIGlmIChcbiAgICAoYXdhaXQgZW50cnkudHlwZSgpKSA9PT0gKGF3YWl0IGJhc2UudHlwZSgpKSAmJlxuICAgIChhd2FpdCBlbnRyeS5tb2RlKCkpID09PSAoYXdhaXQgYmFzZS5tb2RlKCkpICYmXG4gICAgKGF3YWl0IGVudHJ5Lm9pZCgpKSA9PT0gKGF3YWl0IGJhc2Uub2lkKCkpXG4gICkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIHJldHVybiB0cnVlXG59XG5cbi8qKlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vbW9kZWxzL0ZpbGVTeXN0ZW0nKS5GaWxlU3lzdGVtfSBhcmdzLmZzXG4gKiBAcGFyYW0ge3N0cmluZ30gYXJncy5naXRkaXJcbiAqIEBwYXJhbSB7c3RyaW5nfSBhcmdzLnBhdGhcbiAqIEBwYXJhbSB7V2Fsa2VyRW50cnl9IGFyZ3Mub3Vyc1xuICogQHBhcmFtIHtXYWxrZXJFbnRyeX0gYXJncy5iYXNlXG4gKiBAcGFyYW0ge1dhbGtlckVudHJ5fSBhcmdzLnRoZWlyc1xuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLm91ck5hbWVdXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MuYmFzZU5hbWVdXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MudGhlaXJOYW1lXVxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLmZvcm1hdF1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbYXJncy5tYXJrZXJTaXplXVxuICogQHBhcmFtIHtib29sZWFufSBbYXJncy5kcnlSdW4gPSBmYWxzZV1cbiAqXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIG1lcmdlQmxvYnMoe1xuICBmcyxcbiAgZ2l0ZGlyLFxuICBwYXRoLFxuICBvdXJzLFxuICBiYXNlLFxuICB0aGVpcnMsXG4gIG91ck5hbWUsXG4gIHRoZWlyTmFtZSxcbiAgYmFzZU5hbWUsXG4gIGZvcm1hdCxcbiAgbWFya2VyU2l6ZSxcbiAgZHJ5UnVuLFxufSkge1xuICBjb25zdCB0eXBlID0gJ2Jsb2InO1xuICAvLyBDb21wdXRlIHRoZSBuZXcgbW9kZS5cbiAgLy8gU2luY2UgdGhlcmUgYXJlIE9OTFkgdHdvIHZhbGlkIGJsb2IgbW9kZXMgKCcxMDA3NTUnIGFuZCAnMTAwNjQ0JykgaXQgYm9pbHMgZG93biB0byB0aGlzXG4gIGNvbnN0IG1vZGUgPVxuICAgIChhd2FpdCBiYXNlLm1vZGUoKSkgPT09IChhd2FpdCBvdXJzLm1vZGUoKSlcbiAgICAgID8gYXdhaXQgdGhlaXJzLm1vZGUoKVxuICAgICAgOiBhd2FpdCBvdXJzLm1vZGUoKTtcbiAgLy8gVGhlIHRyaXZpYWwgY2FzZTogbm90aGluZyB0byBtZXJnZSBleGNlcHQgbWF5YmUgbW9kZVxuICBpZiAoKGF3YWl0IG91cnMub2lkKCkpID09PSAoYXdhaXQgdGhlaXJzLm9pZCgpKSkge1xuICAgIHJldHVybiB7IG1vZGUsIHBhdGgsIG9pZDogYXdhaXQgb3Vycy5vaWQoKSwgdHlwZSB9XG4gIH1cbiAgLy8gaWYgb25seSBvbmUgc2lkZSBtYWRlIG9pZCBjaGFuZ2VzLCByZXR1cm4gdGhhdCBzaWRlJ3Mgb2lkXG4gIGlmICgoYXdhaXQgb3Vycy5vaWQoKSkgPT09IChhd2FpdCBiYXNlLm9pZCgpKSkge1xuICAgIHJldHVybiB7IG1vZGUsIHBhdGgsIG9pZDogYXdhaXQgdGhlaXJzLm9pZCgpLCB0eXBlIH1cbiAgfVxuICBpZiAoKGF3YWl0IHRoZWlycy5vaWQoKSkgPT09IChhd2FpdCBiYXNlLm9pZCgpKSkge1xuICAgIHJldHVybiB7IG1vZGUsIHBhdGgsIG9pZDogYXdhaXQgb3Vycy5vaWQoKSwgdHlwZSB9XG4gIH1cbiAgLy8gaWYgYm90aCBzaWRlcyBtYWRlIGNoYW5nZXMgZG8gYSBtZXJnZVxuICBjb25zdCB7IG1lcmdlZFRleHQsIGNsZWFuTWVyZ2UgfSA9IG1lcmdlRmlsZSh7XG4gICAgb3VyQ29udGVudDogQnVmZmVyLmZyb20oYXdhaXQgb3Vycy5jb250ZW50KCkpLnRvU3RyaW5nKCd1dGY4JyksXG4gICAgYmFzZUNvbnRlbnQ6IEJ1ZmZlci5mcm9tKGF3YWl0IGJhc2UuY29udGVudCgpKS50b1N0cmluZygndXRmOCcpLFxuICAgIHRoZWlyQ29udGVudDogQnVmZmVyLmZyb20oYXdhaXQgdGhlaXJzLmNvbnRlbnQoKSkudG9TdHJpbmcoJ3V0ZjgnKSxcbiAgICBvdXJOYW1lLFxuICAgIHRoZWlyTmFtZSxcbiAgICBiYXNlTmFtZSxcbiAgICBmb3JtYXQsXG4gICAgbWFya2VyU2l6ZSxcbiAgfSk7XG4gIGlmICghY2xlYW5NZXJnZSkge1xuICAgIC8vIGFsbCBvdGhlciB0eXBlcyBvZiBjb25mbGljdHMgZmFpbFxuICAgIHRocm93IG5ldyBNZXJnZU5vdFN1cHBvcnRlZEVycm9yKClcbiAgfVxuICBjb25zdCBvaWQgPSBhd2FpdCBfd3JpdGVPYmplY3Qoe1xuICAgIGZzLFxuICAgIGdpdGRpcixcbiAgICB0eXBlOiAnYmxvYicsXG4gICAgb2JqZWN0OiBCdWZmZXIuZnJvbShtZXJnZWRUZXh0LCAndXRmOCcpLFxuICAgIGRyeVJ1bixcbiAgfSk7XG4gIHJldHVybiB7IG1vZGUsIHBhdGgsIG9pZCwgdHlwZSB9XG59XG5cbi8vIEB0cy1jaGVja1xuXG4vLyBpbXBvcnQgZGlmZjMgZnJvbSAnbm9kZS1kaWZmMydcbi8qKlxuICpcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE1lcmdlUmVzdWx0IC0gUmV0dXJucyBhbiBvYmplY3Qgd2l0aCBhIHNjaGVtYSBsaWtlIHRoaXM6XG4gKiBAcHJvcGVydHkge3N0cmluZ30gW29pZF0gLSBUaGUgU0hBLTEgb2JqZWN0IGlkIHRoYXQgaXMgbm93IGF0IHRoZSBoZWFkIG9mIHRoZSBicmFuY2guIEFic2VudCBvbmx5IGlmIGBkcnlSdW5gIHdhcyBzcGVjaWZpZWQgYW5kIGBtZXJnZUNvbW1pdGAgaXMgdHJ1ZS5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2FscmVhZHlNZXJnZWRdIC0gVHJ1ZSBpZiB0aGUgYnJhbmNoIHdhcyBhbHJlYWR5IG1lcmdlZCBzbyBubyBjaGFuZ2VzIHdlcmUgbWFkZVxuICogQHByb3BlcnR5IHtib29sZWFufSBbZmFzdEZvcndhcmRdIC0gVHJ1ZSBpZiBpdCB3YXMgYSBmYXN0LWZvcndhcmQgbWVyZ2VcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW21lcmdlQ29tbWl0XSAtIFRydWUgaWYgbWVyZ2UgcmVzdWx0ZWQgaW4gYSBtZXJnZSBjb21taXRcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbdHJlZV0gLSBUaGUgU0hBLTEgb2JqZWN0IGlkIG9mIHRoZSB0cmVlIHJlc3VsdGluZyBmcm9tIGEgbWVyZ2UgY29tbWl0XG4gKlxuICovXG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGFyZ3NcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9tb2RlbHMvRmlsZVN5c3RlbS5qcycpLkZpbGVTeXN0ZW19IGFyZ3MuZnNcbiAqIEBwYXJhbSB7b2JqZWN0fSBhcmdzLmNhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30gYXJncy5naXRkaXJcbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5vdXJzXVxuICogQHBhcmFtIHtzdHJpbmd9IGFyZ3MudGhlaXJzXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGFyZ3MuZmFzdEZvcndhcmRPbmx5XG4gKiBAcGFyYW0ge2Jvb2xlYW59IGFyZ3MuZHJ5UnVuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGFyZ3Mubm9VcGRhdGVCcmFuY2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5tZXNzYWdlXVxuICogQHBhcmFtIHtPYmplY3R9IGFyZ3MuYXV0aG9yXG4gKiBAcGFyYW0ge3N0cmluZ30gYXJncy5hdXRob3IubmFtZVxuICogQHBhcmFtIHtzdHJpbmd9IGFyZ3MuYXV0aG9yLmVtYWlsXG4gKiBAcGFyYW0ge251bWJlcn0gYXJncy5hdXRob3IudGltZXN0YW1wXG4gKiBAcGFyYW0ge251bWJlcn0gYXJncy5hdXRob3IudGltZXpvbmVPZmZzZXRcbiAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzLmNvbW1pdHRlclxuICogQHBhcmFtIHtzdHJpbmd9IGFyZ3MuY29tbWl0dGVyLm5hbWVcbiAqIEBwYXJhbSB7c3RyaW5nfSBhcmdzLmNvbW1pdHRlci5lbWFpbFxuICogQHBhcmFtIHtudW1iZXJ9IGFyZ3MuY29tbWl0dGVyLnRpbWVzdGFtcFxuICogQHBhcmFtIHtudW1iZXJ9IGFyZ3MuY29tbWl0dGVyLnRpbWV6b25lT2Zmc2V0XG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3Muc2lnbmluZ0tleV1cbiAqXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxNZXJnZVJlc3VsdD59IFJlc29sdmVzIHRvIGEgZGVzY3JpcHRpb24gb2YgdGhlIG1lcmdlIG9wZXJhdGlvblxuICpcbiAqL1xuYXN5bmMgZnVuY3Rpb24gX21lcmdlKHtcbiAgZnMsXG4gIGNhY2hlLFxuICBnaXRkaXIsXG4gIG91cnMsXG4gIHRoZWlycyxcbiAgZmFzdEZvcndhcmRPbmx5ID0gZmFsc2UsXG4gIGRyeVJ1biA9IGZhbHNlLFxuICBub1VwZGF0ZUJyYW5jaCA9IGZhbHNlLFxuICBtZXNzYWdlLFxuICBhdXRob3IsXG4gIGNvbW1pdHRlcixcbiAgc2lnbmluZ0tleSxcbn0pIHtcbiAgaWYgKG91cnMgPT09IHVuZGVmaW5lZCkge1xuICAgIG91cnMgPSBhd2FpdCBfY3VycmVudEJyYW5jaCh7IGZzLCBnaXRkaXIsIGZ1bGxuYW1lOiB0cnVlIH0pO1xuICB9XG4gIG91cnMgPSBhd2FpdCBHaXRSZWZNYW5hZ2VyLmV4cGFuZCh7XG4gICAgZnMsXG4gICAgZ2l0ZGlyLFxuICAgIHJlZjogb3VycyxcbiAgfSk7XG4gIHRoZWlycyA9IGF3YWl0IEdpdFJlZk1hbmFnZXIuZXhwYW5kKHtcbiAgICBmcyxcbiAgICBnaXRkaXIsXG4gICAgcmVmOiB0aGVpcnMsXG4gIH0pO1xuICBjb25zdCBvdXJPaWQgPSBhd2FpdCBHaXRSZWZNYW5hZ2VyLnJlc29sdmUoe1xuICAgIGZzLFxuICAgIGdpdGRpcixcbiAgICByZWY6IG91cnMsXG4gIH0pO1xuICBjb25zdCB0aGVpck9pZCA9IGF3YWl0IEdpdFJlZk1hbmFnZXIucmVzb2x2ZSh7XG4gICAgZnMsXG4gICAgZ2l0ZGlyLFxuICAgIHJlZjogdGhlaXJzLFxuICB9KTtcbiAgLy8gZmluZCBtb3N0IHJlY2VudCBjb21tb24gYW5jZXN0b3Igb2YgcmVmIGEgYW5kIHJlZiBiXG4gIGNvbnN0IGJhc2VPaWRzID0gYXdhaXQgX2ZpbmRNZXJnZUJhc2Uoe1xuICAgIGZzLFxuICAgIGNhY2hlLFxuICAgIGdpdGRpcixcbiAgICBvaWRzOiBbb3VyT2lkLCB0aGVpck9pZF0sXG4gIH0pO1xuICBpZiAoYmFzZU9pZHMubGVuZ3RoICE9PSAxKSB7XG4gICAgdGhyb3cgbmV3IE1lcmdlTm90U3VwcG9ydGVkRXJyb3IoKVxuICB9XG4gIGNvbnN0IGJhc2VPaWQgPSBiYXNlT2lkc1swXTtcbiAgLy8gaGFuZGxlIGZhc3QtZm9yd2FyZCBjYXNlXG4gIGlmIChiYXNlT2lkID09PSB0aGVpck9pZCkge1xuICAgIHJldHVybiB7XG4gICAgICBvaWQ6IG91ck9pZCxcbiAgICAgIGFscmVhZHlNZXJnZWQ6IHRydWUsXG4gICAgfVxuICB9XG4gIGlmIChiYXNlT2lkID09PSBvdXJPaWQpIHtcbiAgICBpZiAoIWRyeVJ1biAmJiAhbm9VcGRhdGVCcmFuY2gpIHtcbiAgICAgIGF3YWl0IEdpdFJlZk1hbmFnZXIud3JpdGVSZWYoeyBmcywgZ2l0ZGlyLCByZWY6IG91cnMsIHZhbHVlOiB0aGVpck9pZCB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIG9pZDogdGhlaXJPaWQsXG4gICAgICBmYXN0Rm9yd2FyZDogdHJ1ZSxcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gbm90IGEgc2ltcGxlIGZhc3QtZm9yd2FyZFxuICAgIGlmIChmYXN0Rm9yd2FyZE9ubHkpIHtcbiAgICAgIHRocm93IG5ldyBGYXN0Rm9yd2FyZEVycm9yKClcbiAgICB9XG4gICAgLy8gdHJ5IGEgZmFuY2llciBtZXJnZVxuICAgIGNvbnN0IHRyZWUgPSBhd2FpdCBtZXJnZVRyZWUoe1xuICAgICAgZnMsXG4gICAgICBjYWNoZSxcbiAgICAgIGdpdGRpcixcbiAgICAgIG91ck9pZCxcbiAgICAgIHRoZWlyT2lkLFxuICAgICAgYmFzZU9pZCxcbiAgICAgIG91ck5hbWU6IG91cnMsXG4gICAgICBiYXNlTmFtZTogJ2Jhc2UnLFxuICAgICAgdGhlaXJOYW1lOiB0aGVpcnMsXG4gICAgICBkcnlSdW4sXG4gICAgfSk7XG4gICAgaWYgKCFtZXNzYWdlKSB7XG4gICAgICBtZXNzYWdlID0gYE1lcmdlIGJyYW5jaCAnJHthYmJyZXZpYXRlUmVmKHRoZWlycyl9JyBpbnRvICR7YWJicmV2aWF0ZVJlZihcbiAgICAgICAgb3Vyc1xuICAgICAgKX1gO1xuICAgIH1cbiAgICBjb25zdCBvaWQgPSBhd2FpdCBfY29tbWl0KHtcbiAgICAgIGZzLFxuICAgICAgY2FjaGUsXG4gICAgICBnaXRkaXIsXG4gICAgICBtZXNzYWdlLFxuICAgICAgcmVmOiBvdXJzLFxuICAgICAgdHJlZSxcbiAgICAgIHBhcmVudDogW291ck9pZCwgdGhlaXJPaWRdLFxuICAgICAgYXV0aG9yLFxuICAgICAgY29tbWl0dGVyLFxuICAgICAgc2lnbmluZ0tleSxcbiAgICAgIGRyeVJ1bixcbiAgICAgIG5vVXBkYXRlQnJhbmNoLFxuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICBvaWQsXG4gICAgICB0cmVlLFxuICAgICAgbWVyZ2VDb21taXQ6IHRydWUsXG4gICAgfVxuICB9XG59XG5cbi8vIEB0cy1jaGVja1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBhcmdzXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vbW9kZWxzL0ZpbGVTeXN0ZW0uanMnKS5GaWxlU3lzdGVtfSBhcmdzLmZzXG4gKiBAcGFyYW0ge29iamVjdH0gYXJncy5jYWNoZVxuICogQHBhcmFtIHtIdHRwQ2xpZW50fSBhcmdzLmh0dHBcbiAqIEBwYXJhbSB7UHJvZ3Jlc3NDYWxsYmFja30gW2FyZ3Mub25Qcm9ncmVzc11cbiAqIEBwYXJhbSB7TWVzc2FnZUNhbGxiYWNrfSBbYXJncy5vbk1lc3NhZ2VdXG4gKiBAcGFyYW0ge0F1dGhDYWxsYmFja30gW2FyZ3Mub25BdXRoXVxuICogQHBhcmFtIHtBdXRoRmFpbHVyZUNhbGxiYWNrfSBbYXJncy5vbkF1dGhGYWlsdXJlXVxuICogQHBhcmFtIHtBdXRoU3VjY2Vzc0NhbGxiYWNrfSBbYXJncy5vbkF1dGhTdWNjZXNzXVxuICogQHBhcmFtIHtzdHJpbmd9IGFyZ3MuZGlyXG4gKiBAcGFyYW0ge3N0cmluZ30gYXJncy5naXRkaXJcbiAqIEBwYXJhbSB7c3RyaW5nfSBhcmdzLnJlZlxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLnVybF1cbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5yZW1vdGVdXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MucmVtb3RlUmVmXVxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLmNvcnNQcm94eV1cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gYXJncy5zaW5nbGVCcmFuY2hcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gYXJncy5mYXN0Rm9yd2FyZE9ubHlcbiAqIEBwYXJhbSB7T2JqZWN0PHN0cmluZywgc3RyaW5nPn0gW2FyZ3MuaGVhZGVyc11cbiAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzLmF1dGhvclxuICogQHBhcmFtIHtzdHJpbmd9IGFyZ3MuYXV0aG9yLm5hbWVcbiAqIEBwYXJhbSB7c3RyaW5nfSBhcmdzLmF1dGhvci5lbWFpbFxuICogQHBhcmFtIHtudW1iZXJ9IGFyZ3MuYXV0aG9yLnRpbWVzdGFtcFxuICogQHBhcmFtIHtudW1iZXJ9IGFyZ3MuYXV0aG9yLnRpbWV6b25lT2Zmc2V0XG4gKiBAcGFyYW0ge09iamVjdH0gYXJncy5jb21taXR0ZXJcbiAqIEBwYXJhbSB7c3RyaW5nfSBhcmdzLmNvbW1pdHRlci5uYW1lXG4gKiBAcGFyYW0ge3N0cmluZ30gYXJncy5jb21taXR0ZXIuZW1haWxcbiAqIEBwYXJhbSB7bnVtYmVyfSBhcmdzLmNvbW1pdHRlci50aW1lc3RhbXBcbiAqIEBwYXJhbSB7bnVtYmVyfSBhcmdzLmNvbW1pdHRlci50aW1lem9uZU9mZnNldFxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLnNpZ25pbmdLZXldXG4gKlxuICogQHJldHVybnMge1Byb21pc2U8dm9pZD59IFJlc29sdmVzIHN1Y2Nlc3NmdWxseSB3aGVuIHB1bGwgb3BlcmF0aW9uIGNvbXBsZXRlc1xuICpcbiAqL1xuYXN5bmMgZnVuY3Rpb24gX3B1bGwoe1xuICBmcyxcbiAgY2FjaGUsXG4gIGh0dHAsXG4gIG9uUHJvZ3Jlc3MsXG4gIG9uTWVzc2FnZSxcbiAgb25BdXRoLFxuICBvbkF1dGhTdWNjZXNzLFxuICBvbkF1dGhGYWlsdXJlLFxuICBkaXIsXG4gIGdpdGRpcixcbiAgcmVmLFxuICB1cmwsXG4gIHJlbW90ZSxcbiAgcmVtb3RlUmVmLFxuICBmYXN0Rm9yd2FyZE9ubHksXG4gIGNvcnNQcm94eSxcbiAgc2luZ2xlQnJhbmNoLFxuICBoZWFkZXJzLFxuICBhdXRob3IsXG4gIGNvbW1pdHRlcixcbiAgc2lnbmluZ0tleSxcbn0pIHtcbiAgdHJ5IHtcbiAgICAvLyBJZiByZWYgaXMgdW5kZWZpbmVkLCB1c2UgJ0hFQUQnXG4gICAgaWYgKCFyZWYpIHtcbiAgICAgIGNvbnN0IGhlYWQgPSBhd2FpdCBfY3VycmVudEJyYW5jaCh7IGZzLCBnaXRkaXIgfSk7XG4gICAgICAvLyBUT0RPOiB1c2UgYSBiZXR0ZXIgZXJyb3IuXG4gICAgICBpZiAoIWhlYWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IE1pc3NpbmdQYXJhbWV0ZXJFcnJvcigncmVmJylcbiAgICAgIH1cbiAgICAgIHJlZiA9IGhlYWQ7XG4gICAgfVxuXG4gICAgY29uc3QgeyBmZXRjaEhlYWQsIGZldGNoSGVhZERlc2NyaXB0aW9uIH0gPSBhd2FpdCBfZmV0Y2goe1xuICAgICAgZnMsXG4gICAgICBjYWNoZSxcbiAgICAgIGh0dHAsXG4gICAgICBvblByb2dyZXNzLFxuICAgICAgb25NZXNzYWdlLFxuICAgICAgb25BdXRoLFxuICAgICAgb25BdXRoU3VjY2VzcyxcbiAgICAgIG9uQXV0aEZhaWx1cmUsXG4gICAgICBnaXRkaXIsXG4gICAgICBjb3JzUHJveHksXG4gICAgICByZWYsXG4gICAgICB1cmwsXG4gICAgICByZW1vdGUsXG4gICAgICByZW1vdGVSZWYsXG4gICAgICBzaW5nbGVCcmFuY2gsXG4gICAgICBoZWFkZXJzLFxuICAgIH0pO1xuICAgIC8vIE1lcmdlIHRoZSByZW1vdGUgdHJhY2tpbmcgYnJhbmNoIGludG8gdGhlIGxvY2FsIG9uZS5cbiAgICBhd2FpdCBfbWVyZ2Uoe1xuICAgICAgZnMsXG4gICAgICBjYWNoZSxcbiAgICAgIGdpdGRpcixcbiAgICAgIG91cnM6IHJlZixcbiAgICAgIHRoZWlyczogZmV0Y2hIZWFkLFxuICAgICAgZmFzdEZvcndhcmRPbmx5LFxuICAgICAgbWVzc2FnZTogYE1lcmdlICR7ZmV0Y2hIZWFkRGVzY3JpcHRpb259YCxcbiAgICAgIGF1dGhvcixcbiAgICAgIGNvbW1pdHRlcixcbiAgICAgIHNpZ25pbmdLZXksXG4gICAgICBkcnlSdW46IGZhbHNlLFxuICAgICAgbm9VcGRhdGVCcmFuY2g6IGZhbHNlLFxuICAgIH0pO1xuICAgIGF3YWl0IF9jaGVja291dCh7XG4gICAgICBmcyxcbiAgICAgIGNhY2hlLFxuICAgICAgb25Qcm9ncmVzcyxcbiAgICAgIGRpcixcbiAgICAgIGdpdGRpcixcbiAgICAgIHJlZixcbiAgICAgIHJlbW90ZSxcbiAgICAgIG5vQ2hlY2tvdXQ6IGZhbHNlLFxuICAgIH0pO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBlcnIuY2FsbGVyID0gJ2dpdC5wdWxsJztcbiAgICB0aHJvdyBlcnJcbiAgfVxufVxuXG4vLyBAdHMtY2hlY2tcblxuLyoqXG4gKiBMaWtlIGBwdWxsYCwgYnV0IGhhcmQtY29kZWQgd2l0aCBgZmFzdEZvcndhcmQ6IHRydWVgIHNvIHRoZXJlIGlzIG5vIG5lZWQgZm9yIGFuIGBhdXRob3JgIHBhcmFtZXRlci5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gYXJnc1xuICogQHBhcmFtIHtGc0NsaWVudH0gYXJncy5mcyAtIGEgZmlsZSBzeXN0ZW0gY2xpZW50XG4gKiBAcGFyYW0ge0h0dHBDbGllbnR9IGFyZ3MuaHR0cCAtIGFuIEhUVFAgY2xpZW50XG4gKiBAcGFyYW0ge1Byb2dyZXNzQ2FsbGJhY2t9IFthcmdzLm9uUHJvZ3Jlc3NdIC0gb3B0aW9uYWwgcHJvZ3Jlc3MgZXZlbnQgY2FsbGJhY2tcbiAqIEBwYXJhbSB7TWVzc2FnZUNhbGxiYWNrfSBbYXJncy5vbk1lc3NhZ2VdIC0gb3B0aW9uYWwgbWVzc2FnZSBldmVudCBjYWxsYmFja1xuICogQHBhcmFtIHtBdXRoQ2FsbGJhY2t9IFthcmdzLm9uQXV0aF0gLSBvcHRpb25hbCBhdXRoIGZpbGwgY2FsbGJhY2tcbiAqIEBwYXJhbSB7QXV0aEZhaWx1cmVDYWxsYmFja30gW2FyZ3Mub25BdXRoRmFpbHVyZV0gLSBvcHRpb25hbCBhdXRoIHJlamVjdGVkIGNhbGxiYWNrXG4gKiBAcGFyYW0ge0F1dGhTdWNjZXNzQ2FsbGJhY2t9IFthcmdzLm9uQXV0aFN1Y2Nlc3NdIC0gb3B0aW9uYWwgYXV0aCBhcHByb3ZlZCBjYWxsYmFja1xuICogQHBhcmFtIHtzdHJpbmd9IGFyZ3MuZGlyXSAtIFRoZSBbd29ya2luZyB0cmVlXShkaXItdnMtZ2l0ZGlyLm1kKSBkaXJlY3RvcnkgcGF0aFxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLmdpdGRpcj1qb2luKGRpciwnLmdpdCcpXSAtIFtyZXF1aXJlZF0gVGhlIFtnaXQgZGlyZWN0b3J5XShkaXItdnMtZ2l0ZGlyLm1kKSBwYXRoXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MucmVmXSAtIFdoaWNoIGJyYW5jaCB0byBtZXJnZSBpbnRvLiBCeSBkZWZhdWx0IHRoaXMgaXMgdGhlIGN1cnJlbnRseSBjaGVja2VkIG91dCBicmFuY2guXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MudXJsXSAtIChBZGRlZCBpbiAxLjEuMCkgVGhlIFVSTCBvZiB0aGUgcmVtb3RlIHJlcG9zaXRvcnkuIFRoZSBkZWZhdWx0IGlzIHRoZSB2YWx1ZSBzZXQgaW4gdGhlIGdpdCBjb25maWcgZm9yIHRoYXQgcmVtb3RlLlxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLnJlbW90ZV0gLSAoQWRkZWQgaW4gMS4xLjApIElmIFVSTCBpcyBub3Qgc3BlY2lmaWVkLCBkZXRlcm1pbmVzIHdoaWNoIHJlbW90ZSB0byB1c2UuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MucmVtb3RlUmVmXSAtIChBZGRlZCBpbiAxLjEuMCkgVGhlIG5hbWUgb2YgdGhlIGJyYW5jaCBvbiB0aGUgcmVtb3RlIHRvIGZldGNoLiBCeSBkZWZhdWx0IHRoaXMgaXMgdGhlIGNvbmZpZ3VyZWQgcmVtb3RlIHRyYWNraW5nIGJyYW5jaC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5jb3JzUHJveHldIC0gT3B0aW9uYWwgW0NPUlMgcHJveHldKGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS8lNDBpc29tb3JwaGljLWdpdC9jb3JzLXByb3h5KS4gT3ZlcnJpZGVzIHZhbHVlIGluIHJlcG8gY29uZmlnLlxuICogQHBhcmFtIHtib29sZWFufSBbYXJncy5zaW5nbGVCcmFuY2ggPSBmYWxzZV0gLSBJbnN0ZWFkIG9mIHRoZSBkZWZhdWx0IGJlaGF2aW9yIG9mIGZldGNoaW5nIGFsbCB0aGUgYnJhbmNoZXMsIG9ubHkgZmV0Y2ggYSBzaW5nbGUgYnJhbmNoLlxuICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLCBzdHJpbmc+fSBbYXJncy5oZWFkZXJzXSAtIEFkZGl0aW9uYWwgaGVhZGVycyB0byBpbmNsdWRlIGluIEhUVFAgcmVxdWVzdHMsIHNpbWlsYXIgdG8gZ2l0J3MgYGV4dHJhSGVhZGVyYCBjb25maWdcbiAqIEBwYXJhbSB7b2JqZWN0fSBbYXJncy5jYWNoZV0gLSBhIFtjYWNoZV0oY2FjaGUubWQpIG9iamVjdFxuICpcbiAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fSBSZXNvbHZlcyBzdWNjZXNzZnVsbHkgd2hlbiBwdWxsIG9wZXJhdGlvbiBjb21wbGV0ZXNcbiAqXG4gKiBAZXhhbXBsZVxuICogYXdhaXQgZ2l0LmZhc3RGb3J3YXJkKHtcbiAqICAgZnMsXG4gKiAgIGh0dHAsXG4gKiAgIGRpcjogJy90dXRvcmlhbCcsXG4gKiAgIHJlZjogJ21haW4nLFxuICogICBzaW5nbGVCcmFuY2g6IHRydWVcbiAqIH0pXG4gKiBjb25zb2xlLmxvZygnZG9uZScpXG4gKlxuICovXG5hc3luYyBmdW5jdGlvbiBmYXN0Rm9yd2FyZCh7XG4gIGZzLFxuICBodHRwLFxuICBvblByb2dyZXNzLFxuICBvbk1lc3NhZ2UsXG4gIG9uQXV0aCxcbiAgb25BdXRoU3VjY2VzcyxcbiAgb25BdXRoRmFpbHVyZSxcbiAgZGlyLFxuICBnaXRkaXIgPSBqb2luKGRpciwgJy5naXQnKSxcbiAgcmVmLFxuICB1cmwsXG4gIHJlbW90ZSxcbiAgcmVtb3RlUmVmLFxuICBjb3JzUHJveHksXG4gIHNpbmdsZUJyYW5jaCxcbiAgaGVhZGVycyA9IHt9LFxuICBjYWNoZSA9IHt9LFxufSkge1xuICB0cnkge1xuICAgIGFzc2VydFBhcmFtZXRlcignZnMnLCBmcyk7XG4gICAgYXNzZXJ0UGFyYW1ldGVyKCdodHRwJywgaHR0cCk7XG4gICAgYXNzZXJ0UGFyYW1ldGVyKCdnaXRkaXInLCBnaXRkaXIpO1xuXG4gICAgY29uc3QgdGhpc1dpbGxOb3RCZVVzZWQgPSB7XG4gICAgICBuYW1lOiAnJyxcbiAgICAgIGVtYWlsOiAnJyxcbiAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcbiAgICAgIHRpbWV6b25lT2Zmc2V0OiAwLFxuICAgIH07XG5cbiAgICByZXR1cm4gYXdhaXQgX3B1bGwoe1xuICAgICAgZnM6IG5ldyBGaWxlU3lzdGVtKGZzKSxcbiAgICAgIGNhY2hlLFxuICAgICAgaHR0cCxcbiAgICAgIG9uUHJvZ3Jlc3MsXG4gICAgICBvbk1lc3NhZ2UsXG4gICAgICBvbkF1dGgsXG4gICAgICBvbkF1dGhTdWNjZXNzLFxuICAgICAgb25BdXRoRmFpbHVyZSxcbiAgICAgIGRpcixcbiAgICAgIGdpdGRpcixcbiAgICAgIHJlZixcbiAgICAgIHVybCxcbiAgICAgIHJlbW90ZSxcbiAgICAgIHJlbW90ZVJlZixcbiAgICAgIGZhc3RGb3J3YXJkT25seTogdHJ1ZSxcbiAgICAgIGNvcnNQcm94eSxcbiAgICAgIHNpbmdsZUJyYW5jaCxcbiAgICAgIGhlYWRlcnMsXG4gICAgICBhdXRob3I6IHRoaXNXaWxsTm90QmVVc2VkLFxuICAgICAgY29tbWl0dGVyOiB0aGlzV2lsbE5vdEJlVXNlZCxcbiAgICB9KVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBlcnIuY2FsbGVyID0gJ2dpdC5mYXN0Rm9yd2FyZCc7XG4gICAgdGhyb3cgZXJyXG4gIH1cbn1cblxuLy8gQHRzLWNoZWNrXG5cbi8qKlxuICpcbiAqIEB0eXBlZGVmIHtvYmplY3R9IEZldGNoUmVzdWx0IC0gVGhlIG9iamVjdCByZXR1cm5lZCBoYXMgdGhlIGZvbGxvd2luZyBzY2hlbWE6XG4gKiBAcHJvcGVydHkge3N0cmluZyB8IG51bGx9IGRlZmF1bHRCcmFuY2ggLSBUaGUgYnJhbmNoIHRoYXQgaXMgY2xvbmVkIGlmIG5vIGJyYW5jaCBpcyBzcGVjaWZpZWRcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nIHwgbnVsbH0gZmV0Y2hIZWFkIC0gVGhlIFNIQS0xIG9iamVjdCBpZCBvZiB0aGUgZmV0Y2hlZCBoZWFkIGNvbW1pdFxuICogQHByb3BlcnR5IHtzdHJpbmcgfCBudWxsfSBmZXRjaEhlYWREZXNjcmlwdGlvbiAtIGEgdGV4dHVhbCBkZXNjcmlwdGlvbiBvZiB0aGUgYnJhbmNoIHRoYXQgd2FzIGZldGNoZWRcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0PHN0cmluZywgc3RyaW5nPn0gW2hlYWRlcnNdIC0gVGhlIEhUVFAgcmVzcG9uc2UgaGVhZGVycyByZXR1cm5lZCBieSB0aGUgZ2l0IHNlcnZlclxuICogQHByb3BlcnR5IHtzdHJpbmdbXX0gW3BydW5lZF0gLSBBIGxpc3Qgb2YgYnJhbmNoZXMgdGhhdCB3ZXJlIHBydW5lZCwgaWYgeW91IHByb3ZpZGVkIHRoZSBgcHJ1bmVgIHBhcmFtZXRlclxuICpcbiAqL1xuXG4vKipcbiAqIEZldGNoIGNvbW1pdHMgZnJvbSBhIHJlbW90ZSByZXBvc2l0b3J5XG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGFyZ3NcbiAqIEBwYXJhbSB7RnNDbGllbnR9IGFyZ3MuZnMgLSBhIGZpbGUgc3lzdGVtIGNsaWVudFxuICogQHBhcmFtIHtIdHRwQ2xpZW50fSBhcmdzLmh0dHAgLSBhbiBIVFRQIGNsaWVudFxuICogQHBhcmFtIHtQcm9ncmVzc0NhbGxiYWNrfSBbYXJncy5vblByb2dyZXNzXSAtIG9wdGlvbmFsIHByb2dyZXNzIGV2ZW50IGNhbGxiYWNrXG4gKiBAcGFyYW0ge01lc3NhZ2VDYWxsYmFja30gW2FyZ3Mub25NZXNzYWdlXSAtIG9wdGlvbmFsIG1lc3NhZ2UgZXZlbnQgY2FsbGJhY2tcbiAqIEBwYXJhbSB7QXV0aENhbGxiYWNrfSBbYXJncy5vbkF1dGhdIC0gb3B0aW9uYWwgYXV0aCBmaWxsIGNhbGxiYWNrXG4gKiBAcGFyYW0ge0F1dGhGYWlsdXJlQ2FsbGJhY2t9IFthcmdzLm9uQXV0aEZhaWx1cmVdIC0gb3B0aW9uYWwgYXV0aCByZWplY3RlZCBjYWxsYmFja1xuICogQHBhcmFtIHtBdXRoU3VjY2Vzc0NhbGxiYWNrfSBbYXJncy5vbkF1dGhTdWNjZXNzXSAtIG9wdGlvbmFsIGF1dGggYXBwcm92ZWQgY2FsbGJhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5kaXJdIC0gVGhlIFt3b3JraW5nIHRyZWVdKGRpci12cy1naXRkaXIubWQpIGRpcmVjdG9yeSBwYXRoXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MuZ2l0ZGlyPWpvaW4oZGlyLCcuZ2l0JyldIC0gW3JlcXVpcmVkXSBUaGUgW2dpdCBkaXJlY3RvcnldKGRpci12cy1naXRkaXIubWQpIHBhdGhcbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy51cmxdIC0gVGhlIFVSTCBvZiB0aGUgcmVtb3RlIHJlcG9zaXRvcnkuIFRoZSBkZWZhdWx0IGlzIHRoZSB2YWx1ZSBzZXQgaW4gdGhlIGdpdCBjb25maWcgZm9yIHRoYXQgcmVtb3RlLlxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLnJlbW90ZV0gLSBJZiBVUkwgaXMgbm90IHNwZWNpZmllZCwgZGV0ZXJtaW5lcyB3aGljaCByZW1vdGUgdG8gdXNlLlxuICogQHBhcmFtIHtib29sZWFufSBbYXJncy5zaW5nbGVCcmFuY2ggPSBmYWxzZV0gLSBJbnN0ZWFkIG9mIHRoZSBkZWZhdWx0IGJlaGF2aW9yIG9mIGZldGNoaW5nIGFsbCB0aGUgYnJhbmNoZXMsIG9ubHkgZmV0Y2ggYSBzaW5nbGUgYnJhbmNoLlxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLnJlZl0gLSBXaGljaCBicmFuY2ggdG8gZmV0Y2ggaWYgYHNpbmdsZUJyYW5jaGAgaXMgdHJ1ZS4gQnkgZGVmYXVsdCB0aGlzIGlzIHRoZSBjdXJyZW50IGJyYW5jaCBvciB0aGUgcmVtb3RlJ3MgZGVmYXVsdCBicmFuY2guXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MucmVtb3RlUmVmXSAtIFRoZSBuYW1lIG9mIHRoZSBicmFuY2ggb24gdGhlIHJlbW90ZSB0byBmZXRjaCBpZiBgc2luZ2xlQnJhbmNoYCBpcyB0cnVlLiBCeSBkZWZhdWx0IHRoaXMgaXMgdGhlIGNvbmZpZ3VyZWQgcmVtb3RlIHRyYWNraW5nIGJyYW5jaC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2FyZ3MudGFncyA9IGZhbHNlXSAtIEFsc28gZmV0Y2ggdGFnc1xuICogQHBhcmFtIHtudW1iZXJ9IFthcmdzLmRlcHRoXSAtIEludGVnZXIuIERldGVybWluZXMgaG93IG11Y2ggb2YgdGhlIGdpdCByZXBvc2l0b3J5J3MgaGlzdG9yeSB0byByZXRyaWV2ZVxuICogQHBhcmFtIHtib29sZWFufSBbYXJncy5yZWxhdGl2ZSA9IGZhbHNlXSAtIENoYW5nZXMgdGhlIG1lYW5pbmcgb2YgYGRlcHRoYCB0byBiZSBtZWFzdXJlZCBmcm9tIHRoZSBjdXJyZW50IHNoYWxsb3cgZGVwdGggcmF0aGVyIHRoYW4gZnJvbSB0aGUgYnJhbmNoIHRpcC5cbiAqIEBwYXJhbSB7RGF0ZX0gW2FyZ3Muc2luY2VdIC0gT25seSBmZXRjaCBjb21taXRzIGNyZWF0ZWQgYWZ0ZXIgdGhlIGdpdmVuIGRhdGUuIE11dHVhbGx5IGV4Y2x1c2l2ZSB3aXRoIGBkZXB0aGAuXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBbYXJncy5leGNsdWRlID0gW11dIC0gQSBsaXN0IG9mIGJyYW5jaGVzIG9yIHRhZ3MuIEluc3RydWN0cyB0aGUgcmVtb3RlIHNlcnZlciBub3QgdG8gc2VuZCB1cyBhbnkgY29tbWl0cyByZWFjaGFibGUgZnJvbSB0aGVzZSByZWZzLlxuICogQHBhcmFtIHtib29sZWFufSBbYXJncy5wcnVuZV0gLSBEZWxldGUgbG9jYWwgcmVtb3RlLXRyYWNraW5nIGJyYW5jaGVzIHRoYXQgYXJlIG5vdCBwcmVzZW50IG9uIHRoZSByZW1vdGVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2FyZ3MucHJ1bmVUYWdzXSAtIFBydW5lIGxvY2FsIHRhZ3MgdGhhdCBkb27igJl0IGV4aXN0IG9uIHRoZSByZW1vdGUsIGFuZCBmb3JjZS11cGRhdGUgdGhvc2UgdGFncyB0aGF0IGRpZmZlclxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLmNvcnNQcm94eV0gLSBPcHRpb25hbCBbQ09SUyBwcm94eV0oaHR0cHM6Ly93d3cubnBtanMuY29tLyU0MGlzb21vcnBoaWMtZ2l0L2NvcnMtcHJveHkpLiBPdmVycmlkZXMgdmFsdWUgaW4gcmVwbyBjb25maWcuXG4gKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsIHN0cmluZz59IFthcmdzLmhlYWRlcnNdIC0gQWRkaXRpb25hbCBoZWFkZXJzIHRvIGluY2x1ZGUgaW4gSFRUUCByZXF1ZXN0cywgc2ltaWxhciB0byBnaXQncyBgZXh0cmFIZWFkZXJgIGNvbmZpZ1xuICogQHBhcmFtIHtvYmplY3R9IFthcmdzLmNhY2hlXSAtIGEgW2NhY2hlXShjYWNoZS5tZCkgb2JqZWN0XG4gKlxuICogQHJldHVybnMge1Byb21pc2U8RmV0Y2hSZXN1bHQ+fSBSZXNvbHZlcyBzdWNjZXNzZnVsbHkgd2hlbiBmZXRjaCBjb21wbGV0ZXNcbiAqIEBzZWUgRmV0Y2hSZXN1bHRcbiAqXG4gKiBAZXhhbXBsZVxuICogbGV0IHJlc3VsdCA9IGF3YWl0IGdpdC5mZXRjaCh7XG4gKiAgIGZzLFxuICogICBodHRwLFxuICogICBkaXI6ICcvdHV0b3JpYWwnLFxuICogICBjb3JzUHJveHk6ICdodHRwczovL2NvcnMuaXNvbW9ycGhpYy1naXQub3JnJyxcbiAqICAgdXJsOiAnaHR0cHM6Ly9naXRodWIuY29tL2lzb21vcnBoaWMtZ2l0L2lzb21vcnBoaWMtZ2l0JyxcbiAqICAgcmVmOiAnbWFpbicsXG4gKiAgIGRlcHRoOiAxLFxuICogICBzaW5nbGVCcmFuY2g6IHRydWUsXG4gKiAgIHRhZ3M6IGZhbHNlXG4gKiB9KVxuICogY29uc29sZS5sb2cocmVzdWx0KVxuICpcbiAqL1xuYXN5bmMgZnVuY3Rpb24gZmV0Y2goe1xuICBmcyxcbiAgaHR0cCxcbiAgb25Qcm9ncmVzcyxcbiAgb25NZXNzYWdlLFxuICBvbkF1dGgsXG4gIG9uQXV0aFN1Y2Nlc3MsXG4gIG9uQXV0aEZhaWx1cmUsXG4gIGRpcixcbiAgZ2l0ZGlyID0gam9pbihkaXIsICcuZ2l0JyksXG4gIHJlZixcbiAgcmVtb3RlLFxuICByZW1vdGVSZWYsXG4gIHVybCxcbiAgY29yc1Byb3h5LFxuICBkZXB0aCA9IG51bGwsXG4gIHNpbmNlID0gbnVsbCxcbiAgZXhjbHVkZSA9IFtdLFxuICByZWxhdGl2ZSA9IGZhbHNlLFxuICB0YWdzID0gZmFsc2UsXG4gIHNpbmdsZUJyYW5jaCA9IGZhbHNlLFxuICBoZWFkZXJzID0ge30sXG4gIHBydW5lID0gZmFsc2UsXG4gIHBydW5lVGFncyA9IGZhbHNlLFxuICBjYWNoZSA9IHt9LFxufSkge1xuICB0cnkge1xuICAgIGFzc2VydFBhcmFtZXRlcignZnMnLCBmcyk7XG4gICAgYXNzZXJ0UGFyYW1ldGVyKCdodHRwJywgaHR0cCk7XG4gICAgYXNzZXJ0UGFyYW1ldGVyKCdnaXRkaXInLCBnaXRkaXIpO1xuXG4gICAgcmV0dXJuIGF3YWl0IF9mZXRjaCh7XG4gICAgICBmczogbmV3IEZpbGVTeXN0ZW0oZnMpLFxuICAgICAgY2FjaGUsXG4gICAgICBodHRwLFxuICAgICAgb25Qcm9ncmVzcyxcbiAgICAgIG9uTWVzc2FnZSxcbiAgICAgIG9uQXV0aCxcbiAgICAgIG9uQXV0aFN1Y2Nlc3MsXG4gICAgICBvbkF1dGhGYWlsdXJlLFxuICAgICAgZ2l0ZGlyLFxuICAgICAgcmVmLFxuICAgICAgcmVtb3RlLFxuICAgICAgcmVtb3RlUmVmLFxuICAgICAgdXJsLFxuICAgICAgY29yc1Byb3h5LFxuICAgICAgZGVwdGgsXG4gICAgICBzaW5jZSxcbiAgICAgIGV4Y2x1ZGUsXG4gICAgICByZWxhdGl2ZSxcbiAgICAgIHRhZ3MsXG4gICAgICBzaW5nbGVCcmFuY2gsXG4gICAgICBoZWFkZXJzLFxuICAgICAgcHJ1bmUsXG4gICAgICBwcnVuZVRhZ3MsXG4gICAgfSlcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZXJyLmNhbGxlciA9ICdnaXQuZmV0Y2gnO1xuICAgIHRocm93IGVyclxuICB9XG59XG5cbi8vIEB0cy1jaGVja1xuXG4vKipcbiAqIEZpbmQgdGhlIG1lcmdlIGJhc2UgZm9yIGEgc2V0IG9mIGNvbW1pdHNcbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gYXJnc1xuICogQHBhcmFtIHtGc0NsaWVudH0gYXJncy5mcyAtIGEgZmlsZSBzeXN0ZW0gY2xpZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MuZGlyXSAtIFRoZSBbd29ya2luZyB0cmVlXShkaXItdnMtZ2l0ZGlyLm1kKSBkaXJlY3RvcnkgcGF0aFxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLmdpdGRpcj1qb2luKGRpciwnLmdpdCcpXSAtIFtyZXF1aXJlZF0gVGhlIFtnaXQgZGlyZWN0b3J5XShkaXItdnMtZ2l0ZGlyLm1kKSBwYXRoXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBhcmdzLm9pZHMgLSBXaGljaCBjb21taXRzXG4gKiBAcGFyYW0ge29iamVjdH0gW2FyZ3MuY2FjaGVdIC0gYSBbY2FjaGVdKGNhY2hlLm1kKSBvYmplY3RcbiAqXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGZpbmRNZXJnZUJhc2Uoe1xuICBmcyxcbiAgZGlyLFxuICBnaXRkaXIgPSBqb2luKGRpciwgJy5naXQnKSxcbiAgb2lkcyxcbiAgY2FjaGUgPSB7fSxcbn0pIHtcbiAgdHJ5IHtcbiAgICBhc3NlcnRQYXJhbWV0ZXIoJ2ZzJywgZnMpO1xuICAgIGFzc2VydFBhcmFtZXRlcignZ2l0ZGlyJywgZ2l0ZGlyKTtcbiAgICBhc3NlcnRQYXJhbWV0ZXIoJ29pZHMnLCBvaWRzKTtcblxuICAgIHJldHVybiBhd2FpdCBfZmluZE1lcmdlQmFzZSh7XG4gICAgICBmczogbmV3IEZpbGVTeXN0ZW0oZnMpLFxuICAgICAgY2FjaGUsXG4gICAgICBnaXRkaXIsXG4gICAgICBvaWRzLFxuICAgIH0pXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGVyci5jYWxsZXIgPSAnZ2l0LmZpbmRNZXJnZUJhc2UnO1xuICAgIHRocm93IGVyclxuICB9XG59XG5cbi8vIEB0cy1jaGVja1xuXG4vKipcbiAqIEZpbmQgdGhlIHJvb3QgZ2l0IGRpcmVjdG9yeVxuICpcbiAqIFN0YXJ0aW5nIGF0IGBmaWxlcGF0aGAsIHdhbGtzIHVwd2FyZCB1bnRpbCBpdCBmaW5kcyBhIGRpcmVjdG9yeSB0aGF0IGNvbnRhaW5zIGEgc3ViZGlyZWN0b3J5IGNhbGxlZCAnLmdpdCcuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGFyZ3NcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9tb2RlbHMvRmlsZVN5c3RlbS5qcycpLkZpbGVTeXN0ZW19IGFyZ3MuZnNcbiAqIEBwYXJhbSB7c3RyaW5nfSBhcmdzLmZpbGVwYXRoXG4gKlxuICogQHJldHVybnMge1Byb21pc2U8c3RyaW5nPn0gUmVzb2x2ZXMgc3VjY2Vzc2Z1bGx5IHdpdGggYSByb290IGdpdCBkaXJlY3RvcnkgcGF0aFxuICovXG5hc3luYyBmdW5jdGlvbiBfZmluZFJvb3QoeyBmcywgZmlsZXBhdGggfSkge1xuICBpZiAoYXdhaXQgZnMuZXhpc3RzKGpvaW4oZmlsZXBhdGgsICcuZ2l0JykpKSB7XG4gICAgcmV0dXJuIGZpbGVwYXRoXG4gIH0gZWxzZSB7XG4gICAgY29uc3QgcGFyZW50ID0gZGlybmFtZShmaWxlcGF0aCk7XG4gICAgaWYgKHBhcmVudCA9PT0gZmlsZXBhdGgpIHtcbiAgICAgIHRocm93IG5ldyBOb3RGb3VuZEVycm9yKGBnaXQgcm9vdCBmb3IgJHtmaWxlcGF0aH1gKVxuICAgIH1cbiAgICByZXR1cm4gX2ZpbmRSb290KHsgZnMsIGZpbGVwYXRoOiBwYXJlbnQgfSlcbiAgfVxufVxuXG4vLyBAdHMtY2hlY2tcblxuLyoqXG4gKiBGaW5kIHRoZSByb290IGdpdCBkaXJlY3RvcnlcbiAqXG4gKiBTdGFydGluZyBhdCBgZmlsZXBhdGhgLCB3YWxrcyB1cHdhcmQgdW50aWwgaXQgZmluZHMgYSBkaXJlY3RvcnkgdGhhdCBjb250YWlucyBhIHN1YmRpcmVjdG9yeSBjYWxsZWQgJy5naXQnLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzXG4gKiBAcGFyYW0ge0ZzQ2xpZW50fSBhcmdzLmZzIC0gYSBmaWxlIHN5c3RlbSBjbGllbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBhcmdzLmZpbGVwYXRoIC0gVGhlIGZpbGUgZGlyZWN0b3J5IHRvIHN0YXJ0IHNlYXJjaGluZyBpbi5cbiAqXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxzdHJpbmc+fSBSZXNvbHZlcyBzdWNjZXNzZnVsbHkgd2l0aCBhIHJvb3QgZ2l0IGRpcmVjdG9yeSBwYXRoXG4gKiBAdGhyb3dzIHtOb3RGb3VuZEVycm9yfVxuICpcbiAqIEBleGFtcGxlXG4gKiBsZXQgZ2l0cm9vdCA9IGF3YWl0IGdpdC5maW5kUm9vdCh7XG4gKiAgIGZzLFxuICogICBmaWxlcGF0aDogJy90dXRvcmlhbC9zcmMvdXRpbHMnXG4gKiB9KVxuICogY29uc29sZS5sb2coZ2l0cm9vdClcbiAqXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGZpbmRSb290KHsgZnMsIGZpbGVwYXRoIH0pIHtcbiAgdHJ5IHtcbiAgICBhc3NlcnRQYXJhbWV0ZXIoJ2ZzJywgZnMpO1xuICAgIGFzc2VydFBhcmFtZXRlcignZmlsZXBhdGgnLCBmaWxlcGF0aCk7XG5cbiAgICByZXR1cm4gYXdhaXQgX2ZpbmRSb290KHsgZnM6IG5ldyBGaWxlU3lzdGVtKGZzKSwgZmlsZXBhdGggfSlcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZXJyLmNhbGxlciA9ICdnaXQuZmluZFJvb3QnO1xuICAgIHRocm93IGVyclxuICB9XG59XG5cbi8vIEB0cy1jaGVja1xuXG4vKipcbiAqIFJlYWQgYW4gZW50cnkgZnJvbSB0aGUgZ2l0IGNvbmZpZyBmaWxlcy5cbiAqXG4gKiAqQ2F2ZWF0czoqXG4gKiAtIEN1cnJlbnRseSBvbmx5IHRoZSBsb2NhbCBgJEdJVF9ESVIvY29uZmlnYCBmaWxlIGNhbiBiZSByZWFkIG9yIHdyaXR0ZW4uIEhvd2V2ZXIgc3VwcG9ydCBmb3IgdGhlIGdsb2JhbCBgfi8uZ2l0Y29uZmlnYCBhbmQgc3lzdGVtIGAkKHByZWZpeCkvZXRjL2dpdGNvbmZpZ2Agd2lsbCBiZSBhZGRlZCBpbiB0aGUgZnV0dXJlLlxuICogLSBUaGUgY3VycmVudCBwYXJzZXIgZG9lcyBub3Qgc3VwcG9ydCB0aGUgbW9yZSBleG90aWMgZmVhdHVyZXMgb2YgdGhlIGdpdC1jb25maWcgZmlsZSBmb3JtYXQgc3VjaCBhcyBgW2luY2x1ZGVdYCBhbmQgYFtpbmNsdWRlSWZdYC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gYXJnc1xuICogQHBhcmFtIHtGc0NsaWVudH0gYXJncy5mcyAtIGEgZmlsZSBzeXN0ZW0gaW1wbGVtZW50YXRpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5kaXJdIC0gVGhlIFt3b3JraW5nIHRyZWVdKGRpci12cy1naXRkaXIubWQpIGRpcmVjdG9yeSBwYXRoXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MuZ2l0ZGlyPWpvaW4oZGlyLCcuZ2l0JyldIC0gW3JlcXVpcmVkXSBUaGUgW2dpdCBkaXJlY3RvcnldKGRpci12cy1naXRkaXIubWQpIHBhdGhcbiAqIEBwYXJhbSB7c3RyaW5nfSBhcmdzLnBhdGggLSBUaGUga2V5IG9mIHRoZSBnaXQgY29uZmlnIGVudHJ5XG4gKlxuICogQHJldHVybnMge1Byb21pc2U8YW55Pn0gUmVzb2x2ZXMgd2l0aCB0aGUgY29uZmlnIHZhbHVlXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFJlYWQgY29uZmlnIHZhbHVlXG4gKiBsZXQgdmFsdWUgPSBhd2FpdCBnaXQuZ2V0Q29uZmlnKHtcbiAqICAgZnMsXG4gKiAgIGRpcjogJy90dXRvcmlhbCcsXG4gKiAgIHBhdGg6ICdyZW1vdGUub3JpZ2luLnVybCdcbiAqIH0pXG4gKiBjb25zb2xlLmxvZyh2YWx1ZSlcbiAqXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGdldENvbmZpZyh7IGZzLCBkaXIsIGdpdGRpciA9IGpvaW4oZGlyLCAnLmdpdCcpLCBwYXRoIH0pIHtcbiAgdHJ5IHtcbiAgICBhc3NlcnRQYXJhbWV0ZXIoJ2ZzJywgZnMpO1xuICAgIGFzc2VydFBhcmFtZXRlcignZ2l0ZGlyJywgZ2l0ZGlyKTtcbiAgICBhc3NlcnRQYXJhbWV0ZXIoJ3BhdGgnLCBwYXRoKTtcblxuICAgIHJldHVybiBhd2FpdCBfZ2V0Q29uZmlnKHtcbiAgICAgIGZzOiBuZXcgRmlsZVN5c3RlbShmcyksXG4gICAgICBnaXRkaXIsXG4gICAgICBwYXRoLFxuICAgIH0pXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGVyci5jYWxsZXIgPSAnZ2l0LmdldENvbmZpZyc7XG4gICAgdGhyb3cgZXJyXG4gIH1cbn1cblxuLy8gQHRzLWNoZWNrXG5cbi8qKlxuICogQHBhcmFtIHtPYmplY3R9IGFyZ3NcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9tb2RlbHMvRmlsZVN5c3RlbS5qcycpLkZpbGVTeXN0ZW19IGFyZ3MuZnNcbiAqIEBwYXJhbSB7c3RyaW5nfSBhcmdzLmdpdGRpclxuICogQHBhcmFtIHtzdHJpbmd9IGFyZ3MucGF0aFxuICpcbiAqIEByZXR1cm5zIHtQcm9taXNlPEFycmF5PGFueT4+fSBSZXNvbHZlcyB3aXRoIGFuIGFycmF5IG9mIHRoZSBjb25maWcgdmFsdWVcbiAqXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIF9nZXRDb25maWdBbGwoeyBmcywgZ2l0ZGlyLCBwYXRoIH0pIHtcbiAgY29uc3QgY29uZmlnID0gYXdhaXQgR2l0Q29uZmlnTWFuYWdlci5nZXQoeyBmcywgZ2l0ZGlyIH0pO1xuICByZXR1cm4gY29uZmlnLmdldGFsbChwYXRoKVxufVxuXG4vLyBAdHMtY2hlY2tcblxuLyoqXG4gKiBSZWFkIGEgbXVsdGktdmFsdWVkIGVudHJ5IGZyb20gdGhlIGdpdCBjb25maWcgZmlsZXMuXG4gKlxuICogKkNhdmVhdHM6KlxuICogLSBDdXJyZW50bHkgb25seSB0aGUgbG9jYWwgYCRHSVRfRElSL2NvbmZpZ2AgZmlsZSBjYW4gYmUgcmVhZCBvciB3cml0dGVuLiBIb3dldmVyIHN1cHBvcnQgZm9yIHRoZSBnbG9iYWwgYH4vLmdpdGNvbmZpZ2AgYW5kIHN5c3RlbSBgJChwcmVmaXgpL2V0Yy9naXRjb25maWdgIHdpbGwgYmUgYWRkZWQgaW4gdGhlIGZ1dHVyZS5cbiAqIC0gVGhlIGN1cnJlbnQgcGFyc2VyIGRvZXMgbm90IHN1cHBvcnQgdGhlIG1vcmUgZXhvdGljIGZlYXR1cmVzIG9mIHRoZSBnaXQtY29uZmlnIGZpbGUgZm9ybWF0IHN1Y2ggYXMgYFtpbmNsdWRlXWAgYW5kIGBbaW5jbHVkZUlmXWAuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGFyZ3NcbiAqIEBwYXJhbSB7RnNDbGllbnR9IGFyZ3MuZnMgLSBhIGZpbGUgc3lzdGVtIGltcGxlbWVudGF0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MuZGlyXSAtIFRoZSBbd29ya2luZyB0cmVlXShkaXItdnMtZ2l0ZGlyLm1kKSBkaXJlY3RvcnkgcGF0aFxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLmdpdGRpcj1qb2luKGRpciwnLmdpdCcpXSAtIFtyZXF1aXJlZF0gVGhlIFtnaXQgZGlyZWN0b3J5XShkaXItdnMtZ2l0ZGlyLm1kKSBwYXRoXG4gKiBAcGFyYW0ge3N0cmluZ30gYXJncy5wYXRoIC0gVGhlIGtleSBvZiB0aGUgZ2l0IGNvbmZpZyBlbnRyeVxuICpcbiAqIEByZXR1cm5zIHtQcm9taXNlPEFycmF5PGFueT4+fSBSZXNvbHZlcyB3aXRoIHRoZSBjb25maWcgdmFsdWVcbiAqXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGdldENvbmZpZ0FsbCh7XG4gIGZzLFxuICBkaXIsXG4gIGdpdGRpciA9IGpvaW4oZGlyLCAnLmdpdCcpLFxuICBwYXRoLFxufSkge1xuICB0cnkge1xuICAgIGFzc2VydFBhcmFtZXRlcignZnMnLCBmcyk7XG4gICAgYXNzZXJ0UGFyYW1ldGVyKCdnaXRkaXInLCBnaXRkaXIpO1xuICAgIGFzc2VydFBhcmFtZXRlcigncGF0aCcsIHBhdGgpO1xuXG4gICAgcmV0dXJuIGF3YWl0IF9nZXRDb25maWdBbGwoe1xuICAgICAgZnM6IG5ldyBGaWxlU3lzdGVtKGZzKSxcbiAgICAgIGdpdGRpcixcbiAgICAgIHBhdGgsXG4gICAgfSlcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZXJyLmNhbGxlciA9ICdnaXQuZ2V0Q29uZmlnQWxsJztcbiAgICB0aHJvdyBlcnJcbiAgfVxufVxuXG4vLyBAdHMtY2hlY2tcblxuLyoqXG4gKlxuICogQHR5cGVkZWYge09iamVjdH0gR2V0UmVtb3RlSW5mb1Jlc3VsdCAtIFRoZSBvYmplY3QgcmV0dXJuZWQgaGFzIHRoZSBmb2xsb3dpbmcgc2NoZW1hOlxuICogQHByb3BlcnR5IHtzdHJpbmdbXX0gY2FwYWJpbGl0aWVzIC0gVGhlIGxpc3Qgb2YgY2FwYWJpbGl0aWVzIHJldHVybmVkIGJ5IHRoZSBzZXJ2ZXIgKHBhcnQgb2YgdGhlIEdpdCBwcm90b2NvbClcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBbcmVmc11cbiAqIEBwcm9wZXJ0eSB7T2JqZWN0PHN0cmluZywgc3RyaW5nPn0gW3JlZnMuaGVhZHNdIC0gVGhlIGJyYW5jaGVzIG9uIHRoZSByZW1vdGVcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0PHN0cmluZywgc3RyaW5nPn0gW3JlZnMucHVsbF0gLSBUaGUgc3BlY2lhbCBicmFuY2hlcyByZXByZXNlbnRpbmcgcHVsbCByZXF1ZXN0cyAobm9uLXN0YW5kYXJkKVxuICogQHByb3BlcnR5IHtPYmplY3Q8c3RyaW5nLCBzdHJpbmc+fSBbcmVmcy50YWdzXSAtIFRoZSB0YWdzIG9uIHRoZSByZW1vdGVcbiAqXG4gKi9cblxuLyoqXG4gKiBMaXN0IGEgcmVtb3RlIHNlcnZlcnMgYnJhbmNoZXMsIHRhZ3MsIGFuZCBjYXBhYmlsaXRpZXMuXG4gKlxuICogVGhpcyBpcyBhIHJhcmUgY29tbWFuZCB0aGF0IGRvZXNuJ3QgcmVxdWlyZSBhbiBgZnNgLCBgZGlyYCwgb3IgZXZlbiBgZ2l0ZGlyYCBhcmd1bWVudC5cbiAqIEl0IGp1c3QgY29tbXVuaWNhdGVzIHRvIGEgcmVtb3RlIGdpdCBzZXJ2ZXIsIHVzaW5nIHRoZSBmaXJzdCBzdGVwIG9mIHRoZSBgZ2l0LXVwbG9hZC1wYWNrYCBoYW5kc2hha2UsIGJ1dCBzdG9wcGluZyBzaG9ydCBvZiBmZXRjaGluZyB0aGUgcGFja2ZpbGUuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGFyZ3NcbiAqIEBwYXJhbSB7SHR0cENsaWVudH0gYXJncy5odHRwIC0gYW4gSFRUUCBjbGllbnRcbiAqIEBwYXJhbSB7QXV0aENhbGxiYWNrfSBbYXJncy5vbkF1dGhdIC0gb3B0aW9uYWwgYXV0aCBmaWxsIGNhbGxiYWNrXG4gKiBAcGFyYW0ge0F1dGhGYWlsdXJlQ2FsbGJhY2t9IFthcmdzLm9uQXV0aEZhaWx1cmVdIC0gb3B0aW9uYWwgYXV0aCByZWplY3RlZCBjYWxsYmFja1xuICogQHBhcmFtIHtBdXRoU3VjY2Vzc0NhbGxiYWNrfSBbYXJncy5vbkF1dGhTdWNjZXNzXSAtIG9wdGlvbmFsIGF1dGggYXBwcm92ZWQgY2FsbGJhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBhcmdzLnVybCAtIFRoZSBVUkwgb2YgdGhlIHJlbW90ZSByZXBvc2l0b3J5LiBXaWxsIGJlIGdvdHRlbiBmcm9tIGdpdGNvbmZpZyBpZiBhYnNlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MuY29yc1Byb3h5XSAtIE9wdGlvbmFsIFtDT1JTIHByb3h5XShodHRwczovL3d3dy5ucG1qcy5jb20vJTQwaXNvbW9ycGhpYy1naXQvY29ycy1wcm94eSkuIE92ZXJyaWRlcyB2YWx1ZSBpbiByZXBvIGNvbmZpZy5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2FyZ3MuZm9yUHVzaCA9IGZhbHNlXSAtIEJ5IGRlZmF1bHQsIHRoZSBjb21tYW5kIHF1ZXJpZXMgdGhlICdmZXRjaCcgY2FwYWJpbGl0aWVzLiBJZiB0cnVlLCBpdCB3aWxsIGFzayBmb3IgdGhlICdwdXNoJyBjYXBhYmlsaXRpZXMuXG4gKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsIHN0cmluZz59IFthcmdzLmhlYWRlcnNdIC0gQWRkaXRpb25hbCBoZWFkZXJzIHRvIGluY2x1ZGUgaW4gSFRUUCByZXF1ZXN0cywgc2ltaWxhciB0byBnaXQncyBgZXh0cmFIZWFkZXJgIGNvbmZpZ1xuICpcbiAqIEByZXR1cm5zIHtQcm9taXNlPEdldFJlbW90ZUluZm9SZXN1bHQ+fSBSZXNvbHZlcyBzdWNjZXNzZnVsbHkgd2l0aCBhbiBvYmplY3QgbGlzdGluZyB0aGUgYnJhbmNoZXMsIHRhZ3MsIGFuZCBjYXBhYmlsaXRpZXMgb2YgdGhlIHJlbW90ZS5cbiAqIEBzZWUgR2V0UmVtb3RlSW5mb1Jlc3VsdFxuICpcbiAqIEBleGFtcGxlXG4gKiBsZXQgaW5mbyA9IGF3YWl0IGdpdC5nZXRSZW1vdGVJbmZvKHtcbiAqICAgaHR0cCxcbiAqICAgdXJsOlxuICogICAgIFwiaHR0cHM6Ly9jb3JzLmlzb21vcnBoaWMtZ2l0Lm9yZy9naXRodWIuY29tL2lzb21vcnBoaWMtZ2l0L2lzb21vcnBoaWMtZ2l0LmdpdFwiXG4gKiB9KTtcbiAqIGNvbnNvbGUubG9nKGluZm8pO1xuICpcbiAqL1xuYXN5bmMgZnVuY3Rpb24gZ2V0UmVtb3RlSW5mbyh7XG4gIGh0dHAsXG4gIG9uQXV0aCxcbiAgb25BdXRoU3VjY2VzcyxcbiAgb25BdXRoRmFpbHVyZSxcbiAgY29yc1Byb3h5LFxuICB1cmwsXG4gIGhlYWRlcnMgPSB7fSxcbiAgZm9yUHVzaCA9IGZhbHNlLFxufSkge1xuICB0cnkge1xuICAgIGFzc2VydFBhcmFtZXRlcignaHR0cCcsIGh0dHApO1xuICAgIGFzc2VydFBhcmFtZXRlcigndXJsJywgdXJsKTtcblxuICAgIGNvbnN0IEdpdFJlbW90ZUhUVFAgPSBHaXRSZW1vdGVNYW5hZ2VyLmdldFJlbW90ZUhlbHBlckZvcih7IHVybCB9KTtcbiAgICBjb25zdCByZW1vdGUgPSBhd2FpdCBHaXRSZW1vdGVIVFRQLmRpc2NvdmVyKHtcbiAgICAgIGh0dHAsXG4gICAgICBvbkF1dGgsXG4gICAgICBvbkF1dGhTdWNjZXNzLFxuICAgICAgb25BdXRoRmFpbHVyZSxcbiAgICAgIGNvcnNQcm94eSxcbiAgICAgIHNlcnZpY2U6IGZvclB1c2ggPyAnZ2l0LXJlY2VpdmUtcGFjaycgOiAnZ2l0LXVwbG9hZC1wYWNrJyxcbiAgICAgIHVybCxcbiAgICAgIGhlYWRlcnMsXG4gICAgICBwcm90b2NvbFZlcnNpb246IDEsXG4gICAgfSk7XG5cbiAgICAvLyBOb3RlOiByZW1vdGUuY2FwYWJpbGl0aWVzLCByZW1vdGUucmVmcywgYW5kIHJlbW90ZS5zeW1yZWZzIGFyZSBTZXQgYW5kIE1hcCBvYmplY3RzLFxuICAgIC8vIGJ1dCBvbmUgb2YgdGhlIG9iamVjdGl2ZXMgb2YgdGhlIHB1YmxpYyBBUEkgaXMgdG8gYWx3YXlzIHJldHVybiBKU09OLWNvbXBhdGlibGUgb2JqZWN0c1xuICAgIC8vIHNvIHdlIG11c3QgSlNPTmlmeSB0aGVtLlxuICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgIGNhcGFiaWxpdGllczogWy4uLnJlbW90ZS5jYXBhYmlsaXRpZXNdLFxuICAgIH07XG4gICAgLy8gQ29udmVydCB0aGUgZmxhdCBsaXN0IGludG8gYW4gb2JqZWN0IHRyZWUsIGJlY2F1c2UgSSBmaWd1cmUgOTklIG9mIHRoZSB0aW1lXG4gICAgLy8gdGhhdCB3aWxsIGJlIGVhc2llciB0byB1c2UuXG4gICAgZm9yIChjb25zdCBbcmVmLCBvaWRdIG9mIHJlbW90ZS5yZWZzKSB7XG4gICAgICBjb25zdCBwYXJ0cyA9IHJlZi5zcGxpdCgnLycpO1xuICAgICAgY29uc3QgbGFzdCA9IHBhcnRzLnBvcCgpO1xuICAgICAgbGV0IG8gPSByZXN1bHQ7XG4gICAgICBmb3IgKGNvbnN0IHBhcnQgb2YgcGFydHMpIHtcbiAgICAgICAgb1twYXJ0XSA9IG9bcGFydF0gfHwge307XG4gICAgICAgIG8gPSBvW3BhcnRdO1xuICAgICAgfVxuICAgICAgb1tsYXN0XSA9IG9pZDtcbiAgICB9XG4gICAgLy8gTWVyZ2Ugc3ltcmVmcyBvbiB0b3Agb2YgcmVmcyB0byBtb3JlIGNsb3NlbHkgbWF0Y2ggYWN0dWFsIGdpdCByZXBvIGxheW91dHNcbiAgICBmb3IgKGNvbnN0IFtzeW1yZWYsIHJlZl0gb2YgcmVtb3RlLnN5bXJlZnMpIHtcbiAgICAgIGNvbnN0IHBhcnRzID0gc3ltcmVmLnNwbGl0KCcvJyk7XG4gICAgICBjb25zdCBsYXN0ID0gcGFydHMucG9wKCk7XG4gICAgICBsZXQgbyA9IHJlc3VsdDtcbiAgICAgIGZvciAoY29uc3QgcGFydCBvZiBwYXJ0cykge1xuICAgICAgICBvW3BhcnRdID0gb1twYXJ0XSB8fCB7fTtcbiAgICAgICAgbyA9IG9bcGFydF07XG4gICAgICB9XG4gICAgICBvW2xhc3RdID0gcmVmO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGVyci5jYWxsZXIgPSAnZ2l0LmdldFJlbW90ZUluZm8nO1xuICAgIHRocm93IGVyclxuICB9XG59XG5cbi8vIEB0cy1jaGVja1xuXG4vKipcbiAqIEBwYXJhbSB7YW55fSByZW1vdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcmVmaXhcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gc3ltcmVmc1xuICogQHBhcmFtIHtib29sZWFufSBwZWVsVGFnc1xuICogQHJldHVybnMge1NlcnZlclJlZltdfVxuICovXG5mdW5jdGlvbiBmb3JtYXRJbmZvUmVmcyhyZW1vdGUsIHByZWZpeCwgc3ltcmVmcywgcGVlbFRhZ3MpIHtcbiAgY29uc3QgcmVmcyA9IFtdO1xuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiByZW1vdGUucmVmcykge1xuICAgIGlmIChwcmVmaXggJiYgIWtleS5zdGFydHNXaXRoKHByZWZpeCkpIGNvbnRpbnVlXG5cbiAgICBpZiAoa2V5LmVuZHNXaXRoKCdee30nKSkge1xuICAgICAgaWYgKHBlZWxUYWdzKSB7XG4gICAgICAgIGNvbnN0IF9rZXkgPSBrZXkucmVwbGFjZSgnXnt9JywgJycpO1xuICAgICAgICAvLyBQZWVsZWQgdGFncyBhcmUgYWxtb3N0IGFsd2F5cyBsaXN0ZWQgaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlIG9yaWdpbmFsIHRhZ1xuICAgICAgICBjb25zdCBsYXN0ID0gcmVmc1tyZWZzLmxlbmd0aCAtIDFdO1xuICAgICAgICBjb25zdCByID0gbGFzdC5yZWYgPT09IF9rZXkgPyBsYXN0IDogcmVmcy5maW5kKHggPT4geC5yZWYgPT09IF9rZXkpO1xuICAgICAgICBpZiAociA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJIGRpZCBub3QgZXhwZWN0IHRoaXMgdG8gaGFwcGVuJylcbiAgICAgICAgfVxuICAgICAgICByLnBlZWxlZCA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgY29udGludWVcbiAgICB9XG4gICAgLyoqIEB0eXBlIFNlcnZlclJlZiAqL1xuICAgIGNvbnN0IHJlZiA9IHsgcmVmOiBrZXksIG9pZDogdmFsdWUgfTtcbiAgICBpZiAoc3ltcmVmcykge1xuICAgICAgaWYgKHJlbW90ZS5zeW1yZWZzLmhhcyhrZXkpKSB7XG4gICAgICAgIHJlZi50YXJnZXQgPSByZW1vdGUuc3ltcmVmcy5nZXQoa2V5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVmcy5wdXNoKHJlZik7XG4gIH1cbiAgcmV0dXJuIHJlZnNcbn1cblxuLy8gQHRzLWNoZWNrXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gR2V0UmVtb3RlSW5mbzJSZXN1bHQgLSBUaGlzIG9iamVjdCBoYXMgdGhlIGZvbGxvd2luZyBzY2hlbWE6XG4gKiBAcHJvcGVydHkgezEgfCAyfSBwcm90b2NvbFZlcnNpb24gLSBHaXQgcHJvdG9jb2wgdmVyc2lvbiB0aGUgc2VydmVyIHN1cHBvcnRzXG4gKiBAcHJvcGVydHkge09iamVjdDxzdHJpbmcsIHN0cmluZyB8IHRydWU+fSBjYXBhYmlsaXRpZXMgLSBBbiBvYmplY3Qgb2YgY2FwYWJpbGl0aWVzIHJlcHJlc2VudGVkIGFzIGtleXMgYW5kIHZhbHVlc1xuICogQHByb3BlcnR5IHtTZXJ2ZXJSZWZbXX0gW3JlZnNdIC0gU2VydmVyIHJlZnMgKHRoZXkgZ2V0IHJldHVybmVkIGJ5IHByb3RvY29sIHZlcnNpb24gMSB3aGV0aGVyIHlvdSB3YW50IHRoZW0gb3Igbm90KVxuICovXG5cbi8qKlxuICogTGlzdCBhIHJlbW90ZSBzZXJ2ZXIncyBjYXBhYmlsaXRpZXMuXG4gKlxuICogVGhpcyBpcyBhIHJhcmUgY29tbWFuZCB0aGF0IGRvZXNuJ3QgcmVxdWlyZSBhbiBgZnNgLCBgZGlyYCwgb3IgZXZlbiBgZ2l0ZGlyYCBhcmd1bWVudC5cbiAqIEl0IGp1c3QgY29tbXVuaWNhdGVzIHRvIGEgcmVtb3RlIGdpdCBzZXJ2ZXIsIGRldGVybWluaW5nIHdoYXQgcHJvdG9jb2wgdmVyc2lvbiwgY29tbWFuZHMsIGFuZCBmZWF0dXJlcyBpdCBzdXBwb3J0cy5cbiAqXG4gKiA+IFRoZSBzdWNjZXNzb3IgdG8gW2BnZXRSZW1vdGVJbmZvYF0oLi9nZXRSZW1vdGVJbmZvLm1kKSwgdGhpcyBjb21tYW5kIHN1cHBvcnRzIEdpdCBXaXJlIFByb3RvY29sIFZlcnNpb24gMi5cbiAqID4gVGhlcmVmb3JlIGl0cyByZXR1cm4gdHlwZSBpcyBtb3JlIGNvbXBsaWNhdGVkIGFzIGVpdGhlcjpcbiAqID5cbiAqID4gLSB2MSBjYXBhYmlsaXRpZXMgKGFuZCByZWZzKSBvclxuICogPiAtIHYyIGNhcGFiaWxpdGllcyAoYW5kIG5vIHJlZnMpXG4gKiA+XG4gKiA+IGFyZSByZXR1cm5lZC5cbiAqID4gSWYgeW91IGp1c3QgY2FyZSBhYm91dCByZWZzLCB1c2UgW2BsaXN0U2VydmVyUmVmc2BdKC4vbGlzdFNlcnZlclJlZnMubWQpXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGFyZ3NcbiAqIEBwYXJhbSB7SHR0cENsaWVudH0gYXJncy5odHRwIC0gYW4gSFRUUCBjbGllbnRcbiAqIEBwYXJhbSB7QXV0aENhbGxiYWNrfSBbYXJncy5vbkF1dGhdIC0gb3B0aW9uYWwgYXV0aCBmaWxsIGNhbGxiYWNrXG4gKiBAcGFyYW0ge0F1dGhGYWlsdXJlQ2FsbGJhY2t9IFthcmdzLm9uQXV0aEZhaWx1cmVdIC0gb3B0aW9uYWwgYXV0aCByZWplY3RlZCBjYWxsYmFja1xuICogQHBhcmFtIHtBdXRoU3VjY2Vzc0NhbGxiYWNrfSBbYXJncy5vbkF1dGhTdWNjZXNzXSAtIG9wdGlvbmFsIGF1dGggYXBwcm92ZWQgY2FsbGJhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBhcmdzLnVybCAtIFRoZSBVUkwgb2YgdGhlIHJlbW90ZSByZXBvc2l0b3J5LiBXaWxsIGJlIGdvdHRlbiBmcm9tIGdpdGNvbmZpZyBpZiBhYnNlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MuY29yc1Byb3h5XSAtIE9wdGlvbmFsIFtDT1JTIHByb3h5XShodHRwczovL3d3dy5ucG1qcy5jb20vJTQwaXNvbW9ycGhpYy1naXQvY29ycy1wcm94eSkuIE92ZXJyaWRlcyB2YWx1ZSBpbiByZXBvIGNvbmZpZy5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2FyZ3MuZm9yUHVzaCA9IGZhbHNlXSAtIEJ5IGRlZmF1bHQsIHRoZSBjb21tYW5kIHF1ZXJpZXMgdGhlICdmZXRjaCcgY2FwYWJpbGl0aWVzLiBJZiB0cnVlLCBpdCB3aWxsIGFzayBmb3IgdGhlICdwdXNoJyBjYXBhYmlsaXRpZXMuXG4gKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsIHN0cmluZz59IFthcmdzLmhlYWRlcnNdIC0gQWRkaXRpb25hbCBoZWFkZXJzIHRvIGluY2x1ZGUgaW4gSFRUUCByZXF1ZXN0cywgc2ltaWxhciB0byBnaXQncyBgZXh0cmFIZWFkZXJgIGNvbmZpZ1xuICogQHBhcmFtIHsxIHwgMn0gW2FyZ3MucHJvdG9jb2xWZXJzaW9uID0gMl0gLSBXaGljaCB2ZXJzaW9uIG9mIHRoZSBHaXQgUHJvdG9jb2wgdG8gdXNlLlxuICpcbiAqIEByZXR1cm5zIHtQcm9taXNlPEdldFJlbW90ZUluZm8yUmVzdWx0Pn0gUmVzb2x2ZXMgc3VjY2Vzc2Z1bGx5IHdpdGggYW4gb2JqZWN0IGxpc3RpbmcgdGhlIGNhcGFiaWxpdGllcyBvZiB0aGUgcmVtb3RlLlxuICogQHNlZSBHZXRSZW1vdGVJbmZvMlJlc3VsdFxuICogQHNlZSBTZXJ2ZXJSZWZcbiAqXG4gKiBAZXhhbXBsZVxuICogbGV0IGluZm8gPSBhd2FpdCBnaXQuZ2V0UmVtb3RlSW5mbzIoe1xuICogICBodHRwLFxuICogICBjb3JzUHJveHk6IFwiaHR0cHM6Ly9jb3JzLmlzb21vcnBoaWMtZ2l0Lm9yZ1wiLFxuICogICB1cmw6IFwiaHR0cHM6Ly9naXRodWIuY29tL2lzb21vcnBoaWMtZ2l0L2lzb21vcnBoaWMtZ2l0LmdpdFwiXG4gKiB9KTtcbiAqIGNvbnNvbGUubG9nKGluZm8pO1xuICpcbiAqL1xuYXN5bmMgZnVuY3Rpb24gZ2V0UmVtb3RlSW5mbzIoe1xuICBodHRwLFxuICBvbkF1dGgsXG4gIG9uQXV0aFN1Y2Nlc3MsXG4gIG9uQXV0aEZhaWx1cmUsXG4gIGNvcnNQcm94eSxcbiAgdXJsLFxuICBoZWFkZXJzID0ge30sXG4gIGZvclB1c2ggPSBmYWxzZSxcbiAgcHJvdG9jb2xWZXJzaW9uID0gMixcbn0pIHtcbiAgdHJ5IHtcbiAgICBhc3NlcnRQYXJhbWV0ZXIoJ2h0dHAnLCBodHRwKTtcbiAgICBhc3NlcnRQYXJhbWV0ZXIoJ3VybCcsIHVybCk7XG5cbiAgICBjb25zdCBHaXRSZW1vdGVIVFRQID0gR2l0UmVtb3RlTWFuYWdlci5nZXRSZW1vdGVIZWxwZXJGb3IoeyB1cmwgfSk7XG4gICAgY29uc3QgcmVtb3RlID0gYXdhaXQgR2l0UmVtb3RlSFRUUC5kaXNjb3Zlcih7XG4gICAgICBodHRwLFxuICAgICAgb25BdXRoLFxuICAgICAgb25BdXRoU3VjY2VzcyxcbiAgICAgIG9uQXV0aEZhaWx1cmUsXG4gICAgICBjb3JzUHJveHksXG4gICAgICBzZXJ2aWNlOiBmb3JQdXNoID8gJ2dpdC1yZWNlaXZlLXBhY2snIDogJ2dpdC11cGxvYWQtcGFjaycsXG4gICAgICB1cmwsXG4gICAgICBoZWFkZXJzLFxuICAgICAgcHJvdG9jb2xWZXJzaW9uLFxuICAgIH0pO1xuXG4gICAgaWYgKHJlbW90ZS5wcm90b2NvbFZlcnNpb24gPT09IDIpIHtcbiAgICAgIC8qKiBAdHlwZSBHZXRSZW1vdGVJbmZvMlJlc3VsdCAqL1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcHJvdG9jb2xWZXJzaW9uOiByZW1vdGUucHJvdG9jb2xWZXJzaW9uLFxuICAgICAgICBjYXBhYmlsaXRpZXM6IHJlbW90ZS5jYXBhYmlsaXRpZXMyLFxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIE5vdGU6IHJlbW90ZS5jYXBhYmlsaXRpZXMsIHJlbW90ZS5yZWZzLCBhbmQgcmVtb3RlLnN5bXJlZnMgYXJlIFNldCBhbmQgTWFwIG9iamVjdHMsXG4gICAgLy8gYnV0IG9uZSBvZiB0aGUgb2JqZWN0aXZlcyBvZiB0aGUgcHVibGljIEFQSSBpcyB0byBhbHdheXMgcmV0dXJuIEpTT04tY29tcGF0aWJsZSBvYmplY3RzXG4gICAgLy8gc28gd2UgbXVzdCBKU09OaWZ5IHRoZW0uXG4gICAgLyoqIEB0eXBlIE9iamVjdDxzdHJpbmcsIHRydWU+ICovXG4gICAgY29uc3QgY2FwYWJpbGl0aWVzID0ge307XG4gICAgZm9yIChjb25zdCBjYXAgb2YgcmVtb3RlLmNhcGFiaWxpdGllcykge1xuICAgICAgY29uc3QgW2tleSwgdmFsdWVdID0gY2FwLnNwbGl0KCc9Jyk7XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgY2FwYWJpbGl0aWVzW2tleV0gPSB2YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhcGFiaWxpdGllc1trZXldID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqIEB0eXBlIEdldFJlbW90ZUluZm8yUmVzdWx0ICovXG4gICAgcmV0dXJuIHtcbiAgICAgIHByb3RvY29sVmVyc2lvbjogMSxcbiAgICAgIGNhcGFiaWxpdGllcyxcbiAgICAgIHJlZnM6IGZvcm1hdEluZm9SZWZzKHJlbW90ZSwgdW5kZWZpbmVkLCB0cnVlLCB0cnVlKSxcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGVyci5jYWxsZXIgPSAnZ2l0LmdldFJlbW90ZUluZm8yJztcbiAgICB0aHJvdyBlcnJcbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBoYXNoT2JqZWN0KHtcbiAgdHlwZSxcbiAgb2JqZWN0LFxuICBmb3JtYXQgPSAnY29udGVudCcsXG4gIG9pZCA9IHVuZGVmaW5lZCxcbn0pIHtcbiAgaWYgKGZvcm1hdCAhPT0gJ2RlZmxhdGVkJykge1xuICAgIGlmIChmb3JtYXQgIT09ICd3cmFwcGVkJykge1xuICAgICAgb2JqZWN0ID0gR2l0T2JqZWN0LndyYXAoeyB0eXBlLCBvYmplY3QgfSk7XG4gICAgfVxuICAgIG9pZCA9IGF3YWl0IHNoYXN1bShvYmplY3QpO1xuICB9XG4gIHJldHVybiB7IG9pZCwgb2JqZWN0IH1cbn1cblxuLy8gQHRzLWNoZWNrXG5cbi8qKlxuICpcbiAqIEB0eXBlZGVmIHtvYmplY3R9IEhhc2hCbG9iUmVzdWx0IC0gVGhlIG9iamVjdCByZXR1cm5lZCBoYXMgdGhlIGZvbGxvd2luZyBzY2hlbWE6XG4gKiBAcHJvcGVydHkge3N0cmluZ30gb2lkIC0gVGhlIFNIQS0xIG9iamVjdCBpZFxuICogQHByb3BlcnR5IHsnYmxvYid9IHR5cGUgLSBUaGUgdHlwZSBvZiB0aGUgb2JqZWN0XG4gKiBAcHJvcGVydHkge1VpbnQ4QXJyYXl9IG9iamVjdCAtIFRoZSB3cmFwcGVkIGdpdCBvYmplY3QgKHRoZSB0aGluZyB0aGF0IGlzIGhhc2hlZClcbiAqIEBwcm9wZXJ0eSB7J3dyYXBwZWQnfSBmb3JtYXQgLSBUaGUgZm9ybWF0IG9mIHRoZSBvYmplY3RcbiAqXG4gKi9cblxuLyoqXG4gKiBDb21wdXRlIHdoYXQgdGhlIFNIQS0xIG9iamVjdCBpZCBvZiBhIGZpbGUgd291bGQgYmVcbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gYXJnc1xuICogQHBhcmFtIHtVaW50OEFycmF5fHN0cmluZ30gYXJncy5vYmplY3QgLSBUaGUgb2JqZWN0IHRvIHdyaXRlLiBJZiBgb2JqZWN0YCBpcyBhIFN0cmluZyB0aGVuIGl0IHdpbGwgYmUgY29udmVydGVkIHRvIGEgVWludDhBcnJheSB1c2luZyBVVEYtOCBlbmNvZGluZy5cbiAqXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxIYXNoQmxvYlJlc3VsdD59IFJlc29sdmVzIHN1Y2Nlc3NmdWxseSB3aXRoIHRoZSBTSEEtMSBvYmplY3QgaWQgYW5kIHRoZSB3cmFwcGVkIG9iamVjdCBVaW50OEFycmF5LlxuICogQHNlZSBIYXNoQmxvYlJlc3VsdFxuICpcbiAqIEBleGFtcGxlXG4gKiBsZXQgeyBvaWQsIHR5cGUsIG9iamVjdCwgZm9ybWF0IH0gPSBhd2FpdCBnaXQuaGFzaEJsb2Ioe1xuICogICBvYmplY3Q6ICdIZWxsbyB3b3JsZCEnLFxuICogfSlcbiAqXG4gKiBjb25zb2xlLmxvZygnb2lkJywgb2lkKVxuICogY29uc29sZS5sb2coJ3R5cGUnLCB0eXBlKVxuICogY29uc29sZS5sb2coJ29iamVjdCcsIG9iamVjdClcbiAqIGNvbnNvbGUubG9nKCdmb3JtYXQnLCBmb3JtYXQpXG4gKlxuICovXG5hc3luYyBmdW5jdGlvbiBoYXNoQmxvYih7IG9iamVjdCB9KSB7XG4gIHRyeSB7XG4gICAgYXNzZXJ0UGFyYW1ldGVyKCdvYmplY3QnLCBvYmplY3QpO1xuXG4gICAgLy8gQ29udmVydCBvYmplY3QgdG8gYnVmZmVyXG4gICAgaWYgKHR5cGVvZiBvYmplY3QgPT09ICdzdHJpbmcnKSB7XG4gICAgICBvYmplY3QgPSBCdWZmZXIuZnJvbShvYmplY3QsICd1dGY4Jyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9iamVjdCA9IEJ1ZmZlci5mcm9tKG9iamVjdCk7XG4gICAgfVxuXG4gICAgY29uc3QgdHlwZSA9ICdibG9iJztcbiAgICBjb25zdCB7IG9pZCwgb2JqZWN0OiBfb2JqZWN0IH0gPSBhd2FpdCBoYXNoT2JqZWN0KHtcbiAgICAgIHR5cGU6ICdibG9iJyxcbiAgICAgIGZvcm1hdDogJ2NvbnRlbnQnLFxuICAgICAgb2JqZWN0LFxuICAgIH0pO1xuICAgIHJldHVybiB7IG9pZCwgdHlwZSwgb2JqZWN0OiBuZXcgVWludDhBcnJheShfb2JqZWN0KSwgZm9ybWF0OiAnd3JhcHBlZCcgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBlcnIuY2FsbGVyID0gJ2dpdC5oYXNoQmxvYic7XG4gICAgdGhyb3cgZXJyXG4gIH1cbn1cblxuLy8gQHRzLWNoZWNrXG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGFyZ3NcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9tb2RlbHMvRmlsZVN5c3RlbS5qcycpLkZpbGVTeXN0ZW19IGFyZ3MuZnNcbiAqIEBwYXJhbSB7YW55fSBhcmdzLmNhY2hlXG4gKiBAcGFyYW0ge1Byb2dyZXNzQ2FsbGJhY2t9IFthcmdzLm9uUHJvZ3Jlc3NdXG4gKiBAcGFyYW0ge3N0cmluZ30gYXJncy5kaXJcbiAqIEBwYXJhbSB7c3RyaW5nfSBhcmdzLmdpdGRpclxuICogQHBhcmFtIHtzdHJpbmd9IGFyZ3MuZmlsZXBhdGhcbiAqXG4gKiBAcmV0dXJucyB7UHJvbWlzZTx7b2lkczogc3RyaW5nW119Pn1cbiAqL1xuYXN5bmMgZnVuY3Rpb24gX2luZGV4UGFjayh7XG4gIGZzLFxuICBjYWNoZSxcbiAgb25Qcm9ncmVzcyxcbiAgZGlyLFxuICBnaXRkaXIsXG4gIGZpbGVwYXRoLFxufSkge1xuICB0cnkge1xuICAgIGZpbGVwYXRoID0gam9pbihkaXIsIGZpbGVwYXRoKTtcbiAgICBjb25zdCBwYWNrID0gYXdhaXQgZnMucmVhZChmaWxlcGF0aCk7XG4gICAgY29uc3QgZ2V0RXh0ZXJuYWxSZWZEZWx0YSA9IG9pZCA9PiBfcmVhZE9iamVjdCh7IGZzLCBjYWNoZSwgZ2l0ZGlyLCBvaWQgfSk7XG4gICAgY29uc3QgaWR4ID0gYXdhaXQgR2l0UGFja0luZGV4LmZyb21QYWNrKHtcbiAgICAgIHBhY2ssXG4gICAgICBnZXRFeHRlcm5hbFJlZkRlbHRhLFxuICAgICAgb25Qcm9ncmVzcyxcbiAgICB9KTtcbiAgICBhd2FpdCBmcy53cml0ZShmaWxlcGF0aC5yZXBsYWNlKC9cXC5wYWNrJC8sICcuaWR4JyksIGF3YWl0IGlkeC50b0J1ZmZlcigpKTtcbiAgICByZXR1cm4ge1xuICAgICAgb2lkczogWy4uLmlkeC5oYXNoZXNdLFxuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZXJyLmNhbGxlciA9ICdnaXQuaW5kZXhQYWNrJztcbiAgICB0aHJvdyBlcnJcbiAgfVxufVxuXG4vLyBAdHMtY2hlY2tcblxuLyoqXG4gKiBDcmVhdGUgdGhlIC5pZHggZmlsZSBmb3IgYSBnaXZlbiAucGFjayBmaWxlXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGFyZ3NcbiAqIEBwYXJhbSB7RnNDbGllbnR9IGFyZ3MuZnMgLSBhIGZpbGUgc3lzdGVtIGNsaWVudFxuICogQHBhcmFtIHtQcm9ncmVzc0NhbGxiYWNrfSBbYXJncy5vblByb2dyZXNzXSAtIG9wdGlvbmFsIHByb2dyZXNzIGV2ZW50IGNhbGxiYWNrXG4gKiBAcGFyYW0ge3N0cmluZ30gYXJncy5kaXIgLSBUaGUgW3dvcmtpbmcgdHJlZV0oZGlyLXZzLWdpdGRpci5tZCkgZGlyZWN0b3J5IHBhdGhcbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5naXRkaXI9am9pbihkaXIsJy5naXQnKV0gLSBbcmVxdWlyZWRdIFRoZSBbZ2l0IGRpcmVjdG9yeV0oZGlyLXZzLWdpdGRpci5tZCkgcGF0aFxuICogQHBhcmFtIHtzdHJpbmd9IGFyZ3MuZmlsZXBhdGggLSBUaGUgcGF0aCB0byB0aGUgLnBhY2sgZmlsZSB0byBpbmRleFxuICogQHBhcmFtIHtvYmplY3R9IFthcmdzLmNhY2hlXSAtIGEgW2NhY2hlXShjYWNoZS5tZCkgb2JqZWN0XG4gKlxuICogQHJldHVybnMge1Byb21pc2U8e29pZHM6IHN0cmluZ1tdfT59IFJlc29sdmVzIHdpdGggYSBsaXN0IG9mIHRoZSBTSEEtMSBvYmplY3QgaWRzIGNvbnRhaW5lZCBpbiB0aGUgcGFja2ZpbGVcbiAqXG4gKiBAZXhhbXBsZVxuICogbGV0IHBhY2tmaWxlcyA9IGF3YWl0IGZzLnByb21pc2VzLnJlYWRkaXIoJy90dXRvcmlhbC8uZ2l0L29iamVjdHMvcGFjaycpXG4gKiBwYWNrZmlsZXMgPSBwYWNrZmlsZXMuZmlsdGVyKG5hbWUgPT4gbmFtZS5lbmRzV2l0aCgnLnBhY2snKSlcbiAqIGNvbnNvbGUubG9nKCdwYWNrZmlsZXMnLCBwYWNrZmlsZXMpXG4gKlxuICogY29uc3QgeyBvaWRzIH0gPSBhd2FpdCBnaXQuaW5kZXhQYWNrKHtcbiAqICAgZnMsXG4gKiAgIGRpcjogJy90dXRvcmlhbCcsXG4gKiAgIGZpbGVwYXRoOiBgLmdpdC9vYmplY3RzL3BhY2svJHtwYWNrZmlsZXNbMF19YCxcbiAqICAgYXN5bmMgb25Qcm9ncmVzcyAoZXZ0KSB7XG4gKiAgICAgY29uc29sZS5sb2coYCR7ZXZ0LnBoYXNlfTogJHtldnQubG9hZGVkfSAvICR7ZXZ0LnRvdGFsfWApXG4gKiAgIH1cbiAqIH0pXG4gKiBjb25zb2xlLmxvZyhvaWRzKVxuICpcbiAqL1xuYXN5bmMgZnVuY3Rpb24gaW5kZXhQYWNrKHtcbiAgZnMsXG4gIG9uUHJvZ3Jlc3MsXG4gIGRpcixcbiAgZ2l0ZGlyID0gam9pbihkaXIsICcuZ2l0JyksXG4gIGZpbGVwYXRoLFxuICBjYWNoZSA9IHt9LFxufSkge1xuICB0cnkge1xuICAgIGFzc2VydFBhcmFtZXRlcignZnMnLCBmcyk7XG4gICAgYXNzZXJ0UGFyYW1ldGVyKCdkaXInLCBkaXIpO1xuICAgIGFzc2VydFBhcmFtZXRlcignZ2l0ZGlyJywgZGlyKTtcbiAgICBhc3NlcnRQYXJhbWV0ZXIoJ2ZpbGVwYXRoJywgZmlsZXBhdGgpO1xuXG4gICAgcmV0dXJuIGF3YWl0IF9pbmRleFBhY2soe1xuICAgICAgZnM6IG5ldyBGaWxlU3lzdGVtKGZzKSxcbiAgICAgIGNhY2hlLFxuICAgICAgb25Qcm9ncmVzcyxcbiAgICAgIGRpcixcbiAgICAgIGdpdGRpcixcbiAgICAgIGZpbGVwYXRoLFxuICAgIH0pXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGVyci5jYWxsZXIgPSAnZ2l0LmluZGV4UGFjayc7XG4gICAgdGhyb3cgZXJyXG4gIH1cbn1cblxuLy8gQHRzLWNoZWNrXG5cbi8qKlxuICogSW5pdGlhbGl6ZSBhIG5ldyByZXBvc2l0b3J5XG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGFyZ3NcbiAqIEBwYXJhbSB7RnNDbGllbnR9IGFyZ3MuZnMgLSBhIGZpbGUgc3lzdGVtIGNsaWVudFxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLmRpcl0gLSBUaGUgW3dvcmtpbmcgdHJlZV0oZGlyLXZzLWdpdGRpci5tZCkgZGlyZWN0b3J5IHBhdGhcbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5naXRkaXI9am9pbihkaXIsJy5naXQnKV0gLSBbcmVxdWlyZWRdIFRoZSBbZ2l0IGRpcmVjdG9yeV0oZGlyLXZzLWdpdGRpci5tZCkgcGF0aFxuICogQHBhcmFtIHtib29sZWFufSBbYXJncy5iYXJlID0gZmFsc2VdIC0gSW5pdGlhbGl6ZSBhIGJhcmUgcmVwb3NpdG9yeVxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLmRlZmF1bHRCcmFuY2ggPSAnbWFzdGVyJ10gLSBUaGUgbmFtZSBvZiB0aGUgZGVmYXVsdCBicmFuY2ggKG1pZ2h0IGJlIGNoYW5nZWQgdG8gYSByZXF1aXJlZCBhcmd1bWVudCBpbiAyLjAuMClcbiAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fSAgUmVzb2x2ZXMgc3VjY2Vzc2Z1bGx5IHdoZW4gZmlsZXN5c3RlbSBvcGVyYXRpb25zIGFyZSBjb21wbGV0ZVxuICpcbiAqIEBleGFtcGxlXG4gKiBhd2FpdCBnaXQuaW5pdCh7IGZzLCBkaXI6ICcvdHV0b3JpYWwnIH0pXG4gKiBjb25zb2xlLmxvZygnZG9uZScpXG4gKlxuICovXG5hc3luYyBmdW5jdGlvbiBpbml0KHtcbiAgZnMsXG4gIGJhcmUgPSBmYWxzZSxcbiAgZGlyLFxuICBnaXRkaXIgPSBiYXJlID8gZGlyIDogam9pbihkaXIsICcuZ2l0JyksXG4gIGRlZmF1bHRCcmFuY2ggPSAnbWFzdGVyJyxcbn0pIHtcbiAgdHJ5IHtcbiAgICBhc3NlcnRQYXJhbWV0ZXIoJ2ZzJywgZnMpO1xuICAgIGFzc2VydFBhcmFtZXRlcignZ2l0ZGlyJywgZ2l0ZGlyKTtcbiAgICBpZiAoIWJhcmUpIHtcbiAgICAgIGFzc2VydFBhcmFtZXRlcignZGlyJywgZGlyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXdhaXQgX2luaXQoe1xuICAgICAgZnM6IG5ldyBGaWxlU3lzdGVtKGZzKSxcbiAgICAgIGJhcmUsXG4gICAgICBkaXIsXG4gICAgICBnaXRkaXIsXG4gICAgICBkZWZhdWx0QnJhbmNoLFxuICAgIH0pXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGVyci5jYWxsZXIgPSAnZ2l0LmluaXQnO1xuICAgIHRocm93IGVyclxuICB9XG59XG5cbi8vIEB0cy1jaGVja1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBhcmdzXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vbW9kZWxzL0ZpbGVTeXN0ZW0uanMnKS5GaWxlU3lzdGVtfSBhcmdzLmZzXG4gKiBAcGFyYW0ge2FueX0gYXJncy5jYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGFyZ3MuZ2l0ZGlyXG4gKiBAcGFyYW0ge3N0cmluZ30gYXJncy5vaWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBhcmdzLmFuY2VzdG9yXG4gKiBAcGFyYW0ge251bWJlcn0gYXJncy5kZXB0aCAtIE1heGltdW0gZGVwdGggdG8gc2VhcmNoIGJlZm9yZSBnaXZpbmcgdXAuIC0xIG1lYW5zIG5vIG1heGltdW0gZGVwdGguXG4gKlxuICogQHJldHVybnMge1Byb21pc2U8Ym9vbGVhbj59XG4gKi9cbmFzeW5jIGZ1bmN0aW9uIF9pc0Rlc2NlbmRlbnQoe1xuICBmcyxcbiAgY2FjaGUsXG4gIGdpdGRpcixcbiAgb2lkLFxuICBhbmNlc3RvcixcbiAgZGVwdGgsXG59KSB7XG4gIGNvbnN0IHNoYWxsb3dzID0gYXdhaXQgR2l0U2hhbGxvd01hbmFnZXIucmVhZCh7IGZzLCBnaXRkaXIgfSk7XG4gIGlmICghb2lkKSB7XG4gICAgdGhyb3cgbmV3IE1pc3NpbmdQYXJhbWV0ZXJFcnJvcignb2lkJylcbiAgfVxuICBpZiAoIWFuY2VzdG9yKSB7XG4gICAgdGhyb3cgbmV3IE1pc3NpbmdQYXJhbWV0ZXJFcnJvcignYW5jZXN0b3InKVxuICB9XG4gIC8vIElmIHlvdSBkb24ndCBsaWtlIHRoaXMgYmVoYXZpb3IsIGFkZCB5b3VyIG93biBjaGVjay5cbiAgLy8gRWRnZSBjYXNlcyBhcmUgaGFyZCB0byBkZWZpbmUgYSBwZXJmZWN0IHNvbHV0aW9uLlxuICBpZiAob2lkID09PSBhbmNlc3RvcikgcmV0dXJuIGZhbHNlXG4gIC8vIFdlIGRvIG5vdCB1c2UgcmVjdXJzaW9uIGhlcmUsIGJlY2F1c2UgdGhhdCB3b3VsZCBsZWFkIHRvIGRlcHRoLWZpcnN0IHRyYXZlcnNhbCxcbiAgLy8gYW5kIHdlIHdhbnQgdG8gbWFpbnRhaW4gYSBicmVhZHRoLWZpcnN0IHRyYXZlcnNhbCB0byBhdm9pZCBoaXR0aW5nIHNoYWxsb3cgY2xvbmUgZGVwdGggY3V0b2Zmcy5cbiAgY29uc3QgcXVldWUgPSBbb2lkXTtcbiAgY29uc3QgdmlzaXRlZCA9IG5ldyBTZXQoKTtcbiAgbGV0IHNlYXJjaGRlcHRoID0gMDtcbiAgd2hpbGUgKHF1ZXVlLmxlbmd0aCkge1xuICAgIGlmIChzZWFyY2hkZXB0aCsrID09PSBkZXB0aCkge1xuICAgICAgdGhyb3cgbmV3IE1heERlcHRoRXJyb3IoZGVwdGgpXG4gICAgfVxuICAgIGNvbnN0IG9pZCA9IHF1ZXVlLnNoaWZ0KCk7XG4gICAgY29uc3QgeyB0eXBlLCBvYmplY3QgfSA9IGF3YWl0IF9yZWFkT2JqZWN0KHtcbiAgICAgIGZzLFxuICAgICAgY2FjaGUsXG4gICAgICBnaXRkaXIsXG4gICAgICBvaWQsXG4gICAgfSk7XG4gICAgaWYgKHR5cGUgIT09ICdjb21taXQnKSB7XG4gICAgICB0aHJvdyBuZXcgT2JqZWN0VHlwZUVycm9yKG9pZCwgdHlwZSwgJ2NvbW1pdCcpXG4gICAgfVxuICAgIGNvbnN0IGNvbW1pdCA9IEdpdENvbW1pdC5mcm9tKG9iamVjdCkucGFyc2UoKTtcbiAgICAvLyBBcmUgYW55IG9mIHRoZSBwYXJlbnRzIHRoZSBzb3VnaHQtYWZ0ZXIgYW5jZXN0b3I/XG4gICAgZm9yIChjb25zdCBwYXJlbnQgb2YgY29tbWl0LnBhcmVudCkge1xuICAgICAgaWYgKHBhcmVudCA9PT0gYW5jZXN0b3IpIHJldHVybiB0cnVlXG4gICAgfVxuICAgIC8vIElmIG5vdCwgYWRkIHRoZW0gdG8gaGVhZHMgKHVubGVzcyB3ZSBrbm93IHRoaXMgaXMgYSBzaGFsbG93IGNvbW1pdClcbiAgICBpZiAoIXNoYWxsb3dzLmhhcyhvaWQpKSB7XG4gICAgICBmb3IgKGNvbnN0IHBhcmVudCBvZiBjb21taXQucGFyZW50KSB7XG4gICAgICAgIGlmICghdmlzaXRlZC5oYXMocGFyZW50KSkge1xuICAgICAgICAgIHF1ZXVlLnB1c2gocGFyZW50KTtcbiAgICAgICAgICB2aXNpdGVkLmFkZChwYXJlbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8vIEV2ZW50dWFsbHksIHdlJ2xsIHRyYXZlbCBlbnRpcmUgdHJlZSB0byB0aGUgcm9vdHMgd2hlcmUgYWxsIHRoZSBwYXJlbnRzIGFyZSBlbXB0eSBhcnJheXMsXG4gICAgLy8gb3IgaGl0IHRoZSBzaGFsbG93IGRlcHRoIGFuZCB0aHJvdyBhbiBlcnJvci4gRXhjbHVkaW5nIHRoZSBwb3NzaWJpbGl0eSBvZiBncmFmdHMsIG9yXG4gICAgLy8gZGlmZmVyZW50IGJyYW5jaGVzIGNsb25lZCB0byBkaWZmZXJlbnQgZGVwdGhzLCB5b3Ugd291bGQgaGl0IHRoaXMgZXJyb3IgYXQgdGhlIHNhbWUgdGltZVxuICAgIC8vIGZvciBhbGwgcGFyZW50cywgc28gdHJ5aW5nIHRvIGNvbnRpbnVlIGlzIGZ1dGlsZS5cbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuLy8gQHRzLWNoZWNrXG5cbi8qKlxuICogQ2hlY2sgd2hldGhlciBhIGdpdCBjb21taXQgaXMgZGVzY2VuZGVkIGZyb20gYW5vdGhlclxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBhcmdzXG4gKiBAcGFyYW0ge0ZzQ2xpZW50fSBhcmdzLmZzIC0gYSBmaWxlIHN5c3RlbSBjbGllbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5kaXJdIC0gVGhlIFt3b3JraW5nIHRyZWVdKGRpci12cy1naXRkaXIubWQpIGRpcmVjdG9yeSBwYXRoXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MuZ2l0ZGlyPWpvaW4oZGlyLCcuZ2l0JyldIC0gW3JlcXVpcmVkXSBUaGUgW2dpdCBkaXJlY3RvcnldKGRpci12cy1naXRkaXIubWQpIHBhdGhcbiAqIEBwYXJhbSB7c3RyaW5nfSBhcmdzLm9pZCAtIFRoZSBkZXNjZW5kZW50IGNvbW1pdFxuICogQHBhcmFtIHtzdHJpbmd9IGFyZ3MuYW5jZXN0b3IgLSBUaGUgKHByb3Bvc2VkKSBhbmNlc3RvciBjb21taXRcbiAqIEBwYXJhbSB7bnVtYmVyfSBbYXJncy5kZXB0aCA9IC0xXSAtIE1heGltdW0gZGVwdGggdG8gc2VhcmNoIGJlZm9yZSBnaXZpbmcgdXAuIC0xIG1lYW5zIG5vIG1heGltdW0gZGVwdGguXG4gKiBAcGFyYW0ge29iamVjdH0gW2FyZ3MuY2FjaGVdIC0gYSBbY2FjaGVdKGNhY2hlLm1kKSBvYmplY3RcbiAqXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxib29sZWFuPn0gUmVzb2x2ZXMgdG8gdHJ1ZSBpZiBgb2lkYCBpcyBhIGRlc2NlbmRlbnQgb2YgYGFuY2VzdG9yYFxuICpcbiAqIEBleGFtcGxlXG4gKiBsZXQgb2lkID0gYXdhaXQgZ2l0LnJlc29sdmVSZWYoeyBmcywgZGlyOiAnL3R1dG9yaWFsJywgcmVmOiAnbWFpbicgfSlcbiAqIGxldCBhbmNlc3RvciA9IGF3YWl0IGdpdC5yZXNvbHZlUmVmKHsgZnMsIGRpcjogJy90dXRvcmlhbCcsIHJlZjogJ3YwLjIwLjAnIH0pXG4gKiBjb25zb2xlLmxvZyhvaWQsIGFuY2VzdG9yKVxuICogYXdhaXQgZ2l0LmlzRGVzY2VuZGVudCh7IGZzLCBkaXI6ICcvdHV0b3JpYWwnLCBvaWQsIGFuY2VzdG9yLCBkZXB0aDogLTEgfSlcbiAqXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGlzRGVzY2VuZGVudCh7XG4gIGZzLFxuICBkaXIsXG4gIGdpdGRpciA9IGpvaW4oZGlyLCAnLmdpdCcpLFxuICBvaWQsXG4gIGFuY2VzdG9yLFxuICBkZXB0aCA9IC0xLFxuICBjYWNoZSA9IHt9LFxufSkge1xuICB0cnkge1xuICAgIGFzc2VydFBhcmFtZXRlcignZnMnLCBmcyk7XG4gICAgYXNzZXJ0UGFyYW1ldGVyKCdnaXRkaXInLCBnaXRkaXIpO1xuICAgIGFzc2VydFBhcmFtZXRlcignb2lkJywgb2lkKTtcbiAgICBhc3NlcnRQYXJhbWV0ZXIoJ2FuY2VzdG9yJywgYW5jZXN0b3IpO1xuXG4gICAgcmV0dXJuIGF3YWl0IF9pc0Rlc2NlbmRlbnQoe1xuICAgICAgZnM6IG5ldyBGaWxlU3lzdGVtKGZzKSxcbiAgICAgIGNhY2hlLFxuICAgICAgZ2l0ZGlyLFxuICAgICAgb2lkLFxuICAgICAgYW5jZXN0b3IsXG4gICAgICBkZXB0aCxcbiAgICB9KVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBlcnIuY2FsbGVyID0gJ2dpdC5pc0Rlc2NlbmRlbnQnO1xuICAgIHRocm93IGVyclxuICB9XG59XG5cbi8vIEB0cy1jaGVja1xuXG4vKipcbiAqIExpc3QgYnJhbmNoZXNcbiAqXG4gKiBCeSBkZWZhdWx0IGl0IGxpc3RzIGxvY2FsIGJyYW5jaGVzLiBJZiBhICdyZW1vdGUnIGlzIHNwZWNpZmllZCwgaXQgbGlzdHMgdGhlIHJlbW90ZSdzIGJyYW5jaGVzLiBXaGVuIGxpc3RpbmcgcmVtb3RlIGJyYW5jaGVzLCB0aGUgSEVBRCBicmFuY2ggaXMgbm90IGZpbHRlcmVkIG91dCwgc28gaXQgbWF5IGJlIGluY2x1ZGVkIGluIHRoZSBsaXN0IG9mIHJlc3VsdHMuXG4gKlxuICogTm90ZSB0aGF0IHNwZWNpZnlpbmcgYSByZW1vdGUgZG9lcyBub3QgYWN0dWFsbHkgY29udGFjdCB0aGUgc2VydmVyIGFuZCB1cGRhdGUgdGhlIGxpc3Qgb2YgYnJhbmNoZXMuXG4gKiBJZiB5b3Ugd2FudCBhbiB1cC10by1kYXRlIGxpc3QsIGZpcnN0IGRvIGEgYGZldGNoYCB0byB0aGF0IHJlbW90ZS5cbiAqIChXaGljaCBicmFuY2ggeW91IGZldGNoIGRvZXNuJ3QgbWF0dGVyIC0gdGhlIGxpc3Qgb2YgYnJhbmNoZXMgYXZhaWxhYmxlIG9uIHRoZSByZW1vdGUgaXMgdXBkYXRlZCBkdXJpbmcgdGhlIGZldGNoIGhhbmRzaGFrZS4pXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGFyZ3NcbiAqIEBwYXJhbSB7RnNDbGllbnR9IGFyZ3MuZnMgLSBhIGZpbGUgc3lzdGVtIGNsaWVudFxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLmRpcl0gLSBUaGUgW3dvcmtpbmcgdHJlZV0oZGlyLXZzLWdpdGRpci5tZCkgZGlyZWN0b3J5IHBhdGhcbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5naXRkaXI9am9pbihkaXIsJy5naXQnKV0gLSBbcmVxdWlyZWRdIFRoZSBbZ2l0IGRpcmVjdG9yeV0oZGlyLXZzLWdpdGRpci5tZCkgcGF0aFxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLnJlbW90ZV0gLSBJbnN0ZWFkIG9mIHRoZSBicmFuY2hlcyBpbiBgcmVmcy9oZWFkc2AsIGxpc3QgdGhlIGJyYW5jaGVzIGluIGByZWZzL3JlbW90ZXMvJHtyZW1vdGV9YC5cbiAqXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxBcnJheTxzdHJpbmc+Pn0gUmVzb2x2ZXMgc3VjY2Vzc2Z1bGx5IHdpdGggYW4gYXJyYXkgb2YgYnJhbmNoIG5hbWVzXG4gKlxuICogQGV4YW1wbGVcbiAqIGxldCBicmFuY2hlcyA9IGF3YWl0IGdpdC5saXN0QnJhbmNoZXMoeyBmcywgZGlyOiAnL3R1dG9yaWFsJyB9KVxuICogY29uc29sZS5sb2coYnJhbmNoZXMpXG4gKiBsZXQgcmVtb3RlQnJhbmNoZXMgPSBhd2FpdCBnaXQubGlzdEJyYW5jaGVzKHsgZnMsIGRpcjogJy90dXRvcmlhbCcsIHJlbW90ZTogJ29yaWdpbicgfSlcbiAqIGNvbnNvbGUubG9nKHJlbW90ZUJyYW5jaGVzKVxuICpcbiAqL1xuYXN5bmMgZnVuY3Rpb24gbGlzdEJyYW5jaGVzKHtcbiAgZnMsXG4gIGRpcixcbiAgZ2l0ZGlyID0gam9pbihkaXIsICcuZ2l0JyksXG4gIHJlbW90ZSxcbn0pIHtcbiAgdHJ5IHtcbiAgICBhc3NlcnRQYXJhbWV0ZXIoJ2ZzJywgZnMpO1xuICAgIGFzc2VydFBhcmFtZXRlcignZ2l0ZGlyJywgZ2l0ZGlyKTtcblxuICAgIHJldHVybiBHaXRSZWZNYW5hZ2VyLmxpc3RCcmFuY2hlcyh7XG4gICAgICBmczogbmV3IEZpbGVTeXN0ZW0oZnMpLFxuICAgICAgZ2l0ZGlyLFxuICAgICAgcmVtb3RlLFxuICAgIH0pXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGVyci5jYWxsZXIgPSAnZ2l0Lmxpc3RCcmFuY2hlcyc7XG4gICAgdGhyb3cgZXJyXG4gIH1cbn1cblxuLy8gQHRzLWNoZWNrXG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGFyZ3NcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9tb2RlbHMvRmlsZVN5c3RlbS5qcycpLkZpbGVTeXN0ZW19IGFyZ3MuZnNcbiAqIEBwYXJhbSB7b2JqZWN0fSBhcmdzLmNhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30gYXJncy5naXRkaXJcbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5yZWZdXG4gKlxuICogQHJldHVybnMge1Byb21pc2U8QXJyYXk8c3RyaW5nPj59XG4gKi9cbmFzeW5jIGZ1bmN0aW9uIF9saXN0RmlsZXMoeyBmcywgZ2l0ZGlyLCByZWYsIGNhY2hlIH0pIHtcbiAgaWYgKHJlZikge1xuICAgIGNvbnN0IG9pZCA9IGF3YWl0IEdpdFJlZk1hbmFnZXIucmVzb2x2ZSh7IGdpdGRpciwgZnMsIHJlZiB9KTtcbiAgICBjb25zdCBmaWxlbmFtZXMgPSBbXTtcbiAgICBhd2FpdCBhY2N1bXVsYXRlRmlsZXNGcm9tT2lkKHtcbiAgICAgIGZzLFxuICAgICAgY2FjaGUsXG4gICAgICBnaXRkaXIsXG4gICAgICBvaWQsXG4gICAgICBmaWxlbmFtZXMsXG4gICAgICBwcmVmaXg6ICcnLFxuICAgIH0pO1xuICAgIHJldHVybiBmaWxlbmFtZXNcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gR2l0SW5kZXhNYW5hZ2VyLmFjcXVpcmUoeyBmcywgZ2l0ZGlyLCBjYWNoZSB9LCBhc3luYyBmdW5jdGlvbihcbiAgICAgIGluZGV4XG4gICAgKSB7XG4gICAgICByZXR1cm4gaW5kZXguZW50cmllcy5tYXAoeCA9PiB4LnBhdGgpXG4gICAgfSlcbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBhY2N1bXVsYXRlRmlsZXNGcm9tT2lkKHtcbiAgZnMsXG4gIGNhY2hlLFxuICBnaXRkaXIsXG4gIG9pZCxcbiAgZmlsZW5hbWVzLFxuICBwcmVmaXgsXG59KSB7XG4gIGNvbnN0IHsgdHJlZSB9ID0gYXdhaXQgX3JlYWRUcmVlKHsgZnMsIGNhY2hlLCBnaXRkaXIsIG9pZCB9KTtcbiAgLy8gVE9ETzogVXNlIGB3YWxrYCB0byBkbyB0aGlzLiBTaG91bGQgYmUgZmFzdGVyLlxuICBmb3IgKGNvbnN0IGVudHJ5IG9mIHRyZWUpIHtcbiAgICBpZiAoZW50cnkudHlwZSA9PT0gJ3RyZWUnKSB7XG4gICAgICBhd2FpdCBhY2N1bXVsYXRlRmlsZXNGcm9tT2lkKHtcbiAgICAgICAgZnMsXG4gICAgICAgIGNhY2hlLFxuICAgICAgICBnaXRkaXIsXG4gICAgICAgIG9pZDogZW50cnkub2lkLFxuICAgICAgICBmaWxlbmFtZXMsXG4gICAgICAgIHByZWZpeDogam9pbihwcmVmaXgsIGVudHJ5LnBhdGgpLFxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZpbGVuYW1lcy5wdXNoKGpvaW4ocHJlZml4LCBlbnRyeS5wYXRoKSk7XG4gICAgfVxuICB9XG59XG5cbi8vIEB0cy1jaGVja1xuXG4vKipcbiAqIExpc3QgYWxsIHRoZSBmaWxlcyBpbiB0aGUgZ2l0IGluZGV4IG9yIGEgY29tbWl0XG4gKlxuICogPiBOb3RlOiBUaGlzIGZ1bmN0aW9uIGlzIGVmZmljaWVudCBmb3IgbGlzdGluZyB0aGUgZmlsZXMgaW4gdGhlIHN0YWdpbmcgYXJlYSwgYnV0IGxpc3RpbmcgYWxsIHRoZSBmaWxlcyBpbiBhIGNvbW1pdCByZXF1aXJlcyByZWN1cnNpdmVseSB3YWxraW5nIHRocm91Z2ggdGhlIGdpdCBvYmplY3Qgc3RvcmUuXG4gKiA+IElmIHlvdSBkbyBub3QgcmVxdWlyZSBhIGNvbXBsZXRlIGxpc3Qgb2YgZXZlcnkgZmlsZSwgYmV0dGVyIHBlcmZvcm1hbmNlIGNhbiBiZSBhY2hpZXZlZCBieSB1c2luZyBbd2Fsa10oLi93YWxrKSBhbmQgaWdub3Jpbmcgc3ViZGlyZWN0b3JpZXMgeW91IGRvbid0IGNhcmUgYWJvdXQuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGFyZ3NcbiAqIEBwYXJhbSB7RnNDbGllbnR9IGFyZ3MuZnMgLSBhIGZpbGUgc3lzdGVtIGNsaWVudFxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLmRpcl0gLSBUaGUgW3dvcmtpbmcgdHJlZV0oZGlyLXZzLWdpdGRpci5tZCkgZGlyZWN0b3J5IHBhdGhcbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5naXRkaXI9am9pbihkaXIsJy5naXQnKV0gLSBbcmVxdWlyZWRdIFRoZSBbZ2l0IGRpcmVjdG9yeV0oZGlyLXZzLWdpdGRpci5tZCkgcGF0aFxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLnJlZl0gLSBSZXR1cm4gYSBsaXN0IG9mIGFsbCB0aGUgZmlsZXMgaW4gdGhlIGNvbW1pdCBhdCBgcmVmYCBpbnN0ZWFkIG9mIHRoZSBmaWxlcyBjdXJyZW50bHkgaW4gdGhlIGdpdCBpbmRleCAoYWthIHN0YWdpbmcgYXJlYSlcbiAqIEBwYXJhbSB7b2JqZWN0fSBbYXJncy5jYWNoZV0gLSBhIFtjYWNoZV0oY2FjaGUubWQpIG9iamVjdFxuICpcbiAqIEByZXR1cm5zIHtQcm9taXNlPEFycmF5PHN0cmluZz4+fSBSZXNvbHZlcyBzdWNjZXNzZnVsbHkgd2l0aCBhbiBhcnJheSBvZiBmaWxlcGF0aHNcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gQWxsIHRoZSBmaWxlcyBpbiB0aGUgcHJldmlvdXMgY29tbWl0XG4gKiBsZXQgZmlsZXMgPSBhd2FpdCBnaXQubGlzdEZpbGVzKHsgZnMsIGRpcjogJy90dXRvcmlhbCcsIHJlZjogJ0hFQUQnIH0pXG4gKiBjb25zb2xlLmxvZyhmaWxlcylcbiAqIC8vIEFsbCB0aGUgZmlsZXMgaW4gdGhlIGN1cnJlbnQgc3RhZ2luZyBhcmVhXG4gKiBmaWxlcyA9IGF3YWl0IGdpdC5saXN0RmlsZXMoeyBmcywgZGlyOiAnL3R1dG9yaWFsJyB9KVxuICogY29uc29sZS5sb2coZmlsZXMpXG4gKlxuICovXG5hc3luYyBmdW5jdGlvbiBsaXN0RmlsZXMoe1xuICBmcyxcbiAgZGlyLFxuICBnaXRkaXIgPSBqb2luKGRpciwgJy5naXQnKSxcbiAgcmVmLFxuICBjYWNoZSA9IHt9LFxufSkge1xuICB0cnkge1xuICAgIGFzc2VydFBhcmFtZXRlcignZnMnLCBmcyk7XG4gICAgYXNzZXJ0UGFyYW1ldGVyKCdnaXRkaXInLCBnaXRkaXIpO1xuXG4gICAgcmV0dXJuIGF3YWl0IF9saXN0RmlsZXMoe1xuICAgICAgZnM6IG5ldyBGaWxlU3lzdGVtKGZzKSxcbiAgICAgIGNhY2hlLFxuICAgICAgZ2l0ZGlyLFxuICAgICAgcmVmLFxuICAgIH0pXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGVyci5jYWxsZXIgPSAnZ2l0Lmxpc3RGaWxlcyc7XG4gICAgdGhyb3cgZXJyXG4gIH1cbn1cblxuLy8gQHRzLWNoZWNrXG5cbi8qKlxuICogTGlzdCBhbGwgdGhlIG9iamVjdCBub3Rlc1xuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBhcmdzXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vbW9kZWxzL0ZpbGVTeXN0ZW0uanMnKS5GaWxlU3lzdGVtfSBhcmdzLmZzXG4gKiBAcGFyYW0ge2FueX0gYXJncy5jYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGFyZ3MuZ2l0ZGlyXG4gKiBAcGFyYW0ge3N0cmluZ30gYXJncy5yZWZcbiAqXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxBcnJheTx7dGFyZ2V0OiBzdHJpbmcsIG5vdGU6IHN0cmluZ30+Pn1cbiAqL1xuXG5hc3luYyBmdW5jdGlvbiBfbGlzdE5vdGVzKHsgZnMsIGNhY2hlLCBnaXRkaXIsIHJlZiB9KSB7XG4gIC8vIEdldCB0aGUgY3VycmVudCBub3RlIGNvbW1pdFxuICBsZXQgcGFyZW50O1xuICB0cnkge1xuICAgIHBhcmVudCA9IGF3YWl0IEdpdFJlZk1hbmFnZXIucmVzb2x2ZSh7IGdpdGRpciwgZnMsIHJlZiB9KTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaWYgKGVyciBpbnN0YW5jZW9mIE5vdEZvdW5kRXJyb3IpIHtcbiAgICAgIHJldHVybiBbXVxuICAgIH1cbiAgfVxuXG4gIC8vIENyZWF0ZSB0aGUgY3VycmVudCBub3RlIHRyZWVcbiAgY29uc3QgcmVzdWx0ID0gYXdhaXQgX3JlYWRUcmVlKHtcbiAgICBmcyxcbiAgICBjYWNoZSxcbiAgICBnaXRkaXIsXG4gICAgb2lkOiBwYXJlbnQsXG4gIH0pO1xuXG4gIC8vIEZvcm1hdCB0aGUgdHJlZSBlbnRyaWVzXG4gIGNvbnN0IG5vdGVzID0gcmVzdWx0LnRyZWUubWFwKGVudHJ5ID0+ICh7XG4gICAgdGFyZ2V0OiBlbnRyeS5wYXRoLFxuICAgIG5vdGU6IGVudHJ5Lm9pZCxcbiAgfSkpO1xuICByZXR1cm4gbm90ZXNcbn1cblxuLy8gQHRzLWNoZWNrXG5cbi8qKlxuICogTGlzdCBhbGwgdGhlIG9iamVjdCBub3Rlc1xuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBhcmdzXG4gKiBAcGFyYW0ge0ZzQ2xpZW50fSBhcmdzLmZzIC0gYSBmaWxlIHN5c3RlbSBjbGllbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5kaXJdIC0gVGhlIFt3b3JraW5nIHRyZWVdKGRpci12cy1naXRkaXIubWQpIGRpcmVjdG9yeSBwYXRoXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MuZ2l0ZGlyPWpvaW4oZGlyLCcuZ2l0JyldIC0gW3JlcXVpcmVkXSBUaGUgW2dpdCBkaXJlY3RvcnldKGRpci12cy1naXRkaXIubWQpIHBhdGhcbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5yZWZdIC0gVGhlIG5vdGVzIHJlZiB0byBsb29rIHVuZGVyXG4gKiBAcGFyYW0ge29iamVjdH0gW2FyZ3MuY2FjaGVdIC0gYSBbY2FjaGVdKGNhY2hlLm1kKSBvYmplY3RcbiAqXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxBcnJheTx7dGFyZ2V0OiBzdHJpbmcsIG5vdGU6IHN0cmluZ30+Pn0gUmVzb2x2ZXMgc3VjY2Vzc2Z1bGx5IHdpdGggYW4gYXJyYXkgb2YgZW50cmllcyBjb250YWluaW5nIFNIQS0xIG9iamVjdCBpZHMgb2YgdGhlIG5vdGUgYW5kIHRoZSBvYmplY3QgdGhlIG5vdGUgdGFyZ2V0c1xuICovXG5cbmFzeW5jIGZ1bmN0aW9uIGxpc3ROb3Rlcyh7XG4gIGZzLFxuICBkaXIsXG4gIGdpdGRpciA9IGpvaW4oZGlyLCAnLmdpdCcpLFxuICByZWYgPSAncmVmcy9ub3Rlcy9jb21taXRzJyxcbiAgY2FjaGUgPSB7fSxcbn0pIHtcbiAgdHJ5IHtcbiAgICBhc3NlcnRQYXJhbWV0ZXIoJ2ZzJywgZnMpO1xuICAgIGFzc2VydFBhcmFtZXRlcignZ2l0ZGlyJywgZ2l0ZGlyKTtcbiAgICBhc3NlcnRQYXJhbWV0ZXIoJ3JlZicsIHJlZik7XG5cbiAgICByZXR1cm4gYXdhaXQgX2xpc3ROb3Rlcyh7XG4gICAgICBmczogbmV3IEZpbGVTeXN0ZW0oZnMpLFxuICAgICAgY2FjaGUsXG4gICAgICBnaXRkaXIsXG4gICAgICByZWYsXG4gICAgfSlcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZXJyLmNhbGxlciA9ICdnaXQubGlzdE5vdGVzJztcbiAgICB0aHJvdyBlcnJcbiAgfVxufVxuXG4vLyBAdHMtY2hlY2tcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gYXJnc1xuICogQHBhcmFtIHtpbXBvcnQoJy4uL21vZGVscy9GaWxlU3lzdGVtLmpzJykuRmlsZVN5c3RlbX0gYXJncy5mc1xuICogQHBhcmFtIHtzdHJpbmd9IGFyZ3MuZ2l0ZGlyXG4gKlxuICogQHJldHVybnMge1Byb21pc2U8QXJyYXk8e3JlbW90ZTogc3RyaW5nLCB1cmw6IHN0cmluZ30+Pn1cbiAqL1xuYXN5bmMgZnVuY3Rpb24gX2xpc3RSZW1vdGVzKHsgZnMsIGdpdGRpciB9KSB7XG4gIGNvbnN0IGNvbmZpZyA9IGF3YWl0IEdpdENvbmZpZ01hbmFnZXIuZ2V0KHsgZnMsIGdpdGRpciB9KTtcbiAgY29uc3QgcmVtb3RlTmFtZXMgPSBhd2FpdCBjb25maWcuZ2V0U3Vic2VjdGlvbnMoJ3JlbW90ZScpO1xuICBjb25zdCByZW1vdGVzID0gUHJvbWlzZS5hbGwoXG4gICAgcmVtb3RlTmFtZXMubWFwKGFzeW5jIHJlbW90ZSA9PiB7XG4gICAgICBjb25zdCB1cmwgPSBhd2FpdCBjb25maWcuZ2V0KGByZW1vdGUuJHtyZW1vdGV9LnVybGApO1xuICAgICAgcmV0dXJuIHsgcmVtb3RlLCB1cmwgfVxuICAgIH0pXG4gICk7XG4gIHJldHVybiByZW1vdGVzXG59XG5cbi8vIEB0cy1jaGVja1xuXG4vKipcbiAqIExpc3QgcmVtb3Rlc1xuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBhcmdzXG4gKiBAcGFyYW0ge0ZzQ2xpZW50fSBhcmdzLmZzIC0gYSBmaWxlIHN5c3RlbSBjbGllbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5kaXJdIC0gVGhlIFt3b3JraW5nIHRyZWVdKGRpci12cy1naXRkaXIubWQpIGRpcmVjdG9yeSBwYXRoXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MuZ2l0ZGlyPWpvaW4oZGlyLCcuZ2l0JyldIC0gW3JlcXVpcmVkXSBUaGUgW2dpdCBkaXJlY3RvcnldKGRpci12cy1naXRkaXIubWQpIHBhdGhcbiAqXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxBcnJheTx7cmVtb3RlOiBzdHJpbmcsIHVybDogc3RyaW5nfT4+fSBSZXNvbHZlcyBzdWNjZXNzZnVsbHkgd2l0aCBhbiBhcnJheSBvZiBge3JlbW90ZSwgdXJsfWAgb2JqZWN0c1xuICpcbiAqIEBleGFtcGxlXG4gKiBsZXQgcmVtb3RlcyA9IGF3YWl0IGdpdC5saXN0UmVtb3Rlcyh7IGZzLCBkaXI6ICcvdHV0b3JpYWwnIH0pXG4gKiBjb25zb2xlLmxvZyhyZW1vdGVzKVxuICpcbiAqL1xuYXN5bmMgZnVuY3Rpb24gbGlzdFJlbW90ZXMoeyBmcywgZGlyLCBnaXRkaXIgPSBqb2luKGRpciwgJy5naXQnKSB9KSB7XG4gIHRyeSB7XG4gICAgYXNzZXJ0UGFyYW1ldGVyKCdmcycsIGZzKTtcbiAgICBhc3NlcnRQYXJhbWV0ZXIoJ2dpdGRpcicsIGdpdGRpcik7XG5cbiAgICByZXR1cm4gYXdhaXQgX2xpc3RSZW1vdGVzKHtcbiAgICAgIGZzOiBuZXcgRmlsZVN5c3RlbShmcyksXG4gICAgICBnaXRkaXIsXG4gICAgfSlcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZXJyLmNhbGxlciA9ICdnaXQubGlzdFJlbW90ZXMnO1xuICAgIHRocm93IGVyclxuICB9XG59XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gU2VydmVyUmVmIC0gVGhpcyBvYmplY3QgaGFzIHRoZSBmb2xsb3dpbmcgc2NoZW1hOlxuICogQHByb3BlcnR5IHtzdHJpbmd9IHJlZiAtIFRoZSBuYW1lIG9mIHRoZSByZWZcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBvaWQgLSBUaGUgU0hBLTEgb2JqZWN0IGlkIHRoZSByZWYgcG9pbnRzIHRvXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW3RhcmdldF0gLSBUaGUgdGFyZ2V0IHJlZiBwb2ludGVkIHRvIGJ5IGEgc3ltYm9saWMgcmVmXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW3BlZWxlZF0gLSBJZiB0aGUgb2lkIGlzIHRoZSBTSEEtMSBvYmplY3QgaWQgb2YgYW4gYW5ub3RhdGVkIHRhZywgdGhpcyBpcyB0aGUgU0hBLTEgb2JqZWN0IGlkIHRoYXQgdGhlIGFubm90YXRlZCB0YWcgcG9pbnRzIHRvXG4gKi9cblxuYXN5bmMgZnVuY3Rpb24gcGFyc2VMaXN0UmVmc1Jlc3BvbnNlKHN0cmVhbSkge1xuICBjb25zdCByZWFkID0gR2l0UGt0TGluZS5zdHJlYW1SZWFkZXIoc3RyZWFtKTtcblxuICAvLyBUT0RPOiB3aGVuIHdlIHJlLXdyaXRlIGV2ZXJ5dGhpbmcgdG8gbWluaW1pemUgbWVtb3J5IHVzYWdlLFxuICAvLyB3ZSBjb3VsZCBtYWtlIHRoaXMgYSBnZW5lcmF0b3JcbiAgY29uc3QgcmVmcyA9IFtdO1xuXG4gIGxldCBsaW5lO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIGxpbmUgPSBhd2FpdCByZWFkKCk7XG4gICAgaWYgKGxpbmUgPT09IHRydWUpIGJyZWFrXG4gICAgaWYgKGxpbmUgPT09IG51bGwpIGNvbnRpbnVlXG4gICAgbGluZSA9IGxpbmUudG9TdHJpbmcoJ3V0ZjgnKS5yZXBsYWNlKC9cXG4kLywgJycpO1xuICAgIGNvbnN0IFtvaWQsIHJlZiwgLi4uYXR0cnNdID0gbGluZS5zcGxpdCgnICcpO1xuICAgIGNvbnN0IHIgPSB7IHJlZiwgb2lkIH07XG4gICAgZm9yIChjb25zdCBhdHRyIG9mIGF0dHJzKSB7XG4gICAgICBjb25zdCBbbmFtZSwgdmFsdWVdID0gYXR0ci5zcGxpdCgnOicpO1xuICAgICAgaWYgKG5hbWUgPT09ICdzeW1yZWYtdGFyZ2V0Jykge1xuICAgICAgICByLnRhcmdldCA9IHZhbHVlO1xuICAgICAgfSBlbHNlIGlmIChuYW1lID09PSAncGVlbGVkJykge1xuICAgICAgICByLnBlZWxlZCA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZWZzLnB1c2gocik7XG4gIH1cblxuICByZXR1cm4gcmVmc1xufVxuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBhcmdzXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MucHJlZml4XSAtIE9ubHkgbGlzdCByZWZzIHRoYXQgc3RhcnQgd2l0aCB0aGlzIHByZWZpeFxuICogQHBhcmFtIHtib29sZWFufSBbYXJncy5zeW1yZWZzID0gZmFsc2VdIC0gSW5jbHVkZSBzeW1ib2xpYyByZWYgdGFyZ2V0c1xuICogQHBhcmFtIHtib29sZWFufSBbYXJncy5wZWVsVGFncyA9IGZhbHNlXSAtIEluY2x1ZGUgcGVlbGVkIHRhZ3MgdmFsdWVzXG4gKiBAcmV0dXJucyB7VWludDhBcnJheVtdfVxuICovXG5hc3luYyBmdW5jdGlvbiB3cml0ZUxpc3RSZWZzUmVxdWVzdCh7IHByZWZpeCwgc3ltcmVmcywgcGVlbFRhZ3MgfSkge1xuICBjb25zdCBwYWNrc3RyZWFtID0gW107XG4gIC8vIGNvbW1hbmRcbiAgcGFja3N0cmVhbS5wdXNoKEdpdFBrdExpbmUuZW5jb2RlKCdjb21tYW5kPWxzLXJlZnNcXG4nKSk7XG4gIC8vIGNhcGFiaWxpdHktbGlzdFxuICBwYWNrc3RyZWFtLnB1c2goR2l0UGt0TGluZS5lbmNvZGUoYGFnZW50PSR7cGtnLmFnZW50fVxcbmApKTtcbiAgLy8gW2NvbW1hbmQtYXJnc11cbiAgaWYgKHBlZWxUYWdzIHx8IHN5bXJlZnMgfHwgcHJlZml4KSB7XG4gICAgcGFja3N0cmVhbS5wdXNoKEdpdFBrdExpbmUuZGVsaW0oKSk7XG4gIH1cbiAgaWYgKHBlZWxUYWdzKSBwYWNrc3RyZWFtLnB1c2goR2l0UGt0TGluZS5lbmNvZGUoJ3BlZWwnKSk7XG4gIGlmIChzeW1yZWZzKSBwYWNrc3RyZWFtLnB1c2goR2l0UGt0TGluZS5lbmNvZGUoJ3N5bXJlZnMnKSk7XG4gIGlmIChwcmVmaXgpIHBhY2tzdHJlYW0ucHVzaChHaXRQa3RMaW5lLmVuY29kZShgcmVmLXByZWZpeCAke3ByZWZpeH1gKSk7XG4gIHBhY2tzdHJlYW0ucHVzaChHaXRQa3RMaW5lLmZsdXNoKCkpO1xuICByZXR1cm4gcGFja3N0cmVhbVxufVxuXG4vLyBAdHMtY2hlY2tcblxuLyoqXG4gKiBGZXRjaCBhIGxpc3Qgb2YgcmVmcyAoYnJhbmNoZXMsIHRhZ3MsIGV0YykgZnJvbSBhIHNlcnZlci5cbiAqXG4gKiBUaGlzIGlzIGEgcmFyZSBjb21tYW5kIHRoYXQgZG9lc24ndCByZXF1aXJlIGFuIGBmc2AsIGBkaXJgLCBvciBldmVuIGBnaXRkaXJgIGFyZ3VtZW50LlxuICogSXQganVzdCByZXF1aXJlcyBhbiBgaHR0cGAgYXJndW1lbnQuXG4gKlxuICogIyMjIEFib3V0IGBwcm90b2NvbFZlcnNpb25gXG4gKlxuICogVGhlcmUncyBhIHJhdGhlciBmdW4gdHJhZGUtb2ZmIGJldHdlZW4gR2l0IFByb3RvY29sIFZlcnNpb24gMSBhbmQgR2l0IFByb3RvY29sIFZlcnNpb24gMi5cbiAqIFZlcnNpb24gMiBhY3R1YWxseSByZXF1aXJlcyAyIEhUVFAgcmVxdWVzdHMgaW5zdGVhZCBvZiAxLCBtYWtpbmcgaXQgc2ltaWxhciB0byBmZXRjaCBvciBwdXNoIGluIHRoYXQgcmVnYXJkLlxuICogSG93ZXZlciwgdmVyc2lvbiAyIHN1cHBvcnRzIHNlcnZlci1zaWRlIGZpbHRlcmluZyBieSBwcmVmaXgsIHdoZXJlYXMgdGhhdCBmaWx0ZXJpbmcgaXMgZG9uZSBjbGllbnQtc2lkZSBpbiB2ZXJzaW9uIDEuXG4gKiBXaGljaCBwcm90b2NvbCBpcyBtb3N0IGVmZmljaWVudCB0aGVyZWZvcmUgZGVwZW5kcyBvbiB0aGUgbnVtYmVyIG9mIHJlZnMgb24gdGhlIHJlbW90ZSwgdGhlIGxhdGVuY3kgb2YgdGhlIHNlcnZlciwgYW5kIHNwZWVkIG9mIHRoZSBuZXR3b3JrIGNvbm5lY3Rpb24uXG4gKiBGb3IgYW4gc21hbGwgcmVwb3MgKG9yIGZhc3QgSW50ZXJuZXQgY29ubmVjdGlvbnMpLCB0aGUgcmVxdWlyZW1lbnQgdG8gbWFrZSB0d28gdHJpcHMgdG8gdGhlIHNlcnZlciBtYWtlcyBwcm90b2NvbCAyIHNsb3dlci5cbiAqIEJ1dCBmb3IgbGFyZ2UgcmVwb3MgKG9yIHNsb3cgSW50ZXJuZXQgY29ubmVjdGlvbnMpLCB0aGUgZGVjcmVhc2VkIHBheWxvYWQgc2l6ZSBvZiB0aGUgc2Vjb25kIHJlcXVlc3QgbWFrZXMgdXAgZm9yIHRoZSBhZGRpdGlvbmFsIHJlcXVlc3QuXG4gKlxuICogSGFyZCBudW1iZXJzIHZhcnkgYnkgc2l0dWF0aW9uLCBidXQgaGVyZSdzIHNvbWUgbnVtYmVycyBmcm9tIG15IG1hY2hpbmU6XG4gKlxuICogVXNpbmcgaXNvbW9ycGhpYy1naXQgaW4gYSBicm93c2VyLCB3aXRoIGEgQ09SUyBwcm94eSwgbGlzdGluZyBvbmx5IHRoZSBicmFuY2hlcyAocmVmcy9oZWFkcykgb2YgaHR0cHM6Ly9naXRodWIuY29tL2lzb21vcnBoaWMtZ2l0L2lzb21vcnBoaWMtZ2l0XG4gKiAtIFByb3RvY29sIFZlcnNpb24gMSB0b29rIH4zMDBtcyBhbmQgdHJhbnNmZXJlZCA4NCBLQi5cbiAqIC0gUHJvdG9jb2wgVmVyc2lvbiAyIHRvb2sgfjUwMG1zIGFuZCB0cmFuc2ZlcmVkIDQuMSBLQi5cbiAqXG4gKiBVc2luZyBpc29tb3JwaGljLWdpdCBpbiBhIGJyb3dzZXIsIHdpdGggYSBDT1JTIHByb3h5LCBsaXN0aW5nIG9ubHkgdGhlIGJyYW5jaGVzIChyZWZzL2hlYWRzKSBvZiBodHRwczovL2dpdGxhYi5jb20vZ2l0bGFiLW9yZy9naXRsYWJcbiAqIC0gUHJvdG9jb2wgVmVyc2lvbiAxIHRvb2sgfjQ5MDBtcyBhbmQgdHJhbnNmZXJlZCA5LjQxIE1CLlxuICogLSBQcm90b2NvbCBWZXJzaW9uIDIgdG9vayB+MTI4MG1zIGFuZCB0cmFuc2ZlcmVkIDQzMyBLQi5cbiAqXG4gKiBGaW5hbGx5LCB0aGVyZSBpcyBhIGZ1biBxdWlyayByZWdhcmRpbmcgdGhlIGBzeW1yZWZzYCBwYXJhbWV0ZXIuXG4gKiBQcm90b2NvbCBWZXJzaW9uIDEgd2lsbCBnZW5lcmFsbHkgb25seSByZXR1cm4gdGhlIGBIRUFEYCBzeW1yZWYgYW5kIG5vdCBvdGhlcnMuXG4gKiBIaXN0b3JpY2FsbHksIHRoaXMgbWVhbnQgdGhhdCBzZXJ2ZXJzIGRvbid0IHVzZSBzeW1ib2xpYyByZWZzIGV4Y2VwdCBmb3IgYEhFQURgLCB3aGljaCBpcyB1c2VkIHRvIHBvaW50IGF0IHRoZSBcImRlZmF1bHQgYnJhbmNoXCIuXG4gKiBIb3dldmVyIFByb3RvY29sIFZlcnNpb24gMiBjYW4gcmV0dXJuICphbGwqIHRoZSBzeW1ib2xpYyByZWZzIG9uIHRoZSBzZXJ2ZXIuXG4gKiBTbyBpZiB5b3UgYXJlIHJ1bm5pbmcgeW91ciBvd24gZ2l0IHNlcnZlciwgeW91IGNvdWxkIHRha2UgYWR2YW50YWdlIG9mIHRoYXQgSSBndWVzcy5cbiAqXG4gKiAjIyMjIFRMO0RSXG4gKiBJZiB5b3UgYXJlIF9ub3RfIHRha2luZyBhZHZhbnRhZ2Ugb2YgYHByZWZpeGAgSSB3b3VsZCByZWNvbW1lbmQgYHByb3RvY29sVmVyc2lvbjogMWAuXG4gKiBPdGhlcndpc2UsIEkgcmVjb21tZW5kIHRvIHVzZSB0aGUgZGVmYXVsdCB3aGljaCBpcyBgcHJvdG9jb2xWZXJzaW9uOiAyYC5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gYXJnc1xuICogQHBhcmFtIHtIdHRwQ2xpZW50fSBhcmdzLmh0dHAgLSBhbiBIVFRQIGNsaWVudFxuICogQHBhcmFtIHtBdXRoQ2FsbGJhY2t9IFthcmdzLm9uQXV0aF0gLSBvcHRpb25hbCBhdXRoIGZpbGwgY2FsbGJhY2tcbiAqIEBwYXJhbSB7QXV0aEZhaWx1cmVDYWxsYmFja30gW2FyZ3Mub25BdXRoRmFpbHVyZV0gLSBvcHRpb25hbCBhdXRoIHJlamVjdGVkIGNhbGxiYWNrXG4gKiBAcGFyYW0ge0F1dGhTdWNjZXNzQ2FsbGJhY2t9IFthcmdzLm9uQXV0aFN1Y2Nlc3NdIC0gb3B0aW9uYWwgYXV0aCBhcHByb3ZlZCBjYWxsYmFja1xuICogQHBhcmFtIHtzdHJpbmd9IGFyZ3MudXJsIC0gVGhlIFVSTCBvZiB0aGUgcmVtb3RlIHJlcG9zaXRvcnkuIFdpbGwgYmUgZ290dGVuIGZyb20gZ2l0Y29uZmlnIGlmIGFic2VudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5jb3JzUHJveHldIC0gT3B0aW9uYWwgW0NPUlMgcHJveHldKGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS8lNDBpc29tb3JwaGljLWdpdC9jb3JzLXByb3h5KS4gT3ZlcnJpZGVzIHZhbHVlIGluIHJlcG8gY29uZmlnLlxuICogQHBhcmFtIHtib29sZWFufSBbYXJncy5mb3JQdXNoID0gZmFsc2VdIC0gQnkgZGVmYXVsdCwgdGhlIGNvbW1hbmQgcXVlcmllcyB0aGUgJ2ZldGNoJyBjYXBhYmlsaXRpZXMuIElmIHRydWUsIGl0IHdpbGwgYXNrIGZvciB0aGUgJ3B1c2gnIGNhcGFiaWxpdGllcy5cbiAqIEBwYXJhbSB7T2JqZWN0PHN0cmluZywgc3RyaW5nPn0gW2FyZ3MuaGVhZGVyc10gLSBBZGRpdGlvbmFsIGhlYWRlcnMgdG8gaW5jbHVkZSBpbiBIVFRQIHJlcXVlc3RzLCBzaW1pbGFyIHRvIGdpdCdzIGBleHRyYUhlYWRlcmAgY29uZmlnXG4gKiBAcGFyYW0gezEgfCAyfSBbYXJncy5wcm90b2NvbFZlcnNpb24gPSAyXSAtIFdoaWNoIHZlcnNpb24gb2YgdGhlIEdpdCBQcm90b2NvbCB0byB1c2UuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MucHJlZml4XSAtIE9ubHkgbGlzdCByZWZzIHRoYXQgc3RhcnQgd2l0aCB0aGlzIHByZWZpeFxuICogQHBhcmFtIHtib29sZWFufSBbYXJncy5zeW1yZWZzID0gZmFsc2VdIC0gSW5jbHVkZSBzeW1ib2xpYyByZWYgdGFyZ2V0c1xuICogQHBhcmFtIHtib29sZWFufSBbYXJncy5wZWVsVGFncyA9IGZhbHNlXSAtIEluY2x1ZGUgYW5ub3RhdGVkIHRhZyBwZWVsZWQgdGFyZ2V0c1xuICpcbiAqIEByZXR1cm5zIHtQcm9taXNlPFNlcnZlclJlZltdPn0gUmVzb2x2ZXMgc3VjY2Vzc2Z1bGx5IHdpdGggYW4gYXJyYXkgb2YgU2VydmVyUmVmIG9iamVjdHNcbiAqIEBzZWUgU2VydmVyUmVmXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIExpc3QgYWxsIHRoZSBicmFuY2hlcyBvbiBhIHJlcG9cbiAqIGxldCByZWZzID0gYXdhaXQgZ2l0Lmxpc3RTZXJ2ZXJSZWZzKHtcbiAqICAgaHR0cCxcbiAqICAgY29yc1Byb3h5OiBcImh0dHBzOi8vY29ycy5pc29tb3JwaGljLWdpdC5vcmdcIixcbiAqICAgdXJsOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9pc29tb3JwaGljLWdpdC9pc29tb3JwaGljLWdpdC5naXRcIixcbiAqICAgcHJlZml4OiBcInJlZnMvaGVhZHMvXCIsXG4gKiB9KTtcbiAqIGNvbnNvbGUubG9nKHJlZnMpO1xuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBHZXQgdGhlIGRlZmF1bHQgYnJhbmNoIG9uIGEgcmVwb1xuICogbGV0IHJlZnMgPSBhd2FpdCBnaXQubGlzdFNlcnZlclJlZnMoe1xuICogICBodHRwLFxuICogICBjb3JzUHJveHk6IFwiaHR0cHM6Ly9jb3JzLmlzb21vcnBoaWMtZ2l0Lm9yZ1wiLFxuICogICB1cmw6IFwiaHR0cHM6Ly9naXRodWIuY29tL2lzb21vcnBoaWMtZ2l0L2lzb21vcnBoaWMtZ2l0LmdpdFwiLFxuICogICBwcmVmaXg6IFwiSEVBRFwiLFxuICogICBzeW1yZWZzOiB0cnVlLFxuICogfSk7XG4gKiBjb25zb2xlLmxvZyhyZWZzKTtcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gTGlzdCBhbGwgdGhlIHRhZ3Mgb24gYSByZXBvXG4gKiBsZXQgcmVmcyA9IGF3YWl0IGdpdC5saXN0U2VydmVyUmVmcyh7XG4gKiAgIGh0dHAsXG4gKiAgIGNvcnNQcm94eTogXCJodHRwczovL2NvcnMuaXNvbW9ycGhpYy1naXQub3JnXCIsXG4gKiAgIHVybDogXCJodHRwczovL2dpdGh1Yi5jb20vaXNvbW9ycGhpYy1naXQvaXNvbW9ycGhpYy1naXQuZ2l0XCIsXG4gKiAgIHByZWZpeDogXCJyZWZzL3RhZ3MvXCIsXG4gKiAgIHBlZWxUYWdzOiB0cnVlLFxuICogfSk7XG4gKiBjb25zb2xlLmxvZyhyZWZzKTtcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gTGlzdCBhbGwgdGhlIHB1bGwgcmVxdWVzdHMgb24gYSByZXBvXG4gKiBsZXQgcmVmcyA9IGF3YWl0IGdpdC5saXN0U2VydmVyUmVmcyh7XG4gKiAgIGh0dHAsXG4gKiAgIGNvcnNQcm94eTogXCJodHRwczovL2NvcnMuaXNvbW9ycGhpYy1naXQub3JnXCIsXG4gKiAgIHVybDogXCJodHRwczovL2dpdGh1Yi5jb20vaXNvbW9ycGhpYy1naXQvaXNvbW9ycGhpYy1naXQuZ2l0XCIsXG4gKiAgIHByZWZpeDogXCJyZWZzL3B1bGwvXCIsXG4gKiB9KTtcbiAqIGNvbnNvbGUubG9nKHJlZnMpO1xuICpcbiAqL1xuYXN5bmMgZnVuY3Rpb24gbGlzdFNlcnZlclJlZnMoe1xuICBodHRwLFxuICBvbkF1dGgsXG4gIG9uQXV0aFN1Y2Nlc3MsXG4gIG9uQXV0aEZhaWx1cmUsXG4gIGNvcnNQcm94eSxcbiAgdXJsLFxuICBoZWFkZXJzID0ge30sXG4gIGZvclB1c2ggPSBmYWxzZSxcbiAgcHJvdG9jb2xWZXJzaW9uID0gMixcbiAgcHJlZml4LFxuICBzeW1yZWZzLFxuICBwZWVsVGFncyxcbn0pIHtcbiAgdHJ5IHtcbiAgICBhc3NlcnRQYXJhbWV0ZXIoJ2h0dHAnLCBodHRwKTtcbiAgICBhc3NlcnRQYXJhbWV0ZXIoJ3VybCcsIHVybCk7XG5cbiAgICBjb25zdCByZW1vdGUgPSBhd2FpdCBHaXRSZW1vdGVIVFRQLmRpc2NvdmVyKHtcbiAgICAgIGh0dHAsXG4gICAgICBvbkF1dGgsXG4gICAgICBvbkF1dGhTdWNjZXNzLFxuICAgICAgb25BdXRoRmFpbHVyZSxcbiAgICAgIGNvcnNQcm94eSxcbiAgICAgIHNlcnZpY2U6IGZvclB1c2ggPyAnZ2l0LXJlY2VpdmUtcGFjaycgOiAnZ2l0LXVwbG9hZC1wYWNrJyxcbiAgICAgIHVybCxcbiAgICAgIGhlYWRlcnMsXG4gICAgICBwcm90b2NvbFZlcnNpb24sXG4gICAgfSk7XG5cbiAgICBpZiAocmVtb3RlLnByb3RvY29sVmVyc2lvbiA9PT0gMSkge1xuICAgICAgcmV0dXJuIGZvcm1hdEluZm9SZWZzKHJlbW90ZSwgcHJlZml4LCBzeW1yZWZzLCBwZWVsVGFncylcbiAgICB9XG5cbiAgICAvLyBQcm90b2NvbCBWZXJzaW9uIDJcbiAgICBjb25zdCBib2R5ID0gYXdhaXQgd3JpdGVMaXN0UmVmc1JlcXVlc3QoeyBwcmVmaXgsIHN5bXJlZnMsIHBlZWxUYWdzIH0pO1xuXG4gICAgY29uc3QgcmVzID0gYXdhaXQgR2l0UmVtb3RlSFRUUC5jb25uZWN0KHtcbiAgICAgIGh0dHAsXG4gICAgICBhdXRoOiByZW1vdGUuYXV0aCxcbiAgICAgIGhlYWRlcnMsXG4gICAgICBjb3JzUHJveHksXG4gICAgICBzZXJ2aWNlOiBmb3JQdXNoID8gJ2dpdC1yZWNlaXZlLXBhY2snIDogJ2dpdC11cGxvYWQtcGFjaycsXG4gICAgICB1cmwsXG4gICAgICBib2R5LFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHBhcnNlTGlzdFJlZnNSZXNwb25zZShyZXMuYm9keSlcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZXJyLmNhbGxlciA9ICdnaXQubGlzdFNlcnZlclJlZnMnO1xuICAgIHRocm93IGVyclxuICB9XG59XG5cbi8vIEB0cy1jaGVja1xuXG4vKipcbiAqIExpc3QgdGFnc1xuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBhcmdzXG4gKiBAcGFyYW0ge0ZzQ2xpZW50fSBhcmdzLmZzIC0gYSBmaWxlIHN5c3RlbSBjbGllbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5kaXJdIC0gVGhlIFt3b3JraW5nIHRyZWVdKGRpci12cy1naXRkaXIubWQpIGRpcmVjdG9yeSBwYXRoXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MuZ2l0ZGlyPWpvaW4oZGlyLCcuZ2l0JyldIC0gW3JlcXVpcmVkXSBUaGUgW2dpdCBkaXJlY3RvcnldKGRpci12cy1naXRkaXIubWQpIHBhdGhcbiAqXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxBcnJheTxzdHJpbmc+Pn0gUmVzb2x2ZXMgc3VjY2Vzc2Z1bGx5IHdpdGggYW4gYXJyYXkgb2YgdGFnIG5hbWVzXG4gKlxuICogQGV4YW1wbGVcbiAqIGxldCB0YWdzID0gYXdhaXQgZ2l0Lmxpc3RUYWdzKHsgZnMsIGRpcjogJy90dXRvcmlhbCcgfSlcbiAqIGNvbnNvbGUubG9nKHRhZ3MpXG4gKlxuICovXG5hc3luYyBmdW5jdGlvbiBsaXN0VGFncyh7IGZzLCBkaXIsIGdpdGRpciA9IGpvaW4oZGlyLCAnLmdpdCcpIH0pIHtcbiAgdHJ5IHtcbiAgICBhc3NlcnRQYXJhbWV0ZXIoJ2ZzJywgZnMpO1xuICAgIGFzc2VydFBhcmFtZXRlcignZ2l0ZGlyJywgZ2l0ZGlyKTtcbiAgICByZXR1cm4gR2l0UmVmTWFuYWdlci5saXN0VGFncyh7IGZzOiBuZXcgRmlsZVN5c3RlbShmcyksIGdpdGRpciB9KVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBlcnIuY2FsbGVyID0gJ2dpdC5saXN0VGFncyc7XG4gICAgdGhyb3cgZXJyXG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gcmVzb2x2ZUNvbW1pdCh7IGZzLCBjYWNoZSwgZ2l0ZGlyLCBvaWQgfSkge1xuICBjb25zdCB7IHR5cGUsIG9iamVjdCB9ID0gYXdhaXQgX3JlYWRPYmplY3QoeyBmcywgY2FjaGUsIGdpdGRpciwgb2lkIH0pO1xuICAvLyBSZXNvbHZlIGFubm90YXRlZCB0YWcgb2JqZWN0cyB0byB3aGF0ZXZlclxuICBpZiAodHlwZSA9PT0gJ3RhZycpIHtcbiAgICBvaWQgPSBHaXRBbm5vdGF0ZWRUYWcuZnJvbShvYmplY3QpLnBhcnNlKCkub2JqZWN0O1xuICAgIHJldHVybiByZXNvbHZlQ29tbWl0KHsgZnMsIGNhY2hlLCBnaXRkaXIsIG9pZCB9KVxuICB9XG4gIGlmICh0eXBlICE9PSAnY29tbWl0Jykge1xuICAgIHRocm93IG5ldyBPYmplY3RUeXBlRXJyb3Iob2lkLCB0eXBlLCAnY29tbWl0JylcbiAgfVxuICByZXR1cm4geyBjb21taXQ6IEdpdENvbW1pdC5mcm9tKG9iamVjdCksIG9pZCB9XG59XG5cbi8vIEB0cy1jaGVja1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBhcmdzXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vbW9kZWxzL0ZpbGVTeXN0ZW0uanMnKS5GaWxlU3lzdGVtfSBhcmdzLmZzXG4gKiBAcGFyYW0ge2FueX0gYXJncy5jYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGFyZ3MuZ2l0ZGlyXG4gKiBAcGFyYW0ge3N0cmluZ30gYXJncy5vaWRcbiAqXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxSZWFkQ29tbWl0UmVzdWx0Pn0gUmVzb2x2ZXMgc3VjY2Vzc2Z1bGx5IHdpdGggYSBnaXQgY29tbWl0IG9iamVjdFxuICogQHNlZSBSZWFkQ29tbWl0UmVzdWx0XG4gKiBAc2VlIENvbW1pdE9iamVjdFxuICpcbiAqL1xuYXN5bmMgZnVuY3Rpb24gX3JlYWRDb21taXQoeyBmcywgY2FjaGUsIGdpdGRpciwgb2lkIH0pIHtcbiAgY29uc3QgeyBjb21taXQsIG9pZDogY29tbWl0T2lkIH0gPSBhd2FpdCByZXNvbHZlQ29tbWl0KHtcbiAgICBmcyxcbiAgICBjYWNoZSxcbiAgICBnaXRkaXIsXG4gICAgb2lkLFxuICB9KTtcbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgIG9pZDogY29tbWl0T2lkLFxuICAgIGNvbW1pdDogY29tbWl0LnBhcnNlKCksXG4gICAgcGF5bG9hZDogY29tbWl0LndpdGhvdXRTaWduYXR1cmUoKSxcbiAgfTtcbiAgLy8gQHRzLWlnbm9yZVxuICByZXR1cm4gcmVzdWx0XG59XG5cbmZ1bmN0aW9uIGNvbXBhcmVBZ2UoYSwgYikge1xuICByZXR1cm4gYS5jb21taXR0ZXIudGltZXN0YW1wIC0gYi5jb21taXR0ZXIudGltZXN0YW1wXG59XG5cbi8vIEB0cy1jaGVja1xuXG4vKipcbiAqIEdldCBjb21taXQgZGVzY3JpcHRpb25zIGZyb20gdGhlIGdpdCBoaXN0b3J5XG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGFyZ3NcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9tb2RlbHMvRmlsZVN5c3RlbS5qcycpLkZpbGVTeXN0ZW19IGFyZ3MuZnNcbiAqIEBwYXJhbSB7YW55fSBhcmdzLmNhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30gYXJncy5naXRkaXJcbiAqIEBwYXJhbSB7c3RyaW5nfSBhcmdzLnJlZlxuICogQHBhcmFtIHtudW1iZXJ8dm9pZH0gYXJncy5kZXB0aFxuICogQHBhcmFtIHtEYXRlfHZvaWR9IGFyZ3Muc2luY2VcbiAqXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxBcnJheTxSZWFkQ29tbWl0UmVzdWx0Pj59XG4gKi9cbmFzeW5jIGZ1bmN0aW9uIF9sb2coeyBmcywgY2FjaGUsIGdpdGRpciwgcmVmLCBkZXB0aCwgc2luY2UgfSkge1xuICBjb25zdCBzaW5jZVRpbWVzdGFtcCA9XG4gICAgdHlwZW9mIHNpbmNlID09PSAndW5kZWZpbmVkJ1xuICAgICAgPyB1bmRlZmluZWRcbiAgICAgIDogTWF0aC5mbG9vcihzaW5jZS52YWx1ZU9mKCkgLyAxMDAwKTtcbiAgLy8gVE9ETzogSW4gdGhlIGZ1dHVyZSwgd2UgbWF5IHdhbnQgdG8gaGF2ZSBhbiBBUEkgd2hlcmUgd2UgcmV0dXJuIGFcbiAgLy8gYXN5bmMgaXRlcmF0b3IgdGhhdCBlbWl0cyBjb21taXRzLlxuICBjb25zdCBjb21taXRzID0gW107XG4gIGNvbnN0IHNoYWxsb3dDb21taXRzID0gYXdhaXQgR2l0U2hhbGxvd01hbmFnZXIucmVhZCh7IGZzLCBnaXRkaXIgfSk7XG4gIGNvbnN0IG9pZCA9IGF3YWl0IEdpdFJlZk1hbmFnZXIucmVzb2x2ZSh7IGZzLCBnaXRkaXIsIHJlZiB9KTtcbiAgY29uc3QgdGlwcyA9IFthd2FpdCBfcmVhZENvbW1pdCh7IGZzLCBjYWNoZSwgZ2l0ZGlyLCBvaWQgfSldO1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgY29uc3QgY29tbWl0ID0gdGlwcy5wb3AoKTtcblxuICAgIC8vIFN0b3AgdGhlIGxvZyBpZiB3ZSd2ZSBoaXQgdGhlIGFnZSBsaW1pdFxuICAgIGlmIChcbiAgICAgIHNpbmNlVGltZXN0YW1wICE9PSB1bmRlZmluZWQgJiZcbiAgICAgIGNvbW1pdC5jb21taXQuY29tbWl0dGVyLnRpbWVzdGFtcCA8PSBzaW5jZVRpbWVzdGFtcFxuICAgICkge1xuICAgICAgYnJlYWtcbiAgICB9XG5cbiAgICBjb21taXRzLnB1c2goY29tbWl0KTtcblxuICAgIC8vIFN0b3AgdGhlIGxvb3AgaWYgd2UgaGF2ZSBlbm91Z2ggY29tbWl0cyBub3cuXG4gICAgaWYgKGRlcHRoICE9PSB1bmRlZmluZWQgJiYgY29tbWl0cy5sZW5ndGggPT09IGRlcHRoKSBicmVha1xuXG4gICAgLy8gSWYgdGhpcyBpcyBub3QgYSBzaGFsbG93IGNvbW1pdC4uLlxuICAgIGlmICghc2hhbGxvd0NvbW1pdHMuaGFzKGNvbW1pdC5vaWQpKSB7XG4gICAgICAvLyBBZGQgdGhlIHBhcmVudHMgb2YgdGhpcyBjb21taXQgdG8gdGhlIHF1ZXVlXG4gICAgICAvLyBOb3RlOiBmb3IgdGhlIGNhc2Ugb2YgYSBjb21taXQgd2l0aCBubyBwYXJlbnRzLCBpdCB3aWxsIGNvbmNhdCBhbiBlbXB0eSBhcnJheSwgaGF2aW5nIG5vIG5ldCBlZmZlY3QuXG4gICAgICBmb3IgKGNvbnN0IG9pZCBvZiBjb21taXQuY29tbWl0LnBhcmVudCkge1xuICAgICAgICBjb25zdCBjb21taXQgPSBhd2FpdCBfcmVhZENvbW1pdCh7IGZzLCBjYWNoZSwgZ2l0ZGlyLCBvaWQgfSk7XG4gICAgICAgIGlmICghdGlwcy5tYXAoY29tbWl0ID0+IGNvbW1pdC5vaWQpLmluY2x1ZGVzKGNvbW1pdC5vaWQpKSB7XG4gICAgICAgICAgdGlwcy5wdXNoKGNvbW1pdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBTdG9wIHRoZSBsb29wIGlmIHRoZXJlIGFyZSBubyBtb3JlIGNvbW1pdCBwYXJlbnRzXG4gICAgaWYgKHRpcHMubGVuZ3RoID09PSAwKSBicmVha1xuXG4gICAgLy8gUHJvY2VzcyB0aXBzIGluIG9yZGVyIGJ5IGFnZVxuICAgIHRpcHMuc29ydCgoYSwgYikgPT4gY29tcGFyZUFnZShhLmNvbW1pdCwgYi5jb21taXQpKTtcbiAgfVxuICByZXR1cm4gY29tbWl0c1xufVxuXG4vLyBAdHMtY2hlY2tcblxuLyoqXG4gKiBHZXQgY29tbWl0IGRlc2NyaXB0aW9ucyBmcm9tIHRoZSBnaXQgaGlzdG9yeVxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBhcmdzXG4gKiBAcGFyYW0ge0ZzQ2xpZW50fSBhcmdzLmZzIC0gYSBmaWxlIHN5c3RlbSBjbGllbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5kaXJdIC0gVGhlIFt3b3JraW5nIHRyZWVdKGRpci12cy1naXRkaXIubWQpIGRpcmVjdG9yeSBwYXRoXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MuZ2l0ZGlyPWpvaW4oZGlyLCcuZ2l0JyldIC0gW3JlcXVpcmVkXSBUaGUgW2dpdCBkaXJlY3RvcnldKGRpci12cy1naXRkaXIubWQpIHBhdGhcbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5yZWYgPSAnSEVBRCddIC0gVGhlIGNvbW1pdCB0byBiZWdpbiB3YWxraW5nIGJhY2t3YXJkcyB0aHJvdWdoIHRoZSBoaXN0b3J5IGZyb21cbiAqIEBwYXJhbSB7bnVtYmVyfSBbYXJncy5kZXB0aF0gLSBMaW1pdCB0aGUgbnVtYmVyIG9mIGNvbW1pdHMgcmV0dXJuZWQuIE5vIGxpbWl0IGJ5IGRlZmF1bHQuXG4gKiBAcGFyYW0ge0RhdGV9IFthcmdzLnNpbmNlXSAtIFJldHVybiBoaXN0b3J5IG5ld2VyIHRoYW4gdGhlIGdpdmVuIGRhdGUuIENhbiBiZSBjb21iaW5lZCB3aXRoIGBkZXB0aGAgdG8gZ2V0IHdoaWNoZXZlciBpcyBzaG9ydGVyLlxuICogQHBhcmFtIHtvYmplY3R9IFthcmdzLmNhY2hlXSAtIGEgW2NhY2hlXShjYWNoZS5tZCkgb2JqZWN0XG4gKlxuICogQHJldHVybnMge1Byb21pc2U8QXJyYXk8UmVhZENvbW1pdFJlc3VsdD4+fSBSZXNvbHZlcyB0byBhbiBhcnJheSBvZiBSZWFkQ29tbWl0UmVzdWx0IG9iamVjdHNcbiAqIEBzZWUgUmVhZENvbW1pdFJlc3VsdFxuICogQHNlZSBDb21taXRPYmplY3RcbiAqXG4gKiBAZXhhbXBsZVxuICogbGV0IGNvbW1pdHMgPSBhd2FpdCBnaXQubG9nKHtcbiAqICAgZnMsXG4gKiAgIGRpcjogJy90dXRvcmlhbCcsXG4gKiAgIGRlcHRoOiA1LFxuICogICByZWY6ICdtYWluJ1xuICogfSlcbiAqIGNvbnNvbGUubG9nKGNvbW1pdHMpXG4gKlxuICovXG5hc3luYyBmdW5jdGlvbiBsb2coe1xuICBmcyxcbiAgZGlyLFxuICBnaXRkaXIgPSBqb2luKGRpciwgJy5naXQnKSxcbiAgcmVmID0gJ0hFQUQnLFxuICBkZXB0aCxcbiAgc2luY2UsIC8vIERhdGVcbiAgY2FjaGUgPSB7fSxcbn0pIHtcbiAgdHJ5IHtcbiAgICBhc3NlcnRQYXJhbWV0ZXIoJ2ZzJywgZnMpO1xuICAgIGFzc2VydFBhcmFtZXRlcignZ2l0ZGlyJywgZ2l0ZGlyKTtcbiAgICBhc3NlcnRQYXJhbWV0ZXIoJ3JlZicsIHJlZik7XG5cbiAgICByZXR1cm4gYXdhaXQgX2xvZyh7XG4gICAgICBmczogbmV3IEZpbGVTeXN0ZW0oZnMpLFxuICAgICAgY2FjaGUsXG4gICAgICBnaXRkaXIsXG4gICAgICByZWYsXG4gICAgICBkZXB0aCxcbiAgICAgIHNpbmNlLFxuICAgIH0pXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGVyci5jYWxsZXIgPSAnZ2l0LmxvZyc7XG4gICAgdGhyb3cgZXJyXG4gIH1cbn1cblxuLy8gQHRzLWNoZWNrXG5cbi8qKlxuICpcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE1lcmdlUmVzdWx0IC0gUmV0dXJucyBhbiBvYmplY3Qgd2l0aCBhIHNjaGVtYSBsaWtlIHRoaXM6XG4gKiBAcHJvcGVydHkge3N0cmluZ30gW29pZF0gLSBUaGUgU0hBLTEgb2JqZWN0IGlkIHRoYXQgaXMgbm93IGF0IHRoZSBoZWFkIG9mIHRoZSBicmFuY2guIEFic2VudCBvbmx5IGlmIGBkcnlSdW5gIHdhcyBzcGVjaWZpZWQgYW5kIGBtZXJnZUNvbW1pdGAgaXMgdHJ1ZS5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2FscmVhZHlNZXJnZWRdIC0gVHJ1ZSBpZiB0aGUgYnJhbmNoIHdhcyBhbHJlYWR5IG1lcmdlZCBzbyBubyBjaGFuZ2VzIHdlcmUgbWFkZVxuICogQHByb3BlcnR5IHtib29sZWFufSBbZmFzdEZvcndhcmRdIC0gVHJ1ZSBpZiBpdCB3YXMgYSBmYXN0LWZvcndhcmQgbWVyZ2VcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW21lcmdlQ29tbWl0XSAtIFRydWUgaWYgbWVyZ2UgcmVzdWx0ZWQgaW4gYSBtZXJnZSBjb21taXRcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbdHJlZV0gLSBUaGUgU0hBLTEgb2JqZWN0IGlkIG9mIHRoZSB0cmVlIHJlc3VsdGluZyBmcm9tIGEgbWVyZ2UgY29tbWl0XG4gKlxuICovXG5cbi8qKlxuICogTWVyZ2UgdHdvIGJyYW5jaGVzXG4gKlxuICogIyMgTGltaXRhdGlvbnNcbiAqXG4gKiBDdXJyZW50bHkgaXQgZG9lcyBub3Qgc3VwcG9ydCBpbmNvbXBsZXRlIG1lcmdlcy4gVGhhdCBpcywgaWYgdGhlcmUgYXJlIG1lcmdlIGNvbmZsaWN0cyBpdCBjYW5ub3Qgc29sdmVcbiAqIHdpdGggdGhlIGJ1aWx0IGluIGRpZmYzIGFsZ29yaXRobSBpdCB3aWxsIG5vdCBtb2RpZnkgdGhlIHdvcmtpbmcgZGlyLCBhbmQgd2lsbCB0aHJvdyBhIFtgTWVyZ2VOb3RTdXBwb3J0ZWRFcnJvcmBdKC4vZXJyb3JzLm1kI21lcmdlbm90c3VwcG9ydGVkRXJyb3IpIGVycm9yLlxuICpcbiAqIEN1cnJlbnRseSBpdCB3aWxsIGZhaWwgaWYgbXVsdGlwbGUgY2FuZGlkYXRlIG1lcmdlIGJhc2VzIGFyZSBmb3VuZC4gKEl0IGRvZXNuJ3QgeWV0IGltcGxlbWVudCB0aGUgcmVjdXJzaXZlIG1lcmdlIHN0cmF0ZWd5LilcbiAqXG4gKiBDdXJyZW50bHkgaXQgZG9lcyBub3Qgc3VwcG9ydCBzZWxlY3RpbmcgYWx0ZXJuYXRpdmUgbWVyZ2Ugc3RyYXRlZ2llcy5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gYXJnc1xuICogQHBhcmFtIHtGc0NsaWVudH0gYXJncy5mcyAtIGEgZmlsZSBzeXN0ZW0gY2xpZW50XG4gKiBAcGFyYW0ge1NpZ25DYWxsYmFja30gW2FyZ3Mub25TaWduXSAtIGEgUEdQIHNpZ25pbmcgaW1wbGVtZW50YXRpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5kaXJdIC0gVGhlIFt3b3JraW5nIHRyZWVdKGRpci12cy1naXRkaXIubWQpIGRpcmVjdG9yeSBwYXRoXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MuZ2l0ZGlyPWpvaW4oZGlyLCcuZ2l0JyldIC0gW3JlcXVpcmVkXSBUaGUgW2dpdCBkaXJlY3RvcnldKGRpci12cy1naXRkaXIubWQpIHBhdGhcbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5vdXJzXSAtIFRoZSBicmFuY2ggcmVjZWl2aW5nIHRoZSBtZXJnZS4gSWYgdW5kZWZpbmVkLCBkZWZhdWx0cyB0byB0aGUgY3VycmVudCBicmFuY2guXG4gKiBAcGFyYW0ge3N0cmluZ30gYXJncy50aGVpcnMgLSBUaGUgYnJhbmNoIHRvIGJlIG1lcmdlZFxuICogQHBhcmFtIHtib29sZWFufSBbYXJncy5mYXN0Rm9yd2FyZE9ubHkgPSBmYWxzZV0gLSBJZiB0cnVlLCB0aGVuIG5vbi1mYXN0LWZvcndhcmQgbWVyZ2VzIHdpbGwgdGhyb3cgYW4gRXJyb3IgaW5zdGVhZCBvZiBwZXJmb3JtaW5nIGEgbWVyZ2UuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFthcmdzLmRyeVJ1biA9IGZhbHNlXSAtIElmIHRydWUsIHNpbXVsYXRlcyBhIG1lcmdlIHNvIHlvdSBjYW4gdGVzdCB3aGV0aGVyIGl0IHdvdWxkIHN1Y2NlZWQuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFthcmdzLm5vVXBkYXRlQnJhbmNoID0gZmFsc2VdIC0gSWYgdHJ1ZSwgZG9lcyBub3QgdXBkYXRlIHRoZSBicmFuY2ggcG9pbnRlciBhZnRlciBjcmVhdGluZyB0aGUgY29tbWl0LlxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLm1lc3NhZ2VdIC0gT3ZlcnJpZGVzIHRoZSBkZWZhdWx0IGF1dG8tZ2VuZXJhdGVkIG1lcmdlIGNvbW1pdCBtZXNzYWdlXG4gKiBAcGFyYW0ge09iamVjdH0gW2FyZ3MuYXV0aG9yXSAtIHBhc3NlZCB0byBbY29tbWl0XShjb21taXQubWQpIHdoZW4gY3JlYXRpbmcgYSBtZXJnZSBjb21taXRcbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5hdXRob3IubmFtZV0gLSBEZWZhdWx0IGlzIGB1c2VyLm5hbWVgIGNvbmZpZy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5hdXRob3IuZW1haWxdIC0gRGVmYXVsdCBpcyBgdXNlci5lbWFpbGAgY29uZmlnLlxuICogQHBhcmFtIHtudW1iZXJ9IFthcmdzLmF1dGhvci50aW1lc3RhbXA9TWF0aC5mbG9vcihEYXRlLm5vdygpLzEwMDApXSAtIFNldCB0aGUgYXV0aG9yIHRpbWVzdGFtcCBmaWVsZC4gVGhpcyBpcyB0aGUgaW50ZWdlciBudW1iZXIgb2Ygc2Vjb25kcyBzaW5jZSB0aGUgVW5peCBlcG9jaCAoMTk3MC0wMS0wMSAwMDowMDowMCkuXG4gKiBAcGFyYW0ge251bWJlcn0gW2FyZ3MuYXV0aG9yLnRpbWV6b25lT2Zmc2V0XSAtIFNldCB0aGUgYXV0aG9yIHRpbWV6b25lIG9mZnNldCBmaWVsZC4gVGhpcyBpcyB0aGUgZGlmZmVyZW5jZSwgaW4gbWludXRlcywgZnJvbSB0aGUgY3VycmVudCB0aW1lem9uZSB0byBVVEMuIERlZmF1bHQgaXMgYChuZXcgRGF0ZSgpKS5nZXRUaW1lem9uZU9mZnNldCgpYC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbYXJncy5jb21taXR0ZXJdIC0gcGFzc2VkIHRvIFtjb21taXRdKGNvbW1pdC5tZCkgd2hlbiBjcmVhdGluZyBhIG1lcmdlIGNvbW1pdFxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLmNvbW1pdHRlci5uYW1lXSAtIERlZmF1bHQgaXMgYHVzZXIubmFtZWAgY29uZmlnLlxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLmNvbW1pdHRlci5lbWFpbF0gLSBEZWZhdWx0IGlzIGB1c2VyLmVtYWlsYCBjb25maWcuXG4gKiBAcGFyYW0ge251bWJlcn0gW2FyZ3MuY29tbWl0dGVyLnRpbWVzdGFtcD1NYXRoLmZsb29yKERhdGUubm93KCkvMTAwMCldIC0gU2V0IHRoZSBjb21taXR0ZXIgdGltZXN0YW1wIGZpZWxkLiBUaGlzIGlzIHRoZSBpbnRlZ2VyIG51bWJlciBvZiBzZWNvbmRzIHNpbmNlIHRoZSBVbml4IGVwb2NoICgxOTcwLTAxLTAxIDAwOjAwOjAwKS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbYXJncy5jb21taXR0ZXIudGltZXpvbmVPZmZzZXRdIC0gU2V0IHRoZSBjb21taXR0ZXIgdGltZXpvbmUgb2Zmc2V0IGZpZWxkLiBUaGlzIGlzIHRoZSBkaWZmZXJlbmNlLCBpbiBtaW51dGVzLCBmcm9tIHRoZSBjdXJyZW50IHRpbWV6b25lIHRvIFVUQy4gRGVmYXVsdCBpcyBgKG5ldyBEYXRlKCkpLmdldFRpbWV6b25lT2Zmc2V0KClgLlxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLnNpZ25pbmdLZXldIC0gcGFzc2VkIHRvIFtjb21taXRdKGNvbW1pdC5tZCkgd2hlbiBjcmVhdGluZyBhIG1lcmdlIGNvbW1pdFxuICogQHBhcmFtIHtvYmplY3R9IFthcmdzLmNhY2hlXSAtIGEgW2NhY2hlXShjYWNoZS5tZCkgb2JqZWN0XG4gKlxuICogQHJldHVybnMge1Byb21pc2U8TWVyZ2VSZXN1bHQ+fSBSZXNvbHZlcyB0byBhIGRlc2NyaXB0aW9uIG9mIHRoZSBtZXJnZSBvcGVyYXRpb25cbiAqIEBzZWUgTWVyZ2VSZXN1bHRcbiAqXG4gKiBAZXhhbXBsZVxuICogbGV0IG0gPSBhd2FpdCBnaXQubWVyZ2Uoe1xuICogICBmcyxcbiAqICAgZGlyOiAnL3R1dG9yaWFsJyxcbiAqICAgb3VyczogJ21haW4nLFxuICogICB0aGVpcnM6ICdyZW1vdGVzL29yaWdpbi9tYWluJ1xuICogfSlcbiAqIGNvbnNvbGUubG9nKG0pXG4gKlxuICovXG5hc3luYyBmdW5jdGlvbiBtZXJnZSh7XG4gIGZzOiBfZnMsXG4gIG9uU2lnbixcbiAgZGlyLFxuICBnaXRkaXIgPSBqb2luKGRpciwgJy5naXQnKSxcbiAgb3VycyxcbiAgdGhlaXJzLFxuICBmYXN0Rm9yd2FyZE9ubHkgPSBmYWxzZSxcbiAgZHJ5UnVuID0gZmFsc2UsXG4gIG5vVXBkYXRlQnJhbmNoID0gZmFsc2UsXG4gIG1lc3NhZ2UsXG4gIGF1dGhvcjogX2F1dGhvcixcbiAgY29tbWl0dGVyOiBfY29tbWl0dGVyLFxuICBzaWduaW5nS2V5LFxuICBjYWNoZSA9IHt9LFxufSkge1xuICB0cnkge1xuICAgIGFzc2VydFBhcmFtZXRlcignZnMnLCBfZnMpO1xuICAgIGlmIChzaWduaW5nS2V5KSB7XG4gICAgICBhc3NlcnRQYXJhbWV0ZXIoJ29uU2lnbicsIG9uU2lnbik7XG4gICAgfVxuICAgIGNvbnN0IGZzID0gbmV3IEZpbGVTeXN0ZW0oX2ZzKTtcblxuICAgIGNvbnN0IGF1dGhvciA9IGF3YWl0IG5vcm1hbGl6ZUF1dGhvck9iamVjdCh7IGZzLCBnaXRkaXIsIGF1dGhvcjogX2F1dGhvciB9KTtcbiAgICBpZiAoIWF1dGhvciAmJiAhZmFzdEZvcndhcmRPbmx5KSB0aHJvdyBuZXcgTWlzc2luZ05hbWVFcnJvcignYXV0aG9yJylcblxuICAgIGNvbnN0IGNvbW1pdHRlciA9IGF3YWl0IG5vcm1hbGl6ZUNvbW1pdHRlck9iamVjdCh7XG4gICAgICBmcyxcbiAgICAgIGdpdGRpcixcbiAgICAgIGF1dGhvcixcbiAgICAgIGNvbW1pdHRlcjogX2NvbW1pdHRlcixcbiAgICB9KTtcbiAgICBpZiAoIWNvbW1pdHRlciAmJiAhZmFzdEZvcndhcmRPbmx5KSB7XG4gICAgICB0aHJvdyBuZXcgTWlzc2luZ05hbWVFcnJvcignY29tbWl0dGVyJylcbiAgICB9XG5cbiAgICByZXR1cm4gYXdhaXQgX21lcmdlKHtcbiAgICAgIGZzLFxuICAgICAgY2FjaGUsXG4gICAgICBnaXRkaXIsXG4gICAgICBvdXJzLFxuICAgICAgdGhlaXJzLFxuICAgICAgZmFzdEZvcndhcmRPbmx5LFxuICAgICAgZHJ5UnVuLFxuICAgICAgbm9VcGRhdGVCcmFuY2gsXG4gICAgICBtZXNzYWdlLFxuICAgICAgYXV0aG9yLFxuICAgICAgY29tbWl0dGVyLFxuICAgICAgc2lnbmluZ0tleSxcbiAgICB9KVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBlcnIuY2FsbGVyID0gJ2dpdC5tZXJnZSc7XG4gICAgdGhyb3cgZXJyXG4gIH1cbn1cblxuLyoqXG4gKiBAZW51bSB7bnVtYmVyfVxuICovXG5jb25zdCB0eXBlcyA9IHtcbiAgY29tbWl0OiAwYjAwMTAwMDAsXG4gIHRyZWU6IDBiMDEwMDAwMCxcbiAgYmxvYjogMGIwMTEwMDAwLFxuICB0YWc6IDBiMTAwMDAwMCxcbiAgb2ZzX2RlbHRhOiAwYjExMDAwMDAsXG4gIHJlZl9kZWx0YTogMGIxMTEwMDAwLFxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gYXJnc1xuICogQHBhcmFtIHtpbXBvcnQoJy4uL21vZGVscy9GaWxlU3lzdGVtLmpzJykuRmlsZVN5c3RlbX0gYXJncy5mc1xuICogQHBhcmFtIHthbnl9IGFyZ3MuY2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5kaXJdIC0gVGhlIFt3b3JraW5nIHRyZWVdKGRpci12cy1naXRkaXIubWQpIGRpcmVjdG9yeSBwYXRoXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MuZ2l0ZGlyPWpvaW4oZGlyLCAnLmdpdCcpXSAtIFtyZXF1aXJlZF0gVGhlIFtnaXQgZGlyZWN0b3J5XShkaXItdnMtZ2l0ZGlyLm1kKSBwYXRoXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBhcmdzLm9pZHNcbiAqL1xuYXN5bmMgZnVuY3Rpb24gX3BhY2soe1xuICBmcyxcbiAgY2FjaGUsXG4gIGRpcixcbiAgZ2l0ZGlyID0gam9pbihkaXIsICcuZ2l0JyksXG4gIG9pZHMsXG59KSB7XG4gIGNvbnN0IGhhc2ggPSBuZXcgSGFzaCgpO1xuICBjb25zdCBvdXRwdXRTdHJlYW0gPSBbXTtcbiAgZnVuY3Rpb24gd3JpdGUoY2h1bmssIGVuYykge1xuICAgIGNvbnN0IGJ1ZmYgPSBCdWZmZXIuZnJvbShjaHVuaywgZW5jKTtcbiAgICBvdXRwdXRTdHJlYW0ucHVzaChidWZmKTtcbiAgICBoYXNoLnVwZGF0ZShidWZmKTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiB3cml0ZU9iamVjdCh7IHN0eXBlLCBvYmplY3QgfSkge1xuICAgIC8vIE9iamVjdCB0eXBlIGlzIGVuY29kZWQgaW4gYml0cyA2NTRcbiAgICBjb25zdCB0eXBlID0gdHlwZXNbc3R5cGVdO1xuICAgIC8vIFRoZSBsZW5ndGggZW5jb2RpbmcgZ2V0cyBjb21wbGljYXRlZC5cbiAgICBsZXQgbGVuZ3RoID0gb2JqZWN0Lmxlbmd0aDtcbiAgICAvLyBXaGV0aGVyIHRoZSBuZXh0IGJ5dGUgaXMgcGFydCBvZiB0aGUgdmFyaWFibGUtbGVuZ3RoIGVuY29kZWQgbnVtYmVyXG4gICAgLy8gaXMgZW5jb2RlZCBpbiBiaXQgN1xuICAgIGxldCBtdWx0aWJ5dGUgPSBsZW5ndGggPiAwYjExMTEgPyAwYjEwMDAwMDAwIDogMGIwO1xuICAgIC8vIExhc3QgZm91ciBiaXRzIG9mIGxlbmd0aCBpcyBlbmNvZGVkIGluIGJpdHMgMzIxMFxuICAgIGNvbnN0IGxhc3RGb3VyID0gbGVuZ3RoICYgMGIxMTExO1xuICAgIC8vIERpc2NhcmQgdGhvc2UgYml0c1xuICAgIGxlbmd0aCA9IGxlbmd0aCA+Pj4gNDtcbiAgICAvLyBUaGUgZmlyc3QgYnl0ZSBpcyB0aGVuICgxLWJpdCBtdWx0aWJ5dGU/KSwgKDMtYml0IHR5cGUpLCAoNC1iaXQgbGVhc3Qgc2lnIDQtYml0cyBvZiBsZW5ndGgpXG4gICAgbGV0IGJ5dGUgPSAobXVsdGlieXRlIHwgdHlwZSB8IGxhc3RGb3VyKS50b1N0cmluZygxNik7XG4gICAgd3JpdGUoYnl0ZSwgJ2hleCcpO1xuICAgIC8vIE5vdyB3ZSBrZWVwIGNob3BwaW5nIGF3YXkgYXQgbGVuZ3RoIDctYml0cyBhdCBhIHRpbWUgdW50aWwgaXRzIHplcm8sXG4gICAgLy8gd3JpdGluZyBvdXQgdGhlIGJ5dGVzIGluIHdoYXQgYW1vdW50cyB0byBsaXR0bGUtZW5kaWFuIG9yZGVyLlxuICAgIHdoaWxlIChtdWx0aWJ5dGUpIHtcbiAgICAgIG11bHRpYnl0ZSA9IGxlbmd0aCA+IDBiMDExMTExMTEgPyAwYjEwMDAwMDAwIDogMGIwO1xuICAgICAgYnl0ZSA9IG11bHRpYnl0ZSB8IChsZW5ndGggJiAwYjAxMTExMTExKTtcbiAgICAgIHdyaXRlKHBhZEhleCgyLCBieXRlKSwgJ2hleCcpO1xuICAgICAgbGVuZ3RoID0gbGVuZ3RoID4+PiA3O1xuICAgIH1cbiAgICAvLyBMYXN0bHksIHdlIGNhbiBjb21wcmVzcyBhbmQgd3JpdGUgdGhlIG9iamVjdC5cbiAgICB3cml0ZShCdWZmZXIuZnJvbShhd2FpdCBkZWZsYXRlKG9iamVjdCkpKTtcbiAgfVxuICB3cml0ZSgnUEFDSycpO1xuICB3cml0ZSgnMDAwMDAwMDInLCAnaGV4Jyk7XG4gIC8vIFdyaXRlIGEgNCBieXRlICgzMi1iaXQpIGludFxuICB3cml0ZShwYWRIZXgoOCwgb2lkcy5sZW5ndGgpLCAnaGV4Jyk7XG4gIGZvciAoY29uc3Qgb2lkIG9mIG9pZHMpIHtcbiAgICBjb25zdCB7IHR5cGUsIG9iamVjdCB9ID0gYXdhaXQgX3JlYWRPYmplY3QoeyBmcywgY2FjaGUsIGdpdGRpciwgb2lkIH0pO1xuICAgIGF3YWl0IHdyaXRlT2JqZWN0KHsgd3JpdGUsIG9iamVjdCwgc3R5cGU6IHR5cGUgfSk7XG4gIH1cbiAgLy8gV3JpdGUgU0hBMSBjaGVja3N1bVxuICBjb25zdCBkaWdlc3QgPSBoYXNoLmRpZ2VzdCgpO1xuICBvdXRwdXRTdHJlYW0ucHVzaChkaWdlc3QpO1xuICByZXR1cm4gb3V0cHV0U3RyZWFtXG59XG5cbi8vIEB0cy1jaGVja1xuXG4vKipcbiAqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBQYWNrT2JqZWN0c1Jlc3VsdCBUaGUgcGFja09iamVjdHMgY29tbWFuZCByZXR1cm5zIGFuIG9iamVjdCB3aXRoIHR3byBwcm9wZXJ0aWVzOlxuICogQHByb3BlcnR5IHtzdHJpbmd9IGZpbGVuYW1lIC0gVGhlIHN1Z2dlc3RlZCBmaWxlbmFtZSBmb3IgdGhlIHBhY2tmaWxlIGlmIHlvdSB3YW50IHRvIHNhdmUgaXQgdG8gZGlzayBzb21ld2hlcmUuIEl0IGluY2x1ZGVzIHRoZSBwYWNrZmlsZSBTSEEuXG4gKiBAcHJvcGVydHkge1VpbnQ4QXJyYXl9IFtwYWNrZmlsZV0gLSBUaGUgcGFja2ZpbGUgY29udGVudHMuIE5vdCBwcmVzZW50IGlmIGB3cml0ZWAgcGFyYW1ldGVyIHdhcyB0cnVlLCBpbiB3aGljaCBjYXNlIHRoZSBwYWNrZmlsZSB3YXMgd3JpdHRlbiBzdHJhaWdodCB0byBkaXNrLlxuICovXG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGFyZ3NcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9tb2RlbHMvRmlsZVN5c3RlbS5qcycpLkZpbGVTeXN0ZW19IGFyZ3MuZnNcbiAqIEBwYXJhbSB7YW55fSBhcmdzLmNhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30gYXJncy5naXRkaXJcbiAqIEBwYXJhbSB7c3RyaW5nW119IGFyZ3Mub2lkc1xuICogQHBhcmFtIHtib29sZWFufSBhcmdzLndyaXRlXG4gKlxuICogQHJldHVybnMge1Byb21pc2U8UGFja09iamVjdHNSZXN1bHQ+fVxuICogQHNlZSBQYWNrT2JqZWN0c1Jlc3VsdFxuICovXG5hc3luYyBmdW5jdGlvbiBfcGFja09iamVjdHMoeyBmcywgY2FjaGUsIGdpdGRpciwgb2lkcywgd3JpdGUgfSkge1xuICBjb25zdCBidWZmZXJzID0gYXdhaXQgX3BhY2soeyBmcywgY2FjaGUsIGdpdGRpciwgb2lkcyB9KTtcbiAgY29uc3QgcGFja2ZpbGUgPSBCdWZmZXIuZnJvbShhd2FpdCBjb2xsZWN0KGJ1ZmZlcnMpKTtcbiAgY29uc3QgcGFja2ZpbGVTaGEgPSBwYWNrZmlsZS5zbGljZSgtMjApLnRvU3RyaW5nKCdoZXgnKTtcbiAgY29uc3QgZmlsZW5hbWUgPSBgcGFjay0ke3BhY2tmaWxlU2hhfS5wYWNrYDtcbiAgaWYgKHdyaXRlKSB7XG4gICAgYXdhaXQgZnMud3JpdGUoam9pbihnaXRkaXIsIGBvYmplY3RzL3BhY2svJHtmaWxlbmFtZX1gKSwgcGFja2ZpbGUpO1xuICAgIHJldHVybiB7IGZpbGVuYW1lIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIGZpbGVuYW1lLFxuICAgIHBhY2tmaWxlOiBuZXcgVWludDhBcnJheShwYWNrZmlsZSksXG4gIH1cbn1cblxuLy8gQHRzLWNoZWNrXG5cbi8qKlxuICpcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFBhY2tPYmplY3RzUmVzdWx0IFRoZSBwYWNrT2JqZWN0cyBjb21tYW5kIHJldHVybnMgYW4gb2JqZWN0IHdpdGggdHdvIHByb3BlcnRpZXM6XG4gKiBAcHJvcGVydHkge3N0cmluZ30gZmlsZW5hbWUgLSBUaGUgc3VnZ2VzdGVkIGZpbGVuYW1lIGZvciB0aGUgcGFja2ZpbGUgaWYgeW91IHdhbnQgdG8gc2F2ZSBpdCB0byBkaXNrIHNvbWV3aGVyZS4gSXQgaW5jbHVkZXMgdGhlIHBhY2tmaWxlIFNIQS5cbiAqIEBwcm9wZXJ0eSB7VWludDhBcnJheX0gW3BhY2tmaWxlXSAtIFRoZSBwYWNrZmlsZSBjb250ZW50cy4gTm90IHByZXNlbnQgaWYgYHdyaXRlYCBwYXJhbWV0ZXIgd2FzIHRydWUsIGluIHdoaWNoIGNhc2UgdGhlIHBhY2tmaWxlIHdhcyB3cml0dGVuIHN0cmFpZ2h0IHRvIGRpc2suXG4gKi9cblxuLyoqXG4gKiBDcmVhdGUgYSBwYWNrZmlsZSBmcm9tIGFuIGFycmF5IG9mIFNIQS0xIG9iamVjdCBpZHNcbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gYXJnc1xuICogQHBhcmFtIHtGc0NsaWVudH0gYXJncy5mcyAtIGEgZmlsZSBzeXN0ZW0gY2xpZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MuZGlyXSAtIFRoZSBbd29ya2luZyB0cmVlXShkaXItdnMtZ2l0ZGlyLm1kKSBkaXJlY3RvcnkgcGF0aFxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLmdpdGRpcj1qb2luKGRpciwgJy5naXQnKV0gLSBbcmVxdWlyZWRdIFRoZSBbZ2l0IGRpcmVjdG9yeV0oZGlyLXZzLWdpdGRpci5tZCkgcGF0aFxuICogQHBhcmFtIHtzdHJpbmdbXX0gYXJncy5vaWRzIC0gQW4gYXJyYXkgb2YgU0hBLTEgb2JqZWN0IGlkcyB0byBiZSBpbmNsdWRlZCBpbiB0aGUgcGFja2ZpbGVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2FyZ3Mud3JpdGUgPSBmYWxzZV0gLSBXaGV0aGVyIHRvIHNhdmUgdGhlIHBhY2tmaWxlIHRvIGRpc2sgb3Igbm90XG4gKiBAcGFyYW0ge29iamVjdH0gW2FyZ3MuY2FjaGVdIC0gYSBbY2FjaGVdKGNhY2hlLm1kKSBvYmplY3RcbiAqXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxQYWNrT2JqZWN0c1Jlc3VsdD59IFJlc29sdmVzIHN1Y2Nlc3NmdWxseSB3aGVuIHRoZSBwYWNrZmlsZSBpcyByZWFkeSB3aXRoIHRoZSBmaWxlbmFtZSBhbmQgYnVmZmVyXG4gKiBAc2VlIFBhY2tPYmplY3RzUmVzdWx0XG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIENyZWF0ZSBhIHBhY2tmaWxlIGNvbnRhaW5pbmcgb25seSBhbiBlbXB0eSB0cmVlXG4gKiBsZXQgeyBwYWNrZmlsZSB9ID0gYXdhaXQgZ2l0LnBhY2tPYmplY3RzKHtcbiAqICAgZnMsXG4gKiAgIGRpcjogJy90dXRvcmlhbCcsXG4gKiAgIG9pZHM6IFsnNGI4MjVkYzY0MmNiNmViOWEwNjBlNTRiZjhkNjkyODhmYmVlNDkwNCddXG4gKiB9KVxuICogY29uc29sZS5sb2cocGFja2ZpbGUpXG4gKlxuICovXG5hc3luYyBmdW5jdGlvbiBwYWNrT2JqZWN0cyh7XG4gIGZzLFxuICBkaXIsXG4gIGdpdGRpciA9IGpvaW4oZGlyLCAnLmdpdCcpLFxuICBvaWRzLFxuICB3cml0ZSA9IGZhbHNlLFxuICBjYWNoZSA9IHt9LFxufSkge1xuICB0cnkge1xuICAgIGFzc2VydFBhcmFtZXRlcignZnMnLCBmcyk7XG4gICAgYXNzZXJ0UGFyYW1ldGVyKCdnaXRkaXInLCBnaXRkaXIpO1xuICAgIGFzc2VydFBhcmFtZXRlcignb2lkcycsIG9pZHMpO1xuXG4gICAgcmV0dXJuIGF3YWl0IF9wYWNrT2JqZWN0cyh7XG4gICAgICBmczogbmV3IEZpbGVTeXN0ZW0oZnMpLFxuICAgICAgY2FjaGUsXG4gICAgICBnaXRkaXIsXG4gICAgICBvaWRzLFxuICAgICAgd3JpdGUsXG4gICAgfSlcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZXJyLmNhbGxlciA9ICdnaXQucGFja09iamVjdHMnO1xuICAgIHRocm93IGVyclxuICB9XG59XG5cbi8vIEB0cy1jaGVja1xuXG4vKipcbiAqIEZldGNoIGFuZCBtZXJnZSBjb21taXRzIGZyb20gYSByZW1vdGUgcmVwb3NpdG9yeVxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBhcmdzXG4gKiBAcGFyYW0ge0ZzQ2xpZW50fSBhcmdzLmZzIC0gYSBmaWxlIHN5c3RlbSBjbGllbnRcbiAqIEBwYXJhbSB7SHR0cENsaWVudH0gYXJncy5odHRwIC0gYW4gSFRUUCBjbGllbnRcbiAqIEBwYXJhbSB7UHJvZ3Jlc3NDYWxsYmFja30gW2FyZ3Mub25Qcm9ncmVzc10gLSBvcHRpb25hbCBwcm9ncmVzcyBldmVudCBjYWxsYmFja1xuICogQHBhcmFtIHtNZXNzYWdlQ2FsbGJhY2t9IFthcmdzLm9uTWVzc2FnZV0gLSBvcHRpb25hbCBtZXNzYWdlIGV2ZW50IGNhbGxiYWNrXG4gKiBAcGFyYW0ge0F1dGhDYWxsYmFja30gW2FyZ3Mub25BdXRoXSAtIG9wdGlvbmFsIGF1dGggZmlsbCBjYWxsYmFja1xuICogQHBhcmFtIHtBdXRoRmFpbHVyZUNhbGxiYWNrfSBbYXJncy5vbkF1dGhGYWlsdXJlXSAtIG9wdGlvbmFsIGF1dGggcmVqZWN0ZWQgY2FsbGJhY2tcbiAqIEBwYXJhbSB7QXV0aFN1Y2Nlc3NDYWxsYmFja30gW2FyZ3Mub25BdXRoU3VjY2Vzc10gLSBvcHRpb25hbCBhdXRoIGFwcHJvdmVkIGNhbGxiYWNrXG4gKiBAcGFyYW0ge3N0cmluZ30gYXJncy5kaXJdIC0gVGhlIFt3b3JraW5nIHRyZWVdKGRpci12cy1naXRkaXIubWQpIGRpcmVjdG9yeSBwYXRoXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MuZ2l0ZGlyPWpvaW4oZGlyLCcuZ2l0JyldIC0gW3JlcXVpcmVkXSBUaGUgW2dpdCBkaXJlY3RvcnldKGRpci12cy1naXRkaXIubWQpIHBhdGhcbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5yZWZdIC0gV2hpY2ggYnJhbmNoIHRvIG1lcmdlIGludG8uIEJ5IGRlZmF1bHQgdGhpcyBpcyB0aGUgY3VycmVudGx5IGNoZWNrZWQgb3V0IGJyYW5jaC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy51cmxdIC0gKEFkZGVkIGluIDEuMS4wKSBUaGUgVVJMIG9mIHRoZSByZW1vdGUgcmVwb3NpdG9yeS4gVGhlIGRlZmF1bHQgaXMgdGhlIHZhbHVlIHNldCBpbiB0aGUgZ2l0IGNvbmZpZyBmb3IgdGhhdCByZW1vdGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MucmVtb3RlXSAtIChBZGRlZCBpbiAxLjEuMCkgSWYgVVJMIGlzIG5vdCBzcGVjaWZpZWQsIGRldGVybWluZXMgd2hpY2ggcmVtb3RlIHRvIHVzZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5yZW1vdGVSZWZdIC0gKEFkZGVkIGluIDEuMS4wKSBUaGUgbmFtZSBvZiB0aGUgYnJhbmNoIG9uIHRoZSByZW1vdGUgdG8gZmV0Y2guIEJ5IGRlZmF1bHQgdGhpcyBpcyB0aGUgY29uZmlndXJlZCByZW1vdGUgdHJhY2tpbmcgYnJhbmNoLlxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLmNvcnNQcm94eV0gLSBPcHRpb25hbCBbQ09SUyBwcm94eV0oaHR0cHM6Ly93d3cubnBtanMuY29tLyU0MGlzb21vcnBoaWMtZ2l0L2NvcnMtcHJveHkpLiBPdmVycmlkZXMgdmFsdWUgaW4gcmVwbyBjb25maWcuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFthcmdzLnNpbmdsZUJyYW5jaCA9IGZhbHNlXSAtIEluc3RlYWQgb2YgdGhlIGRlZmF1bHQgYmVoYXZpb3Igb2YgZmV0Y2hpbmcgYWxsIHRoZSBicmFuY2hlcywgb25seSBmZXRjaCBhIHNpbmdsZSBicmFuY2guXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFthcmdzLmZhc3RGb3J3YXJkT25seSA9IGZhbHNlXSAtIE9ubHkgcGVyZm9ybSBzaW1wbGUgZmFzdC1mb3J3YXJkIG1lcmdlcy4gKERvbid0IGNyZWF0ZSBtZXJnZSBjb21taXRzLilcbiAqIEBwYXJhbSB7T2JqZWN0PHN0cmluZywgc3RyaW5nPn0gW2FyZ3MuaGVhZGVyc10gLSBBZGRpdGlvbmFsIGhlYWRlcnMgdG8gaW5jbHVkZSBpbiBIVFRQIHJlcXVlc3RzLCBzaW1pbGFyIHRvIGdpdCdzIGBleHRyYUhlYWRlcmAgY29uZmlnXG4gKiBAcGFyYW0ge09iamVjdH0gW2FyZ3MuYXV0aG9yXSAtIFRoZSBkZXRhaWxzIGFib3V0IHRoZSBhdXRob3IuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MuYXV0aG9yLm5hbWVdIC0gRGVmYXVsdCBpcyBgdXNlci5uYW1lYCBjb25maWcuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MuYXV0aG9yLmVtYWlsXSAtIERlZmF1bHQgaXMgYHVzZXIuZW1haWxgIGNvbmZpZy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbYXJncy5hdXRob3IudGltZXN0YW1wPU1hdGguZmxvb3IoRGF0ZS5ub3coKS8xMDAwKV0gLSBTZXQgdGhlIGF1dGhvciB0aW1lc3RhbXAgZmllbGQuIFRoaXMgaXMgdGhlIGludGVnZXIgbnVtYmVyIG9mIHNlY29uZHMgc2luY2UgdGhlIFVuaXggZXBvY2ggKDE5NzAtMDEtMDEgMDA6MDA6MDApLlxuICogQHBhcmFtIHtudW1iZXJ9IFthcmdzLmF1dGhvci50aW1lem9uZU9mZnNldF0gLSBTZXQgdGhlIGF1dGhvciB0aW1lem9uZSBvZmZzZXQgZmllbGQuIFRoaXMgaXMgdGhlIGRpZmZlcmVuY2UsIGluIG1pbnV0ZXMsIGZyb20gdGhlIGN1cnJlbnQgdGltZXpvbmUgdG8gVVRDLiBEZWZhdWx0IGlzIGAobmV3IERhdGUoKSkuZ2V0VGltZXpvbmVPZmZzZXQoKWAuXG4gKiBAcGFyYW0ge09iamVjdH0gW2FyZ3MuY29tbWl0dGVyID0gYXV0aG9yXSAtIFRoZSBkZXRhaWxzIGFib3V0IHRoZSBjb21taXQgY29tbWl0dGVyLCBpbiB0aGUgc2FtZSBmb3JtYXQgYXMgdGhlIGF1dGhvciBwYXJhbWV0ZXIuIElmIG5vdCBzcGVjaWZpZWQsIHRoZSBhdXRob3IgZGV0YWlscyBhcmUgdXNlZC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5jb21taXR0ZXIubmFtZV0gLSBEZWZhdWx0IGlzIGB1c2VyLm5hbWVgIGNvbmZpZy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5jb21taXR0ZXIuZW1haWxdIC0gRGVmYXVsdCBpcyBgdXNlci5lbWFpbGAgY29uZmlnLlxuICogQHBhcmFtIHtudW1iZXJ9IFthcmdzLmNvbW1pdHRlci50aW1lc3RhbXA9TWF0aC5mbG9vcihEYXRlLm5vdygpLzEwMDApXSAtIFNldCB0aGUgY29tbWl0dGVyIHRpbWVzdGFtcCBmaWVsZC4gVGhpcyBpcyB0aGUgaW50ZWdlciBudW1iZXIgb2Ygc2Vjb25kcyBzaW5jZSB0aGUgVW5peCBlcG9jaCAoMTk3MC0wMS0wMSAwMDowMDowMCkuXG4gKiBAcGFyYW0ge251bWJlcn0gW2FyZ3MuY29tbWl0dGVyLnRpbWV6b25lT2Zmc2V0XSAtIFNldCB0aGUgY29tbWl0dGVyIHRpbWV6b25lIG9mZnNldCBmaWVsZC4gVGhpcyBpcyB0aGUgZGlmZmVyZW5jZSwgaW4gbWludXRlcywgZnJvbSB0aGUgY3VycmVudCB0aW1lem9uZSB0byBVVEMuIERlZmF1bHQgaXMgYChuZXcgRGF0ZSgpKS5nZXRUaW1lem9uZU9mZnNldCgpYC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5zaWduaW5nS2V5XSAtIHBhc3NlZCB0byBbY29tbWl0XShjb21taXQubWQpIHdoZW4gY3JlYXRpbmcgYSBtZXJnZSBjb21taXRcbiAqIEBwYXJhbSB7b2JqZWN0fSBbYXJncy5jYWNoZV0gLSBhIFtjYWNoZV0oY2FjaGUubWQpIG9iamVjdFxuICpcbiAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fSBSZXNvbHZlcyBzdWNjZXNzZnVsbHkgd2hlbiBwdWxsIG9wZXJhdGlvbiBjb21wbGV0ZXNcbiAqXG4gKiBAZXhhbXBsZVxuICogYXdhaXQgZ2l0LnB1bGwoe1xuICogICBmcyxcbiAqICAgaHR0cCxcbiAqICAgZGlyOiAnL3R1dG9yaWFsJyxcbiAqICAgcmVmOiAnbWFpbicsXG4gKiAgIHNpbmdsZUJyYW5jaDogdHJ1ZVxuICogfSlcbiAqIGNvbnNvbGUubG9nKCdkb25lJylcbiAqXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHB1bGwoe1xuICBmczogX2ZzLFxuICBodHRwLFxuICBvblByb2dyZXNzLFxuICBvbk1lc3NhZ2UsXG4gIG9uQXV0aCxcbiAgb25BdXRoU3VjY2VzcyxcbiAgb25BdXRoRmFpbHVyZSxcbiAgZGlyLFxuICBnaXRkaXIgPSBqb2luKGRpciwgJy5naXQnKSxcbiAgcmVmLFxuICB1cmwsXG4gIHJlbW90ZSxcbiAgcmVtb3RlUmVmLFxuICBmYXN0Rm9yd2FyZE9ubHkgPSBmYWxzZSxcbiAgY29yc1Byb3h5LFxuICBzaW5nbGVCcmFuY2gsXG4gIGhlYWRlcnMgPSB7fSxcbiAgYXV0aG9yOiBfYXV0aG9yLFxuICBjb21taXR0ZXI6IF9jb21taXR0ZXIsXG4gIHNpZ25pbmdLZXksXG4gIGNhY2hlID0ge30sXG59KSB7XG4gIHRyeSB7XG4gICAgYXNzZXJ0UGFyYW1ldGVyKCdmcycsIF9mcyk7XG4gICAgYXNzZXJ0UGFyYW1ldGVyKCdnaXRkaXInLCBnaXRkaXIpO1xuXG4gICAgY29uc3QgZnMgPSBuZXcgRmlsZVN5c3RlbShfZnMpO1xuXG4gICAgY29uc3QgYXV0aG9yID0gYXdhaXQgbm9ybWFsaXplQXV0aG9yT2JqZWN0KHsgZnMsIGdpdGRpciwgYXV0aG9yOiBfYXV0aG9yIH0pO1xuICAgIGlmICghYXV0aG9yKSB0aHJvdyBuZXcgTWlzc2luZ05hbWVFcnJvcignYXV0aG9yJylcblxuICAgIGNvbnN0IGNvbW1pdHRlciA9IGF3YWl0IG5vcm1hbGl6ZUNvbW1pdHRlck9iamVjdCh7XG4gICAgICBmcyxcbiAgICAgIGdpdGRpcixcbiAgICAgIGF1dGhvcixcbiAgICAgIGNvbW1pdHRlcjogX2NvbW1pdHRlcixcbiAgICB9KTtcbiAgICBpZiAoIWNvbW1pdHRlcikgdGhyb3cgbmV3IE1pc3NpbmdOYW1lRXJyb3IoJ2NvbW1pdHRlcicpXG5cbiAgICByZXR1cm4gYXdhaXQgX3B1bGwoe1xuICAgICAgZnMsXG4gICAgICBjYWNoZSxcbiAgICAgIGh0dHAsXG4gICAgICBvblByb2dyZXNzLFxuICAgICAgb25NZXNzYWdlLFxuICAgICAgb25BdXRoLFxuICAgICAgb25BdXRoU3VjY2VzcyxcbiAgICAgIG9uQXV0aEZhaWx1cmUsXG4gICAgICBkaXIsXG4gICAgICBnaXRkaXIsXG4gICAgICByZWYsXG4gICAgICB1cmwsXG4gICAgICByZW1vdGUsXG4gICAgICByZW1vdGVSZWYsXG4gICAgICBmYXN0Rm9yd2FyZE9ubHksXG4gICAgICBjb3JzUHJveHksXG4gICAgICBzaW5nbGVCcmFuY2gsXG4gICAgICBoZWFkZXJzLFxuICAgICAgYXV0aG9yLFxuICAgICAgY29tbWl0dGVyLFxuICAgICAgc2lnbmluZ0tleSxcbiAgICB9KVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBlcnIuY2FsbGVyID0gJ2dpdC5wdWxsJztcbiAgICB0aHJvdyBlcnJcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBhcmdzXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vbW9kZWxzL0ZpbGVTeXN0ZW0uanMnKS5GaWxlU3lzdGVtfSBhcmdzLmZzXG4gKiBAcGFyYW0ge2FueX0gYXJncy5jYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLmRpcl1cbiAqIEBwYXJhbSB7c3RyaW5nfSBhcmdzLmdpdGRpclxuICogQHBhcmFtIHtJdGVyYWJsZTxzdHJpbmc+fSBhcmdzLnN0YXJ0XG4gKiBAcGFyYW0ge0l0ZXJhYmxlPHN0cmluZz59IGFyZ3MuZmluaXNoXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxTZXQ8c3RyaW5nPj59XG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGxpc3RDb21taXRzQW5kVGFncyh7XG4gIGZzLFxuICBjYWNoZSxcbiAgZGlyLFxuICBnaXRkaXIgPSBqb2luKGRpciwgJy5naXQnKSxcbiAgc3RhcnQsXG4gIGZpbmlzaCxcbn0pIHtcbiAgY29uc3Qgc2hhbGxvd3MgPSBhd2FpdCBHaXRTaGFsbG93TWFuYWdlci5yZWFkKHsgZnMsIGdpdGRpciB9KTtcbiAgY29uc3Qgc3RhcnRpbmdTZXQgPSBuZXcgU2V0KCk7XG4gIGNvbnN0IGZpbmlzaGluZ1NldCA9IG5ldyBTZXQoKTtcbiAgZm9yIChjb25zdCByZWYgb2Ygc3RhcnQpIHtcbiAgICBzdGFydGluZ1NldC5hZGQoYXdhaXQgR2l0UmVmTWFuYWdlci5yZXNvbHZlKHsgZnMsIGdpdGRpciwgcmVmIH0pKTtcbiAgfVxuICBmb3IgKGNvbnN0IHJlZiBvZiBmaW5pc2gpIHtcbiAgICAvLyBXZSBtYXkgbm90IGhhdmUgdGhlc2UgcmVmcyBsb2NhbGx5IHNvIHdlIG11c3QgdHJ5L2NhdGNoXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IG9pZCA9IGF3YWl0IEdpdFJlZk1hbmFnZXIucmVzb2x2ZSh7IGZzLCBnaXRkaXIsIHJlZiB9KTtcbiAgICAgIGZpbmlzaGluZ1NldC5hZGQob2lkKTtcbiAgICB9IGNhdGNoIChlcnIpIHt9XG4gIH1cbiAgY29uc3QgdmlzaXRlZCA9IG5ldyBTZXQoKTtcbiAgLy8gQmVjYXVzZSBnaXQgY29tbWl0cyBhcmUgbmFtZWQgYnkgdGhlaXIgaGFzaCwgdGhlcmUgaXMgbm9cbiAgLy8gd2F5IHRvIGNvbnN0cnVjdCBhIGN5Y2xlLiBUaGVyZWZvcmUgd2Ugd29uJ3Qgd29ycnkgYWJvdXRcbiAgLy8gc2V0dGluZyBhIGRlZmF1bHQgcmVjdXJzaW9uIGxpbWl0LlxuICBhc3luYyBmdW5jdGlvbiB3YWxrKG9pZCkge1xuICAgIHZpc2l0ZWQuYWRkKG9pZCk7XG4gICAgY29uc3QgeyB0eXBlLCBvYmplY3QgfSA9IGF3YWl0IF9yZWFkT2JqZWN0KHsgZnMsIGNhY2hlLCBnaXRkaXIsIG9pZCB9KTtcbiAgICAvLyBSZWN1cnNpdmVseSByZXNvbHZlIGFubm90YXRlZCB0YWdzXG4gICAgaWYgKHR5cGUgPT09ICd0YWcnKSB7XG4gICAgICBjb25zdCB0YWcgPSBHaXRBbm5vdGF0ZWRUYWcuZnJvbShvYmplY3QpO1xuICAgICAgY29uc3QgY29tbWl0ID0gdGFnLmhlYWRlcnMoKS5vYmplY3Q7XG4gICAgICByZXR1cm4gd2Fsayhjb21taXQpXG4gICAgfVxuICAgIGlmICh0eXBlICE9PSAnY29tbWl0Jykge1xuICAgICAgdGhyb3cgbmV3IE9iamVjdFR5cGVFcnJvcihvaWQsIHR5cGUsICdjb21taXQnKVxuICAgIH1cbiAgICBpZiAoIXNoYWxsb3dzLmhhcyhvaWQpKSB7XG4gICAgICBjb25zdCBjb21taXQgPSBHaXRDb21taXQuZnJvbShvYmplY3QpO1xuICAgICAgY29uc3QgcGFyZW50cyA9IGNvbW1pdC5oZWFkZXJzKCkucGFyZW50O1xuICAgICAgZm9yIChvaWQgb2YgcGFyZW50cykge1xuICAgICAgICBpZiAoIWZpbmlzaGluZ1NldC5oYXMob2lkKSAmJiAhdmlzaXRlZC5oYXMob2lkKSkge1xuICAgICAgICAgIGF3YWl0IHdhbGsob2lkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICAvLyBMZXQncyBnbyB3YWxraW5nIVxuICBmb3IgKGNvbnN0IG9pZCBvZiBzdGFydGluZ1NldCkge1xuICAgIGF3YWl0IHdhbGsob2lkKTtcbiAgfVxuICByZXR1cm4gdmlzaXRlZFxufVxuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBhcmdzXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vbW9kZWxzL0ZpbGVTeXN0ZW0uanMnKS5GaWxlU3lzdGVtfSBhcmdzLmZzXG4gKiBAcGFyYW0ge2FueX0gYXJncy5jYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLmRpcl1cbiAqIEBwYXJhbSB7c3RyaW5nfSBhcmdzLmdpdGRpclxuICogQHBhcmFtIHtJdGVyYWJsZTxzdHJpbmc+fSBhcmdzLm9pZHNcbiAqIEByZXR1cm5zIHtQcm9taXNlPFNldDxzdHJpbmc+Pn1cbiAqL1xuYXN5bmMgZnVuY3Rpb24gbGlzdE9iamVjdHMoe1xuICBmcyxcbiAgY2FjaGUsXG4gIGRpcixcbiAgZ2l0ZGlyID0gam9pbihkaXIsICcuZ2l0JyksXG4gIG9pZHMsXG59KSB7XG4gIGNvbnN0IHZpc2l0ZWQgPSBuZXcgU2V0KCk7XG4gIC8vIFdlIGRvbid0IGRvIHRoZSBwdXJlc3Qgc2ltcGxlc3QgcmVjdXJzaW9uLCBiZWNhdXNlIHdlIGNhblxuICAvLyBhdm9pZCByZWFkaW5nIEJsb2Igb2JqZWN0cyBlbnRpcmVseSBzaW5jZSB0aGUgVHJlZSBvYmplY3RzXG4gIC8vIHRlbGwgdXMgd2hpY2ggb2lkcyBhcmUgQmxvYnMgYW5kIHdoaWNoIGFyZSBUcmVlcy5cbiAgYXN5bmMgZnVuY3Rpb24gd2FsayhvaWQpIHtcbiAgICBpZiAodmlzaXRlZC5oYXMob2lkKSkgcmV0dXJuXG4gICAgdmlzaXRlZC5hZGQob2lkKTtcbiAgICBjb25zdCB7IHR5cGUsIG9iamVjdCB9ID0gYXdhaXQgX3JlYWRPYmplY3QoeyBmcywgY2FjaGUsIGdpdGRpciwgb2lkIH0pO1xuICAgIGlmICh0eXBlID09PSAndGFnJykge1xuICAgICAgY29uc3QgdGFnID0gR2l0QW5ub3RhdGVkVGFnLmZyb20ob2JqZWN0KTtcbiAgICAgIGNvbnN0IG9iaiA9IHRhZy5oZWFkZXJzKCkub2JqZWN0O1xuICAgICAgYXdhaXQgd2FsayhvYmopO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2NvbW1pdCcpIHtcbiAgICAgIGNvbnN0IGNvbW1pdCA9IEdpdENvbW1pdC5mcm9tKG9iamVjdCk7XG4gICAgICBjb25zdCB0cmVlID0gY29tbWl0LmhlYWRlcnMoKS50cmVlO1xuICAgICAgYXdhaXQgd2Fsayh0cmVlKTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICd0cmVlJykge1xuICAgICAgY29uc3QgdHJlZSA9IEdpdFRyZWUuZnJvbShvYmplY3QpO1xuICAgICAgZm9yIChjb25zdCBlbnRyeSBvZiB0cmVlKSB7XG4gICAgICAgIC8vIGFkZCBibG9icyB0byB0aGUgc2V0XG4gICAgICAgIC8vIHNraXAgb3ZlciBzdWJtb2R1bGVzIHdob3NlIHR5cGUgaXMgJ2NvbW1pdCdcbiAgICAgICAgaWYgKGVudHJ5LnR5cGUgPT09ICdibG9iJykge1xuICAgICAgICAgIHZpc2l0ZWQuYWRkKGVudHJ5Lm9pZCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVjdXJzZSBmb3IgdHJlZXNcbiAgICAgICAgaWYgKGVudHJ5LnR5cGUgPT09ICd0cmVlJykge1xuICAgICAgICAgIGF3YWl0IHdhbGsoZW50cnkub2lkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICAvLyBMZXQncyBnbyB3YWxraW5nIVxuICBmb3IgKGNvbnN0IG9pZCBvZiBvaWRzKSB7XG4gICAgYXdhaXQgd2FsayhvaWQpO1xuICB9XG4gIHJldHVybiB2aXNpdGVkXG59XG5cbmFzeW5jIGZ1bmN0aW9uIHBhcnNlUmVjZWl2ZVBhY2tSZXNwb25zZShwYWNrZmlsZSkge1xuICAvKiogQHR5cGUgUHVzaFJlc3VsdCAqL1xuICBjb25zdCByZXN1bHQgPSB7fTtcbiAgbGV0IHJlc3BvbnNlID0gJyc7XG4gIGNvbnN0IHJlYWQgPSBHaXRQa3RMaW5lLnN0cmVhbVJlYWRlcihwYWNrZmlsZSk7XG4gIGxldCBsaW5lID0gYXdhaXQgcmVhZCgpO1xuICB3aGlsZSAobGluZSAhPT0gdHJ1ZSkge1xuICAgIGlmIChsaW5lICE9PSBudWxsKSByZXNwb25zZSArPSBsaW5lLnRvU3RyaW5nKCd1dGY4JykgKyAnXFxuJztcbiAgICBsaW5lID0gYXdhaXQgcmVhZCgpO1xuICB9XG5cbiAgY29uc3QgbGluZXMgPSByZXNwb25zZS50b1N0cmluZygndXRmOCcpLnNwbGl0KCdcXG4nKTtcbiAgLy8gV2UncmUgZXhwZWN0aW5nIFwidW5wYWNrIHt1bnBhY2stcmVzdWx0fVwiXG4gIGxpbmUgPSBsaW5lcy5zaGlmdCgpO1xuICBpZiAoIWxpbmUuc3RhcnRzV2l0aCgndW5wYWNrICcpKSB7XG4gICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoJ3VucGFjayBva1wiIG9yIFwidW5wYWNrIFtlcnJvciBtZXNzYWdlXScsIGxpbmUpXG4gIH1cbiAgcmVzdWx0Lm9rID0gbGluZSA9PT0gJ3VucGFjayBvayc7XG4gIGlmICghcmVzdWx0Lm9rKSB7XG4gICAgcmVzdWx0LmVycm9yID0gbGluZS5zbGljZSgndW5wYWNrICcubGVuZ3RoKTtcbiAgfVxuICByZXN1bHQucmVmcyA9IHt9O1xuICBmb3IgKGNvbnN0IGxpbmUgb2YgbGluZXMpIHtcbiAgICBpZiAobGluZS50cmltKCkgPT09ICcnKSBjb250aW51ZVxuICAgIGNvbnN0IHN0YXR1cyA9IGxpbmUuc2xpY2UoMCwgMik7XG4gICAgY29uc3QgcmVmQW5kTWVzc2FnZSA9IGxpbmUuc2xpY2UoMyk7XG4gICAgbGV0IHNwYWNlID0gcmVmQW5kTWVzc2FnZS5pbmRleE9mKCcgJyk7XG4gICAgaWYgKHNwYWNlID09PSAtMSkgc3BhY2UgPSByZWZBbmRNZXNzYWdlLmxlbmd0aDtcbiAgICBjb25zdCByZWYgPSByZWZBbmRNZXNzYWdlLnNsaWNlKDAsIHNwYWNlKTtcbiAgICBjb25zdCBlcnJvciA9IHJlZkFuZE1lc3NhZ2Uuc2xpY2Uoc3BhY2UgKyAxKTtcbiAgICByZXN1bHQucmVmc1tyZWZdID0ge1xuICAgICAgb2s6IHN0YXR1cyA9PT0gJ29rJyxcbiAgICAgIGVycm9yLFxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5hc3luYyBmdW5jdGlvbiB3cml0ZVJlY2VpdmVQYWNrUmVxdWVzdCh7XG4gIGNhcGFiaWxpdGllcyA9IFtdLFxuICB0cmlwbGV0cyA9IFtdLFxufSkge1xuICBjb25zdCBwYWNrc3RyZWFtID0gW107XG4gIGxldCBjYXBzRmlyc3RMaW5lID0gYFxceDAwICR7Y2FwYWJpbGl0aWVzLmpvaW4oJyAnKX1gO1xuICBmb3IgKGNvbnN0IHRyaXAgb2YgdHJpcGxldHMpIHtcbiAgICBwYWNrc3RyZWFtLnB1c2goXG4gICAgICBHaXRQa3RMaW5lLmVuY29kZShcbiAgICAgICAgYCR7dHJpcC5vbGRvaWR9ICR7dHJpcC5vaWR9ICR7dHJpcC5mdWxsUmVmfSR7Y2Fwc0ZpcnN0TGluZX1cXG5gXG4gICAgICApXG4gICAgKTtcbiAgICBjYXBzRmlyc3RMaW5lID0gJyc7XG4gIH1cbiAgcGFja3N0cmVhbS5wdXNoKEdpdFBrdExpbmUuZmx1c2goKSk7XG4gIHJldHVybiBwYWNrc3RyZWFtXG59XG5cbi8vIEB0cy1jaGVja1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBhcmdzXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vbW9kZWxzL0ZpbGVTeXN0ZW0uanMnKS5GaWxlU3lzdGVtfSBhcmdzLmZzXG4gKiBAcGFyYW0ge2FueX0gYXJncy5jYWNoZVxuICogQHBhcmFtIHtIdHRwQ2xpZW50fSBhcmdzLmh0dHBcbiAqIEBwYXJhbSB7UHJvZ3Jlc3NDYWxsYmFja30gW2FyZ3Mub25Qcm9ncmVzc11cbiAqIEBwYXJhbSB7TWVzc2FnZUNhbGxiYWNrfSBbYXJncy5vbk1lc3NhZ2VdXG4gKiBAcGFyYW0ge0F1dGhDYWxsYmFja30gW2FyZ3Mub25BdXRoXVxuICogQHBhcmFtIHtBdXRoRmFpbHVyZUNhbGxiYWNrfSBbYXJncy5vbkF1dGhGYWlsdXJlXVxuICogQHBhcmFtIHtBdXRoU3VjY2Vzc0NhbGxiYWNrfSBbYXJncy5vbkF1dGhTdWNjZXNzXVxuICogQHBhcmFtIHtzdHJpbmd9IGFyZ3MuZ2l0ZGlyXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MucmVmXVxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLnJlbW90ZVJlZl1cbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5yZW1vdGVdXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFthcmdzLmZvcmNlID0gZmFsc2VdXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFthcmdzLmRlbGV0ZSA9IGZhbHNlXVxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLnVybF1cbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5jb3JzUHJveHldXG4gKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsIHN0cmluZz59IFthcmdzLmhlYWRlcnNdXG4gKlxuICogQHJldHVybnMge1Byb21pc2U8UHVzaFJlc3VsdD59XG4gKi9cbmFzeW5jIGZ1bmN0aW9uIF9wdXNoKHtcbiAgZnMsXG4gIGNhY2hlLFxuICBodHRwLFxuICBvblByb2dyZXNzLFxuICBvbk1lc3NhZ2UsXG4gIG9uQXV0aCxcbiAgb25BdXRoU3VjY2VzcyxcbiAgb25BdXRoRmFpbHVyZSxcbiAgZ2l0ZGlyLFxuICByZWY6IF9yZWYsXG4gIHJlbW90ZVJlZjogX3JlbW90ZVJlZixcbiAgcmVtb3RlLFxuICB1cmw6IF91cmwsXG4gIGZvcmNlID0gZmFsc2UsXG4gIGRlbGV0ZTogX2RlbGV0ZSA9IGZhbHNlLFxuICBjb3JzUHJveHksXG4gIGhlYWRlcnMgPSB7fSxcbn0pIHtcbiAgY29uc3QgcmVmID0gX3JlZiB8fCAoYXdhaXQgX2N1cnJlbnRCcmFuY2goeyBmcywgZ2l0ZGlyIH0pKTtcbiAgaWYgKHR5cGVvZiByZWYgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgdGhyb3cgbmV3IE1pc3NpbmdQYXJhbWV0ZXJFcnJvcigncmVmJylcbiAgfVxuICBjb25zdCBjb25maWcgPSBhd2FpdCBHaXRDb25maWdNYW5hZ2VyLmdldCh7IGZzLCBnaXRkaXIgfSk7XG4gIC8vIEZpZ3VyZSBvdXQgd2hhdCByZW1vdGUgdG8gdXNlLlxuICByZW1vdGUgPVxuICAgIHJlbW90ZSB8fFxuICAgIChhd2FpdCBjb25maWcuZ2V0KGBicmFuY2guJHtyZWZ9LnB1c2hSZW1vdGVgKSkgfHxcbiAgICAoYXdhaXQgY29uZmlnLmdldCgncmVtb3RlLnB1c2hEZWZhdWx0JykpIHx8XG4gICAgKGF3YWl0IGNvbmZpZy5nZXQoYGJyYW5jaC4ke3JlZn0ucmVtb3RlYCkpIHx8XG4gICAgJ29yaWdpbic7XG4gIC8vIExvb2t1cCB0aGUgVVJMIGZvciB0aGUgZ2l2ZW4gcmVtb3RlLlxuICBjb25zdCB1cmwgPVxuICAgIF91cmwgfHxcbiAgICAoYXdhaXQgY29uZmlnLmdldChgcmVtb3RlLiR7cmVtb3RlfS5wdXNodXJsYCkpIHx8XG4gICAgKGF3YWl0IGNvbmZpZy5nZXQoYHJlbW90ZS4ke3JlbW90ZX0udXJsYCkpO1xuICBpZiAodHlwZW9mIHVybCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB0aHJvdyBuZXcgTWlzc2luZ1BhcmFtZXRlckVycm9yKCdyZW1vdGUgT1IgdXJsJylcbiAgfVxuICAvLyBGaWd1cmUgb3V0IHdoYXQgcmVtb3RlIHJlZiB0byB1c2UuXG4gIGNvbnN0IHJlbW90ZVJlZiA9IF9yZW1vdGVSZWYgfHwgKGF3YWl0IGNvbmZpZy5nZXQoYGJyYW5jaC4ke3JlZn0ubWVyZ2VgKSk7XG4gIGlmICh0eXBlb2YgdXJsID09PSAndW5kZWZpbmVkJykge1xuICAgIHRocm93IG5ldyBNaXNzaW5nUGFyYW1ldGVyRXJyb3IoJ3JlbW90ZVJlZicpXG4gIH1cblxuICBpZiAoY29yc1Byb3h5ID09PSB1bmRlZmluZWQpIHtcbiAgICBjb3JzUHJveHkgPSBhd2FpdCBjb25maWcuZ2V0KCdodHRwLmNvcnNQcm94eScpO1xuICB9XG5cbiAgY29uc3QgZnVsbFJlZiA9IGF3YWl0IEdpdFJlZk1hbmFnZXIuZXhwYW5kKHsgZnMsIGdpdGRpciwgcmVmIH0pO1xuICBjb25zdCBvaWQgPSBfZGVsZXRlXG4gICAgPyAnMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCdcbiAgICA6IGF3YWl0IEdpdFJlZk1hbmFnZXIucmVzb2x2ZSh7IGZzLCBnaXRkaXIsIHJlZjogZnVsbFJlZiB9KTtcblxuICAvKiogQHR5cGUgdHlwZW9mIGltcG9ydChcIi4uL21hbmFnZXJzL0dpdFJlbW90ZUhUVFBcIikuR2l0UmVtb3RlSFRUUCAqL1xuICBjb25zdCBHaXRSZW1vdGVIVFRQID0gR2l0UmVtb3RlTWFuYWdlci5nZXRSZW1vdGVIZWxwZXJGb3IoeyB1cmwgfSk7XG4gIGNvbnN0IGh0dHBSZW1vdGUgPSBhd2FpdCBHaXRSZW1vdGVIVFRQLmRpc2NvdmVyKHtcbiAgICBodHRwLFxuICAgIG9uQXV0aCxcbiAgICBvbkF1dGhTdWNjZXNzLFxuICAgIG9uQXV0aEZhaWx1cmUsXG4gICAgY29yc1Byb3h5LFxuICAgIHNlcnZpY2U6ICdnaXQtcmVjZWl2ZS1wYWNrJyxcbiAgICB1cmwsXG4gICAgaGVhZGVycyxcbiAgICBwcm90b2NvbFZlcnNpb246IDEsXG4gIH0pO1xuICBjb25zdCBhdXRoID0gaHR0cFJlbW90ZS5hdXRoOyAvLyBoYWNrIHRvIGdldCBuZXcgY3JlZGVudGlhbHMgZnJvbSBDcmVkZW50aWFsTWFuYWdlciBBUElcbiAgbGV0IGZ1bGxSZW1vdGVSZWY7XG4gIGlmICghcmVtb3RlUmVmKSB7XG4gICAgZnVsbFJlbW90ZVJlZiA9IGZ1bGxSZWY7XG4gIH0gZWxzZSB7XG4gICAgdHJ5IHtcbiAgICAgIGZ1bGxSZW1vdGVSZWYgPSBhd2FpdCBHaXRSZWZNYW5hZ2VyLmV4cGFuZEFnYWluc3RNYXAoe1xuICAgICAgICByZWY6IHJlbW90ZVJlZixcbiAgICAgICAgbWFwOiBodHRwUmVtb3RlLnJlZnMsXG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBOb3RGb3VuZEVycm9yKSB7XG4gICAgICAgIC8vIFRoZSByZW1vdGUgcmVmZXJlbmNlIGRvZXNuJ3QgZXhpc3QgeWV0LlxuICAgICAgICAvLyBJZiBpdCBpcyBmdWxseSBzcGVjaWZpZWQsIHVzZSB0aGF0IHZhbHVlLiBPdGhlcndpc2UsIHRyZWF0IGl0IGFzIGEgYnJhbmNoLlxuICAgICAgICBmdWxsUmVtb3RlUmVmID0gcmVtb3RlUmVmLnN0YXJ0c1dpdGgoJ3JlZnMvJylcbiAgICAgICAgICA/IHJlbW90ZVJlZlxuICAgICAgICAgIDogYHJlZnMvaGVhZHMvJHtyZW1vdGVSZWZ9YDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGVyclxuICAgICAgfVxuICAgIH1cbiAgfVxuICBjb25zdCBvbGRvaWQgPVxuICAgIGh0dHBSZW1vdGUucmVmcy5nZXQoZnVsbFJlbW90ZVJlZikgfHxcbiAgICAnMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCc7XG5cbiAgLy8gUmVtb3RlcyBjYW4gYWx3YXlzIGFjY2VwdCB0aGluLXBhY2tzIFVOTEVTUyB0aGV5IHNwZWNpZnkgdGhlICduby10aGluJyBjYXBhYmlsaXR5XG4gIGNvbnN0IHRoaW5QYWNrID0gIWh0dHBSZW1vdGUuY2FwYWJpbGl0aWVzLmhhcygnbm8tdGhpbicpO1xuXG4gIGxldCBvYmplY3RzID0gbmV3IFNldCgpO1xuICBpZiAoIV9kZWxldGUpIHtcbiAgICBjb25zdCBmaW5pc2ggPSBbLi4uaHR0cFJlbW90ZS5yZWZzLnZhbHVlcygpXTtcbiAgICBsZXQgc2tpcE9iamVjdHMgPSBuZXcgU2V0KCk7XG5cbiAgICAvLyBJZiByZW1vdGUgYnJhbmNoIGlzIHByZXNlbnQsIGxvb2sgZm9yIGEgY29tbW9uIG1lcmdlIGJhc2UuXG4gICAgaWYgKG9sZG9pZCAhPT0gJzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnKSB7XG4gICAgICAvLyB0cmljayB0byBzcGVlZCB1cCBjb21tb24gZm9yY2UgcHVzaCBzY2VuYXJpb3NcbiAgICAgIGNvbnN0IG1lcmdlYmFzZSA9IGF3YWl0IF9maW5kTWVyZ2VCYXNlKHtcbiAgICAgICAgZnMsXG4gICAgICAgIGNhY2hlLFxuICAgICAgICBnaXRkaXIsXG4gICAgICAgIG9pZHM6IFtvaWQsIG9sZG9pZF0sXG4gICAgICB9KTtcbiAgICAgIGZvciAoY29uc3Qgb2lkIG9mIG1lcmdlYmFzZSkgZmluaXNoLnB1c2gob2lkKTtcbiAgICAgIGlmICh0aGluUGFjaykge1xuICAgICAgICBza2lwT2JqZWN0cyA9IGF3YWl0IGxpc3RPYmplY3RzKHsgZnMsIGNhY2hlLCBnaXRkaXIsIG9pZHM6IG1lcmdlYmFzZSB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZiByZW1vdGUgZG9lcyBub3QgaGF2ZSB0aGUgY29tbWl0LCBmaWd1cmUgb3V0IHRoZSBvYmplY3RzIHRvIHNlbmRcbiAgICBpZiAoIWZpbmlzaC5pbmNsdWRlcyhvaWQpKSB7XG4gICAgICBjb25zdCBjb21taXRzID0gYXdhaXQgbGlzdENvbW1pdHNBbmRUYWdzKHtcbiAgICAgICAgZnMsXG4gICAgICAgIGNhY2hlLFxuICAgICAgICBnaXRkaXIsXG4gICAgICAgIHN0YXJ0OiBbb2lkXSxcbiAgICAgICAgZmluaXNoLFxuICAgICAgfSk7XG4gICAgICBvYmplY3RzID0gYXdhaXQgbGlzdE9iamVjdHMoeyBmcywgY2FjaGUsIGdpdGRpciwgb2lkczogY29tbWl0cyB9KTtcbiAgICB9XG5cbiAgICBpZiAodGhpblBhY2spIHtcbiAgICAgIC8vIElmIHRoZXJlJ3MgYSBkZWZhdWx0IGJyYW5jaCBmb3IgdGhlIHJlbW90ZSBsZXRzIHNraXAgdGhvc2Ugb2JqZWN0cyB0b28uXG4gICAgICAvLyBTaW5jZSB0aGlzIGlzIGFuIG9wdGlvbmFsIG9wdGltaXphdGlvbiwgd2UganVzdCBjYXRjaCBhbmQgY29udGludWUgaWYgdGhlcmUgaXNcbiAgICAgIC8vIGFuIGVycm9yIChiZWNhdXNlIHdlIGNhbid0IGZpbmQgYSBkZWZhdWx0IGJyYW5jaCwgb3IgY2FuJ3QgZmluZCBhIGNvbW1pdCwgZXRjKVxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gU2FkbHksIHRoZSBkaXNjb3ZlcnkgcGhhc2Ugd2l0aCAnZm9yUHVzaCcgZG9lc24ndCByZXR1cm4gc3ltcmVmcywgc28gd2UgaGF2ZSB0b1xuICAgICAgICAvLyByZWx5IG9uIGV4aXN0aW5nIG9uZXMuXG4gICAgICAgIGNvbnN0IHJlZiA9IGF3YWl0IEdpdFJlZk1hbmFnZXIucmVzb2x2ZSh7XG4gICAgICAgICAgZnMsXG4gICAgICAgICAgZ2l0ZGlyLFxuICAgICAgICAgIHJlZjogYHJlZnMvcmVtb3Rlcy8ke3JlbW90ZX0vSEVBRGAsXG4gICAgICAgICAgZGVwdGg6IDIsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB7IG9pZCB9ID0gYXdhaXQgR2l0UmVmTWFuYWdlci5yZXNvbHZlQWdhaW5zdE1hcCh7XG4gICAgICAgICAgcmVmOiByZWYucmVwbGFjZShgcmVmcy9yZW1vdGVzLyR7cmVtb3RlfS9gLCAnJyksXG4gICAgICAgICAgZnVsbHJlZjogcmVmLFxuICAgICAgICAgIG1hcDogaHR0cFJlbW90ZS5yZWZzLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3Qgb2lkcyA9IFtvaWRdO1xuICAgICAgICBmb3IgKGNvbnN0IG9pZCBvZiBhd2FpdCBsaXN0T2JqZWN0cyh7IGZzLCBjYWNoZSwgZ2l0ZGlyLCBvaWRzIH0pKSB7XG4gICAgICAgICAgc2tpcE9iamVjdHMuYWRkKG9pZCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHt9XG5cbiAgICAgIC8vIFJlbW92ZSBvYmplY3RzIHRoYXQgd2Uga25vdyB0aGUgcmVtb3RlIGFscmVhZHkgaGFzXG4gICAgICBmb3IgKGNvbnN0IG9pZCBvZiBza2lwT2JqZWN0cykge1xuICAgICAgICBvYmplY3RzLmRlbGV0ZShvaWQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghZm9yY2UpIHtcbiAgICAgIC8vIElzIGl0IGEgdGFnIHRoYXQgYWxyZWFkeSBleGlzdHM/XG4gICAgICBpZiAoXG4gICAgICAgIGZ1bGxSZWYuc3RhcnRzV2l0aCgncmVmcy90YWdzJykgJiZcbiAgICAgICAgb2xkb2lkICE9PSAnMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCdcbiAgICAgICkge1xuICAgICAgICB0aHJvdyBuZXcgUHVzaFJlamVjdGVkRXJyb3IoJ3RhZy1leGlzdHMnKVxuICAgICAgfVxuICAgICAgLy8gSXMgaXQgYSBub24tZmFzdC1mb3J3YXJkIGNvbW1pdD9cbiAgICAgIGlmIChcbiAgICAgICAgb2lkICE9PSAnMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcgJiZcbiAgICAgICAgb2xkb2lkICE9PSAnMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcgJiZcbiAgICAgICAgIShhd2FpdCBfaXNEZXNjZW5kZW50KHtcbiAgICAgICAgICBmcyxcbiAgICAgICAgICBjYWNoZSxcbiAgICAgICAgICBnaXRkaXIsXG4gICAgICAgICAgb2lkLFxuICAgICAgICAgIGFuY2VzdG9yOiBvbGRvaWQsXG4gICAgICAgICAgZGVwdGg6IC0xLFxuICAgICAgICB9KSlcbiAgICAgICkge1xuICAgICAgICB0aHJvdyBuZXcgUHVzaFJlamVjdGVkRXJyb3IoJ25vdC1mYXN0LWZvcndhcmQnKVxuICAgICAgfVxuICAgIH1cbiAgfVxuICAvLyBXZSBjYW4gb25seSBzYWZlbHkgdXNlIGNhcGFiaWxpdGllcyB0aGF0IHRoZSBzZXJ2ZXIgYWxzbyB1bmRlcnN0YW5kcy5cbiAgLy8gRm9yIGluc3RhbmNlLCBBV1MgQ29kZUNvbW1pdCBhYm9ydHMgYSBwdXNoIGlmIHlvdSBpbmNsdWRlIHRoZSBgYWdlbnRgISEhXG4gIGNvbnN0IGNhcGFiaWxpdGllcyA9IGZpbHRlckNhcGFiaWxpdGllcyhcbiAgICBbLi4uaHR0cFJlbW90ZS5jYXBhYmlsaXRpZXNdLFxuICAgIFsncmVwb3J0LXN0YXR1cycsICdzaWRlLWJhbmQtNjRrJywgYGFnZW50PSR7cGtnLmFnZW50fWBdXG4gICk7XG4gIGNvbnN0IHBhY2tzdHJlYW0xID0gYXdhaXQgd3JpdGVSZWNlaXZlUGFja1JlcXVlc3Qoe1xuICAgIGNhcGFiaWxpdGllcyxcbiAgICB0cmlwbGV0czogW3sgb2xkb2lkLCBvaWQsIGZ1bGxSZWY6IGZ1bGxSZW1vdGVSZWYgfV0sXG4gIH0pO1xuICBjb25zdCBwYWNrc3RyZWFtMiA9IF9kZWxldGVcbiAgICA/IFtdXG4gICAgOiBhd2FpdCBfcGFjayh7XG4gICAgICAgIGZzLFxuICAgICAgICBjYWNoZSxcbiAgICAgICAgZ2l0ZGlyLFxuICAgICAgICBvaWRzOiBbLi4ub2JqZWN0c10sXG4gICAgICB9KTtcbiAgY29uc3QgcmVzID0gYXdhaXQgR2l0UmVtb3RlSFRUUC5jb25uZWN0KHtcbiAgICBodHRwLFxuICAgIG9uUHJvZ3Jlc3MsXG4gICAgY29yc1Byb3h5LFxuICAgIHNlcnZpY2U6ICdnaXQtcmVjZWl2ZS1wYWNrJyxcbiAgICB1cmwsXG4gICAgYXV0aCxcbiAgICBoZWFkZXJzLFxuICAgIGJvZHk6IFsuLi5wYWNrc3RyZWFtMSwgLi4ucGFja3N0cmVhbTJdLFxuICB9KTtcbiAgY29uc3QgeyBwYWNrZmlsZSwgcHJvZ3Jlc3MgfSA9IGF3YWl0IEdpdFNpZGVCYW5kLmRlbXV4KHJlcy5ib2R5KTtcbiAgaWYgKG9uTWVzc2FnZSkge1xuICAgIGNvbnN0IGxpbmVzID0gc3BsaXRMaW5lcyhwcm9ncmVzcyk7XG4gICAgZm9yQXdhaXQobGluZXMsIGFzeW5jIGxpbmUgPT4ge1xuICAgICAgYXdhaXQgb25NZXNzYWdlKGxpbmUpO1xuICAgIH0pO1xuICB9XG4gIC8vIFBhcnNlIHRoZSByZXNwb25zZSFcbiAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcGFyc2VSZWNlaXZlUGFja1Jlc3BvbnNlKHBhY2tmaWxlKTtcbiAgaWYgKHJlcy5oZWFkZXJzKSB7XG4gICAgcmVzdWx0LmhlYWRlcnMgPSByZXMuaGVhZGVycztcbiAgfVxuXG4gIC8vIFVwZGF0ZSB0aGUgbG9jYWwgY29weSBvZiB0aGUgcmVtb3RlIHJlZlxuICBpZiAocmVtb3RlICYmIHJlc3VsdC5vayAmJiByZXN1bHQucmVmc1tmdWxsUmVtb3RlUmVmXS5vaykge1xuICAgIC8vIFRPRE86IEkgdGhpbmsgdGhpcyBzaG91bGQgYWN0dWFsbHkgYmUgdXNpbmcgYSByZWZzcGVjIHRyYW5zZm9ybSByYXRoZXIgdGhhbiBhc3N1bWluZyAncmVmcy9yZW1vdGVzL3tyZW1vdGV9J1xuICAgIGNvbnN0IHJlZiA9IGByZWZzL3JlbW90ZXMvJHtyZW1vdGV9LyR7ZnVsbFJlbW90ZVJlZi5yZXBsYWNlKFxuICAgICAgJ3JlZnMvaGVhZHMnLFxuICAgICAgJydcbiAgICApfWA7XG4gICAgaWYgKF9kZWxldGUpIHtcbiAgICAgIGF3YWl0IEdpdFJlZk1hbmFnZXIuZGVsZXRlUmVmKHsgZnMsIGdpdGRpciwgcmVmIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBhd2FpdCBHaXRSZWZNYW5hZ2VyLndyaXRlUmVmKHsgZnMsIGdpdGRpciwgcmVmLCB2YWx1ZTogb2lkIH0pO1xuICAgIH1cbiAgfVxuICBpZiAocmVzdWx0Lm9rICYmIE9iamVjdC52YWx1ZXMocmVzdWx0LnJlZnMpLmV2ZXJ5KHJlc3VsdCA9PiByZXN1bHQub2spKSB7XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9IGVsc2Uge1xuICAgIGNvbnN0IHByZXR0eURldGFpbHMgPSBPYmplY3QuZW50cmllcyhyZXN1bHQucmVmcylcbiAgICAgIC5maWx0ZXIoKFtrLCB2XSkgPT4gIXYub2spXG4gICAgICAubWFwKChbaywgdl0pID0+IGBcXG4gIC0gJHtrfTogJHt2LmVycm9yfWApXG4gICAgICAuam9pbignJyk7XG4gICAgdGhyb3cgbmV3IEdpdFB1c2hFcnJvcihwcmV0dHlEZXRhaWxzLCByZXN1bHQpXG4gIH1cbn1cblxuLy8gQHRzLWNoZWNrXG5cbi8qKlxuICogUHVzaCBhIGJyYW5jaCBvciB0YWdcbiAqXG4gKiBUaGUgcHVzaCBjb21tYW5kIHJldHVybnMgYW4gb2JqZWN0IHRoYXQgZGVzY3JpYmVzIHRoZSByZXN1bHQgb2YgdGhlIGF0dGVtcHRlZCBwdXNoIG9wZXJhdGlvbi5cbiAqICpOb3RlczoqIElmIHRoZXJlIHdlcmUgbm8gZXJyb3JzLCB0aGVuIHRoZXJlIHdpbGwgYmUgbm8gYGVycm9yc2AgcHJvcGVydHkuIFRoZXJlIGNhbiBiZSBhIG1peCBvZiBgb2tgIG1lc3NhZ2VzIGFuZCBgZXJyb3JzYCBtZXNzYWdlcy5cbiAqXG4gKiB8IHBhcmFtICB8IHR5cGUgWz0gZGVmYXVsdF0gfCBkZXNjcmlwdGlvbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgLS0tLS0tIHwgLS0tLS0tLS0tLS0tLS0tLSB8IC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gfFxuICogfCBvayAgICAgfCBBcnJheVxcPHN0cmluZ1xcPiAgfCBUaGUgZmlyc3QgaXRlbSBpcyBcInVucGFja1wiIGlmIHRoZSBvdmVyYWxsIG9wZXJhdGlvbiB3YXMgc3VjY2Vzc2Z1bC4gVGhlIHJlbWFpbmluZyBpdGVtcyBhcmUgdGhlIG5hbWVzIG9mIHJlZnMgdGhhdCB3ZXJlIHVwZGF0ZWQgc3VjY2Vzc2Z1bGx5LiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogfCBlcnJvcnMgfCBBcnJheVxcPHN0cmluZ1xcPiAgfCBJZiB0aGUgb3ZlcmFsbCBvcGVyYXRpb24gdGhyZXcgYW5kIGVycm9yLCB0aGUgZmlyc3QgaXRlbSB3aWxsIGJlIFwidW5wYWNrIHtPdmVyYWxsIGVycm9yIG1lc3NhZ2V9XCIuIFRoZSByZW1haW5pbmcgaXRlbXMgYXJlIGluZGl2aWR1YWwgcmVmcyB0aGF0IGZhaWxlZCB0byBiZSB1cGRhdGVkIGluIHRoZSBmb3JtYXQgXCJ7cmVmIG5hbWV9IHtlcnJvciBtZXNzYWdlfVwiLiB8XG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGFyZ3NcbiAqIEBwYXJhbSB7RnNDbGllbnR9IGFyZ3MuZnMgLSBhIGZpbGUgc3lzdGVtIGNsaWVudFxuICogQHBhcmFtIHtIdHRwQ2xpZW50fSBhcmdzLmh0dHAgLSBhbiBIVFRQIGNsaWVudFxuICogQHBhcmFtIHtQcm9ncmVzc0NhbGxiYWNrfSBbYXJncy5vblByb2dyZXNzXSAtIG9wdGlvbmFsIHByb2dyZXNzIGV2ZW50IGNhbGxiYWNrXG4gKiBAcGFyYW0ge01lc3NhZ2VDYWxsYmFja30gW2FyZ3Mub25NZXNzYWdlXSAtIG9wdGlvbmFsIG1lc3NhZ2UgZXZlbnQgY2FsbGJhY2tcbiAqIEBwYXJhbSB7QXV0aENhbGxiYWNrfSBbYXJncy5vbkF1dGhdIC0gb3B0aW9uYWwgYXV0aCBmaWxsIGNhbGxiYWNrXG4gKiBAcGFyYW0ge0F1dGhGYWlsdXJlQ2FsbGJhY2t9IFthcmdzLm9uQXV0aEZhaWx1cmVdIC0gb3B0aW9uYWwgYXV0aCByZWplY3RlZCBjYWxsYmFja1xuICogQHBhcmFtIHtBdXRoU3VjY2Vzc0NhbGxiYWNrfSBbYXJncy5vbkF1dGhTdWNjZXNzXSAtIG9wdGlvbmFsIGF1dGggYXBwcm92ZWQgY2FsbGJhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5kaXJdIC0gVGhlIFt3b3JraW5nIHRyZWVdKGRpci12cy1naXRkaXIubWQpIGRpcmVjdG9yeSBwYXRoXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MuZ2l0ZGlyPWpvaW4oZGlyLCcuZ2l0JyldIC0gW3JlcXVpcmVkXSBUaGUgW2dpdCBkaXJlY3RvcnldKGRpci12cy1naXRkaXIubWQpIHBhdGhcbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5yZWZdIC0gV2hpY2ggYnJhbmNoIHRvIHB1c2guIEJ5IGRlZmF1bHQgdGhpcyBpcyB0aGUgY3VycmVudGx5IGNoZWNrZWQgb3V0IGJyYW5jaC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy51cmxdIC0gVGhlIFVSTCBvZiB0aGUgcmVtb3RlIHJlcG9zaXRvcnkuIFRoZSBkZWZhdWx0IGlzIHRoZSB2YWx1ZSBzZXQgaW4gdGhlIGdpdCBjb25maWcgZm9yIHRoYXQgcmVtb3RlLlxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLnJlbW90ZV0gLSBJZiBVUkwgaXMgbm90IHNwZWNpZmllZCwgZGV0ZXJtaW5lcyB3aGljaCByZW1vdGUgdG8gdXNlLlxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLnJlbW90ZVJlZl0gLSBUaGUgbmFtZSBvZiB0aGUgcmVjZWl2aW5nIGJyYW5jaCBvbiB0aGUgcmVtb3RlLiBCeSBkZWZhdWx0IHRoaXMgaXMgdGhlIGNvbmZpZ3VyZWQgcmVtb3RlIHRyYWNraW5nIGJyYW5jaC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2FyZ3MuZm9yY2UgPSBmYWxzZV0gLSBJZiB0cnVlLCBiZWhhdmVzIHRoZSBzYW1lIGFzIGBnaXQgcHVzaCAtLWZvcmNlYFxuICogQHBhcmFtIHtib29sZWFufSBbYXJncy5kZWxldGUgPSBmYWxzZV0gLSBJZiB0cnVlLCBkZWxldGUgdGhlIHJlbW90ZSByZWZcbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5jb3JzUHJveHldIC0gT3B0aW9uYWwgW0NPUlMgcHJveHldKGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS8lNDBpc29tb3JwaGljLWdpdC9jb3JzLXByb3h5KS4gT3ZlcnJpZGVzIHZhbHVlIGluIHJlcG8gY29uZmlnLlxuICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLCBzdHJpbmc+fSBbYXJncy5oZWFkZXJzXSAtIEFkZGl0aW9uYWwgaGVhZGVycyB0byBpbmNsdWRlIGluIEhUVFAgcmVxdWVzdHMsIHNpbWlsYXIgdG8gZ2l0J3MgYGV4dHJhSGVhZGVyYCBjb25maWdcbiAqIEBwYXJhbSB7b2JqZWN0fSBbYXJncy5jYWNoZV0gLSBhIFtjYWNoZV0oY2FjaGUubWQpIG9iamVjdFxuICpcbiAqIEByZXR1cm5zIHtQcm9taXNlPFB1c2hSZXN1bHQ+fSBSZXNvbHZlcyBzdWNjZXNzZnVsbHkgd2hlbiBwdXNoIGNvbXBsZXRlcyB3aXRoIGEgZGV0YWlsZWQgZGVzY3JpcHRpb24gb2YgdGhlIG9wZXJhdGlvbiBmcm9tIHRoZSBzZXJ2ZXIuXG4gKiBAc2VlIFB1c2hSZXN1bHRcbiAqIEBzZWUgUmVmVXBkYXRlU3RhdHVzXG4gKlxuICogQGV4YW1wbGVcbiAqIGxldCBwdXNoUmVzdWx0ID0gYXdhaXQgZ2l0LnB1c2goe1xuICogICBmcyxcbiAqICAgaHR0cCxcbiAqICAgZGlyOiAnL3R1dG9yaWFsJyxcbiAqICAgcmVtb3RlOiAnb3JpZ2luJyxcbiAqICAgcmVmOiAnbWFpbicsXG4gKiAgIG9uQXV0aDogKCkgPT4gKHsgdXNlcm5hbWU6IHByb2Nlc3MuZW52LkdJVEhVQl9UT0tFTiB9KSxcbiAqIH0pXG4gKiBjb25zb2xlLmxvZyhwdXNoUmVzdWx0KVxuICpcbiAqL1xuYXN5bmMgZnVuY3Rpb24gcHVzaCh7XG4gIGZzLFxuICBodHRwLFxuICBvblByb2dyZXNzLFxuICBvbk1lc3NhZ2UsXG4gIG9uQXV0aCxcbiAgb25BdXRoU3VjY2VzcyxcbiAgb25BdXRoRmFpbHVyZSxcbiAgZGlyLFxuICBnaXRkaXIgPSBqb2luKGRpciwgJy5naXQnKSxcbiAgcmVmLFxuICByZW1vdGVSZWYsXG4gIHJlbW90ZSA9ICdvcmlnaW4nLFxuICB1cmwsXG4gIGZvcmNlID0gZmFsc2UsXG4gIGRlbGV0ZTogX2RlbGV0ZSA9IGZhbHNlLFxuICBjb3JzUHJveHksXG4gIGhlYWRlcnMgPSB7fSxcbiAgY2FjaGUgPSB7fSxcbn0pIHtcbiAgdHJ5IHtcbiAgICBhc3NlcnRQYXJhbWV0ZXIoJ2ZzJywgZnMpO1xuICAgIGFzc2VydFBhcmFtZXRlcignaHR0cCcsIGh0dHApO1xuICAgIGFzc2VydFBhcmFtZXRlcignZ2l0ZGlyJywgZ2l0ZGlyKTtcblxuICAgIHJldHVybiBhd2FpdCBfcHVzaCh7XG4gICAgICBmczogbmV3IEZpbGVTeXN0ZW0oZnMpLFxuICAgICAgY2FjaGUsXG4gICAgICBodHRwLFxuICAgICAgb25Qcm9ncmVzcyxcbiAgICAgIG9uTWVzc2FnZSxcbiAgICAgIG9uQXV0aCxcbiAgICAgIG9uQXV0aFN1Y2Nlc3MsXG4gICAgICBvbkF1dGhGYWlsdXJlLFxuICAgICAgZ2l0ZGlyLFxuICAgICAgcmVmLFxuICAgICAgcmVtb3RlUmVmLFxuICAgICAgcmVtb3RlLFxuICAgICAgdXJsLFxuICAgICAgZm9yY2UsXG4gICAgICBkZWxldGU6IF9kZWxldGUsXG4gICAgICBjb3JzUHJveHksXG4gICAgICBoZWFkZXJzLFxuICAgIH0pXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGVyci5jYWxsZXIgPSAnZ2l0LnB1c2gnO1xuICAgIHRocm93IGVyclxuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHJlc29sdmVCbG9iKHsgZnMsIGNhY2hlLCBnaXRkaXIsIG9pZCB9KSB7XG4gIGNvbnN0IHsgdHlwZSwgb2JqZWN0IH0gPSBhd2FpdCBfcmVhZE9iamVjdCh7IGZzLCBjYWNoZSwgZ2l0ZGlyLCBvaWQgfSk7XG4gIC8vIFJlc29sdmUgYW5ub3RhdGVkIHRhZyBvYmplY3RzIHRvIHdoYXRldmVyXG4gIGlmICh0eXBlID09PSAndGFnJykge1xuICAgIG9pZCA9IEdpdEFubm90YXRlZFRhZy5mcm9tKG9iamVjdCkucGFyc2UoKS5vYmplY3Q7XG4gICAgcmV0dXJuIHJlc29sdmVCbG9iKHsgZnMsIGNhY2hlLCBnaXRkaXIsIG9pZCB9KVxuICB9XG4gIGlmICh0eXBlICE9PSAnYmxvYicpIHtcbiAgICB0aHJvdyBuZXcgT2JqZWN0VHlwZUVycm9yKG9pZCwgdHlwZSwgJ2Jsb2InKVxuICB9XG4gIHJldHVybiB7IG9pZCwgYmxvYjogbmV3IFVpbnQ4QXJyYXkob2JqZWN0KSB9XG59XG5cbi8vIEB0cy1jaGVja1xuXG4vKipcbiAqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBSZWFkQmxvYlJlc3VsdCAtIFRoZSBvYmplY3QgcmV0dXJuZWQgaGFzIHRoZSBmb2xsb3dpbmcgc2NoZW1hOlxuICogQHByb3BlcnR5IHtzdHJpbmd9IG9pZFxuICogQHByb3BlcnR5IHtVaW50OEFycmF5fSBibG9iXG4gKlxuICovXG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGFyZ3NcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9tb2RlbHMvRmlsZVN5c3RlbS5qcycpLkZpbGVTeXN0ZW19IGFyZ3MuZnNcbiAqIEBwYXJhbSB7YW55fSBhcmdzLmNhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30gYXJncy5naXRkaXJcbiAqIEBwYXJhbSB7c3RyaW5nfSBhcmdzLm9pZFxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLmZpbGVwYXRoXVxuICpcbiAqIEByZXR1cm5zIHtQcm9taXNlPFJlYWRCbG9iUmVzdWx0Pn0gUmVzb2x2ZXMgc3VjY2Vzc2Z1bGx5IHdpdGggYSBibG9iIG9iamVjdCBkZXNjcmlwdGlvblxuICogQHNlZSBSZWFkQmxvYlJlc3VsdFxuICovXG5hc3luYyBmdW5jdGlvbiBfcmVhZEJsb2Ioe1xuICBmcyxcbiAgY2FjaGUsXG4gIGdpdGRpcixcbiAgb2lkLFxuICBmaWxlcGF0aCA9IHVuZGVmaW5lZCxcbn0pIHtcbiAgaWYgKGZpbGVwYXRoICE9PSB1bmRlZmluZWQpIHtcbiAgICBvaWQgPSBhd2FpdCByZXNvbHZlRmlsZXBhdGgoeyBmcywgY2FjaGUsIGdpdGRpciwgb2lkLCBmaWxlcGF0aCB9KTtcbiAgfVxuICBjb25zdCBibG9iID0gYXdhaXQgcmVzb2x2ZUJsb2Ioe1xuICAgIGZzLFxuICAgIGNhY2hlLFxuICAgIGdpdGRpcixcbiAgICBvaWQsXG4gIH0pO1xuICByZXR1cm4gYmxvYlxufVxuXG4vLyBAdHMtY2hlY2tcblxuLyoqXG4gKlxuICogQHR5cGVkZWYge09iamVjdH0gUmVhZEJsb2JSZXN1bHQgLSBUaGUgb2JqZWN0IHJldHVybmVkIGhhcyB0aGUgZm9sbG93aW5nIHNjaGVtYTpcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBvaWRcbiAqIEBwcm9wZXJ0eSB7VWludDhBcnJheX0gYmxvYlxuICpcbiAqL1xuXG4vKipcbiAqIFJlYWQgYSBibG9iIG9iamVjdCBkaXJlY3RseVxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBhcmdzXG4gKiBAcGFyYW0ge0ZzQ2xpZW50fSBhcmdzLmZzIC0gYSBmaWxlIHN5c3RlbSBjbGllbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5kaXJdIC0gVGhlIFt3b3JraW5nIHRyZWVdKGRpci12cy1naXRkaXIubWQpIGRpcmVjdG9yeSBwYXRoXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MuZ2l0ZGlyPWpvaW4oZGlyLCcuZ2l0JyldIC0gW3JlcXVpcmVkXSBUaGUgW2dpdCBkaXJlY3RvcnldKGRpci12cy1naXRkaXIubWQpIHBhdGhcbiAqIEBwYXJhbSB7c3RyaW5nfSBhcmdzLm9pZCAtIFRoZSBTSEEtMSBvYmplY3QgaWQgdG8gZ2V0LiBBbm5vdGF0ZWQgdGFncywgY29tbWl0cywgYW5kIHRyZWVzIGFyZSBwZWVsZWQuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MuZmlsZXBhdGhdIC0gRG9uJ3QgcmV0dXJuIHRoZSBvYmplY3Qgd2l0aCBgb2lkYCBpdHNlbGYsIGJ1dCByZXNvbHZlIGBvaWRgIHRvIGEgdHJlZSBhbmQgdGhlbiByZXR1cm4gdGhlIGJsb2Igb2JqZWN0IGF0IHRoYXQgZmlsZXBhdGguXG4gKiBAcGFyYW0ge29iamVjdH0gW2FyZ3MuY2FjaGVdIC0gYSBbY2FjaGVdKGNhY2hlLm1kKSBvYmplY3RcbiAqXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxSZWFkQmxvYlJlc3VsdD59IFJlc29sdmVzIHN1Y2Nlc3NmdWxseSB3aXRoIGEgYmxvYiBvYmplY3QgZGVzY3JpcHRpb25cbiAqIEBzZWUgUmVhZEJsb2JSZXN1bHRcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gR2V0IHRoZSBjb250ZW50cyBvZiAnUkVBRE1FLm1kJyBpbiB0aGUgbWFpbiBicmFuY2guXG4gKiBsZXQgY29tbWl0T2lkID0gYXdhaXQgZ2l0LnJlc29sdmVSZWYoeyBmcywgZGlyOiAnL3R1dG9yaWFsJywgcmVmOiAnbWFpbicgfSlcbiAqIGNvbnNvbGUubG9nKGNvbW1pdE9pZClcbiAqIGxldCB7IGJsb2IgfSA9IGF3YWl0IGdpdC5yZWFkQmxvYih7XG4gKiAgIGZzLFxuICogICBkaXI6ICcvdHV0b3JpYWwnLFxuICogICBvaWQ6IGNvbW1pdE9pZCxcbiAqICAgZmlsZXBhdGg6ICdSRUFETUUubWQnXG4gKiB9KVxuICogY29uc29sZS5sb2coQnVmZmVyLmZyb20oYmxvYikudG9TdHJpbmcoJ3V0ZjgnKSlcbiAqXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHJlYWRCbG9iKHtcbiAgZnMsXG4gIGRpcixcbiAgZ2l0ZGlyID0gam9pbihkaXIsICcuZ2l0JyksXG4gIG9pZCxcbiAgZmlsZXBhdGgsXG4gIGNhY2hlID0ge30sXG59KSB7XG4gIHRyeSB7XG4gICAgYXNzZXJ0UGFyYW1ldGVyKCdmcycsIGZzKTtcbiAgICBhc3NlcnRQYXJhbWV0ZXIoJ2dpdGRpcicsIGdpdGRpcik7XG4gICAgYXNzZXJ0UGFyYW1ldGVyKCdvaWQnLCBvaWQpO1xuXG4gICAgcmV0dXJuIGF3YWl0IF9yZWFkQmxvYih7XG4gICAgICBmczogbmV3IEZpbGVTeXN0ZW0oZnMpLFxuICAgICAgY2FjaGUsXG4gICAgICBnaXRkaXIsXG4gICAgICBvaWQsXG4gICAgICBmaWxlcGF0aCxcbiAgICB9KVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBlcnIuY2FsbGVyID0gJ2dpdC5yZWFkQmxvYic7XG4gICAgdGhyb3cgZXJyXG4gIH1cbn1cblxuLy8gQHRzLWNoZWNrXG5cbi8qKlxuICogUmVhZCBhIGNvbW1pdCBvYmplY3QgZGlyZWN0bHlcbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gYXJnc1xuICogQHBhcmFtIHtGc0NsaWVudH0gYXJncy5mcyAtIGEgZmlsZSBzeXN0ZW0gY2xpZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MuZGlyXSAtIFRoZSBbd29ya2luZyB0cmVlXShkaXItdnMtZ2l0ZGlyLm1kKSBkaXJlY3RvcnkgcGF0aFxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLmdpdGRpcj1qb2luKGRpciwnLmdpdCcpXSAtIFtyZXF1aXJlZF0gVGhlIFtnaXQgZGlyZWN0b3J5XShkaXItdnMtZ2l0ZGlyLm1kKSBwYXRoXG4gKiBAcGFyYW0ge3N0cmluZ30gYXJncy5vaWQgLSBUaGUgU0hBLTEgb2JqZWN0IGlkIHRvIGdldC4gQW5ub3RhdGVkIHRhZ3MgYXJlIHBlZWxlZC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBbYXJncy5jYWNoZV0gLSBhIFtjYWNoZV0oY2FjaGUubWQpIG9iamVjdFxuICpcbiAqIEByZXR1cm5zIHtQcm9taXNlPFJlYWRDb21taXRSZXN1bHQ+fSBSZXNvbHZlcyBzdWNjZXNzZnVsbHkgd2l0aCBhIGdpdCBjb21taXQgb2JqZWN0XG4gKiBAc2VlIFJlYWRDb21taXRSZXN1bHRcbiAqIEBzZWUgQ29tbWl0T2JqZWN0XG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFJlYWQgYSBjb21taXQgb2JqZWN0XG4gKiBsZXQgc2hhID0gYXdhaXQgZ2l0LnJlc29sdmVSZWYoeyBmcywgZGlyOiAnL3R1dG9yaWFsJywgcmVmOiAnbWFpbicgfSlcbiAqIGNvbnNvbGUubG9nKHNoYSlcbiAqIGxldCBjb21taXQgPSBhd2FpdCBnaXQucmVhZENvbW1pdCh7IGZzLCBkaXI6ICcvdHV0b3JpYWwnLCBvaWQ6IHNoYSB9KVxuICogY29uc29sZS5sb2coY29tbWl0KVxuICpcbiAqL1xuYXN5bmMgZnVuY3Rpb24gcmVhZENvbW1pdCh7XG4gIGZzLFxuICBkaXIsXG4gIGdpdGRpciA9IGpvaW4oZGlyLCAnLmdpdCcpLFxuICBvaWQsXG4gIGNhY2hlID0ge30sXG59KSB7XG4gIHRyeSB7XG4gICAgYXNzZXJ0UGFyYW1ldGVyKCdmcycsIGZzKTtcbiAgICBhc3NlcnRQYXJhbWV0ZXIoJ2dpdGRpcicsIGdpdGRpcik7XG4gICAgYXNzZXJ0UGFyYW1ldGVyKCdvaWQnLCBvaWQpO1xuXG4gICAgcmV0dXJuIGF3YWl0IF9yZWFkQ29tbWl0KHtcbiAgICAgIGZzOiBuZXcgRmlsZVN5c3RlbShmcyksXG4gICAgICBjYWNoZSxcbiAgICAgIGdpdGRpcixcbiAgICAgIG9pZCxcbiAgICB9KVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBlcnIuY2FsbGVyID0gJ2dpdC5yZWFkQ29tbWl0JztcbiAgICB0aHJvdyBlcnJcbiAgfVxufVxuXG4vLyBAdHMtY2hlY2tcblxuLyoqXG4gKiBSZWFkIHRoZSBjb250ZW50cyBvZiBhIG5vdGVcbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gYXJnc1xuICogQHBhcmFtIHtpbXBvcnQoJy4uL21vZGVscy9GaWxlU3lzdGVtLmpzJykuRmlsZVN5c3RlbX0gYXJncy5mc1xuICogQHBhcmFtIHthbnl9IGFyZ3MuY2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBhcmdzLmdpdGRpclxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLnJlZl0gLSBUaGUgbm90ZXMgcmVmIHRvIGxvb2sgdW5kZXJcbiAqIEBwYXJhbSB7c3RyaW5nfSBhcmdzLm9pZFxuICpcbiAqIEByZXR1cm5zIHtQcm9taXNlPFVpbnQ4QXJyYXk+fSBSZXNvbHZlcyBzdWNjZXNzZnVsbHkgd2l0aCBub3RlIGNvbnRlbnRzIGFzIGEgQnVmZmVyLlxuICovXG5cbmFzeW5jIGZ1bmN0aW9uIF9yZWFkTm90ZSh7XG4gIGZzLFxuICBjYWNoZSxcbiAgZ2l0ZGlyLFxuICByZWYgPSAncmVmcy9ub3Rlcy9jb21taXRzJyxcbiAgb2lkLFxufSkge1xuICBjb25zdCBwYXJlbnQgPSBhd2FpdCBHaXRSZWZNYW5hZ2VyLnJlc29sdmUoeyBnaXRkaXIsIGZzLCByZWYgfSk7XG4gIGNvbnN0IHsgYmxvYiB9ID0gYXdhaXQgX3JlYWRCbG9iKHtcbiAgICBmcyxcbiAgICBjYWNoZSxcbiAgICBnaXRkaXIsXG4gICAgb2lkOiBwYXJlbnQsXG4gICAgZmlsZXBhdGg6IG9pZCxcbiAgfSk7XG5cbiAgcmV0dXJuIGJsb2Jcbn1cblxuLy8gQHRzLWNoZWNrXG5cbi8qKlxuICogUmVhZCB0aGUgY29udGVudHMgb2YgYSBub3RlXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGFyZ3NcbiAqIEBwYXJhbSB7RnNDbGllbnR9IGFyZ3MuZnMgLSBhIGZpbGUgc3lzdGVtIGNsaWVudFxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLmRpcl0gLSBUaGUgW3dvcmtpbmcgdHJlZV0oZGlyLXZzLWdpdGRpci5tZCkgZGlyZWN0b3J5IHBhdGhcbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5naXRkaXI9am9pbihkaXIsJy5naXQnKV0gLSBbcmVxdWlyZWRdIFRoZSBbZ2l0IGRpcmVjdG9yeV0oZGlyLXZzLWdpdGRpci5tZCkgcGF0aFxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLnJlZl0gLSBUaGUgbm90ZXMgcmVmIHRvIGxvb2sgdW5kZXJcbiAqIEBwYXJhbSB7c3RyaW5nfSBhcmdzLm9pZCAtIFRoZSBTSEEtMSBvYmplY3QgaWQgb2YgdGhlIG9iamVjdCB0byBnZXQgdGhlIG5vdGUgZm9yLlxuICogQHBhcmFtIHtvYmplY3R9IFthcmdzLmNhY2hlXSAtIGEgW2NhY2hlXShjYWNoZS5tZCkgb2JqZWN0XG4gKlxuICogQHJldHVybnMge1Byb21pc2U8VWludDhBcnJheT59IFJlc29sdmVzIHN1Y2Nlc3NmdWxseSB3aXRoIG5vdGUgY29udGVudHMgYXMgYSBCdWZmZXIuXG4gKi9cblxuYXN5bmMgZnVuY3Rpb24gcmVhZE5vdGUoe1xuICBmcyxcbiAgZGlyLFxuICBnaXRkaXIgPSBqb2luKGRpciwgJy5naXQnKSxcbiAgcmVmID0gJ3JlZnMvbm90ZXMvY29tbWl0cycsXG4gIG9pZCxcbiAgY2FjaGUgPSB7fSxcbn0pIHtcbiAgdHJ5IHtcbiAgICBhc3NlcnRQYXJhbWV0ZXIoJ2ZzJywgZnMpO1xuICAgIGFzc2VydFBhcmFtZXRlcignZ2l0ZGlyJywgZ2l0ZGlyKTtcbiAgICBhc3NlcnRQYXJhbWV0ZXIoJ3JlZicsIHJlZik7XG4gICAgYXNzZXJ0UGFyYW1ldGVyKCdvaWQnLCBvaWQpO1xuXG4gICAgcmV0dXJuIGF3YWl0IF9yZWFkTm90ZSh7XG4gICAgICBmczogbmV3IEZpbGVTeXN0ZW0oZnMpLFxuICAgICAgY2FjaGUsXG4gICAgICBnaXRkaXIsXG4gICAgICByZWYsXG4gICAgICBvaWQsXG4gICAgfSlcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZXJyLmNhbGxlciA9ICdnaXQucmVhZE5vdGUnO1xuICAgIHRocm93IGVyclxuICB9XG59XG5cbi8vIEB0cy1jaGVja1xuXG4vKipcbiAqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBEZWZsYXRlZE9iamVjdFxuICogQHByb3BlcnR5IHtzdHJpbmd9IG9pZFxuICogQHByb3BlcnR5IHsnZGVmbGF0ZWQnfSB0eXBlXG4gKiBAcHJvcGVydHkgeydkZWZsYXRlZCd9IGZvcm1hdFxuICogQHByb3BlcnR5IHtVaW50OEFycmF5fSBvYmplY3RcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbc291cmNlXVxuICpcbiAqL1xuXG4vKipcbiAqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBXcmFwcGVkT2JqZWN0XG4gKiBAcHJvcGVydHkge3N0cmluZ30gb2lkXG4gKiBAcHJvcGVydHkgeyd3cmFwcGVkJ30gdHlwZVxuICogQHByb3BlcnR5IHsnd3JhcHBlZCd9IGZvcm1hdFxuICogQHByb3BlcnR5IHtVaW50OEFycmF5fSBvYmplY3RcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbc291cmNlXVxuICpcbiAqL1xuXG4vKipcbiAqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBSYXdPYmplY3RcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBvaWRcbiAqIEBwcm9wZXJ0eSB7J2Jsb2InfCdjb21taXQnfCd0cmVlJ3wndGFnJ30gdHlwZVxuICogQHByb3BlcnR5IHsnY29udGVudCd9IGZvcm1hdFxuICogQHByb3BlcnR5IHtVaW50OEFycmF5fSBvYmplY3RcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbc291cmNlXVxuICpcbiAqL1xuXG4vKipcbiAqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBQYXJzZWRCbG9iT2JqZWN0XG4gKiBAcHJvcGVydHkge3N0cmluZ30gb2lkXG4gKiBAcHJvcGVydHkgeydibG9iJ30gdHlwZVxuICogQHByb3BlcnR5IHsncGFyc2VkJ30gZm9ybWF0XG4gKiBAcHJvcGVydHkge3N0cmluZ30gb2JqZWN0XG4gKiBAcHJvcGVydHkge3N0cmluZ30gW3NvdXJjZV1cbiAqXG4gKi9cblxuLyoqXG4gKlxuICogQHR5cGVkZWYge09iamVjdH0gUGFyc2VkQ29tbWl0T2JqZWN0XG4gKiBAcHJvcGVydHkge3N0cmluZ30gb2lkXG4gKiBAcHJvcGVydHkgeydjb21taXQnfSB0eXBlXG4gKiBAcHJvcGVydHkgeydwYXJzZWQnfSBmb3JtYXRcbiAqIEBwcm9wZXJ0eSB7Q29tbWl0T2JqZWN0fSBvYmplY3RcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbc291cmNlXVxuICpcbiAqL1xuXG4vKipcbiAqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBQYXJzZWRUcmVlT2JqZWN0XG4gKiBAcHJvcGVydHkge3N0cmluZ30gb2lkXG4gKiBAcHJvcGVydHkgeyd0cmVlJ30gdHlwZVxuICogQHByb3BlcnR5IHsncGFyc2VkJ30gZm9ybWF0XG4gKiBAcHJvcGVydHkge1RyZWVPYmplY3R9IG9iamVjdFxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtzb3VyY2VdXG4gKlxuICovXG5cbi8qKlxuICpcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFBhcnNlZFRhZ09iamVjdFxuICogQHByb3BlcnR5IHtzdHJpbmd9IG9pZFxuICogQHByb3BlcnR5IHsndGFnJ30gdHlwZVxuICogQHByb3BlcnR5IHsncGFyc2VkJ30gZm9ybWF0XG4gKiBAcHJvcGVydHkge1RhZ09iamVjdH0gb2JqZWN0XG4gKiBAcHJvcGVydHkge3N0cmluZ30gW3NvdXJjZV1cbiAqXG4gKi9cblxuLyoqXG4gKlxuICogQHR5cGVkZWYge1BhcnNlZEJsb2JPYmplY3QgfCBQYXJzZWRDb21taXRPYmplY3QgfCBQYXJzZWRUcmVlT2JqZWN0IHwgUGFyc2VkVGFnT2JqZWN0fSBQYXJzZWRPYmplY3RcbiAqL1xuXG4vKipcbiAqXG4gKiBAdHlwZWRlZiB7RGVmbGF0ZWRPYmplY3QgfCBXcmFwcGVkT2JqZWN0IHwgUmF3T2JqZWN0IHwgUGFyc2VkT2JqZWN0IH0gUmVhZE9iamVjdFJlc3VsdFxuICovXG5cbi8qKlxuICogUmVhZCBhIGdpdCBvYmplY3QgZGlyZWN0bHkgYnkgaXRzIFNIQS0xIG9iamVjdCBpZFxuICpcbiAqIFJlZ2FyZGluZyBgUmVhZE9iamVjdFJlc3VsdGA6XG4gKlxuICogLSBgb2lkYCB3aWxsIGJlIHRoZSBzYW1lIGFzIHRoZSBgb2lkYCBhcmd1bWVudCB1bmxlc3MgdGhlIGBmaWxlcGF0aGAgYXJndW1lbnQgaXMgcHJvdmlkZWQsIGluIHdoaWNoIGNhc2UgaXQgd2lsbCBiZSB0aGUgb2lkIG9mIHRoZSB0cmVlIG9yIGJsb2IgYmVpbmcgcmV0dXJuZWQuXG4gKiAtIGB0eXBlYCBvZiBkZWZsYXRlZCBvYmplY3RzIGlzIGAnZGVmbGF0ZWQnYCwgYW5kIGB0eXBlYCBvZiB3cmFwcGVkIG9iamVjdHMgaXMgYCd3cmFwcGVkJ2BcbiAqIC0gYGZvcm1hdGAgaXMgdXN1YWxseSwgYnV0IG5vdCBhbHdheXMsIHRoZSBmb3JtYXQgeW91IHJlcXVlc3RlZC4gUGFja2ZpbGVzIGRvIG5vdCBzdG9yZSBlYWNoIG9iamVjdCBpbmRpdmlkdWFsbHkgY29tcHJlc3NlZCBzbyBpZiB5b3UgZW5kIHVwIHJlYWRpbmcgdGhlIG9iamVjdCBmcm9tIGEgcGFja2ZpbGUgaXQgd2lsbCBiZSByZXR1cm5lZCBpbiBmb3JtYXQgJ2NvbnRlbnQnIGV2ZW4gaWYgeW91IHJlcXVlc3RlZCAnZGVmbGF0ZWQnIG9yICd3cmFwcGVkJy5cbiAqIC0gYG9iamVjdGAgd2lsbCBiZSBhbiBhY3R1YWwgT2JqZWN0IGlmIGZvcm1hdCBpcyAncGFyc2VkJyBhbmQgdGhlIG9iamVjdCBpcyBhIGNvbW1pdCwgdHJlZSwgb3IgYW5ub3RhdGVkIHRhZy4gQmxvYnMgYXJlIHN0aWxsIGZvcm1hdHRlZCBhcyBCdWZmZXJzIHVubGVzcyBhbiBlbmNvZGluZyBpcyBwcm92aWRlZCBpbiB3aGljaCBjYXNlIHRoZXknbGwgYmUgc3RyaW5ncy4gSWYgZm9ybWF0IGlzIGFueXRoaW5nIG90aGVyIHRoYW4gJ3BhcnNlZCcsIG9iamVjdCB3aWxsIGJlIGEgQnVmZmVyLlxuICogLSBgc291cmNlYCBpcyB0aGUgbmFtZSBvZiB0aGUgcGFja2ZpbGUgb3IgbG9vc2Ugb2JqZWN0IGZpbGUgd2hlcmUgdGhlIG9iamVjdCB3YXMgZm91bmQuXG4gKlxuICogVGhlIGBmb3JtYXRgIHBhcmFtZXRlciBjYW4gaGF2ZSB0aGUgZm9sbG93aW5nIHZhbHVlczpcbiAqXG4gKiB8IHBhcmFtICAgICAgfCBkZXNjcmlwdGlvbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogfCAtLS0tLS0tLS0tIHwgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIHxcbiAqIHwgJ2RlZmxhdGVkJyB8IFJldHVybiB0aGUgcmF3IGRlZmxhdGUtY29tcHJlc3NlZCBidWZmZXIgZm9yIGFuIG9iamVjdCBpZiBwb3NzaWJsZS4gVXNlZnVsIGZvciBlZmZpY2llbnRseSBzaHVmZmxpbmcgYXJvdW5kIGxvb3NlIG9iamVjdHMgd2hlbiB5b3UgZG9uJ3QgY2FyZSBhYm91dCB0aGUgY29udGVudHMgYW5kIGNhbiBzYXZlIHRpbWUgYnkgbm90IGluZmxhdGluZyB0aGVtLiB8XG4gKiB8ICd3cmFwcGVkJyAgfCBSZXR1cm4gdGhlIGluZmxhdGVkIG9iamVjdCBidWZmZXIgd3JhcHBlZCBpbiB0aGUgZ2l0IG9iamVjdCBoZWFkZXIgaWYgcG9zc2libGUuIFRoaXMgaXMgdGhlIHJhdyBkYXRhIHVzZWQgd2hlbiBjYWxjdWxhdGluZyB0aGUgU0hBLTEgb2JqZWN0IGlkIG9mIGEgZ2l0IG9iamVjdC4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogfCAnY29udGVudCcgIHwgUmV0dXJuIHRoZSBvYmplY3QgYnVmZmVyIHdpdGhvdXQgdGhlIGdpdCBoZWFkZXIuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgJ3BhcnNlZCcgICB8IFJldHVybnMgYSBwYXJzZWQgcmVwcmVzZW50YXRpb24gb2YgdGhlIG9iamVjdC4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKlxuICogVGhlIHJlc3VsdCB3aWxsIGJlIGluIG9uZSBvZiB0aGUgZm9sbG93aW5nIHNjaGVtYXM6XG4gKlxuICogIyMgYCdkZWZsYXRlZCdgIGZvcm1hdFxuICpcbiAqIHtAbGluayBEZWZsYXRlZE9iamVjdCB0eXBlZGVmfVxuICpcbiAqICMjIGAnd3JhcHBlZCdgIGZvcm1hdFxuICpcbiAqIHtAbGluayBXcmFwcGVkT2JqZWN0IHR5cGVkZWZ9XG4gKlxuICogIyMgYCdjb250ZW50J2AgZm9ybWF0XG4gKlxuICoge0BsaW5rIFJhd09iamVjdCB0eXBlZGVmfVxuICpcbiAqICMjIGAncGFyc2VkJ2AgZm9ybWF0XG4gKlxuICogIyMjIHBhcnNlZCBgJ2Jsb2InYCB0eXBlXG4gKlxuICoge0BsaW5rIFBhcnNlZEJsb2JPYmplY3QgdHlwZWRlZn1cbiAqXG4gKiAjIyMgcGFyc2VkIGAnY29tbWl0J2AgdHlwZVxuICpcbiAqIHtAbGluayBQYXJzZWRDb21taXRPYmplY3QgdHlwZWRlZn1cbiAqIHtAbGluayBDb21taXRPYmplY3QgdHlwZWRlZn1cbiAqXG4gKiAjIyMgcGFyc2VkIGAndHJlZSdgIHR5cGVcbiAqXG4gKiB7QGxpbmsgUGFyc2VkVHJlZU9iamVjdCB0eXBlZGVmfVxuICoge0BsaW5rIFRyZWVPYmplY3QgdHlwZWRlZn1cbiAqIHtAbGluayBUcmVlRW50cnkgdHlwZWRlZn1cbiAqXG4gKiAjIyMgcGFyc2VkIGAndGFnJ2AgdHlwZVxuICpcbiAqIHtAbGluayBQYXJzZWRUYWdPYmplY3QgdHlwZWRlZn1cbiAqIHtAbGluayBUYWdPYmplY3QgdHlwZWRlZn1cbiAqXG4gKiBAZGVwcmVjYXRlZFxuICogPiBUaGlzIGNvbW1hbmQgaXMgb3Zlcmx5IGNvbXBsaWNhdGVkLlxuICogPlxuICogPiBJZiB5b3Uga25vdyB0aGUgdHlwZSBvZiBvYmplY3QgeW91IGFyZSByZWFkaW5nLCB1c2UgW2ByZWFkQmxvYmBdKC4vcmVhZEJsb2IubWQpLCBbYHJlYWRDb21taXRgXSguL3JlYWRDb21taXQubWQpLCBbYHJlYWRUYWdgXSguL3JlYWRUYWcubWQpLCBvciBbYHJlYWRUcmVlYF0oLi9yZWFkVHJlZS5tZCkuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGFyZ3NcbiAqIEBwYXJhbSB7RnNDbGllbnR9IGFyZ3MuZnMgLSBhIGZpbGUgc3lzdGVtIGNsaWVudFxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLmRpcl0gLSBUaGUgW3dvcmtpbmcgdHJlZV0oZGlyLXZzLWdpdGRpci5tZCkgZGlyZWN0b3J5IHBhdGhcbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5naXRkaXI9am9pbihkaXIsJy5naXQnKV0gLSBbcmVxdWlyZWRdIFRoZSBbZ2l0IGRpcmVjdG9yeV0oZGlyLXZzLWdpdGRpci5tZCkgcGF0aFxuICogQHBhcmFtIHtzdHJpbmd9IGFyZ3Mub2lkIC0gVGhlIFNIQS0xIG9iamVjdCBpZCB0byBnZXRcbiAqIEBwYXJhbSB7J2RlZmxhdGVkJyB8ICd3cmFwcGVkJyB8ICdjb250ZW50JyB8ICdwYXJzZWQnfSBbYXJncy5mb3JtYXQgPSAncGFyc2VkJ10gLSBXaGF0IGZvcm1hdCB0byByZXR1cm4gdGhlIG9iamVjdCBpbi4gVGhlIGNob2ljZXMgYXJlIGRlc2NyaWJlZCBpbiBtb3JlIGRldGFpbCBiZWxvdy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5maWxlcGF0aF0gLSBEb24ndCByZXR1cm4gdGhlIG9iamVjdCB3aXRoIGBvaWRgIGl0c2VsZiwgYnV0IHJlc29sdmUgYG9pZGAgdG8gYSB0cmVlIGFuZCB0aGVuIHJldHVybiB0aGUgb2JqZWN0IGF0IHRoYXQgZmlsZXBhdGguIFRvIHJldHVybiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgYSB0cmVlIHNldCBmaWxlcGF0aCB0byBgJydgXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MuZW5jb2RpbmddIC0gQSBjb252ZW5pZW5jZSBhcmd1bWVudCB0aGF0IG9ubHkgYWZmZWN0cyBibG9icy4gSW5zdGVhZCBvZiByZXR1cm5pbmcgYG9iamVjdGAgYXMgYSBidWZmZXIsIGl0IHJldHVybnMgYSBzdHJpbmcgcGFyc2VkIHVzaW5nIHRoZSBnaXZlbiBlbmNvZGluZy5cbiAqIEBwYXJhbSB7b2JqZWN0fSBbYXJncy5jYWNoZV0gLSBhIFtjYWNoZV0oY2FjaGUubWQpIG9iamVjdFxuICpcbiAqIEByZXR1cm5zIHtQcm9taXNlPFJlYWRPYmplY3RSZXN1bHQ+fSBSZXNvbHZlcyBzdWNjZXNzZnVsbHkgd2l0aCBhIGdpdCBvYmplY3QgZGVzY3JpcHRpb25cbiAqIEBzZWUgUmVhZE9iamVjdFJlc3VsdFxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBHaXZlbiBhIHJhbnNvbSBTSEEtMSBvYmplY3QgaWQsIGZpZ3VyZSBvdXQgd2hhdCBpdCBpc1xuICogbGV0IHsgdHlwZSwgb2JqZWN0IH0gPSBhd2FpdCBnaXQucmVhZE9iamVjdCh7XG4gKiAgIGZzLFxuICogICBkaXI6ICcvdHV0b3JpYWwnLFxuICogICBvaWQ6ICcwNjk4YTc4MWEwMjI2NGE2ZjM3YmEzZmY0MWQ3ODA2N2VhZjBmMDc1J1xuICogfSlcbiAqIHN3aXRjaCAodHlwZSkge1xuICogICBjYXNlICdjb21taXQnOiB7XG4gKiAgICAgY29uc29sZS5sb2cob2JqZWN0KVxuICogICAgIGJyZWFrXG4gKiAgIH1cbiAqICAgY2FzZSAndHJlZSc6IHtcbiAqICAgICBjb25zb2xlLmxvZyhvYmplY3QpXG4gKiAgICAgYnJlYWtcbiAqICAgfVxuICogICBjYXNlICdibG9iJzoge1xuICogICAgIGNvbnNvbGUubG9nKG9iamVjdClcbiAqICAgICBicmVha1xuICogICB9XG4gKiAgIGNhc2UgJ3RhZyc6IHtcbiAqICAgICBjb25zb2xlLmxvZyhvYmplY3QpXG4gKiAgICAgYnJlYWtcbiAqICAgfVxuICogfVxuICpcbiAqL1xuYXN5bmMgZnVuY3Rpb24gcmVhZE9iamVjdCh7XG4gIGZzOiBfZnMsXG4gIGRpcixcbiAgZ2l0ZGlyID0gam9pbihkaXIsICcuZ2l0JyksXG4gIG9pZCxcbiAgZm9ybWF0ID0gJ3BhcnNlZCcsXG4gIGZpbGVwYXRoID0gdW5kZWZpbmVkLFxuICBlbmNvZGluZyA9IHVuZGVmaW5lZCxcbiAgY2FjaGUgPSB7fSxcbn0pIHtcbiAgdHJ5IHtcbiAgICBhc3NlcnRQYXJhbWV0ZXIoJ2ZzJywgX2ZzKTtcbiAgICBhc3NlcnRQYXJhbWV0ZXIoJ2dpdGRpcicsIGdpdGRpcik7XG4gICAgYXNzZXJ0UGFyYW1ldGVyKCdvaWQnLCBvaWQpO1xuXG4gICAgY29uc3QgZnMgPSBuZXcgRmlsZVN5c3RlbShfZnMpO1xuICAgIGlmIChmaWxlcGF0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBvaWQgPSBhd2FpdCByZXNvbHZlRmlsZXBhdGgoe1xuICAgICAgICBmcyxcbiAgICAgICAgY2FjaGUsXG4gICAgICAgIGdpdGRpcixcbiAgICAgICAgb2lkLFxuICAgICAgICBmaWxlcGF0aCxcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBHaXRPYmplY3RNYW5hZ2VyIGRvZXMgbm90IGtub3cgaG93IHRvIHBhcnNlIGNvbnRlbnQsIHNvIHdlIHR3ZWFrIHRoYXQgcGFyYW1ldGVyIGJlZm9yZSBwYXNzaW5nIGl0LlxuICAgIGNvbnN0IF9mb3JtYXQgPSBmb3JtYXQgPT09ICdwYXJzZWQnID8gJ2NvbnRlbnQnIDogZm9ybWF0O1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IF9yZWFkT2JqZWN0KHtcbiAgICAgIGZzLFxuICAgICAgY2FjaGUsXG4gICAgICBnaXRkaXIsXG4gICAgICBvaWQsXG4gICAgICBmb3JtYXQ6IF9mb3JtYXQsXG4gICAgfSk7XG4gICAgcmVzdWx0Lm9pZCA9IG9pZDtcbiAgICBpZiAoZm9ybWF0ID09PSAncGFyc2VkJykge1xuICAgICAgcmVzdWx0LmZvcm1hdCA9ICdwYXJzZWQnO1xuICAgICAgc3dpdGNoIChyZXN1bHQudHlwZSkge1xuICAgICAgICBjYXNlICdjb21taXQnOlxuICAgICAgICAgIHJlc3VsdC5vYmplY3QgPSBHaXRDb21taXQuZnJvbShyZXN1bHQub2JqZWN0KS5wYXJzZSgpO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgJ3RyZWUnOlxuICAgICAgICAgIHJlc3VsdC5vYmplY3QgPSBHaXRUcmVlLmZyb20ocmVzdWx0Lm9iamVjdCkuZW50cmllcygpO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgJ2Jsb2InOlxuICAgICAgICAgIC8vIEhlcmUgd2UgY29uc2lkZXIgcmV0dXJuaW5nIGEgcmF3IEJ1ZmZlciBhcyB0aGUgJ2NvbnRlbnQnIGZvcm1hdFxuICAgICAgICAgIC8vIGFuZCByZXR1cm5pbmcgYSBzdHJpbmcgYXMgdGhlICdwYXJzZWQnIGZvcm1hdFxuICAgICAgICAgIGlmIChlbmNvZGluZykge1xuICAgICAgICAgICAgcmVzdWx0Lm9iamVjdCA9IHJlc3VsdC5vYmplY3QudG9TdHJpbmcoZW5jb2RpbmcpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQub2JqZWN0ID0gbmV3IFVpbnQ4QXJyYXkocmVzdWx0Lm9iamVjdCk7XG4gICAgICAgICAgICByZXN1bHQuZm9ybWF0ID0gJ2NvbnRlbnQnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlICd0YWcnOlxuICAgICAgICAgIHJlc3VsdC5vYmplY3QgPSBHaXRBbm5vdGF0ZWRUYWcuZnJvbShyZXN1bHQub2JqZWN0KS5wYXJzZSgpO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IE9iamVjdFR5cGVFcnJvcihcbiAgICAgICAgICAgIHJlc3VsdC5vaWQsXG4gICAgICAgICAgICByZXN1bHQudHlwZSxcbiAgICAgICAgICAgICdibG9ifGNvbW1pdHx0YWd8dHJlZSdcbiAgICAgICAgICApXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChyZXN1bHQuZm9ybWF0ID09PSAnZGVmbGF0ZWQnIHx8IHJlc3VsdC5mb3JtYXQgPT09ICd3cmFwcGVkJykge1xuICAgICAgcmVzdWx0LnR5cGUgPSByZXN1bHQuZm9ybWF0O1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGVyci5jYWxsZXIgPSAnZ2l0LnJlYWRPYmplY3QnO1xuICAgIHRocm93IGVyclxuICB9XG59XG5cbi8vIEB0cy1jaGVja1xuXG4vKipcbiAqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBSZWFkVGFnUmVzdWx0IC0gVGhlIG9iamVjdCByZXR1cm5lZCBoYXMgdGhlIGZvbGxvd2luZyBzY2hlbWE6XG4gKiBAcHJvcGVydHkge3N0cmluZ30gb2lkIC0gU0hBLTEgb2JqZWN0IGlkIG9mIHRoaXMgdGFnXG4gKiBAcHJvcGVydHkge1RhZ09iamVjdH0gdGFnIC0gdGhlIHBhcnNlZCB0YWcgb2JqZWN0XG4gKiBAcHJvcGVydHkge3N0cmluZ30gcGF5bG9hZCAtIFBHUCBzaWduaW5nIHBheWxvYWRcbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBhcmdzXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vbW9kZWxzL0ZpbGVTeXN0ZW0uanMnKS5GaWxlU3lzdGVtfSBhcmdzLmZzXG4gKiBAcGFyYW0ge2FueX0gYXJncy5jYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGFyZ3MuZ2l0ZGlyXG4gKiBAcGFyYW0ge3N0cmluZ30gYXJncy5vaWRcbiAqXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxSZWFkVGFnUmVzdWx0Pn1cbiAqL1xuYXN5bmMgZnVuY3Rpb24gX3JlYWRUYWcoeyBmcywgY2FjaGUsIGdpdGRpciwgb2lkIH0pIHtcbiAgY29uc3QgeyB0eXBlLCBvYmplY3QgfSA9IGF3YWl0IF9yZWFkT2JqZWN0KHtcbiAgICBmcyxcbiAgICBjYWNoZSxcbiAgICBnaXRkaXIsXG4gICAgb2lkLFxuICAgIGZvcm1hdDogJ2NvbnRlbnQnLFxuICB9KTtcbiAgaWYgKHR5cGUgIT09ICd0YWcnKSB7XG4gICAgdGhyb3cgbmV3IE9iamVjdFR5cGVFcnJvcihvaWQsIHR5cGUsICd0YWcnKVxuICB9XG4gIGNvbnN0IHRhZyA9IEdpdEFubm90YXRlZFRhZy5mcm9tKG9iamVjdCk7XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICBvaWQsXG4gICAgdGFnOiB0YWcucGFyc2UoKSxcbiAgICBwYXlsb2FkOiB0YWcucGF5bG9hZCgpLFxuICB9O1xuICAvLyBAdHMtaWdub3JlXG4gIHJldHVybiByZXN1bHRcbn1cblxuLyoqXG4gKlxuICogQHR5cGVkZWYge09iamVjdH0gUmVhZFRhZ1Jlc3VsdCAtIFRoZSBvYmplY3QgcmV0dXJuZWQgaGFzIHRoZSBmb2xsb3dpbmcgc2NoZW1hOlxuICogQHByb3BlcnR5IHtzdHJpbmd9IG9pZCAtIFNIQS0xIG9iamVjdCBpZCBvZiB0aGlzIHRhZ1xuICogQHByb3BlcnR5IHtUYWdPYmplY3R9IHRhZyAtIHRoZSBwYXJzZWQgdGFnIG9iamVjdFxuICogQHByb3BlcnR5IHtzdHJpbmd9IHBheWxvYWQgLSBQR1Agc2lnbmluZyBwYXlsb2FkXG4gKi9cblxuLyoqXG4gKiBSZWFkIGFuIGFubm90YXRlZCB0YWcgb2JqZWN0IGRpcmVjdGx5XG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGFyZ3NcbiAqIEBwYXJhbSB7RnNDbGllbnR9IGFyZ3MuZnMgLSBhIGZpbGUgc3lzdGVtIGNsaWVudFxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLmRpcl0gLSBUaGUgW3dvcmtpbmcgdHJlZV0oZGlyLXZzLWdpdGRpci5tZCkgZGlyZWN0b3J5IHBhdGhcbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5naXRkaXI9am9pbihkaXIsJy5naXQnKV0gLSBbcmVxdWlyZWRdIFRoZSBbZ2l0IGRpcmVjdG9yeV0oZGlyLXZzLWdpdGRpci5tZCkgcGF0aFxuICogQHBhcmFtIHtzdHJpbmd9IGFyZ3Mub2lkIC0gVGhlIFNIQS0xIG9iamVjdCBpZCB0byBnZXRcbiAqIEBwYXJhbSB7b2JqZWN0fSBbYXJncy5jYWNoZV0gLSBhIFtjYWNoZV0oY2FjaGUubWQpIG9iamVjdFxuICpcbiAqIEByZXR1cm5zIHtQcm9taXNlPFJlYWRUYWdSZXN1bHQ+fSBSZXNvbHZlcyBzdWNjZXNzZnVsbHkgd2l0aCBhIGdpdCBvYmplY3QgZGVzY3JpcHRpb25cbiAqIEBzZWUgUmVhZFRhZ1Jlc3VsdFxuICogQHNlZSBUYWdPYmplY3RcbiAqXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHJlYWRUYWcoe1xuICBmcyxcbiAgZGlyLFxuICBnaXRkaXIgPSBqb2luKGRpciwgJy5naXQnKSxcbiAgb2lkLFxuICBjYWNoZSA9IHt9LFxufSkge1xuICB0cnkge1xuICAgIGFzc2VydFBhcmFtZXRlcignZnMnLCBmcyk7XG4gICAgYXNzZXJ0UGFyYW1ldGVyKCdnaXRkaXInLCBnaXRkaXIpO1xuICAgIGFzc2VydFBhcmFtZXRlcignb2lkJywgb2lkKTtcblxuICAgIHJldHVybiBhd2FpdCBfcmVhZFRhZyh7XG4gICAgICBmczogbmV3IEZpbGVTeXN0ZW0oZnMpLFxuICAgICAgY2FjaGUsXG4gICAgICBnaXRkaXIsXG4gICAgICBvaWQsXG4gICAgfSlcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZXJyLmNhbGxlciA9ICdnaXQucmVhZFRhZyc7XG4gICAgdGhyb3cgZXJyXG4gIH1cbn1cblxuLy8gQHRzLWNoZWNrXG5cbi8qKlxuICpcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFJlYWRUcmVlUmVzdWx0IC0gVGhlIG9iamVjdCByZXR1cm5lZCBoYXMgdGhlIGZvbGxvd2luZyBzY2hlbWE6XG4gKiBAcHJvcGVydHkge3N0cmluZ30gb2lkIC0gU0hBLTEgb2JqZWN0IGlkIG9mIHRoaXMgdHJlZVxuICogQHByb3BlcnR5IHtUcmVlT2JqZWN0fSB0cmVlIC0gdGhlIHBhcnNlZCB0cmVlIG9iamVjdFxuICovXG5cbi8qKlxuICogUmVhZCBhIHRyZWUgb2JqZWN0IGRpcmVjdGx5XG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGFyZ3NcbiAqIEBwYXJhbSB7RnNDbGllbnR9IGFyZ3MuZnMgLSBhIGZpbGUgc3lzdGVtIGNsaWVudFxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLmRpcl0gLSBUaGUgW3dvcmtpbmcgdHJlZV0oZGlyLXZzLWdpdGRpci5tZCkgZGlyZWN0b3J5IHBhdGhcbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5naXRkaXI9am9pbihkaXIsJy5naXQnKV0gLSBbcmVxdWlyZWRdIFRoZSBbZ2l0IGRpcmVjdG9yeV0oZGlyLXZzLWdpdGRpci5tZCkgcGF0aFxuICogQHBhcmFtIHtzdHJpbmd9IGFyZ3Mub2lkIC0gVGhlIFNIQS0xIG9iamVjdCBpZCB0byBnZXQuIEFubm90YXRlZCB0YWdzIGFuZCBjb21taXRzIGFyZSBwZWVsZWQuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MuZmlsZXBhdGhdIC0gRG9uJ3QgcmV0dXJuIHRoZSBvYmplY3Qgd2l0aCBgb2lkYCBpdHNlbGYsIGJ1dCByZXNvbHZlIGBvaWRgIHRvIGEgdHJlZSBhbmQgdGhlbiByZXR1cm4gdGhlIHRyZWUgb2JqZWN0IGF0IHRoYXQgZmlsZXBhdGguXG4gKiBAcGFyYW0ge29iamVjdH0gW2FyZ3MuY2FjaGVdIC0gYSBbY2FjaGVdKGNhY2hlLm1kKSBvYmplY3RcbiAqXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxSZWFkVHJlZVJlc3VsdD59IFJlc29sdmVzIHN1Y2Nlc3NmdWxseSB3aXRoIGEgZ2l0IHRyZWUgb2JqZWN0XG4gKiBAc2VlIFJlYWRUcmVlUmVzdWx0XG4gKiBAc2VlIFRyZWVPYmplY3RcbiAqIEBzZWUgVHJlZUVudHJ5XG4gKlxuICovXG5hc3luYyBmdW5jdGlvbiByZWFkVHJlZSh7XG4gIGZzLFxuICBkaXIsXG4gIGdpdGRpciA9IGpvaW4oZGlyLCAnLmdpdCcpLFxuICBvaWQsXG4gIGZpbGVwYXRoID0gdW5kZWZpbmVkLFxuICBjYWNoZSA9IHt9LFxufSkge1xuICB0cnkge1xuICAgIGFzc2VydFBhcmFtZXRlcignZnMnLCBmcyk7XG4gICAgYXNzZXJ0UGFyYW1ldGVyKCdnaXRkaXInLCBnaXRkaXIpO1xuICAgIGFzc2VydFBhcmFtZXRlcignb2lkJywgb2lkKTtcblxuICAgIHJldHVybiBhd2FpdCBfcmVhZFRyZWUoe1xuICAgICAgZnM6IG5ldyBGaWxlU3lzdGVtKGZzKSxcbiAgICAgIGNhY2hlLFxuICAgICAgZ2l0ZGlyLFxuICAgICAgb2lkLFxuICAgICAgZmlsZXBhdGgsXG4gICAgfSlcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZXJyLmNhbGxlciA9ICdnaXQucmVhZFRyZWUnO1xuICAgIHRocm93IGVyclxuICB9XG59XG5cbi8vIEB0cy1jaGVja1xuXG4vKipcbiAqIFJlbW92ZSBhIGZpbGUgZnJvbSB0aGUgZ2l0IGluZGV4IChha2Egc3RhZ2luZyBhcmVhKVxuICpcbiAqIE5vdGUgdGhhdCB0aGlzIGRvZXMgTk9UIGRlbGV0ZSB0aGUgZmlsZSBpbiB0aGUgd29ya2luZyBkaXJlY3RvcnkuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGFyZ3NcbiAqIEBwYXJhbSB7RnNDbGllbnR9IGFyZ3MuZnMgLSBhIGZpbGUgc3lzdGVtIGNsaWVudFxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLmRpcl0gLSBUaGUgW3dvcmtpbmcgdHJlZV0oZGlyLXZzLWdpdGRpci5tZCkgZGlyZWN0b3J5IHBhdGhcbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5naXRkaXI9am9pbihkaXIsICcuZ2l0JyldIC0gW3JlcXVpcmVkXSBUaGUgW2dpdCBkaXJlY3RvcnldKGRpci12cy1naXRkaXIubWQpIHBhdGhcbiAqIEBwYXJhbSB7c3RyaW5nfSBhcmdzLmZpbGVwYXRoIC0gVGhlIHBhdGggdG8gdGhlIGZpbGUgdG8gcmVtb3ZlIGZyb20gdGhlIGluZGV4XG4gKiBAcGFyYW0ge29iamVjdH0gW2FyZ3MuY2FjaGVdIC0gYSBbY2FjaGVdKGNhY2hlLm1kKSBvYmplY3RcbiAqXG4gKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn0gUmVzb2x2ZXMgc3VjY2Vzc2Z1bGx5IG9uY2UgdGhlIGdpdCBpbmRleCBoYXMgYmVlbiB1cGRhdGVkXG4gKlxuICogQGV4YW1wbGVcbiAqIGF3YWl0IGdpdC5yZW1vdmUoeyBmcywgZGlyOiAnL3R1dG9yaWFsJywgZmlsZXBhdGg6ICdSRUFETUUubWQnIH0pXG4gKiBjb25zb2xlLmxvZygnZG9uZScpXG4gKlxuICovXG5hc3luYyBmdW5jdGlvbiByZW1vdmUoe1xuICBmczogX2ZzLFxuICBkaXIsXG4gIGdpdGRpciA9IGpvaW4oZGlyLCAnLmdpdCcpLFxuICBmaWxlcGF0aCxcbiAgY2FjaGUgPSB7fSxcbn0pIHtcbiAgdHJ5IHtcbiAgICBhc3NlcnRQYXJhbWV0ZXIoJ2ZzJywgX2ZzKTtcbiAgICBhc3NlcnRQYXJhbWV0ZXIoJ2dpdGRpcicsIGdpdGRpcik7XG4gICAgYXNzZXJ0UGFyYW1ldGVyKCdmaWxlcGF0aCcsIGZpbGVwYXRoKTtcblxuICAgIGF3YWl0IEdpdEluZGV4TWFuYWdlci5hY3F1aXJlKFxuICAgICAgeyBmczogbmV3IEZpbGVTeXN0ZW0oX2ZzKSwgZ2l0ZGlyLCBjYWNoZSB9LFxuICAgICAgYXN5bmMgZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgICAgaW5kZXguZGVsZXRlKHsgZmlsZXBhdGggfSk7XG4gICAgICB9XG4gICAgKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZXJyLmNhbGxlciA9ICdnaXQucmVtb3ZlJztcbiAgICB0aHJvdyBlcnJcbiAgfVxufVxuXG4vLyBAdHMtY2hlY2tcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gYXJnc1xuICogQHBhcmFtIHtpbXBvcnQoJy4uL21vZGVscy9GaWxlU3lzdGVtLmpzJykuRmlsZVN5c3RlbX0gYXJncy5mc1xuICogQHBhcmFtIHtvYmplY3R9IGFyZ3MuY2FjaGVcbiAqIEBwYXJhbSB7U2lnbkNhbGxiYWNrfSBbYXJncy5vblNpZ25dXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MuZGlyXVxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLmdpdGRpcj1qb2luKGRpciwnLmdpdCcpXVxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLnJlZl1cbiAqIEBwYXJhbSB7c3RyaW5nfSBhcmdzLm9pZFxuICogQHBhcmFtIHtPYmplY3R9IGFyZ3MuYXV0aG9yXG4gKiBAcGFyYW0ge3N0cmluZ30gYXJncy5hdXRob3IubmFtZVxuICogQHBhcmFtIHtzdHJpbmd9IGFyZ3MuYXV0aG9yLmVtYWlsXG4gKiBAcGFyYW0ge251bWJlcn0gYXJncy5hdXRob3IudGltZXN0YW1wXG4gKiBAcGFyYW0ge251bWJlcn0gYXJncy5hdXRob3IudGltZXpvbmVPZmZzZXRcbiAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzLmNvbW1pdHRlclxuICogQHBhcmFtIHtzdHJpbmd9IGFyZ3MuY29tbWl0dGVyLm5hbWVcbiAqIEBwYXJhbSB7c3RyaW5nfSBhcmdzLmNvbW1pdHRlci5lbWFpbFxuICogQHBhcmFtIHtudW1iZXJ9IGFyZ3MuY29tbWl0dGVyLnRpbWVzdGFtcFxuICogQHBhcmFtIHtudW1iZXJ9IGFyZ3MuY29tbWl0dGVyLnRpbWV6b25lT2Zmc2V0XG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3Muc2lnbmluZ0tleV1cbiAqXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxzdHJpbmc+fVxuICovXG5cbmFzeW5jIGZ1bmN0aW9uIF9yZW1vdmVOb3RlKHtcbiAgZnMsXG4gIGNhY2hlLFxuICBvblNpZ24sXG4gIGdpdGRpcixcbiAgcmVmID0gJ3JlZnMvbm90ZXMvY29tbWl0cycsXG4gIG9pZCxcbiAgYXV0aG9yLFxuICBjb21taXR0ZXIsXG4gIHNpZ25pbmdLZXksXG59KSB7XG4gIC8vIEdldCB0aGUgY3VycmVudCBub3RlIGNvbW1pdFxuICBsZXQgcGFyZW50O1xuICB0cnkge1xuICAgIHBhcmVudCA9IGF3YWl0IEdpdFJlZk1hbmFnZXIucmVzb2x2ZSh7IGdpdGRpciwgZnMsIHJlZiB9KTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaWYgKCEoZXJyIGluc3RhbmNlb2YgTm90Rm91bmRFcnJvcikpIHtcbiAgICAgIHRocm93IGVyclxuICAgIH1cbiAgfVxuXG4gIC8vIEknbSB1c2luZyB0aGUgXCJlbXB0eSB0cmVlXCIgbWFnaWMgbnVtYmVyIGhlcmUgZm9yIGJyZXZpdHlcbiAgY29uc3QgcmVzdWx0ID0gYXdhaXQgX3JlYWRUcmVlKHtcbiAgICBmcyxcbiAgICBnaXRkaXIsXG4gICAgb2lkOiBwYXJlbnQgfHwgJzRiODI1ZGM2NDJjYjZlYjlhMDYwZTU0YmY4ZDY5Mjg4ZmJlZTQ5MDQnLFxuICB9KTtcbiAgbGV0IHRyZWUgPSByZXN1bHQudHJlZTtcblxuICAvLyBSZW1vdmUgdGhlIG5vdGUgYmxvYiBlbnRyeSBmcm9tIHRoZSB0cmVlXG4gIHRyZWUgPSB0cmVlLmZpbHRlcihlbnRyeSA9PiBlbnRyeS5wYXRoICE9PSBvaWQpO1xuXG4gIC8vIENyZWF0ZSB0aGUgbmV3IG5vdGUgdHJlZVxuICBjb25zdCB0cmVlT2lkID0gYXdhaXQgX3dyaXRlVHJlZSh7XG4gICAgZnMsXG4gICAgZ2l0ZGlyLFxuICAgIHRyZWUsXG4gIH0pO1xuXG4gIC8vIENyZWF0ZSB0aGUgbmV3IG5vdGUgY29tbWl0XG4gIGNvbnN0IGNvbW1pdE9pZCA9IGF3YWl0IF9jb21taXQoe1xuICAgIGZzLFxuICAgIGNhY2hlLFxuICAgIG9uU2lnbixcbiAgICBnaXRkaXIsXG4gICAgcmVmLFxuICAgIHRyZWU6IHRyZWVPaWQsXG4gICAgcGFyZW50OiBwYXJlbnQgJiYgW3BhcmVudF0sXG4gICAgbWVzc2FnZTogYE5vdGUgcmVtb3ZlZCBieSAnaXNvbW9ycGhpYy1naXQgcmVtb3ZlTm90ZSdcXG5gLFxuICAgIGF1dGhvcixcbiAgICBjb21taXR0ZXIsXG4gICAgc2lnbmluZ0tleSxcbiAgfSk7XG5cbiAgcmV0dXJuIGNvbW1pdE9pZFxufVxuXG4vLyBAdHMtY2hlY2tcblxuLyoqXG4gKiBSZW1vdmUgYW4gb2JqZWN0IG5vdGVcbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gYXJnc1xuICogQHBhcmFtIHtGc0NsaWVudH0gYXJncy5mcyAtIGEgZmlsZSBzeXN0ZW0gY2xpZW50XG4gKiBAcGFyYW0ge1NpZ25DYWxsYmFja30gW2FyZ3Mub25TaWduXSAtIGEgUEdQIHNpZ25pbmcgaW1wbGVtZW50YXRpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5kaXJdIC0gVGhlIFt3b3JraW5nIHRyZWVdKGRpci12cy1naXRkaXIubWQpIGRpcmVjdG9yeSBwYXRoXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MuZ2l0ZGlyPWpvaW4oZGlyLCcuZ2l0JyldIC0gW3JlcXVpcmVkXSBUaGUgW2dpdCBkaXJlY3RvcnldKGRpci12cy1naXRkaXIubWQpIHBhdGhcbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5yZWZdIC0gVGhlIG5vdGVzIHJlZiB0byBsb29rIHVuZGVyXG4gKiBAcGFyYW0ge3N0cmluZ30gYXJncy5vaWQgLSBUaGUgU0hBLTEgb2JqZWN0IGlkIG9mIHRoZSBvYmplY3QgdG8gcmVtb3ZlIHRoZSBub3RlIGZyb20uXG4gKiBAcGFyYW0ge09iamVjdH0gW2FyZ3MuYXV0aG9yXSAtIFRoZSBkZXRhaWxzIGFib3V0IHRoZSBhdXRob3IuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MuYXV0aG9yLm5hbWVdIC0gRGVmYXVsdCBpcyBgdXNlci5uYW1lYCBjb25maWcuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MuYXV0aG9yLmVtYWlsXSAtIERlZmF1bHQgaXMgYHVzZXIuZW1haWxgIGNvbmZpZy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbYXJncy5hdXRob3IudGltZXN0YW1wPU1hdGguZmxvb3IoRGF0ZS5ub3coKS8xMDAwKV0gLSBTZXQgdGhlIGF1dGhvciB0aW1lc3RhbXAgZmllbGQuIFRoaXMgaXMgdGhlIGludGVnZXIgbnVtYmVyIG9mIHNlY29uZHMgc2luY2UgdGhlIFVuaXggZXBvY2ggKDE5NzAtMDEtMDEgMDA6MDA6MDApLlxuICogQHBhcmFtIHtudW1iZXJ9IFthcmdzLmF1dGhvci50aW1lem9uZU9mZnNldF0gLSBTZXQgdGhlIGF1dGhvciB0aW1lem9uZSBvZmZzZXQgZmllbGQuIFRoaXMgaXMgdGhlIGRpZmZlcmVuY2UsIGluIG1pbnV0ZXMsIGZyb20gdGhlIGN1cnJlbnQgdGltZXpvbmUgdG8gVVRDLiBEZWZhdWx0IGlzIGAobmV3IERhdGUoKSkuZ2V0VGltZXpvbmVPZmZzZXQoKWAuXG4gKiBAcGFyYW0ge09iamVjdH0gW2FyZ3MuY29tbWl0dGVyID0gYXV0aG9yXSAtIFRoZSBkZXRhaWxzIGFib3V0IHRoZSBub3RlIGNvbW1pdHRlciwgaW4gdGhlIHNhbWUgZm9ybWF0IGFzIHRoZSBhdXRob3IgcGFyYW1ldGVyLiBJZiBub3Qgc3BlY2lmaWVkLCB0aGUgYXV0aG9yIGRldGFpbHMgYXJlIHVzZWQuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MuY29tbWl0dGVyLm5hbWVdIC0gRGVmYXVsdCBpcyBgdXNlci5uYW1lYCBjb25maWcuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MuY29tbWl0dGVyLmVtYWlsXSAtIERlZmF1bHQgaXMgYHVzZXIuZW1haWxgIGNvbmZpZy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbYXJncy5jb21taXR0ZXIudGltZXN0YW1wPU1hdGguZmxvb3IoRGF0ZS5ub3coKS8xMDAwKV0gLSBTZXQgdGhlIGNvbW1pdHRlciB0aW1lc3RhbXAgZmllbGQuIFRoaXMgaXMgdGhlIGludGVnZXIgbnVtYmVyIG9mIHNlY29uZHMgc2luY2UgdGhlIFVuaXggZXBvY2ggKDE5NzAtMDEtMDEgMDA6MDA6MDApLlxuICogQHBhcmFtIHtudW1iZXJ9IFthcmdzLmNvbW1pdHRlci50aW1lem9uZU9mZnNldF0gLSBTZXQgdGhlIGNvbW1pdHRlciB0aW1lem9uZSBvZmZzZXQgZmllbGQuIFRoaXMgaXMgdGhlIGRpZmZlcmVuY2UsIGluIG1pbnV0ZXMsIGZyb20gdGhlIGN1cnJlbnQgdGltZXpvbmUgdG8gVVRDLiBEZWZhdWx0IGlzIGAobmV3IERhdGUoKSkuZ2V0VGltZXpvbmVPZmZzZXQoKWAuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3Muc2lnbmluZ0tleV0gLSBTaWduIHRoZSB0YWcgb2JqZWN0IHVzaW5nIHRoaXMgcHJpdmF0ZSBQR1Aga2V5LlxuICogQHBhcmFtIHtvYmplY3R9IFthcmdzLmNhY2hlXSAtIGEgW2NhY2hlXShjYWNoZS5tZCkgb2JqZWN0XG4gKlxuICogQHJldHVybnMge1Byb21pc2U8c3RyaW5nPn0gUmVzb2x2ZXMgc3VjY2Vzc2Z1bGx5IHdpdGggdGhlIFNIQS0xIG9iamVjdCBpZCBvZiB0aGUgY29tbWl0IG9iamVjdCBmb3IgdGhlIG5vdGUgcmVtb3ZhbC5cbiAqL1xuXG5hc3luYyBmdW5jdGlvbiByZW1vdmVOb3RlKHtcbiAgZnM6IF9mcyxcbiAgb25TaWduLFxuICBkaXIsXG4gIGdpdGRpciA9IGpvaW4oZGlyLCAnLmdpdCcpLFxuICByZWYgPSAncmVmcy9ub3Rlcy9jb21taXRzJyxcbiAgb2lkLFxuICBhdXRob3I6IF9hdXRob3IsXG4gIGNvbW1pdHRlcjogX2NvbW1pdHRlcixcbiAgc2lnbmluZ0tleSxcbiAgY2FjaGUgPSB7fSxcbn0pIHtcbiAgdHJ5IHtcbiAgICBhc3NlcnRQYXJhbWV0ZXIoJ2ZzJywgX2ZzKTtcbiAgICBhc3NlcnRQYXJhbWV0ZXIoJ2dpdGRpcicsIGdpdGRpcik7XG4gICAgYXNzZXJ0UGFyYW1ldGVyKCdvaWQnLCBvaWQpO1xuXG4gICAgY29uc3QgZnMgPSBuZXcgRmlsZVN5c3RlbShfZnMpO1xuXG4gICAgY29uc3QgYXV0aG9yID0gYXdhaXQgbm9ybWFsaXplQXV0aG9yT2JqZWN0KHsgZnMsIGdpdGRpciwgYXV0aG9yOiBfYXV0aG9yIH0pO1xuICAgIGlmICghYXV0aG9yKSB0aHJvdyBuZXcgTWlzc2luZ05hbWVFcnJvcignYXV0aG9yJylcblxuICAgIGNvbnN0IGNvbW1pdHRlciA9IGF3YWl0IG5vcm1hbGl6ZUNvbW1pdHRlck9iamVjdCh7XG4gICAgICBmcyxcbiAgICAgIGdpdGRpcixcbiAgICAgIGF1dGhvcixcbiAgICAgIGNvbW1pdHRlcjogX2NvbW1pdHRlcixcbiAgICB9KTtcbiAgICBpZiAoIWNvbW1pdHRlcikgdGhyb3cgbmV3IE1pc3NpbmdOYW1lRXJyb3IoJ2NvbW1pdHRlcicpXG5cbiAgICByZXR1cm4gYXdhaXQgX3JlbW92ZU5vdGUoe1xuICAgICAgZnMsXG4gICAgICBjYWNoZSxcbiAgICAgIG9uU2lnbixcbiAgICAgIGdpdGRpcixcbiAgICAgIHJlZixcbiAgICAgIG9pZCxcbiAgICAgIGF1dGhvcixcbiAgICAgIGNvbW1pdHRlcixcbiAgICAgIHNpZ25pbmdLZXksXG4gICAgfSlcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZXJyLmNhbGxlciA9ICdnaXQucmVtb3ZlTm90ZSc7XG4gICAgdGhyb3cgZXJyXG4gIH1cbn1cblxuLy8gQHRzLWNoZWNrXG5cbi8qKlxuICogUmVuYW1lIGEgYnJhbmNoXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGFyZ3NcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9tb2RlbHMvRmlsZVN5c3RlbS5qcycpLkZpbGVTeXN0ZW19IGFyZ3MuZnNcbiAqIEBwYXJhbSB7c3RyaW5nfSBhcmdzLmdpdGRpclxuICogQHBhcmFtIHtzdHJpbmd9IGFyZ3MucmVmIC0gVGhlIG5hbWUgb2YgdGhlIG5ldyBicmFuY2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBhcmdzLm9sZHJlZiAtIFRoZSBuYW1lIG9mIHRoZSBvbGQgYnJhbmNoXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFthcmdzLmNoZWNrb3V0ID0gZmFsc2VdXG4gKlxuICogQHJldHVybnMge1Byb21pc2U8dm9pZD59IFJlc29sdmVzIHN1Y2Nlc3NmdWxseSB3aGVuIGZpbGVzeXN0ZW0gb3BlcmF0aW9ucyBhcmUgY29tcGxldGVcbiAqL1xuYXN5bmMgZnVuY3Rpb24gX3JlbmFtZUJyYW5jaCh7XG4gIGZzLFxuICBnaXRkaXIsXG4gIG9sZHJlZixcbiAgcmVmLFxuICBjaGVja291dCA9IGZhbHNlLFxufSkge1xuICBpZiAocmVmICE9PSBjbGVhbkdpdFJlZi5jbGVhbihyZWYpKSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRSZWZOYW1lRXJyb3IocmVmLCBjbGVhbkdpdFJlZi5jbGVhbihyZWYpKVxuICB9XG5cbiAgaWYgKG9sZHJlZiAhPT0gY2xlYW5HaXRSZWYuY2xlYW4ob2xkcmVmKSkge1xuICAgIHRocm93IG5ldyBJbnZhbGlkUmVmTmFtZUVycm9yKG9sZHJlZiwgY2xlYW5HaXRSZWYuY2xlYW4ob2xkcmVmKSlcbiAgfVxuXG4gIGNvbnN0IGZ1bGxvbGRyZWYgPSBgcmVmcy9oZWFkcy8ke29sZHJlZn1gO1xuICBjb25zdCBmdWxsbmV3cmVmID0gYHJlZnMvaGVhZHMvJHtyZWZ9YDtcblxuICBjb25zdCBuZXdleGlzdCA9IGF3YWl0IEdpdFJlZk1hbmFnZXIuZXhpc3RzKHsgZnMsIGdpdGRpciwgcmVmOiBmdWxsbmV3cmVmIH0pO1xuXG4gIGlmIChuZXdleGlzdCkge1xuICAgIHRocm93IG5ldyBBbHJlYWR5RXhpc3RzRXJyb3IoJ2JyYW5jaCcsIHJlZiwgZmFsc2UpXG4gIH1cblxuICBjb25zdCB2YWx1ZSA9IGF3YWl0IEdpdFJlZk1hbmFnZXIucmVzb2x2ZSh7XG4gICAgZnMsXG4gICAgZ2l0ZGlyLFxuICAgIHJlZjogZnVsbG9sZHJlZixcbiAgICBkZXB0aDogMSxcbiAgfSk7XG5cbiAgYXdhaXQgR2l0UmVmTWFuYWdlci53cml0ZVJlZih7IGZzLCBnaXRkaXIsIHJlZjogZnVsbG5ld3JlZiwgdmFsdWUgfSk7XG4gIGF3YWl0IEdpdFJlZk1hbmFnZXIuZGVsZXRlUmVmKHsgZnMsIGdpdGRpciwgcmVmOiBmdWxsb2xkcmVmIH0pO1xuXG4gIGlmIChjaGVja291dCkge1xuICAgIC8vIFVwZGF0ZSBIRUFEXG4gICAgYXdhaXQgR2l0UmVmTWFuYWdlci53cml0ZVN5bWJvbGljUmVmKHtcbiAgICAgIGZzLFxuICAgICAgZ2l0ZGlyLFxuICAgICAgcmVmOiAnSEVBRCcsXG4gICAgICB2YWx1ZTogZnVsbG5ld3JlZixcbiAgICB9KTtcbiAgfVxufVxuXG4vLyBAdHMtY2hlY2tcblxuLyoqXG4gKiBSZW5hbWUgYSBicmFuY2hcbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gYXJnc1xuICogQHBhcmFtIHtGc0NsaWVudH0gYXJncy5mcyAtIGEgZmlsZSBzeXN0ZW0gaW1wbGVtZW50YXRpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5kaXJdIC0gVGhlIFt3b3JraW5nIHRyZWVdKGRpci12cy1naXRkaXIubWQpIGRpcmVjdG9yeSBwYXRoXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MuZ2l0ZGlyPWpvaW4oZGlyLCcuZ2l0JyldIC0gW3JlcXVpcmVkXSBUaGUgW2dpdCBkaXJlY3RvcnldKGRpci12cy1naXRkaXIubWQpIHBhdGhcbiAqIEBwYXJhbSB7c3RyaW5nfSBhcmdzLnJlZiAtIFdoYXQgdG8gbmFtZSB0aGUgYnJhbmNoXG4gKiBAcGFyYW0ge3N0cmluZ30gYXJncy5vbGRyZWYgLSBXaGF0IHRoZSBuYW1lIG9mIHRoZSBicmFuY2ggd2FzXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFthcmdzLmNoZWNrb3V0ID0gZmFsc2VdIC0gVXBkYXRlIGBIRUFEYCB0byBwb2ludCBhdCB0aGUgbmV3bHkgY3JlYXRlZCBicmFuY2hcbiAqXG4gKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn0gUmVzb2x2ZXMgc3VjY2Vzc2Z1bGx5IHdoZW4gZmlsZXN5c3RlbSBvcGVyYXRpb25zIGFyZSBjb21wbGV0ZVxuICpcbiAqIEBleGFtcGxlXG4gKiBhd2FpdCBnaXQucmVuYW1lQnJhbmNoKHsgZnMsIGRpcjogJy90dXRvcmlhbCcsIHJlZjogJ21haW4nLCBvbGRyZWY6ICdtYXN0ZXInIH0pXG4gKiBjb25zb2xlLmxvZygnZG9uZScpXG4gKlxuICovXG5hc3luYyBmdW5jdGlvbiByZW5hbWVCcmFuY2goe1xuICBmcyxcbiAgZGlyLFxuICBnaXRkaXIgPSBqb2luKGRpciwgJy5naXQnKSxcbiAgcmVmLFxuICBvbGRyZWYsXG4gIGNoZWNrb3V0ID0gZmFsc2UsXG59KSB7XG4gIHRyeSB7XG4gICAgYXNzZXJ0UGFyYW1ldGVyKCdmcycsIGZzKTtcbiAgICBhc3NlcnRQYXJhbWV0ZXIoJ2dpdGRpcicsIGdpdGRpcik7XG4gICAgYXNzZXJ0UGFyYW1ldGVyKCdyZWYnLCByZWYpO1xuICAgIGFzc2VydFBhcmFtZXRlcignb2xkcmVmJywgb2xkcmVmKTtcbiAgICByZXR1cm4gYXdhaXQgX3JlbmFtZUJyYW5jaCh7XG4gICAgICBmczogbmV3IEZpbGVTeXN0ZW0oZnMpLFxuICAgICAgZ2l0ZGlyLFxuICAgICAgcmVmLFxuICAgICAgb2xkcmVmLFxuICAgICAgY2hlY2tvdXQsXG4gICAgfSlcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZXJyLmNhbGxlciA9ICdnaXQucmVuYW1lQnJhbmNoJztcbiAgICB0aHJvdyBlcnJcbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBoYXNoT2JqZWN0JDEoeyBnaXRkaXIsIHR5cGUsIG9iamVjdCB9KSB7XG4gIHJldHVybiBzaGFzdW0oR2l0T2JqZWN0LndyYXAoeyB0eXBlLCBvYmplY3QgfSkpXG59XG5cbi8vIEB0cy1jaGVja1xuXG4vKipcbiAqIFJlc2V0IGEgZmlsZSBpbiB0aGUgZ2l0IGluZGV4IChha2Egc3RhZ2luZyBhcmVhKVxuICpcbiAqIE5vdGUgdGhhdCB0aGlzIGRvZXMgTk9UIG1vZGlmeSB0aGUgZmlsZSBpbiB0aGUgd29ya2luZyBkaXJlY3RvcnkuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGFyZ3NcbiAqIEBwYXJhbSB7RnNDbGllbnR9IGFyZ3MuZnMgLSBhIGZpbGUgc3lzdGVtIGNsaWVudFxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLmRpcl0gLSBUaGUgW3dvcmtpbmcgdHJlZV0oZGlyLXZzLWdpdGRpci5tZCkgZGlyZWN0b3J5IHBhdGhcbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5naXRkaXI9am9pbihkaXIsICcuZ2l0JyldIC0gW3JlcXVpcmVkXSBUaGUgW2dpdCBkaXJlY3RvcnldKGRpci12cy1naXRkaXIubWQpIHBhdGhcbiAqIEBwYXJhbSB7c3RyaW5nfSBhcmdzLmZpbGVwYXRoIC0gVGhlIHBhdGggdG8gdGhlIGZpbGUgdG8gcmVzZXQgaW4gdGhlIGluZGV4XG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MucmVmID0gJ0hFQUQnXSAtIEEgcmVmIHRvIHRoZSBjb21taXQgdG8gdXNlXG4gKiBAcGFyYW0ge29iamVjdH0gW2FyZ3MuY2FjaGVdIC0gYSBbY2FjaGVdKGNhY2hlLm1kKSBvYmplY3RcbiAqXG4gKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn0gUmVzb2x2ZXMgc3VjY2Vzc2Z1bGx5IG9uY2UgdGhlIGdpdCBpbmRleCBoYXMgYmVlbiB1cGRhdGVkXG4gKlxuICogQGV4YW1wbGVcbiAqIGF3YWl0IGdpdC5yZXNldEluZGV4KHsgZnMsIGRpcjogJy90dXRvcmlhbCcsIGZpbGVwYXRoOiAnUkVBRE1FLm1kJyB9KVxuICogY29uc29sZS5sb2coJ2RvbmUnKVxuICpcbiAqL1xuYXN5bmMgZnVuY3Rpb24gcmVzZXRJbmRleCh7XG4gIGZzOiBfZnMsXG4gIGRpcixcbiAgZ2l0ZGlyID0gam9pbihkaXIsICcuZ2l0JyksXG4gIGZpbGVwYXRoLFxuICByZWYgPSAnSEVBRCcsXG4gIGNhY2hlID0ge30sXG59KSB7XG4gIHRyeSB7XG4gICAgYXNzZXJ0UGFyYW1ldGVyKCdmcycsIF9mcyk7XG4gICAgYXNzZXJ0UGFyYW1ldGVyKCdnaXRkaXInLCBnaXRkaXIpO1xuICAgIGFzc2VydFBhcmFtZXRlcignZmlsZXBhdGgnLCBmaWxlcGF0aCk7XG4gICAgYXNzZXJ0UGFyYW1ldGVyKCdyZWYnLCByZWYpO1xuXG4gICAgY29uc3QgZnMgPSBuZXcgRmlsZVN5c3RlbShfZnMpO1xuICAgIC8vIFJlc29sdmUgY29tbWl0XG4gICAgbGV0IG9pZCA9IGF3YWl0IEdpdFJlZk1hbmFnZXIucmVzb2x2ZSh7IGZzLCBnaXRkaXIsIHJlZiB9KTtcbiAgICBsZXQgd29ya2Rpck9pZDtcbiAgICB0cnkge1xuICAgICAgLy8gUmVzb2x2ZSBibG9iXG4gICAgICBvaWQgPSBhd2FpdCByZXNvbHZlRmlsZXBhdGgoe1xuICAgICAgICBmcyxcbiAgICAgICAgY2FjaGUsXG4gICAgICAgIGdpdGRpcixcbiAgICAgICAgb2lkLFxuICAgICAgICBmaWxlcGF0aCxcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIFRoaXMgbWVhbnMgd2UncmUgcmVzZXR0aW5nIHRoZSBmaWxlIHRvIGEgXCJkZWxldGVkXCIgc3RhdGVcbiAgICAgIG9pZCA9IG51bGw7XG4gICAgfVxuICAgIC8vIEZvciBmaWxlcyB0aGF0IGFyZW4ndCBpbiB0aGUgd29ya2RpciB1c2UgemVyb3NcbiAgICBsZXQgc3RhdHMgPSB7XG4gICAgICBjdGltZTogbmV3IERhdGUoMCksXG4gICAgICBtdGltZTogbmV3IERhdGUoMCksXG4gICAgICBkZXY6IDAsXG4gICAgICBpbm86IDAsXG4gICAgICBtb2RlOiAwLFxuICAgICAgdWlkOiAwLFxuICAgICAgZ2lkOiAwLFxuICAgICAgc2l6ZTogMCxcbiAgICB9O1xuICAgIC8vIElmIHRoZSBmaWxlIGV4aXN0cyBpbiB0aGUgd29ya2Rpci4uLlxuICAgIGNvbnN0IG9iamVjdCA9IGRpciAmJiAoYXdhaXQgZnMucmVhZChqb2luKGRpciwgZmlsZXBhdGgpKSk7XG4gICAgaWYgKG9iamVjdCkge1xuICAgICAgLy8gLi4uIGFuZCBoYXMgdGhlIHNhbWUgaGFzaCBhcyB0aGUgZGVzaXJlZCBzdGF0ZS4uLlxuICAgICAgd29ya2Rpck9pZCA9IGF3YWl0IGhhc2hPYmplY3QkMSh7XG4gICAgICAgIGdpdGRpcixcbiAgICAgICAgdHlwZTogJ2Jsb2InLFxuICAgICAgICBvYmplY3QsXG4gICAgICB9KTtcbiAgICAgIGlmIChvaWQgPT09IHdvcmtkaXJPaWQpIHtcbiAgICAgICAgLy8gLi4uIHVzZSB0aGUgd29ya2RpciBTdGF0cyBvYmplY3RcbiAgICAgICAgc3RhdHMgPSBhd2FpdCBmcy5sc3RhdChqb2luKGRpciwgZmlsZXBhdGgpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgYXdhaXQgR2l0SW5kZXhNYW5hZ2VyLmFjcXVpcmUoeyBmcywgZ2l0ZGlyLCBjYWNoZSB9LCBhc3luYyBmdW5jdGlvbihpbmRleCkge1xuICAgICAgaW5kZXguZGVsZXRlKHsgZmlsZXBhdGggfSk7XG4gICAgICBpZiAob2lkKSB7XG4gICAgICAgIGluZGV4Lmluc2VydCh7IGZpbGVwYXRoLCBzdGF0cywgb2lkIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBlcnIuY2FsbGVyID0gJ2dpdC5yZXNldCc7XG4gICAgdGhyb3cgZXJyXG4gIH1cbn1cblxuLy8gQHRzLWNoZWNrXG5cbi8qKlxuICogR2V0IHRoZSB2YWx1ZSBvZiBhIHN5bWJvbGljIHJlZiBvciByZXNvbHZlIGEgcmVmIHRvIGl0cyBTSEEtMSBvYmplY3QgaWRcbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gYXJnc1xuICogQHBhcmFtIHtGc0NsaWVudH0gYXJncy5mcyAtIGEgZmlsZSBzeXN0ZW0gY2xpZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MuZGlyXSAtIFRoZSBbd29ya2luZyB0cmVlXShkaXItdnMtZ2l0ZGlyLm1kKSBkaXJlY3RvcnkgcGF0aFxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLmdpdGRpcj1qb2luKGRpciwgJy5naXQnKV0gLSBbcmVxdWlyZWRdIFRoZSBbZ2l0IGRpcmVjdG9yeV0oZGlyLXZzLWdpdGRpci5tZCkgcGF0aFxuICogQHBhcmFtIHtzdHJpbmd9IGFyZ3MucmVmIC0gVGhlIHJlZiB0byByZXNvbHZlXG4gKiBAcGFyYW0ge251bWJlcn0gW2FyZ3MuZGVwdGggPSB1bmRlZmluZWRdIC0gSG93IG1hbnkgc3ltYm9saWMgcmVmZXJlbmNlcyB0byBmb2xsb3cgYmVmb3JlIHJldHVybmluZ1xuICpcbiAqIEByZXR1cm5zIHtQcm9taXNlPHN0cmluZz59IFJlc29sdmVzIHN1Y2Nlc3NmdWxseSB3aXRoIGEgU0hBLTEgb2JqZWN0IGlkIG9yIHRoZSB2YWx1ZSBvZiBhIHN5bWJvbGljIHJlZlxuICpcbiAqIEBleGFtcGxlXG4gKiBsZXQgY3VycmVudENvbW1pdCA9IGF3YWl0IGdpdC5yZXNvbHZlUmVmKHsgZnMsIGRpcjogJy90dXRvcmlhbCcsIHJlZjogJ0hFQUQnIH0pXG4gKiBjb25zb2xlLmxvZyhjdXJyZW50Q29tbWl0KVxuICogbGV0IGN1cnJlbnRCcmFuY2ggPSBhd2FpdCBnaXQucmVzb2x2ZVJlZih7IGZzLCBkaXI6ICcvdHV0b3JpYWwnLCByZWY6ICdIRUFEJywgZGVwdGg6IDIgfSlcbiAqIGNvbnNvbGUubG9nKGN1cnJlbnRCcmFuY2gpXG4gKlxuICovXG5hc3luYyBmdW5jdGlvbiByZXNvbHZlUmVmKHtcbiAgZnMsXG4gIGRpcixcbiAgZ2l0ZGlyID0gam9pbihkaXIsICcuZ2l0JyksXG4gIHJlZixcbiAgZGVwdGgsXG59KSB7XG4gIHRyeSB7XG4gICAgYXNzZXJ0UGFyYW1ldGVyKCdmcycsIGZzKTtcbiAgICBhc3NlcnRQYXJhbWV0ZXIoJ2dpdGRpcicsIGdpdGRpcik7XG4gICAgYXNzZXJ0UGFyYW1ldGVyKCdyZWYnLCByZWYpO1xuXG4gICAgY29uc3Qgb2lkID0gYXdhaXQgR2l0UmVmTWFuYWdlci5yZXNvbHZlKHtcbiAgICAgIGZzOiBuZXcgRmlsZVN5c3RlbShmcyksXG4gICAgICBnaXRkaXIsXG4gICAgICByZWYsXG4gICAgICBkZXB0aCxcbiAgICB9KTtcbiAgICByZXR1cm4gb2lkXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGVyci5jYWxsZXIgPSAnZ2l0LnJlc29sdmVSZWYnO1xuICAgIHRocm93IGVyclxuICB9XG59XG5cbi8vIEB0cy1jaGVja1xuXG4vKipcbiAqIFdyaXRlIGFuIGVudHJ5IHRvIHRoZSBnaXQgY29uZmlnIGZpbGVzLlxuICpcbiAqICpDYXZlYXRzOipcbiAqIC0gQ3VycmVudGx5IG9ubHkgdGhlIGxvY2FsIGAkR0lUX0RJUi9jb25maWdgIGZpbGUgY2FuIGJlIHJlYWQgb3Igd3JpdHRlbi4gSG93ZXZlciBzdXBwb3J0IGZvciB0aGUgZ2xvYmFsIGB+Ly5naXRjb25maWdgIGFuZCBzeXN0ZW0gYCQocHJlZml4KS9ldGMvZ2l0Y29uZmlnYCB3aWxsIGJlIGFkZGVkIGluIHRoZSBmdXR1cmUuXG4gKiAtIFRoZSBjdXJyZW50IHBhcnNlciBkb2VzIG5vdCBzdXBwb3J0IHRoZSBtb3JlIGV4b3RpYyBmZWF0dXJlcyBvZiB0aGUgZ2l0LWNvbmZpZyBmaWxlIGZvcm1hdCBzdWNoIGFzIGBbaW5jbHVkZV1gIGFuZCBgW2luY2x1ZGVJZl1gLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzXG4gKiBAcGFyYW0ge0ZzQ2xpZW50fSBhcmdzLmZzIC0gYSBmaWxlIHN5c3RlbSBpbXBsZW1lbnRhdGlvblxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLmRpcl0gLSBUaGUgW3dvcmtpbmcgdHJlZV0oZGlyLXZzLWdpdGRpci5tZCkgZGlyZWN0b3J5IHBhdGhcbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5naXRkaXI9am9pbihkaXIsJy5naXQnKV0gLSBbcmVxdWlyZWRdIFRoZSBbZ2l0IGRpcmVjdG9yeV0oZGlyLXZzLWdpdGRpci5tZCkgcGF0aFxuICogQHBhcmFtIHtzdHJpbmd9IGFyZ3MucGF0aCAtIFRoZSBrZXkgb2YgdGhlIGdpdCBjb25maWcgZW50cnlcbiAqIEBwYXJhbSB7c3RyaW5nIHwgYm9vbGVhbiB8IG51bWJlciB8IHZvaWR9IGFyZ3MudmFsdWUgLSBBIHZhbHVlIHRvIHN0b3JlIGF0IHRoYXQgcGF0aC4gKFVzZSBgdW5kZWZpbmVkYCBhcyB0aGUgdmFsdWUgdG8gZGVsZXRlIGEgY29uZmlnIGVudHJ5LilcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2FyZ3MuYXBwZW5kID0gZmFsc2VdIC0gSWYgdHJ1ZSwgd2lsbCBhcHBlbmQgcmF0aGVyIHRoYW4gcmVwbGFjZSB3aGVuIHNldHRpbmcgKHVzZSB3aXRoIG11bHRpLXZhbHVlZCBjb25maWcgb3B0aW9ucykuXG4gKlxuICogQHJldHVybnMge1Byb21pc2U8dm9pZD59IFJlc29sdmVzIHN1Y2Nlc3NmdWxseSB3aGVuIG9wZXJhdGlvbiBjb21wbGV0ZWRcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gV3JpdGUgY29uZmlnIHZhbHVlXG4gKiBhd2FpdCBnaXQuc2V0Q29uZmlnKHtcbiAqICAgZnMsXG4gKiAgIGRpcjogJy90dXRvcmlhbCcsXG4gKiAgIHBhdGg6ICd1c2VyLm5hbWUnLFxuICogICB2YWx1ZTogJ01yLiBUZXN0J1xuICogfSlcbiAqXG4gKiAvLyBQcmludCBvdXQgY29uZmlnIGZpbGVcbiAqIGxldCBmaWxlID0gYXdhaXQgZnMucHJvbWlzZXMucmVhZEZpbGUoJy90dXRvcmlhbC8uZ2l0L2NvbmZpZycsICd1dGY4JylcbiAqIGNvbnNvbGUubG9nKGZpbGUpXG4gKlxuICogLy8gRGVsZXRlIGEgY29uZmlnIGVudHJ5XG4gKiBhd2FpdCBnaXQuc2V0Q29uZmlnKHtcbiAqICAgZnMsXG4gKiAgIGRpcjogJy90dXRvcmlhbCcsXG4gKiAgIHBhdGg6ICd1c2VyLm5hbWUnLFxuICogICB2YWx1ZTogdW5kZWZpbmVkXG4gKiB9KVxuICpcbiAqIC8vIFByaW50IG91dCBjb25maWcgZmlsZVxuICogZmlsZSA9IGF3YWl0IGZzLnByb21pc2VzLnJlYWRGaWxlKCcvdHV0b3JpYWwvLmdpdC9jb25maWcnLCAndXRmOCcpXG4gKiBjb25zb2xlLmxvZyhmaWxlKVxuICovXG5hc3luYyBmdW5jdGlvbiBzZXRDb25maWcoe1xuICBmczogX2ZzLFxuICBkaXIsXG4gIGdpdGRpciA9IGpvaW4oZGlyLCAnLmdpdCcpLFxuICBwYXRoLFxuICB2YWx1ZSxcbiAgYXBwZW5kID0gZmFsc2UsXG59KSB7XG4gIHRyeSB7XG4gICAgYXNzZXJ0UGFyYW1ldGVyKCdmcycsIF9mcyk7XG4gICAgYXNzZXJ0UGFyYW1ldGVyKCdnaXRkaXInLCBnaXRkaXIpO1xuICAgIGFzc2VydFBhcmFtZXRlcigncGF0aCcsIHBhdGgpO1xuICAgIC8vIGFzc2VydFBhcmFtZXRlcigndmFsdWUnLCB2YWx1ZSkgLy8gV2UgYWN0dWFsbHkgYWxsb3cgJ3VuZGVmaW5lZCcgYXMgYSB2YWx1ZSB0byB1bnNldC9kZWxldGVcblxuICAgIGNvbnN0IGZzID0gbmV3IEZpbGVTeXN0ZW0oX2ZzKTtcbiAgICBjb25zdCBjb25maWcgPSBhd2FpdCBHaXRDb25maWdNYW5hZ2VyLmdldCh7IGZzLCBnaXRkaXIgfSk7XG4gICAgaWYgKGFwcGVuZCkge1xuICAgICAgYXdhaXQgY29uZmlnLmFwcGVuZChwYXRoLCB2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGF3YWl0IGNvbmZpZy5zZXQocGF0aCwgdmFsdWUpO1xuICAgIH1cbiAgICBhd2FpdCBHaXRDb25maWdNYW5hZ2VyLnNhdmUoeyBmcywgZ2l0ZGlyLCBjb25maWcgfSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGVyci5jYWxsZXIgPSAnZ2l0LnNldENvbmZpZyc7XG4gICAgdGhyb3cgZXJyXG4gIH1cbn1cblxuLy8gQHRzLWNoZWNrXG5cbi8qKlxuICogVGVsbCB3aGV0aGVyIGEgZmlsZSBoYXMgYmVlbiBjaGFuZ2VkXG4gKlxuICogVGhlIHBvc3NpYmxlIHJlc29sdmUgdmFsdWVzIGFyZTpcbiAqXG4gKiB8IHN0YXR1cyAgICAgICAgICAgICAgICB8IGRlc2NyaXB0aW9uICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogfCAtLS0tLS0tLS0tLS0tLS0tLS0tLS0gfCAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIHxcbiAqIHwgYFwiaWdub3JlZFwiYCAgICAgICAgICAgfCBmaWxlIGlnbm9yZWQgYnkgYSAuZ2l0aWdub3JlIHJ1bGUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgYFwidW5tb2RpZmllZFwiYCAgICAgICAgfCBmaWxlIHVuY2hhbmdlZCBmcm9tIEhFQUQgY29tbWl0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgYFwiKm1vZGlmaWVkXCJgICAgICAgICAgfCBmaWxlIGhhcyBtb2RpZmljYXRpb25zLCBub3QgeWV0IHN0YWdlZCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgYFwiKmRlbGV0ZWRcImAgICAgICAgICAgfCBmaWxlIGhhcyBiZWVuIHJlbW92ZWQsIGJ1dCB0aGUgcmVtb3ZhbCBpcyBub3QgeWV0IHN0YWdlZCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgYFwiKmFkZGVkXCJgICAgICAgICAgICAgfCBmaWxlIGlzIHVudHJhY2tlZCwgbm90IHlldCBzdGFnZWQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgYFwiYWJzZW50XCJgICAgICAgICAgICAgfCBmaWxlIG5vdCBwcmVzZW50IGluIEhFQUQgY29tbWl0LCBzdGFnaW5nIGFyZWEsIG9yIHdvcmtpbmcgZGlyICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgYFwibW9kaWZpZWRcImAgICAgICAgICAgfCBmaWxlIGhhcyBtb2RpZmljYXRpb25zLCBzdGFnZWQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgYFwiZGVsZXRlZFwiYCAgICAgICAgICAgfCBmaWxlIGhhcyBiZWVuIHJlbW92ZWQsIHN0YWdlZCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgYFwiYWRkZWRcImAgICAgICAgICAgICAgfCBwcmV2aW91c2x5IHVudHJhY2tlZCBmaWxlLCBzdGFnZWQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgYFwiKnVubW9kaWZpZWRcImAgICAgICAgfCB3b3JraW5nIGRpciBhbmQgSEVBRCBjb21taXQgbWF0Y2gsIGJ1dCBpbmRleCBkaWZmZXJzICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgYFwiKmFic2VudFwiYCAgICAgICAgICAgfCBmaWxlIG5vdCBwcmVzZW50IGluIHdvcmtpbmcgZGlyIG9yIEhFQUQgY29tbWl0LCBidXQgcHJlc2VudCBpbiB0aGUgaW5kZXggICAgICAgICAgICAgIHxcbiAqIHwgYFwiKnVuZGVsZXRlZFwiYCAgICAgICAgfCBmaWxlIHdhcyBkZWxldGVkIGZyb20gdGhlIGluZGV4LCBidXQgaXMgc3RpbGwgaW4gdGhlIHdvcmtpbmcgZGlyICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgYFwiKnVuZGVsZXRlbW9kaWZpZWRcImAgfCBmaWxlIHdhcyBkZWxldGVkIGZyb20gdGhlIGluZGV4LCBidXQgaXMgcHJlc2VudCB3aXRoIG1vZGlmaWNhdGlvbnMgaW4gdGhlIHdvcmtpbmcgZGlyIHxcbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gYXJnc1xuICogQHBhcmFtIHtGc0NsaWVudH0gYXJncy5mcyAtIGEgZmlsZSBzeXN0ZW0gY2xpZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gYXJncy5kaXIgLSBUaGUgW3dvcmtpbmcgdHJlZV0oZGlyLXZzLWdpdGRpci5tZCkgZGlyZWN0b3J5IHBhdGhcbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5naXRkaXI9am9pbihkaXIsICcuZ2l0JyldIC0gW3JlcXVpcmVkXSBUaGUgW2dpdCBkaXJlY3RvcnldKGRpci12cy1naXRkaXIubWQpIHBhdGhcbiAqIEBwYXJhbSB7c3RyaW5nfSBhcmdzLmZpbGVwYXRoIC0gVGhlIHBhdGggdG8gdGhlIGZpbGUgdG8gcXVlcnlcbiAqIEBwYXJhbSB7b2JqZWN0fSBbYXJncy5jYWNoZV0gLSBhIFtjYWNoZV0oY2FjaGUubWQpIG9iamVjdFxuICpcbiAqIEByZXR1cm5zIHtQcm9taXNlPCdpZ25vcmVkJ3wndW5tb2RpZmllZCd8Jyptb2RpZmllZCd8JypkZWxldGVkJ3wnKmFkZGVkJ3wnYWJzZW50J3wnbW9kaWZpZWQnfCdkZWxldGVkJ3wnYWRkZWQnfCcqdW5tb2RpZmllZCd8JyphYnNlbnQnfCcqdW5kZWxldGVkJ3wnKnVuZGVsZXRlbW9kaWZpZWQnPn0gUmVzb2x2ZXMgc3VjY2Vzc2Z1bGx5IHdpdGggdGhlIGZpbGUncyBnaXQgc3RhdHVzXG4gKlxuICogQGV4YW1wbGVcbiAqIGxldCBzdGF0dXMgPSBhd2FpdCBnaXQuc3RhdHVzKHsgZnMsIGRpcjogJy90dXRvcmlhbCcsIGZpbGVwYXRoOiAnUkVBRE1FLm1kJyB9KVxuICogY29uc29sZS5sb2coc3RhdHVzKVxuICpcbiAqL1xuYXN5bmMgZnVuY3Rpb24gc3RhdHVzKHtcbiAgZnM6IF9mcyxcbiAgZGlyLFxuICBnaXRkaXIgPSBqb2luKGRpciwgJy5naXQnKSxcbiAgZmlsZXBhdGgsXG4gIGNhY2hlID0ge30sXG59KSB7XG4gIHRyeSB7XG4gICAgYXNzZXJ0UGFyYW1ldGVyKCdmcycsIF9mcyk7XG4gICAgYXNzZXJ0UGFyYW1ldGVyKCdnaXRkaXInLCBnaXRkaXIpO1xuICAgIGFzc2VydFBhcmFtZXRlcignZmlsZXBhdGgnLCBmaWxlcGF0aCk7XG5cbiAgICBjb25zdCBmcyA9IG5ldyBGaWxlU3lzdGVtKF9mcyk7XG4gICAgY29uc3QgaWdub3JlZCA9IGF3YWl0IEdpdElnbm9yZU1hbmFnZXIuaXNJZ25vcmVkKHtcbiAgICAgIGZzLFxuICAgICAgZ2l0ZGlyLFxuICAgICAgZGlyLFxuICAgICAgZmlsZXBhdGgsXG4gICAgfSk7XG4gICAgaWYgKGlnbm9yZWQpIHtcbiAgICAgIHJldHVybiAnaWdub3JlZCdcbiAgICB9XG4gICAgY29uc3QgaGVhZFRyZWUgPSBhd2FpdCBnZXRIZWFkVHJlZSh7IGZzLCBjYWNoZSwgZ2l0ZGlyIH0pO1xuICAgIGNvbnN0IHRyZWVPaWQgPSBhd2FpdCBnZXRPaWRBdFBhdGgoe1xuICAgICAgZnMsXG4gICAgICBjYWNoZSxcbiAgICAgIGdpdGRpcixcbiAgICAgIHRyZWU6IGhlYWRUcmVlLFxuICAgICAgcGF0aDogZmlsZXBhdGgsXG4gICAgfSk7XG4gICAgY29uc3QgaW5kZXhFbnRyeSA9IGF3YWl0IEdpdEluZGV4TWFuYWdlci5hY3F1aXJlKFxuICAgICAgeyBmcywgZ2l0ZGlyLCBjYWNoZSB9LFxuICAgICAgYXN5bmMgZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgICAgZm9yIChjb25zdCBlbnRyeSBvZiBpbmRleCkge1xuICAgICAgICAgIGlmIChlbnRyeS5wYXRoID09PSBmaWxlcGF0aCkgcmV0dXJuIGVudHJ5XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgIH1cbiAgICApO1xuICAgIGNvbnN0IHN0YXRzID0gYXdhaXQgZnMubHN0YXQoam9pbihkaXIsIGZpbGVwYXRoKSk7XG5cbiAgICBjb25zdCBIID0gdHJlZU9pZCAhPT0gbnVsbDsgLy8gaGVhZFxuICAgIGNvbnN0IEkgPSBpbmRleEVudHJ5ICE9PSBudWxsOyAvLyBpbmRleFxuICAgIGNvbnN0IFcgPSBzdGF0cyAhPT0gbnVsbDsgLy8gd29ya2luZyBkaXJcblxuICAgIGNvbnN0IGdldFdvcmtkaXJPaWQgPSBhc3luYyAoKSA9PiB7XG4gICAgICBpZiAoSSAmJiAhY29tcGFyZVN0YXRzKGluZGV4RW50cnksIHN0YXRzKSkge1xuICAgICAgICByZXR1cm4gaW5kZXhFbnRyeS5vaWRcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IG9iamVjdCA9IGF3YWl0IGZzLnJlYWQoam9pbihkaXIsIGZpbGVwYXRoKSk7XG4gICAgICAgIGNvbnN0IHdvcmtkaXJPaWQgPSBhd2FpdCBoYXNoT2JqZWN0JDEoe1xuICAgICAgICAgIGdpdGRpcixcbiAgICAgICAgICB0eXBlOiAnYmxvYicsXG4gICAgICAgICAgb2JqZWN0LFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gSWYgdGhlIG9pZCBpbiB0aGUgaW5kZXggPT09IHdvcmtpbmcgZGlyIG9pZCBidXQgc3RhdHMgZGlmZmVyZWQgdXBkYXRlIGNhY2hlXG4gICAgICAgIGlmIChJICYmIGluZGV4RW50cnkub2lkID09PSB3b3JrZGlyT2lkKSB7XG4gICAgICAgICAgLy8gYW5kIGFzIGxvbmcgYXMgb3VyIGZzLnN0YXRzIGFyZW4ndCBiYWQuXG4gICAgICAgICAgLy8gc2l6ZSBvZiAtMSBoYXBwZW5zIG92ZXIgYSBCcm93c2VyRlMgSFRUUCBCYWNrZW5kIHRoYXQgZG9lc24ndCBzZXJ2ZSBDb250ZW50LUxlbmd0aCBoZWFkZXJzXG4gICAgICAgICAgLy8gKGxpa2UgdGhlIEthcm1hIHdlYnNlcnZlcikgYmVjYXVzZSBCcm93c2VyRlMgSFRUUCBCYWNrZW5kIHVzZXMgSFRUUCBIRUFEIHJlcXVlc3RzIHRvIGRvIGZzLnN0YXRcbiAgICAgICAgICBpZiAoc3RhdHMuc2l6ZSAhPT0gLTEpIHtcbiAgICAgICAgICAgIC8vIFdlIGRvbid0IGF3YWl0IHRoaXMgc28gd2UgY2FuIHJldHVybiBmYXN0ZXIgZm9yIG9uZS1vZmYgY2FzZXMuXG4gICAgICAgICAgICBHaXRJbmRleE1hbmFnZXIuYWNxdWlyZSh7IGZzLCBnaXRkaXIsIGNhY2hlIH0sIGFzeW5jIGZ1bmN0aW9uKFxuICAgICAgICAgICAgICBpbmRleFxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIGluZGV4Lmluc2VydCh7IGZpbGVwYXRoLCBzdGF0cywgb2lkOiB3b3JrZGlyT2lkIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3b3JrZGlyT2lkXG4gICAgICB9XG4gICAgfTtcblxuICAgIGlmICghSCAmJiAhVyAmJiAhSSkgcmV0dXJuICdhYnNlbnQnIC8vIC0tLVxuICAgIGlmICghSCAmJiAhVyAmJiBJKSByZXR1cm4gJyphYnNlbnQnIC8vIC1BLVxuICAgIGlmICghSCAmJiBXICYmICFJKSByZXR1cm4gJyphZGRlZCcgLy8gLS1BXG4gICAgaWYgKCFIICYmIFcgJiYgSSkge1xuICAgICAgY29uc3Qgd29ya2Rpck9pZCA9IGF3YWl0IGdldFdvcmtkaXJPaWQoKTtcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIHJldHVybiB3b3JrZGlyT2lkID09PSBpbmRleEVudHJ5Lm9pZCA/ICdhZGRlZCcgOiAnKmFkZGVkJyAvLyAtQUEgOiAtQUJcbiAgICB9XG4gICAgaWYgKEggJiYgIVcgJiYgIUkpIHJldHVybiAnZGVsZXRlZCcgLy8gQS0tXG4gICAgaWYgKEggJiYgIVcgJiYgSSkge1xuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgcmV0dXJuIHRyZWVPaWQgPT09IGluZGV4RW50cnkub2lkID8gJypkZWxldGVkJyA6ICcqZGVsZXRlZCcgLy8gQUEtIDogQUItXG4gICAgfVxuICAgIGlmIChIICYmIFcgJiYgIUkpIHtcbiAgICAgIGNvbnN0IHdvcmtkaXJPaWQgPSBhd2FpdCBnZXRXb3JrZGlyT2lkKCk7XG4gICAgICByZXR1cm4gd29ya2Rpck9pZCA9PT0gdHJlZU9pZCA/ICcqdW5kZWxldGVkJyA6ICcqdW5kZWxldGVtb2RpZmllZCcgLy8gQS1BIDogQS1CXG4gICAgfVxuICAgIGlmIChIICYmIFcgJiYgSSkge1xuICAgICAgY29uc3Qgd29ya2Rpck9pZCA9IGF3YWl0IGdldFdvcmtkaXJPaWQoKTtcbiAgICAgIGlmICh3b3JrZGlyT2lkID09PSB0cmVlT2lkKSB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgcmV0dXJuIHdvcmtkaXJPaWQgPT09IGluZGV4RW50cnkub2lkID8gJ3VubW9kaWZpZWQnIDogJyp1bm1vZGlmaWVkJyAvLyBBQUEgOiBBQkFcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgcmV0dXJuIHdvcmtkaXJPaWQgPT09IGluZGV4RW50cnkub2lkID8gJ21vZGlmaWVkJyA6ICcqbW9kaWZpZWQnIC8vIEFCQiA6IEFBQlxuICAgICAgfVxuICAgIH1cbiAgICAvKlxuICAgIC0tLVxuICAgIC1BLVxuICAgIC0tQVxuICAgIC1BQVxuICAgIC1BQlxuICAgIEEtLVxuICAgIEFBLVxuICAgIEFCLVxuICAgIEEtQVxuICAgIEEtQlxuICAgIEFBQVxuICAgIEFCQVxuICAgIEFCQlxuICAgIEFBQlxuICAgICovXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGVyci5jYWxsZXIgPSAnZ2l0LnN0YXR1cyc7XG4gICAgdGhyb3cgZXJyXG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gZ2V0T2lkQXRQYXRoKHsgZnMsIGNhY2hlLCBnaXRkaXIsIHRyZWUsIHBhdGggfSkge1xuICBpZiAodHlwZW9mIHBhdGggPT09ICdzdHJpbmcnKSBwYXRoID0gcGF0aC5zcGxpdCgnLycpO1xuICBjb25zdCBkaXJuYW1lID0gcGF0aC5zaGlmdCgpO1xuICBmb3IgKGNvbnN0IGVudHJ5IG9mIHRyZWUpIHtcbiAgICBpZiAoZW50cnkucGF0aCA9PT0gZGlybmFtZSkge1xuICAgICAgaWYgKHBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBlbnRyeS5vaWRcbiAgICAgIH1cbiAgICAgIGNvbnN0IHsgdHlwZSwgb2JqZWN0IH0gPSBhd2FpdCBfcmVhZE9iamVjdCh7XG4gICAgICAgIGZzLFxuICAgICAgICBjYWNoZSxcbiAgICAgICAgZ2l0ZGlyLFxuICAgICAgICBvaWQ6IGVudHJ5Lm9pZCxcbiAgICAgIH0pO1xuICAgICAgaWYgKHR5cGUgPT09ICd0cmVlJykge1xuICAgICAgICBjb25zdCB0cmVlID0gR2l0VHJlZS5mcm9tKG9iamVjdCk7XG4gICAgICAgIHJldHVybiBnZXRPaWRBdFBhdGgoeyBmcywgY2FjaGUsIGdpdGRpciwgdHJlZSwgcGF0aCB9KVxuICAgICAgfVxuICAgICAgaWYgKHR5cGUgPT09ICdibG9iJykge1xuICAgICAgICB0aHJvdyBuZXcgT2JqZWN0VHlwZUVycm9yKGVudHJ5Lm9pZCwgdHlwZSwgJ2Jsb2InLCBwYXRoLmpvaW4oJy8nKSlcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGxcbn1cblxuYXN5bmMgZnVuY3Rpb24gZ2V0SGVhZFRyZWUoeyBmcywgY2FjaGUsIGdpdGRpciB9KSB7XG4gIC8vIEdldCB0aGUgdHJlZSBmcm9tIHRoZSBIRUFEIGNvbW1pdC5cbiAgbGV0IG9pZDtcbiAgdHJ5IHtcbiAgICBvaWQgPSBhd2FpdCBHaXRSZWZNYW5hZ2VyLnJlc29sdmUoeyBmcywgZ2l0ZGlyLCByZWY6ICdIRUFEJyB9KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIEhhbmRsZSBmcmVzaCBicmFuY2hlcyB3aXRoIG5vIGNvbW1pdHNcbiAgICBpZiAoZSBpbnN0YW5jZW9mIE5vdEZvdW5kRXJyb3IpIHtcbiAgICAgIHJldHVybiBbXVxuICAgIH1cbiAgfVxuICBjb25zdCB7IHRyZWUgfSA9IGF3YWl0IF9yZWFkVHJlZSh7IGZzLCBjYWNoZSwgZ2l0ZGlyLCBvaWQgfSk7XG4gIHJldHVybiB0cmVlXG59XG5cbi8vIEB0cy1jaGVja1xuXG4vKipcbiAqIEVmZmljaWVudGx5IGdldCB0aGUgc3RhdHVzIG9mIG11bHRpcGxlIGZpbGVzIGF0IG9uY2UuXG4gKlxuICogVGhlIHJldHVybmVkIGBTdGF0dXNNYXRyaXhgIGlzIGFkbWl0dGVkbHkgbm90IHRoZSBlYXNpZXN0IGZvcm1hdCB0byByZWFkLlxuICogSG93ZXZlciBpdCBjb252ZXlzIGEgbGFyZ2UgYW1vdW50IG9mIGluZm9ybWF0aW9uIGluIGRlbnNlIGZvcm1hdCB0aGF0IHNob3VsZCBtYWtlIGl0IGVhc3kgdG8gY3JlYXRlIHJlcG9ydHMgYWJvdXQgdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIHJlcG9zaXRvcnk7XG4gKiB3aXRob3V0IGhhdmluZyB0byBkbyBtdWx0aXBsZSwgdGltZS1jb25zdW1pbmcgaXNvbW9ycGhpYy1naXQgY2FsbHMuXG4gKiBNeSBob3BlIGlzIHRoYXQgdGhlIHNwZWVkIGFuZCBmbGV4aWJpbGl0eSBvZiB0aGUgZnVuY3Rpb24gd2lsbCBtYWtlIHVwIGZvciB0aGUgbGVhcm5pbmcgY3VydmUgb2YgaW50ZXJwcmV0aW5nIHRoZSByZXR1cm4gdmFsdWUuXG4gKlxuICogYGBganMgbGl2ZVxuICogLy8gZ2V0IHRoZSBzdGF0dXMgb2YgYWxsIHRoZSBmaWxlcyBpbiAnc3JjJ1xuICogbGV0IHN0YXR1cyA9IGF3YWl0IGdpdC5zdGF0dXNNYXRyaXgoe1xuICogICBmcyxcbiAqICAgZGlyOiAnL3R1dG9yaWFsJyxcbiAqICAgZmlsdGVyOiBmID0+IGYuc3RhcnRzV2l0aCgnc3JjLycpXG4gKiB9KVxuICogY29uc29sZS5sb2coc3RhdHVzKVxuICogYGBgXG4gKlxuICogYGBganMgbGl2ZVxuICogLy8gZ2V0IHRoZSBzdGF0dXMgb2YgYWxsIHRoZSBKU09OIGFuZCBNYXJrZG93biBmaWxlc1xuICogbGV0IHN0YXR1cyA9IGF3YWl0IGdpdC5zdGF0dXNNYXRyaXgoe1xuICogICBmcyxcbiAqICAgZGlyOiAnL3R1dG9yaWFsJyxcbiAqICAgZmlsdGVyOiBmID0+IGYuZW5kc1dpdGgoJy5qc29uJykgfHwgZi5lbmRzV2l0aCgnLm1kJylcbiAqIH0pXG4gKiBjb25zb2xlLmxvZyhzdGF0dXMpXG4gKiBgYGBcbiAqXG4gKiBUaGUgcmVzdWx0IGlzIHJldHVybmVkIGFzIGEgMkQgYXJyYXkuXG4gKiBUaGUgb3V0ZXIgYXJyYXkgcmVwcmVzZW50cyB0aGUgZmlsZXMgYW5kL29yIGJsb2JzIGluIHRoZSByZXBvLCBpbiBhbHBoYWJldGljYWwgb3JkZXIuXG4gKiBUaGUgaW5uZXIgYXJyYXlzIGRlc2NyaWJlIHRoZSBzdGF0dXMgb2YgdGhlIGZpbGU6XG4gKiB0aGUgZmlyc3QgdmFsdWUgaXMgdGhlIGZpbGVwYXRoLCBhbmQgdGhlIG5leHQgdGhyZWUgYXJlIGludGVnZXJzXG4gKiByZXByZXNlbnRpbmcgdGhlIEhFQUQgc3RhdHVzLCBXT1JLRElSIHN0YXR1cywgYW5kIFNUQUdFIHN0YXR1cyBvZiB0aGUgZW50cnkuXG4gKlxuICogYGBganNcbiAqIC8vIGV4YW1wbGUgU3RhdHVzTWF0cml4XG4gKiBbXG4gKiAgIFtcImEudHh0XCIsIDAsIDIsIDBdLCAvLyBuZXcsIHVudHJhY2tlZFxuICogICBbXCJiLnR4dFwiLCAwLCAyLCAyXSwgLy8gYWRkZWQsIHN0YWdlZFxuICogICBbXCJjLnR4dFwiLCAwLCAyLCAzXSwgLy8gYWRkZWQsIHN0YWdlZCwgd2l0aCB1bnN0YWdlZCBjaGFuZ2VzXG4gKiAgIFtcImQudHh0XCIsIDEsIDEsIDFdLCAvLyB1bm1vZGlmaWVkXG4gKiAgIFtcImUudHh0XCIsIDEsIDIsIDFdLCAvLyBtb2RpZmllZCwgdW5zdGFnZWRcbiAqICAgW1wiZi50eHRcIiwgMSwgMiwgMl0sIC8vIG1vZGlmaWVkLCBzdGFnZWRcbiAqICAgW1wiZy50eHRcIiwgMSwgMiwgM10sIC8vIG1vZGlmaWVkLCBzdGFnZWQsIHdpdGggdW5zdGFnZWQgY2hhbmdlc1xuICogICBbXCJoLnR4dFwiLCAxLCAwLCAxXSwgLy8gZGVsZXRlZCwgdW5zdGFnZWRcbiAqICAgW1wiaS50eHRcIiwgMSwgMCwgMF0sIC8vIGRlbGV0ZWQsIHN0YWdlZFxuICogXVxuICogYGBgXG4gKlxuICogLSBUaGUgSEVBRCBzdGF0dXMgaXMgZWl0aGVyIGFic2VudCAoMCkgb3IgcHJlc2VudCAoMSkuXG4gKiAtIFRoZSBXT1JLRElSIHN0YXR1cyBpcyBlaXRoZXIgYWJzZW50ICgwKSwgaWRlbnRpY2FsIHRvIEhFQUQgKDEpLCBvciBkaWZmZXJlbnQgZnJvbSBIRUFEICgyKS5cbiAqIC0gVGhlIFNUQUdFIHN0YXR1cyBpcyBlaXRoZXIgYWJzZW50ICgwKSwgaWRlbnRpY2FsIHRvIEhFQUQgKDEpLCBpZGVudGljYWwgdG8gV09SS0RJUiAoMiksIG9yIGRpZmZlcmVudCBmcm9tIFdPUktESVIgKDMpLlxuICpcbiAqIGBgYHRzXG4gKiB0eXBlIEZpbGVuYW1lICAgICAgPSBzdHJpbmdcbiAqIHR5cGUgSGVhZFN0YXR1cyAgICA9IDAgfCAxXG4gKiB0eXBlIFdvcmtkaXJTdGF0dXMgPSAwIHwgMSB8IDJcbiAqIHR5cGUgU3RhZ2VTdGF0dXMgICA9IDAgfCAxIHwgMiB8IDNcbiAqXG4gKiB0eXBlIFN0YXR1c1JvdyAgICAgPSBbRmlsZW5hbWUsIEhlYWRTdGF0dXMsIFdvcmtkaXJTdGF0dXMsIFN0YWdlU3RhdHVzXVxuICpcbiAqIHR5cGUgU3RhdHVzTWF0cml4ICA9IFN0YXR1c1Jvd1tdXG4gKiBgYGBcbiAqXG4gKiA+IFRoaW5rIG9mIHRoZSBuYXR1cmFsIHByb2dyZXNzaW9uIG9mIGZpbGUgbW9kaWZpY2F0aW9ucyBhcyBiZWluZyBmcm9tIEhFQUQgKHByZXZpb3VzKSAtPiBXT1JLRElSIChjdXJyZW50KSAtPiBTVEFHRSAobmV4dCkuXG4gKiA+IFRoZW4gSEVBRCBpcyBcInZlcnNpb24gMVwiLCBXT1JLRElSIGlzIFwidmVyc2lvbiAyXCIsIGFuZCBTVEFHRSBpcyBcInZlcnNpb24gM1wiLlxuICogPiBUaGVuLCBpbWFnaW5lIGEgXCJ2ZXJzaW9uIDBcIiB3aGljaCBpcyBiZWZvcmUgdGhlIGZpbGUgd2FzIGNyZWF0ZWQuXG4gKiA+IFRoZW4gdGhlIHN0YXR1cyB2YWx1ZSBpbiBlYWNoIGNvbHVtbiBjb3JyZXNwb25kcyB0byB0aGUgb2xkZXN0IHZlcnNpb24gb2YgdGhlIGZpbGUgaXQgaXMgaWRlbnRpY2FsIHRvLlxuICogPiAoRm9yIGEgZmlsZSB0byBiZSBpZGVudGljYWwgdG8gXCJ2ZXJzaW9uIDBcIiBtZWFucyB0aGUgZmlsZSBpcyBkZWxldGVkLilcbiAqXG4gKiBIZXJlIGFyZSBzb21lIGV4YW1wbGVzIG9mIHF1ZXJpZXMgeW91IGNhbiBhbnN3ZXIgdXNpbmcgdGhlIHJlc3VsdDpcbiAqXG4gKiAjIyMjIFE6IFdoYXQgZmlsZXMgaGF2ZSBiZWVuIGRlbGV0ZWQ/XG4gKiBgYGBqc1xuICogY29uc3QgRklMRSA9IDAsIFdPUktESVIgPSAyXG4gKlxuICogY29uc3QgZmlsZW5hbWVzID0gKGF3YWl0IHN0YXR1c01hdHJpeCh7IGRpciB9KSlcbiAqICAgLmZpbHRlcihyb3cgPT4gcm93W1dPUktESVJdID09PSAwKVxuICogICAubWFwKHJvdyA9PiByb3dbRklMRV0pXG4gKiBgYGBcbiAqXG4gKiAjIyMjIFE6IFdoYXQgZmlsZXMgaGF2ZSB1bnN0YWdlZCBjaGFuZ2VzP1xuICogYGBganNcbiAqIGNvbnN0IEZJTEUgPSAwLCBXT1JLRElSID0gMiwgU1RBR0UgPSAzXG4gKlxuICogY29uc3QgZmlsZW5hbWVzID0gKGF3YWl0IHN0YXR1c01hdHJpeCh7IGRpciB9KSlcbiAqICAgLmZpbHRlcihyb3cgPT4gcm93W1dPUktESVJdICE9PSByb3dbU1RBR0VdKVxuICogICAubWFwKHJvdyA9PiByb3dbRklMRV0pXG4gKiBgYGBcbiAqXG4gKiAjIyMjIFE6IFdoYXQgZmlsZXMgaGF2ZSBiZWVuIG1vZGlmaWVkIHNpbmNlIHRoZSBsYXN0IGNvbW1pdD9cbiAqIGBgYGpzXG4gKiBjb25zdCBGSUxFID0gMCwgSEVBRCA9IDEsIFdPUktESVIgPSAyXG4gKlxuICogY29uc3QgZmlsZW5hbWVzID0gKGF3YWl0IHN0YXR1c01hdHJpeCh7IGRpciB9KSlcbiAqICAgLmZpbHRlcihyb3cgPT4gcm93W0hFQURdICE9PSByb3dbV09SS0RJUl0pXG4gKiAgIC5tYXAocm93ID0+IHJvd1tGSUxFXSlcbiAqIGBgYFxuICpcbiAqICMjIyMgUTogV2hhdCBmaWxlcyB3aWxsIE5PVCBiZSBjaGFuZ2VkIGlmIEkgY29tbWl0IHJpZ2h0IG5vdz9cbiAqIGBgYGpzXG4gKiBjb25zdCBGSUxFID0gMCwgSEVBRCA9IDEsIFNUQUdFID0gM1xuICpcbiAqIGNvbnN0IGZpbGVuYW1lcyA9IChhd2FpdCBzdGF0dXNNYXRyaXgoeyBkaXIgfSkpXG4gKiAgIC5maWx0ZXIocm93ID0+IHJvd1tIRUFEXSA9PT0gcm93W1NUQUdFXSlcbiAqICAgLm1hcChyb3cgPT4gcm93W0ZJTEVdKVxuICogYGBgXG4gKlxuICogRm9yIHJlZmVyZW5jZSwgaGVyZSBhcmUgYWxsIHBvc3NpYmxlIGNvbWJpbmF0aW9uczpcbiAqXG4gKiB8IEhFQUQgfCBXT1JLRElSIHwgU1RBR0UgfCBgZ2l0IHN0YXR1cyAtLXNob3J0YCBlcXVpdmFsZW50IHxcbiAqIHwgLS0tLSB8IC0tLS0tLS0gfCAtLS0tLSB8IC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gfFxuICogfCAwICAgIHwgMCAgICAgICB8IDAgICAgIHwgYGAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiB8IDAgICAgfCAwICAgICAgIHwgMyAgICAgfCBgQURgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgMCAgICB8IDIgICAgICAgfCAwICAgICB8IGA/P2AgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogfCAwICAgIHwgMiAgICAgICB8IDIgICAgIHwgYEEgYCAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiB8IDAgICAgfCAyICAgICAgIHwgMyAgICAgfCBgQU1gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgMSAgICB8IDAgICAgICAgfCAwICAgICB8IGBEIGAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogfCAxICAgIHwgMCAgICAgICB8IDEgICAgIHwgYCBEYCAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiB8IDEgICAgfCAwICAgICAgIHwgMyAgICAgfCBgTURgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgMSAgICB8IDEgICAgICAgfCAwICAgICB8IGBEIGAgKyBgPz9gICAgICAgICAgICAgICAgICAgICAgfFxuICogfCAxICAgIHwgMSAgICAgICB8IDEgICAgIHwgYGAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiB8IDEgICAgfCAxICAgICAgIHwgMyAgICAgfCBgTU1gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgMSAgICB8IDIgICAgICAgfCAwICAgICB8IGBEIGAgKyBgPz9gICAgICAgICAgICAgICAgICAgICAgfFxuICogfCAxICAgIHwgMiAgICAgICB8IDEgICAgIHwgYCBNYCAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiB8IDEgICAgfCAyICAgICAgIHwgMiAgICAgfCBgTSBgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgMSAgICB8IDIgICAgICAgfCAzICAgICB8IGBNTWAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBhcmdzXG4gKiBAcGFyYW0ge0ZzQ2xpZW50fSBhcmdzLmZzIC0gYSBmaWxlIHN5c3RlbSBjbGllbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBhcmdzLmRpciAtIFRoZSBbd29ya2luZyB0cmVlXShkaXItdnMtZ2l0ZGlyLm1kKSBkaXJlY3RvcnkgcGF0aFxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLmdpdGRpcj1qb2luKGRpciwgJy5naXQnKV0gLSBbcmVxdWlyZWRdIFRoZSBbZ2l0IGRpcmVjdG9yeV0oZGlyLXZzLWdpdGRpci5tZCkgcGF0aFxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLnJlZiA9ICdIRUFEJ10gLSBPcHRpb25hbGx5IHNwZWNpZnkgYSBkaWZmZXJlbnQgY29tbWl0IHRvIGNvbXBhcmUgYWdhaW5zdCB0aGUgd29ya2RpciBhbmQgc3RhZ2UgaW5zdGVhZCBvZiB0aGUgSEVBRFxuICogQHBhcmFtIHtzdHJpbmdbXX0gW2FyZ3MuZmlsZXBhdGhzID0gWycuJ11dIC0gTGltaXQgdGhlIHF1ZXJ5IHRvIHRoZSBnaXZlbiBmaWxlcyBhbmQgZGlyZWN0b3JpZXNcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oc3RyaW5nKTogYm9vbGVhbn0gW2FyZ3MuZmlsdGVyXSAtIEZpbHRlciB0aGUgcmVzdWx0cyB0byBvbmx5IHRob3NlIHdob3NlIGZpbGVwYXRoIG1hdGNoZXMgYSBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7b2JqZWN0fSBbYXJncy5jYWNoZV0gLSBhIFtjYWNoZV0oY2FjaGUubWQpIG9iamVjdFxuICpcbiAqIEByZXR1cm5zIHtQcm9taXNlPEFycmF5PFN0YXR1c1Jvdz4+fSBSZXNvbHZlcyB3aXRoIGEgc3RhdHVzIG1hdHJpeCwgZGVzY3JpYmVkIGJlbG93LlxuICogQHNlZSBTdGF0dXNSb3dcbiAqL1xuYXN5bmMgZnVuY3Rpb24gc3RhdHVzTWF0cml4KHtcbiAgZnM6IF9mcyxcbiAgZGlyLFxuICBnaXRkaXIgPSBqb2luKGRpciwgJy5naXQnKSxcbiAgcmVmID0gJ0hFQUQnLFxuICBmaWxlcGF0aHMgPSBbJy4nXSxcbiAgZmlsdGVyLFxuICBjYWNoZSA9IHt9LFxufSkge1xuICB0cnkge1xuICAgIGFzc2VydFBhcmFtZXRlcignZnMnLCBfZnMpO1xuICAgIGFzc2VydFBhcmFtZXRlcignZ2l0ZGlyJywgZ2l0ZGlyKTtcbiAgICBhc3NlcnRQYXJhbWV0ZXIoJ3JlZicsIHJlZik7XG5cbiAgICBjb25zdCBmcyA9IG5ldyBGaWxlU3lzdGVtKF9mcyk7XG4gICAgcmV0dXJuIGF3YWl0IF93YWxrKHtcbiAgICAgIGZzLFxuICAgICAgY2FjaGUsXG4gICAgICBkaXIsXG4gICAgICBnaXRkaXIsXG4gICAgICB0cmVlczogW1RSRUUoeyByZWYgfSksIFdPUktESVIoKSwgU1RBR0UoKV0sXG4gICAgICBtYXA6IGFzeW5jIGZ1bmN0aW9uKGZpbGVwYXRoLCBbaGVhZCwgd29ya2Rpciwgc3RhZ2VdKSB7XG4gICAgICAgIC8vIElnbm9yZSBpZ25vcmVkIGZpbGVzLCBidXQgb25seSBpZiB0aGV5IGFyZSBub3QgYWxyZWFkeSB0cmFja2VkLlxuICAgICAgICBpZiAoIWhlYWQgJiYgIXN0YWdlICYmIHdvcmtkaXIpIHtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBhd2FpdCBHaXRJZ25vcmVNYW5hZ2VyLmlzSWdub3JlZCh7XG4gICAgICAgICAgICAgIGZzLFxuICAgICAgICAgICAgICBkaXIsXG4gICAgICAgICAgICAgIGZpbGVwYXRoLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIG1hdGNoIGFnYWluc3QgYmFzZSBwYXRoc1xuICAgICAgICBpZiAoIWZpbGVwYXRocy5zb21lKGJhc2UgPT4gd29ydGhXYWxraW5nKGZpbGVwYXRoLCBiYXNlKSkpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgICB9XG4gICAgICAgIC8vIExhdGUgZmlsdGVyIGFnYWluc3QgZmlsZSBuYW1lc1xuICAgICAgICBpZiAoZmlsdGVyKSB7XG4gICAgICAgICAgaWYgKCFmaWx0ZXIoZmlsZXBhdGgpKSByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZvciBub3csIGp1c3QgYmFpbCBvbiBkaXJlY3Rvcmllc1xuICAgICAgICBjb25zdCBoZWFkVHlwZSA9IGhlYWQgJiYgKGF3YWl0IGhlYWQudHlwZSgpKTtcbiAgICAgICAgaWYgKGhlYWRUeXBlID09PSAndHJlZScgfHwgaGVhZFR5cGUgPT09ICdzcGVjaWFsJykgcmV0dXJuXG4gICAgICAgIGlmIChoZWFkVHlwZSA9PT0gJ2NvbW1pdCcpIHJldHVybiBudWxsXG5cbiAgICAgICAgY29uc3Qgd29ya2RpclR5cGUgPSB3b3JrZGlyICYmIChhd2FpdCB3b3JrZGlyLnR5cGUoKSk7XG4gICAgICAgIGlmICh3b3JrZGlyVHlwZSA9PT0gJ3RyZWUnIHx8IHdvcmtkaXJUeXBlID09PSAnc3BlY2lhbCcpIHJldHVyblxuXG4gICAgICAgIGNvbnN0IHN0YWdlVHlwZSA9IHN0YWdlICYmIChhd2FpdCBzdGFnZS50eXBlKCkpO1xuICAgICAgICBpZiAoc3RhZ2VUeXBlID09PSAnY29tbWl0JykgcmV0dXJuIG51bGxcbiAgICAgICAgaWYgKHN0YWdlVHlwZSA9PT0gJ3RyZWUnIHx8IHN0YWdlVHlwZSA9PT0gJ3NwZWNpYWwnKSByZXR1cm5cblxuICAgICAgICAvLyBGaWd1cmUgb3V0IHRoZSBvaWRzLCB1c2luZyB0aGUgc3RhZ2VkIG9pZCBmb3IgdGhlIHdvcmtpbmcgZGlyIG9pZCBpZiB0aGUgc3RhdHMgbWF0Y2guXG4gICAgICAgIGNvbnN0IGhlYWRPaWQgPSBoZWFkID8gYXdhaXQgaGVhZC5vaWQoKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3Qgc3RhZ2VPaWQgPSBzdGFnZSA/IGF3YWl0IHN0YWdlLm9pZCgpIDogdW5kZWZpbmVkO1xuICAgICAgICBsZXQgd29ya2Rpck9pZDtcbiAgICAgICAgaWYgKCFoZWFkICYmIHdvcmtkaXIgJiYgIXN0YWdlKSB7XG4gICAgICAgICAgLy8gV2UgZG9uJ3QgYWN0dWFsbHkgTkVFRCB0aGUgc2hhLiBBbnkgc2hhIHdpbGwgZG9cbiAgICAgICAgICAvLyBUT0RPOiB1cGRhdGUgdGhpcyBsb2dpYyB0byBoYW5kbGUgTiB0cmVlcyBpbnN0ZWFkIG9mIGp1c3QgMy5cbiAgICAgICAgICB3b3JrZGlyT2lkID0gJzQyJztcbiAgICAgICAgfSBlbHNlIGlmICh3b3JrZGlyKSB7XG4gICAgICAgICAgd29ya2Rpck9pZCA9IGF3YWl0IHdvcmtkaXIub2lkKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZW50cnkgPSBbdW5kZWZpbmVkLCBoZWFkT2lkLCB3b3JrZGlyT2lkLCBzdGFnZU9pZF07XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGVudHJ5Lm1hcCh2YWx1ZSA9PiBlbnRyeS5pbmRleE9mKHZhbHVlKSk7XG4gICAgICAgIHJlc3VsdC5zaGlmdCgpOyAvLyByZW1vdmUgbGVhZGluZyB1bmRlZmluZWQgZW50cnlcbiAgICAgICAgcmV0dXJuIFtmaWxlcGF0aCwgLi4ucmVzdWx0XVxuICAgICAgfSxcbiAgICB9KVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBlcnIuY2FsbGVyID0gJ2dpdC5zdGF0dXNNYXRyaXgnO1xuICAgIHRocm93IGVyclxuICB9XG59XG5cbi8vIEB0cy1jaGVja1xuXG4vKipcbiAqIENyZWF0ZSBhIGxpZ2h0d2VpZ2h0IHRhZ1xuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBhcmdzXG4gKiBAcGFyYW0ge0ZzQ2xpZW50fSBhcmdzLmZzIC0gYSBmaWxlIHN5c3RlbSBjbGllbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5kaXJdIC0gVGhlIFt3b3JraW5nIHRyZWVdKGRpci12cy1naXRkaXIubWQpIGRpcmVjdG9yeSBwYXRoXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MuZ2l0ZGlyPWpvaW4oZGlyLCcuZ2l0JyldIC0gW3JlcXVpcmVkXSBUaGUgW2dpdCBkaXJlY3RvcnldKGRpci12cy1naXRkaXIubWQpIHBhdGhcbiAqIEBwYXJhbSB7c3RyaW5nfSBhcmdzLnJlZiAtIFdoYXQgdG8gbmFtZSB0aGUgdGFnXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3Mub2JqZWN0ID0gJ0hFQUQnXSAtIFdoYXQgb2lkIHRoZSB0YWcgcmVmZXJzIHRvLiAoV2lsbCByZXNvbHZlIHRvIG9pZCBpZiB2YWx1ZSBpcyBhIHJlZi4pIEJ5IGRlZmF1bHQsIHRoZSBjb21taXQgb2JqZWN0IHdoaWNoIGlzIHJlZmVycmVkIGJ5IHRoZSBjdXJyZW50IGBIRUFEYCBpcyB1c2VkLlxuICogQHBhcmFtIHtib29sZWFufSBbYXJncy5mb3JjZSA9IGZhbHNlXSAtIEluc3RlYWQgb2YgdGhyb3dpbmcgYW4gZXJyb3IgaWYgYSB0YWcgbmFtZWQgYHJlZmAgYWxyZWFkeSBleGlzdHMsIG92ZXJ3cml0ZSB0aGUgZXhpc3RpbmcgdGFnLlxuICpcbiAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fSBSZXNvbHZlcyBzdWNjZXNzZnVsbHkgd2hlbiBmaWxlc3lzdGVtIG9wZXJhdGlvbnMgYXJlIGNvbXBsZXRlXG4gKlxuICogQGV4YW1wbGVcbiAqIGF3YWl0IGdpdC50YWcoeyBmcywgZGlyOiAnL3R1dG9yaWFsJywgcmVmOiAndGVzdC10YWcnIH0pXG4gKiBjb25zb2xlLmxvZygnZG9uZScpXG4gKlxuICovXG5hc3luYyBmdW5jdGlvbiB0YWcoe1xuICBmczogX2ZzLFxuICBkaXIsXG4gIGdpdGRpciA9IGpvaW4oZGlyLCAnLmdpdCcpLFxuICByZWYsXG4gIG9iamVjdCxcbiAgZm9yY2UgPSBmYWxzZSxcbn0pIHtcbiAgdHJ5IHtcbiAgICBhc3NlcnRQYXJhbWV0ZXIoJ2ZzJywgX2ZzKTtcbiAgICBhc3NlcnRQYXJhbWV0ZXIoJ2dpdGRpcicsIGdpdGRpcik7XG4gICAgYXNzZXJ0UGFyYW1ldGVyKCdyZWYnLCByZWYpO1xuXG4gICAgY29uc3QgZnMgPSBuZXcgRmlsZVN5c3RlbShfZnMpO1xuXG4gICAgaWYgKHJlZiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgTWlzc2luZ1BhcmFtZXRlckVycm9yKCdyZWYnKVxuICAgIH1cblxuICAgIHJlZiA9IHJlZi5zdGFydHNXaXRoKCdyZWZzL3RhZ3MvJykgPyByZWYgOiBgcmVmcy90YWdzLyR7cmVmfWA7XG5cbiAgICAvLyBSZXNvbHZlIHBhc3NlZCBvYmplY3RcbiAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IEdpdFJlZk1hbmFnZXIucmVzb2x2ZSh7XG4gICAgICBmcyxcbiAgICAgIGdpdGRpcixcbiAgICAgIHJlZjogb2JqZWN0IHx8ICdIRUFEJyxcbiAgICB9KTtcblxuICAgIGlmICghZm9yY2UgJiYgKGF3YWl0IEdpdFJlZk1hbmFnZXIuZXhpc3RzKHsgZnMsIGdpdGRpciwgcmVmIH0pKSkge1xuICAgICAgdGhyb3cgbmV3IEFscmVhZHlFeGlzdHNFcnJvcigndGFnJywgcmVmKVxuICAgIH1cblxuICAgIGF3YWl0IEdpdFJlZk1hbmFnZXIud3JpdGVSZWYoeyBmcywgZ2l0ZGlyLCByZWYsIHZhbHVlIH0pO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBlcnIuY2FsbGVyID0gJ2dpdC50YWcnO1xuICAgIHRocm93IGVyclxuICB9XG59XG5cbi8vIEB0cy1jaGVja1xuXG4vKipcbiAqIFJldHVybiB0aGUgdmVyc2lvbiBudW1iZXIgb2YgaXNvbW9ycGhpYy1naXRcbiAqXG4gKiBJIGRvbid0IGtub3cgd2h5IHlvdSBtaWdodCBuZWVkIHRoaXMuIEkgYWRkZWQgaXQganVzdCBzbyBJIGNvdWxkIGNoZWNrIHRoYXQgSSB3YXMgZ2V0dGluZ1xuICogdGhlIGNvcnJlY3QgdmVyc2lvbiBvZiB0aGUgbGlicmFyeSBhbmQgbm90IGEgY2FjaGVkIHZlcnNpb24uXG4gKlxuICogQHJldHVybnMge3N0cmluZ30gdGhlIHZlcnNpb24gc3RyaW5nIHRha2VuIGZyb20gcGFja2FnZS5qc29uIGF0IHB1YmxpY2F0aW9uIHRpbWVcbiAqXG4gKiBAZXhhbXBsZVxuICogY29uc29sZS5sb2coZ2l0LnZlcnNpb24oKSlcbiAqXG4gKi9cbmZ1bmN0aW9uIHZlcnNpb24oKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHBrZy52ZXJzaW9uXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGVyci5jYWxsZXIgPSAnZ2l0LnZlcnNpb24nO1xuICAgIHRocm93IGVyclxuICB9XG59XG5cbi8vIEB0cy1jaGVja1xuXG4vKipcbiAqIEBjYWxsYmFjayBXYWxrZXJNYXBcbiAqIEBwYXJhbSB7c3RyaW5nfSBmaWxlbmFtZVxuICogQHBhcmFtIHs/V2Fsa2VyRW50cnlbXX0gZW50cmllc1xuICogQHJldHVybnMge1Byb21pc2U8YW55Pn1cbiAqL1xuXG4vKipcbiAqIEBjYWxsYmFjayBXYWxrZXJSZWR1Y2VcbiAqIEBwYXJhbSB7YW55fSBwYXJlbnRcbiAqIEBwYXJhbSB7YW55W119IGNoaWxkcmVuXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxhbnk+fVxuICovXG5cbi8qKlxuICogQGNhbGxiYWNrIFdhbGtlckl0ZXJhdGVDYWxsYmFja1xuICogQHBhcmFtIHtXYWxrZXJFbnRyeVtdfSBlbnRyaWVzXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxhbnlbXT59XG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgV2Fsa2VySXRlcmF0ZVxuICogQHBhcmFtIHtXYWxrZXJJdGVyYXRlQ2FsbGJhY2t9IHdhbGtcbiAqIEBwYXJhbSB7SXRlcmFibGVJdGVyYXRvcjxXYWxrZXJFbnRyeVtdPn0gY2hpbGRyZW5cbiAqIEByZXR1cm5zIHtQcm9taXNlPGFueVtdPn1cbiAqL1xuXG4vKipcbiAqIEEgcG93ZXJmdWwgcmVjdXJzaXZlIHRyZWUtd2Fsa2luZyB1dGlsaXR5LlxuICpcbiAqIFRoZSBgd2Fsa2AgQVBJIHNpbXBsaWZpZXMgZ2F0aGVyaW5nIGRldGFpbGVkIGluZm9ybWF0aW9uIGFib3V0IGEgdHJlZSBvciBjb21wYXJpbmcgYWxsIHRoZSBmaWxlcGF0aHMgaW4gdHdvIG9yIG1vcmUgdHJlZXMuXG4gKiBUcmVlcyBjYW4gYmUgZ2l0IGNvbW1pdHMsIHRoZSB3b3JraW5nIGRpcmVjdG9yeSwgb3IgdGhlIG9yIGdpdCBpbmRleCAoc3RhZ2luZyBhcmVhKS5cbiAqIEFzIGxvbmcgYXMgYSBmaWxlIG9yIGRpcmVjdG9yeSBpcyBwcmVzZW50IGluIGF0IGxlYXN0IG9uZSBvZiB0aGUgdHJlZXMsIGl0IHdpbGwgYmUgdHJhdmVyc2VkLlxuICogRW50cmllcyBhcmUgdHJhdmVyc2VkIGluIGFscGhhYmV0aWNhbCBvcmRlci5cbiAqXG4gKiBUaGUgYXJndW1lbnRzIHRvIGB3YWxrYCBhcmUgdGhlIGB0cmVlc2AgeW91IHdhbnQgdG8gdHJhdmVyc2UsIGFuZCAzIG9wdGlvbmFsIHRyYW5zZm9ybSBmdW5jdGlvbnM6XG4gKiAgYG1hcGAsIGByZWR1Y2VgLCBhbmQgYGl0ZXJhdGVgLlxuICpcbiAqICMjIGBUUkVFYCwgYFdPUktESVJgLCBhbmQgYFNUQUdFYFxuICpcbiAqIFRyZWUgd2Fsa2VycyBhcmUgcmVwcmVzZW50ZWQgYnkgdGhyZWUgc2VwYXJhdGUgZnVuY3Rpb25zIHRoYXQgY2FuIGJlIGltcG9ydGVkOlxuICpcbiAqIGBgYGpzXG4gKiBpbXBvcnQgeyBUUkVFLCBXT1JLRElSLCBTVEFHRSB9IGZyb20gJ2lzb21vcnBoaWMtZ2l0J1xuICogYGBgXG4gKlxuICogVGhlc2UgZnVuY3Rpb25zIHJldHVybiBvcGFxdWUgaGFuZGxlcyBjYWxsZWQgYFdhbGtlcmBzLlxuICogVGhlIG9ubHkgdGhpbmcgdGhhdCBgV2Fsa2VyYCBvYmplY3RzIGFyZSBnb29kIGZvciBpcyBwYXNzaW5nIGludG8gYHdhbGtgLlxuICogSGVyZSBhcmUgdGhlIHRocmVlIGBXYWxrZXJgcyBwYXNzZWQgaW50byBgd2Fsa2AgYnkgdGhlIGBzdGF0dXNNYXRyaXhgIGNvbW1hbmQgZm9yIGV4YW1wbGU6XG4gKlxuICogYGBganNcbiAqIGxldCByZWYgPSAnSEVBRCdcbiAqXG4gKiBsZXQgdHJlZXMgPSBbVFJFRSh7IHJlZiB9KSwgV09SS0RJUigpLCBTVEFHRSgpXVxuICogYGBgXG4gKlxuICogRm9yIHRoZSBhcmd1bWVudHMsIHNlZSB0aGUgZG9jIHBhZ2VzIGZvciBbVFJFRV0oLi9UUkVFLm1kKSwgW1dPUktESVJdKC4vV09SS0RJUi5tZCksIGFuZCBbU1RBR0VdKC4vU1RBR0UubWQpLlxuICpcbiAqIGBtYXBgLCBgcmVkdWNlYCwgYW5kIGBpdGVyYXRlYCBhbGxvdyB5b3UgY29udHJvbCB0aGUgcmVjdXJzaXZlIHdhbGsgYnkgcHJ1bmluZyBhbmQgdHJhbnNmb3JtaW5nIGBXYWxrZXJFbnRyeWBzIGludG8gdGhlIGRlc2lyZWQgcmVzdWx0LlxuICpcbiAqICMjIFdhbGtlckVudHJ5XG4gKlxuICoge0BsaW5rIFdhbGtlckVudHJ5IHR5cGVkZWZ9XG4gKlxuICogYG1hcGAgcmVjZWl2ZXMgYW4gYXJyYXkgb2YgYFdhbGtlckVudHJ5W11gIGFzIGl0cyBtYWluIGFyZ3VtZW50LCBvbmUgYFdhbGtlckVudHJ5YCBmb3IgZWFjaCBgV2Fsa2VyYCBpbiB0aGUgYHRyZWVzYCBhcmd1bWVudC5cbiAqIFRoZSBtZXRob2RzIGFyZSBtZW1vaXplZCBwZXIgYFdhbGtlckVudHJ5YCBzbyBjYWxsaW5nIHRoZW0gbXVsdGlwbGUgdGltZXMgaW4gYSBgbWFwYCBmdW5jdGlvbiBkb2VzIG5vdCBhZHZlcnNlbHkgaW1wYWN0IHBlcmZvcm1hbmNlLlxuICogQnkgb25seSBjb21wdXRpbmcgdGhlc2UgdmFsdWVzIGlmIG5lZWRlZCwgeW91IGJ1aWxkIGNhbiBidWlsZCBsZWFuLCBtZWFuLCBlZmZpY2llbnQgd2Fsa2luZyBtYWNoaW5lcy5cbiAqXG4gKiAjIyMgV2Fsa2VyRW50cnkjdHlwZSgpXG4gKlxuICogUmV0dXJucyB0aGUga2luZCBhcyBhIHN0cmluZy4gVGhpcyBpcyBub3JtYWxseSBlaXRoZXIgYHRyZWVgIG9yIGBibG9iYC5cbiAqXG4gKiBgVFJFRWAsIGBTVEFHRWAsIGFuZCBgV09SS0RJUmAgd2Fsa2VycyBhbGwgcmV0dXJuIGEgc3RyaW5nLlxuICpcbiAqIFBvc3NpYmxlIHZhbHVlczpcbiAqXG4gKiAtIGAndHJlZSdgIGRpcmVjdG9yeVxuICogLSBgJ2Jsb2InYCBmaWxlXG4gKiAtIGAnc3BlY2lhbCdgIHVzZWQgYnkgYFdPUktESVJgIHRvIHJlcHJlc2VudCBpcnJlZ3VsYXIgZmlsZXMgbGlrZSBzb2NrZXRzIGFuZCBGSUZPc1xuICogLSBgJ2NvbW1pdCdgIHVzZWQgYnkgYFRSRUVgIHRvIHJlcHJlc2VudCBzdWJtb2R1bGVzXG4gKlxuICogYGBganNcbiAqIGF3YWl0IGVudHJ5LnR5cGUoKVxuICogYGBgXG4gKlxuICogIyMjIFdhbGtlckVudHJ5I21vZGUoKVxuICpcbiAqIFJldHVybnMgdGhlIGZpbGUgbW9kZSBhcyBhIG51bWJlci4gVXNlIHRoaXMgdG8gZGlzdGluZ3Vpc2ggYmV0d2VlbiByZWd1bGFyIGZpbGVzLCBzeW1saW5rcywgYW5kIGV4ZWN1dGFibGUgZmlsZXMuXG4gKlxuICogYFRSRUVgLCBgU1RBR0VgLCBhbmQgYFdPUktESVJgIHdhbGtlcnMgYWxsIHJldHVybiBhIG51bWJlciBmb3IgYWxsIGB0eXBlYHMgb2YgZW50cmllcy5cbiAqXG4gKiBJdCBoYXMgYmVlbiBub3JtYWxpemVkIHRvIG9uZSBvZiB0aGUgNCB2YWx1ZXMgdGhhdCBhcmUgYWxsb3dlZCBpbiBnaXQgY29tbWl0czpcbiAqXG4gKiAtIGAwbzQwMDAwYCBkaXJlY3RvcnlcbiAqIC0gYDBvMTAwNjQ0YCBmaWxlXG4gKiAtIGAwbzEwMDc1NWAgZmlsZSAoZXhlY3V0YWJsZSlcbiAqIC0gYDBvMTIwMDAwYCBzeW1saW5rXG4gKlxuICogVGlwOiB0byBtYWtlIG1vZGVzIG1vcmUgcmVhZGFibGUsIHlvdSBjYW4gcHJpbnQgdGhlbSB0byBvY3RhbCB1c2luZyBgLnRvU3RyaW5nKDgpYC5cbiAqXG4gKiBgYGBqc1xuICogYXdhaXQgZW50cnkubW9kZSgpXG4gKiBgYGBcbiAqXG4gKiAjIyMgV2Fsa2VyRW50cnkjb2lkKClcbiAqXG4gKiBSZXR1cm5zIHRoZSBTSEEtMSBvYmplY3QgaWQgZm9yIGJsb2JzIGFuZCB0cmVlcy5cbiAqXG4gKiBgVFJFRWAgd2Fsa2VycyByZXR1cm4gYSBzdHJpbmcgZm9yIGBibG9iYCBhbmQgYHRyZWVgIGVudHJpZXMuXG4gKlxuICogYFNUQUdFYCBhbmQgYFdPUktESVJgIHdhbGtlcnMgcmV0dXJuIGEgc3RyaW5nIGZvciBgYmxvYmAgZW50cmllcyBhbmQgYHVuZGVmaW5lZGAgZm9yIGB0cmVlYCBlbnRyaWVzLlxuICpcbiAqIGBgYGpzXG4gKiBhd2FpdCBlbnRyeS5vaWQoKVxuICogYGBgXG4gKlxuICogIyMjIFdhbGtlckVudHJ5I2NvbnRlbnQoKVxuICpcbiAqIFJldHVybnMgdGhlIGZpbGUgY29udGVudHMgYXMgYSBCdWZmZXIuXG4gKlxuICogYFRSRUVgIGFuZCBgV09SS0RJUmAgd2Fsa2VycyByZXR1cm4gYSBCdWZmZXIgZm9yIGBibG9iYCBlbnRyaWVzIGFuZCBgdW5kZWZpbmVkYCBmb3IgYHRyZWVgIGVudHJpZXMuXG4gKlxuICogYFNUQUdFYCB3YWxrZXJzIGFsd2F5cyByZXR1cm4gYHVuZGVmaW5lZGAgc2luY2UgdGhlIGZpbGUgY29udGVudHMgYXJlIG5ldmVyIHN0b3JlZCBpbiB0aGUgc3RhZ2UuXG4gKlxuICogYGBganNcbiAqIGF3YWl0IGVudHJ5LmNvbnRlbnQoKVxuICogYGBgXG4gKlxuICogIyMjIFdhbGtlckVudHJ5I3N0YXQoKVxuICpcbiAqIFJldHVybnMgYSBub3JtYWxpemVkIHN1YnNldCBvZiBmaWxlc3lzdGVtIFN0YXQgZGF0YS5cbiAqXG4gKiBgV09SS0RJUmAgd2Fsa2VycyByZXR1cm4gYSBgU3RhdGAgZm9yIGBibG9iYCBhbmQgYHRyZWVgIGVudHJpZXMuXG4gKlxuICogYFNUQUdFYCB3YWxrZXJzIHJldHVybiBhIGBTdGF0YCBmb3IgYGJsb2JgIGVudHJpZXMgYW5kIGB1bmRlZmluZWRgIGZvciBgdHJlZWAgZW50cmllcy5cbiAqXG4gKiBgVFJFRWAgd2Fsa2VycyByZXR1cm4gYHVuZGVmaW5lZGAgZm9yIGFsbCBlbnRyeSB0eXBlcy5cbiAqXG4gKiBgYGBqc1xuICogYXdhaXQgZW50cnkuc3RhdCgpXG4gKiBgYGBcbiAqXG4gKiB7QGxpbmsgU3RhdCB0eXBlZGVmfVxuICpcbiAqICMjIG1hcChzdHJpbmcsIEFycmF5PFdhbGtlckVudHJ5fG51bGw+KSA9PiBQcm9taXNlPGFueT5cbiAqXG4gKiB7QGxpbmsgV2Fsa2VyTWFwIHR5cGVkZWZ9XG4gKlxuICogVGhpcyBpcyB0aGUgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgb25jZSBwZXIgZW50cnkgQkVGT1JFIHZpc2l0aW5nIHRoZSBjaGlsZHJlbiBvZiB0aGF0IG5vZGUuXG4gKlxuICogSWYgeW91IHJldHVybiBgbnVsbGAgZm9yIGEgYHRyZWVgIGVudHJ5LCB0aGVuIG5vbmUgb2YgdGhlIGNoaWxkcmVuIG9mIHRoYXQgYHRyZWVgIGVudHJ5IHdpbGwgYmUgd2Fsa2VkLlxuICpcbiAqIFRoaXMgaXMgYSBnb29kIHBsYWNlIGZvciBxdWVyeSBsb2dpYywgc3VjaCBhcyBleGFtaW5pbmcgdGhlIGNvbnRlbnRzIG9mIGEgZmlsZS5cbiAqIFVsdGltYXRlbHksIGNvbXBhcmUgYWxsIHRoZSBlbnRyaWVzIGFuZCByZXR1cm4gYW55IHZhbHVlcyB5b3UgYXJlIGludGVyZXN0ZWQgaW4uXG4gKiBJZiB5b3UgZG8gbm90IHJldHVybiBhIHZhbHVlIChvciByZXR1cm4gdW5kZWZpbmVkKSB0aGF0IGVudHJ5IHdpbGwgYmUgZmlsdGVyZWQgZnJvbSB0aGUgcmVzdWx0cy5cbiAqXG4gKiBFeGFtcGxlIDE6IEZpbmQgYWxsIHRoZSBmaWxlcyBjb250YWluaW5nIHRoZSB3b3JkICdmb28nLlxuICogYGBganNcbiAqIGFzeW5jIGZ1bmN0aW9uIG1hcChmaWxlcGF0aCwgW2hlYWQsIHdvcmtkaXJdKSB7XG4gKiAgIGxldCBjb250ZW50ID0gKGF3YWl0IHdvcmtkaXIuY29udGVudCgpKS50b1N0cmluZygndXRmOCcpXG4gKiAgIGlmIChjb250ZW50LmNvbnRhaW5zKCdmb28nKSkge1xuICogICAgIHJldHVybiB7XG4gKiAgICAgICBmaWxlcGF0aCxcbiAqICAgICAgIGNvbnRlbnRcbiAqICAgICB9XG4gKiAgIH1cbiAqIH1cbiAqIGBgYFxuICpcbiAqIEV4YW1wbGUgMjogUmV0dXJuIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gdGhlIHdvcmtpbmcgZGlyZWN0b3J5IGFuZCB0aGUgSEVBRCBjb21taXRcbiAqIGBgYGpzXG4gKiBjb25zdCBkaWZmID0gcmVxdWlyZSgnZGlmZi1saW5lcycpXG4gKiBhc3luYyBmdW5jdGlvbiBtYXAoZmlsZXBhdGgsIFtoZWFkLCB3b3JrZGlyXSkge1xuICogICByZXR1cm4ge1xuICogICAgIGZpbGVwYXRoLFxuICogICAgIG9pZDogYXdhaXQgaGVhZC5vaWQoKSxcbiAqICAgICBkaWZmOiBkaWZmKChhd2FpdCBoZWFkLmNvbnRlbnQoKSkudG9TdHJpbmcoJ3V0ZjgnKSwgKGF3YWl0IHdvcmtkaXIuY29udGVudCgpKS50b1N0cmluZygndXRmOCcpKVxuICogICB9XG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBFeGFtcGxlIDM6XG4gKiBgYGBqc1xuICogbGV0IHBhdGggPSByZXF1aXJlKCdwYXRoJylcbiAqIC8vIE9ubHkgZXhhbWluZSBmaWxlcyBpbiB0aGUgZGlyZWN0b3J5IGBjd2RgXG4gKiBsZXQgY3dkID0gJ3NyYy9hcHAnXG4gKiBhc3luYyBmdW5jdGlvbiBtYXAgKGZpbGVwYXRoLCBbaGVhZCwgd29ya2Rpciwgc3RhZ2VdKSB7XG4gKiAgIGlmIChcbiAqICAgICAvLyBkb24ndCBza2lwIHRoZSByb290IGRpcmVjdG9yeVxuICogICAgIGhlYWQuZnVsbHBhdGggIT09ICcuJyAmJlxuICogICAgIC8vIHJldHVybiB0cnVlIGZvciAnc3JjJyBhbmQgJ3NyYy9hcHAnXG4gKiAgICAgIWN3ZC5zdGFydHNXaXRoKGZpbGVwYXRoKSAmJlxuICogICAgIC8vIHJldHVybiB0cnVlIGZvciAnc3JjL2FwcC8qJ1xuICogICAgIHBhdGguZGlybmFtZShmaWxlcGF0aCkgIT09IGN3ZFxuICogICApIHtcbiAqICAgICByZXR1cm4gbnVsbFxuICogICB9IGVsc2Uge1xuICogICAgIHJldHVybiBmaWxlcGF0aFxuICogICB9XG4gKiB9XG4gKiBgYGBcbiAqXG4gKiAjIyByZWR1Y2UocGFyZW50LCBjaGlsZHJlbilcbiAqXG4gKiB7QGxpbmsgV2Fsa2VyUmVkdWNlIHR5cGVkZWZ9XG4gKlxuICogVGhpcyBpcyB0aGUgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgb25jZSBwZXIgZW50cnkgQUZURVIgdmlzaXRpbmcgdGhlIGNoaWxkcmVuIG9mIHRoYXQgbm9kZS5cbiAqXG4gKiBEZWZhdWx0OiBgYXN5bmMgKHBhcmVudCwgY2hpbGRyZW4pID0+IHBhcmVudCA9PT0gdW5kZWZpbmVkID8gY2hpbGRyZW4uZmxhdCgpIDogW3BhcmVudCwgY2hpbGRyZW5dLmZsYXQoKWBcbiAqXG4gKiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGlzIGZ1bmN0aW9uIHJldHVybnMgYWxsIGRpcmVjdG9yaWVzIGFuZCBjaGlsZHJlbiBpbiBhIGdpYW50IGZsYXQgYXJyYXkuXG4gKiBZb3UgY2FuIGRlZmluZSBhIGRpZmZlcmVudCBhY2N1bXVsYXRpb24gbWV0aG9kIHRob3VnaC5cbiAqXG4gKiBFeGFtcGxlOiBSZXR1cm4gYSBoaWVyYXJjaGljYWwgc3RydWN0dXJlXG4gKiBgYGBqc1xuICogYXN5bmMgZnVuY3Rpb24gcmVkdWNlIChwYXJlbnQsIGNoaWxkcmVuKSB7XG4gKiAgIHJldHVybiBPYmplY3QuYXNzaWduKHBhcmVudCwgeyBjaGlsZHJlbiB9KVxuICogfVxuICogYGBgXG4gKlxuICogIyMgaXRlcmF0ZSh3YWxrLCBjaGlsZHJlbilcbiAqXG4gKiB7QGxpbmsgV2Fsa2VySXRlcmF0ZSB0eXBlZGVmfVxuICpcbiAqIHtAbGluayBXYWxrZXJJdGVyYXRlQ2FsbGJhY2sgdHlwZWRlZn1cbiAqXG4gKiBEZWZhdWx0OiBgKHdhbGssIGNoaWxkcmVuKSA9PiBQcm9taXNlLmFsbChbLi4uY2hpbGRyZW5dLm1hcCh3YWxrKSlgXG4gKlxuICogVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gcmVjdXJzZXMgYWxsIGNoaWxkcmVuIGNvbmN1cnJlbnRseSB1c2luZyBQcm9taXNlLmFsbC5cbiAqIEhvd2V2ZXIgeW91IGNvdWxkIHVzZSBhIGN1c3RvbSBmdW5jdGlvbiB0byB0cmF2ZXJzZSBjaGlsZHJlbiBzZXJpYWxseSBvciB1c2UgYSBnbG9iYWwgcXVldWUgdG8gdGhyb3R0bGUgcmVjdXJzaW9uLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBhcmdzXG4gKiBAcGFyYW0ge0ZzQ2xpZW50fSBhcmdzLmZzIC0gYSBmaWxlIHN5c3RlbSBjbGllbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5kaXJdIC0gVGhlIFt3b3JraW5nIHRyZWVdKGRpci12cy1naXRkaXIubWQpIGRpcmVjdG9yeSBwYXRoXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MuZ2l0ZGlyPWpvaW4oZGlyLCcuZ2l0JyldIC0gW3JlcXVpcmVkXSBUaGUgW2dpdCBkaXJlY3RvcnldKGRpci12cy1naXRkaXIubWQpIHBhdGhcbiAqIEBwYXJhbSB7V2Fsa2VyW119IGFyZ3MudHJlZXMgLSBUaGUgdHJlZXMgeW91IHdhbnQgdG8gdHJhdmVyc2VcbiAqIEBwYXJhbSB7V2Fsa2VyTWFwfSBbYXJncy5tYXBdIC0gVHJhbnNmb3JtIGBXYWxrZXJFbnRyeWBzIGludG8gYSByZXN1bHQgZm9ybVxuICogQHBhcmFtIHtXYWxrZXJSZWR1Y2V9IFthcmdzLnJlZHVjZV0gLSBDb250cm9sIGhvdyBtYXBwZWQgZW50cmllcyBhcmUgY29tYmluZWQgd2l0aCB0aGVpciBwYXJlbnQgcmVzdWx0XG4gKiBAcGFyYW0ge1dhbGtlckl0ZXJhdGV9IFthcmdzLml0ZXJhdGVdIC0gRmluZS10dW5lIGhvdyBlbnRyaWVzIHdpdGhpbiBhIHRyZWUgYXJlIGl0ZXJhdGVkIG92ZXJcbiAqIEBwYXJhbSB7b2JqZWN0fSBbYXJncy5jYWNoZV0gLSBhIFtjYWNoZV0oY2FjaGUubWQpIG9iamVjdFxuICpcbiAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59IFRoZSBmaW5pc2hlZCB0cmVlLXdhbGtpbmcgcmVzdWx0XG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHdhbGsoe1xuICBmcyxcbiAgZGlyLFxuICBnaXRkaXIgPSBqb2luKGRpciwgJy5naXQnKSxcbiAgdHJlZXMsXG4gIG1hcCxcbiAgcmVkdWNlLFxuICBpdGVyYXRlLFxuICBjYWNoZSA9IHt9LFxufSkge1xuICB0cnkge1xuICAgIGFzc2VydFBhcmFtZXRlcignZnMnLCBmcyk7XG4gICAgYXNzZXJ0UGFyYW1ldGVyKCdnaXRkaXInLCBnaXRkaXIpO1xuICAgIGFzc2VydFBhcmFtZXRlcigndHJlZXMnLCB0cmVlcyk7XG5cbiAgICByZXR1cm4gYXdhaXQgX3dhbGsoe1xuICAgICAgZnM6IG5ldyBGaWxlU3lzdGVtKGZzKSxcbiAgICAgIGNhY2hlLFxuICAgICAgZGlyLFxuICAgICAgZ2l0ZGlyLFxuICAgICAgdHJlZXMsXG4gICAgICBtYXAsXG4gICAgICByZWR1Y2UsXG4gICAgICBpdGVyYXRlLFxuICAgIH0pXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGVyci5jYWxsZXIgPSAnZ2l0LndhbGsnO1xuICAgIHRocm93IGVyclxuICB9XG59XG5cbi8vIEB0cy1jaGVja1xuXG4vKipcbiAqIFdyaXRlIGEgYmxvYiBvYmplY3QgZGlyZWN0bHlcbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gYXJnc1xuICogQHBhcmFtIHtGc0NsaWVudH0gYXJncy5mcyAtIGEgZmlsZSBzeXN0ZW0gY2xpZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MuZGlyXSAtIFRoZSBbd29ya2luZyB0cmVlXShkaXItdnMtZ2l0ZGlyLm1kKSBkaXJlY3RvcnkgcGF0aFxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLmdpdGRpcj1qb2luKGRpciwnLmdpdCcpXSAtIFtyZXF1aXJlZF0gVGhlIFtnaXQgZGlyZWN0b3J5XShkaXItdnMtZ2l0ZGlyLm1kKSBwYXRoXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGFyZ3MuYmxvYiAtIFRoZSBibG9iIG9iamVjdCB0byB3cml0ZVxuICpcbiAqIEByZXR1cm5zIHtQcm9taXNlPHN0cmluZz59IFJlc29sdmVzIHN1Y2Nlc3NmdWxseSB3aXRoIHRoZSBTSEEtMSBvYmplY3QgaWQgb2YgdGhlIG5ld2x5IHdyaXR0ZW4gb2JqZWN0XG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIE1hbnVhbGx5IGNyZWF0ZSBhIGJsb2IuXG4gKiBsZXQgb2lkID0gYXdhaXQgZ2l0LndyaXRlQmxvYih7XG4gKiAgIGZzLFxuICogICBkaXI6ICcvdHV0b3JpYWwnLFxuICogICBibG9iOiBuZXcgVWludDhBcnJheShbXSlcbiAqIH0pXG4gKlxuICogY29uc29sZS5sb2coJ29pZCcsIG9pZCkgLy8gc2hvdWxkIGJlICdlNjlkZTI5YmIyZDFkNjQzNGI4YjI5YWU3NzVhZDhjMmU0OGM1MzkxJ1xuICpcbiAqL1xuYXN5bmMgZnVuY3Rpb24gd3JpdGVCbG9iKHsgZnMsIGRpciwgZ2l0ZGlyID0gam9pbihkaXIsICcuZ2l0JyksIGJsb2IgfSkge1xuICB0cnkge1xuICAgIGFzc2VydFBhcmFtZXRlcignZnMnLCBmcyk7XG4gICAgYXNzZXJ0UGFyYW1ldGVyKCdnaXRkaXInLCBnaXRkaXIpO1xuICAgIGFzc2VydFBhcmFtZXRlcignYmxvYicsIGJsb2IpO1xuXG4gICAgcmV0dXJuIGF3YWl0IF93cml0ZU9iamVjdCh7XG4gICAgICBmczogbmV3IEZpbGVTeXN0ZW0oZnMpLFxuICAgICAgZ2l0ZGlyLFxuICAgICAgdHlwZTogJ2Jsb2InLFxuICAgICAgb2JqZWN0OiBibG9iLFxuICAgICAgZm9ybWF0OiAnY29udGVudCcsXG4gICAgfSlcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZXJyLmNhbGxlciA9ICdnaXQud3JpdGVCbG9iJztcbiAgICB0aHJvdyBlcnJcbiAgfVxufVxuXG4vLyBAdHMtY2hlY2tcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gYXJnc1xuICogQHBhcmFtIHtpbXBvcnQoJy4uL21vZGVscy9GaWxlU3lzdGVtLmpzJykuRmlsZVN5c3RlbX0gYXJncy5mc1xuICogQHBhcmFtIHtzdHJpbmd9IGFyZ3MuZ2l0ZGlyXG4gKiBAcGFyYW0ge0NvbW1pdE9iamVjdH0gYXJncy5jb21taXRcbiAqXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxzdHJpbmc+fVxuICogQHNlZSBDb21taXRPYmplY3RcbiAqXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIF93cml0ZUNvbW1pdCh7IGZzLCBnaXRkaXIsIGNvbW1pdCB9KSB7XG4gIC8vIENvbnZlcnQgb2JqZWN0IHRvIGJ1ZmZlclxuICBjb25zdCBvYmplY3QgPSBHaXRDb21taXQuZnJvbShjb21taXQpLnRvT2JqZWN0KCk7XG4gIGNvbnN0IG9pZCA9IGF3YWl0IF93cml0ZU9iamVjdCh7XG4gICAgZnMsXG4gICAgZ2l0ZGlyLFxuICAgIHR5cGU6ICdjb21taXQnLFxuICAgIG9iamVjdCxcbiAgICBmb3JtYXQ6ICdjb250ZW50JyxcbiAgfSk7XG4gIHJldHVybiBvaWRcbn1cblxuLy8gQHRzLWNoZWNrXG5cbi8qKlxuICogV3JpdGUgYSBjb21taXQgb2JqZWN0IGRpcmVjdGx5XG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGFyZ3NcbiAqIEBwYXJhbSB7RnNDbGllbnR9IGFyZ3MuZnMgLSBhIGZpbGUgc3lzdGVtIGNsaWVudFxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLmRpcl0gLSBUaGUgW3dvcmtpbmcgdHJlZV0oZGlyLXZzLWdpdGRpci5tZCkgZGlyZWN0b3J5IHBhdGhcbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5naXRkaXI9am9pbihkaXIsJy5naXQnKV0gLSBbcmVxdWlyZWRdIFRoZSBbZ2l0IGRpcmVjdG9yeV0oZGlyLXZzLWdpdGRpci5tZCkgcGF0aFxuICogQHBhcmFtIHtDb21taXRPYmplY3R9IGFyZ3MuY29tbWl0IC0gVGhlIG9iamVjdCB0byB3cml0ZVxuICpcbiAqIEByZXR1cm5zIHtQcm9taXNlPHN0cmluZz59IFJlc29sdmVzIHN1Y2Nlc3NmdWxseSB3aXRoIHRoZSBTSEEtMSBvYmplY3QgaWQgb2YgdGhlIG5ld2x5IHdyaXR0ZW4gb2JqZWN0XG4gKiBAc2VlIENvbW1pdE9iamVjdFxuICpcbiAqL1xuYXN5bmMgZnVuY3Rpb24gd3JpdGVDb21taXQoe1xuICBmcyxcbiAgZGlyLFxuICBnaXRkaXIgPSBqb2luKGRpciwgJy5naXQnKSxcbiAgY29tbWl0LFxufSkge1xuICB0cnkge1xuICAgIGFzc2VydFBhcmFtZXRlcignZnMnLCBmcyk7XG4gICAgYXNzZXJ0UGFyYW1ldGVyKCdnaXRkaXInLCBnaXRkaXIpO1xuICAgIGFzc2VydFBhcmFtZXRlcignY29tbWl0JywgY29tbWl0KTtcblxuICAgIHJldHVybiBhd2FpdCBfd3JpdGVDb21taXQoe1xuICAgICAgZnM6IG5ldyBGaWxlU3lzdGVtKGZzKSxcbiAgICAgIGdpdGRpcixcbiAgICAgIGNvbW1pdCxcbiAgICB9KVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBlcnIuY2FsbGVyID0gJ2dpdC53cml0ZUNvbW1pdCc7XG4gICAgdGhyb3cgZXJyXG4gIH1cbn1cblxuLy8gQHRzLWNoZWNrXG5cbi8qKlxuICogV3JpdGUgYSBnaXQgb2JqZWN0IGRpcmVjdGx5XG4gKlxuICogYGZvcm1hdGAgY2FuIGhhdmUgdGhlIGZvbGxvd2luZyB2YWx1ZXM6XG4gKlxuICogfCBwYXJhbSAgICAgIHwgZGVzY3JpcHRpb24gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiB8IC0tLS0tLS0tLS0gfCAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIHxcbiAqIHwgJ2RlZmxhdGVkJyB8IFRyZWF0IGBvYmplY3RgIGFzIHRoZSByYXcgZGVmbGF0ZS1jb21wcmVzc2VkIGJ1ZmZlciBmb3IgYW4gb2JqZWN0LCBtZWFuaW5nIGNhbiBiZSB3cml0dGVuIHRvIGAuZ2l0L29iamVjdHMvKipgIGFzLWlzLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiB8ICd3cmFwcGVkJyAgfCBUcmVhdCBgb2JqZWN0YCBhcyB0aGUgaW5mbGF0ZWQgb2JqZWN0IGJ1ZmZlciB3cmFwcGVkIGluIHRoZSBnaXQgb2JqZWN0IGhlYWRlci4gVGhpcyBpcyB0aGUgcmF3IGJ1ZmZlciB1c2VkIHdoZW4gY2FsY3VsYXRpbmcgdGhlIFNIQS0xIG9iamVjdCBpZCBvZiBhIGdpdCBvYmplY3QuIHxcbiAqIHwgJ2NvbnRlbnQnICB8IFRyZWF0IGBvYmplY3RgIGFzIHRoZSBvYmplY3QgYnVmZmVyIHdpdGhvdXQgdGhlIGdpdCBoZWFkZXIuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogfCAncGFyc2VkJyAgIHwgVHJlYXQgYG9iamVjdGAgYXMgYSBwYXJzZWQgcmVwcmVzZW50YXRpb24gb2YgdGhlIG9iamVjdC4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKlxuICogSWYgYGZvcm1hdGAgaXMgYCdwYXJzZWQnYCwgdGhlbiBgb2JqZWN0YCBtdXN0IG1hdGNoIG9uZSBvZiB0aGUgc2NoZW1hcyBmb3IgYENvbW1pdE9iamVjdGAsIGBUcmVlT2JqZWN0YCwgYFRhZ09iamVjdGAsIG9yIGEgYHN0cmluZ2AgKGZvciBibG9icykuXG4gKlxuICoge0BsaW5rIENvbW1pdE9iamVjdCB0eXBlZGVmfVxuICpcbiAqIHtAbGluayBUcmVlT2JqZWN0IHR5cGVkZWZ9XG4gKlxuICoge0BsaW5rIFRhZ09iamVjdCB0eXBlZGVmfVxuICpcbiAqIElmIGBmb3JtYXRgIGlzIGAnY29udGVudCdgLCBgJ3dyYXBwZWQnYCwgb3IgYCdkZWZsYXRlZCdgLCBgb2JqZWN0YCBzaG91bGQgYmUgYSBgVWludDhBcnJheWAuXG4gKlxuICogQGRlcHJlY2F0ZWRcbiAqID4gVGhpcyBjb21tYW5kIGlzIG92ZXJseSBjb21wbGljYXRlZC5cbiAqID5cbiAqID4gSWYgeW91IGtub3cgdGhlIHR5cGUgb2Ygb2JqZWN0IHlvdSBhcmUgd3JpdGluZywgdXNlIFtgd3JpdGVCbG9iYF0oLi93cml0ZUJsb2IubWQpLCBbYHdyaXRlQ29tbWl0YF0oLi93cml0ZUNvbW1pdC5tZCksIFtgd3JpdGVUYWdgXSguL3dyaXRlVGFnLm1kKSwgb3IgW2B3cml0ZVRyZWVgXSguL3dyaXRlVHJlZS5tZCkuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGFyZ3NcbiAqIEBwYXJhbSB7RnNDbGllbnR9IGFyZ3MuZnMgLSBhIGZpbGUgc3lzdGVtIGNsaWVudFxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLmRpcl0gLSBUaGUgW3dvcmtpbmcgdHJlZV0oZGlyLXZzLWdpdGRpci5tZCkgZGlyZWN0b3J5IHBhdGhcbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5naXRkaXI9am9pbihkaXIsJy5naXQnKV0gLSBbcmVxdWlyZWRdIFRoZSBbZ2l0IGRpcmVjdG9yeV0oZGlyLXZzLWdpdGRpci5tZCkgcGF0aFxuICogQHBhcmFtIHtzdHJpbmcgfCBVaW50OEFycmF5IHwgQ29tbWl0T2JqZWN0IHwgVHJlZU9iamVjdCB8IFRhZ09iamVjdH0gYXJncy5vYmplY3QgLSBUaGUgb2JqZWN0IHRvIHdyaXRlLlxuICogQHBhcmFtIHsnYmxvYid8J3RyZWUnfCdjb21taXQnfCd0YWcnfSBbYXJncy50eXBlXSAtIFRoZSBraW5kIG9mIG9iamVjdCB0byB3cml0ZS5cbiAqIEBwYXJhbSB7J2RlZmxhdGVkJyB8ICd3cmFwcGVkJyB8ICdjb250ZW50JyB8ICdwYXJzZWQnfSBbYXJncy5mb3JtYXQgPSAncGFyc2VkJ10gLSBXaGF0IGZvcm1hdCB0aGUgb2JqZWN0IGlzIGluLiBUaGUgcG9zc2libGUgY2hvaWNlcyBhcmUgbGlzdGVkIGJlbG93LlxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLm9pZF0gLSBJZiBgZm9ybWF0YCBpcyBgJ2RlZmxhdGVkJ2AgdGhlbiB0aGlzIHBhcmFtIGlzIHJlcXVpcmVkLiBPdGhlcndpc2UgaXQgaXMgY2FsY3VsYXRlZC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5lbmNvZGluZ10gLSBJZiBgdHlwZWAgaXMgYCdibG9iJ2AgdGhlbiBgb2JqZWN0YCB3aWxsIGJlIGNvbnZlcnRlZCB0byBhIFVpbnQ4QXJyYXkgdXNpbmcgYGVuY29kaW5nYC5cbiAqXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxzdHJpbmc+fSBSZXNvbHZlcyBzdWNjZXNzZnVsbHkgd2l0aCB0aGUgU0hBLTEgb2JqZWN0IGlkIG9mIHRoZSBuZXdseSB3cml0dGVuIG9iamVjdC5cbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gTWFudWFsbHkgY3JlYXRlIGFuIGFubm90YXRlZCB0YWcuXG4gKiBsZXQgc2hhID0gYXdhaXQgZ2l0LnJlc29sdmVSZWYoeyBmcywgZGlyOiAnL3R1dG9yaWFsJywgcmVmOiAnSEVBRCcgfSlcbiAqIGNvbnNvbGUubG9nKCdjb21taXQnLCBzaGEpXG4gKlxuICogbGV0IG9pZCA9IGF3YWl0IGdpdC53cml0ZU9iamVjdCh7XG4gKiAgIGZzLFxuICogICBkaXI6ICcvdHV0b3JpYWwnLFxuICogICB0eXBlOiAndGFnJyxcbiAqICAgb2JqZWN0OiB7XG4gKiAgICAgb2JqZWN0OiBzaGEsXG4gKiAgICAgdHlwZTogJ2NvbW1pdCcsXG4gKiAgICAgdGFnOiAnbXktdGFnJyxcbiAqICAgICB0YWdnZXI6IHtcbiAqICAgICAgIG5hbWU6ICd5b3VyIG5hbWUnLFxuICogICAgICAgZW1haWw6ICdlbWFpbEBleGFtcGxlLmNvbScsXG4gKiAgICAgICB0aW1lc3RhbXA6IE1hdGguZmxvb3IoRGF0ZS5ub3coKS8xMDAwKSxcbiAqICAgICAgIHRpbWV6b25lT2Zmc2V0OiBuZXcgRGF0ZSgpLmdldFRpbWV6b25lT2Zmc2V0KClcbiAqICAgICB9LFxuICogICAgIG1lc3NhZ2U6ICdPcHRpb25hbCBtZXNzYWdlJ1xuICogICB9XG4gKiB9KVxuICpcbiAqIGNvbnNvbGUubG9nKCd0YWcnLCBvaWQpXG4gKlxuICovXG5hc3luYyBmdW5jdGlvbiB3cml0ZU9iamVjdCh7XG4gIGZzOiBfZnMsXG4gIGRpcixcbiAgZ2l0ZGlyID0gam9pbihkaXIsICcuZ2l0JyksXG4gIHR5cGUsXG4gIG9iamVjdCxcbiAgZm9ybWF0ID0gJ3BhcnNlZCcsXG4gIG9pZCxcbiAgZW5jb2RpbmcgPSB1bmRlZmluZWQsXG59KSB7XG4gIHRyeSB7XG4gICAgY29uc3QgZnMgPSBuZXcgRmlsZVN5c3RlbShfZnMpO1xuICAgIC8vIENvbnZlcnQgb2JqZWN0IHRvIGJ1ZmZlclxuICAgIGlmIChmb3JtYXQgPT09ICdwYXJzZWQnKSB7XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSAnY29tbWl0JzpcbiAgICAgICAgICBvYmplY3QgPSBHaXRDb21taXQuZnJvbShvYmplY3QpLnRvT2JqZWN0KCk7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAndHJlZSc6XG4gICAgICAgICAgb2JqZWN0ID0gR2l0VHJlZS5mcm9tKG9iamVjdCkudG9PYmplY3QoKTtcbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlICdibG9iJzpcbiAgICAgICAgICBvYmplY3QgPSBCdWZmZXIuZnJvbShvYmplY3QsIGVuY29kaW5nKTtcbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlICd0YWcnOlxuICAgICAgICAgIG9iamVjdCA9IEdpdEFubm90YXRlZFRhZy5mcm9tKG9iamVjdCkudG9PYmplY3QoKTtcbiAgICAgICAgICBicmVha1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBPYmplY3RUeXBlRXJyb3Iob2lkIHx8ICcnLCB0eXBlLCAnYmxvYnxjb21taXR8dGFnfHRyZWUnKVxuICAgICAgfVxuICAgICAgLy8gR2l0T2JqZWN0TWFuYWdlciBkb2VzIG5vdCBrbm93IGhvdyB0byBzZXJpYWxpemUgY29udGVudCwgc28gd2UgdHdlYWsgdGhhdCBwYXJhbWV0ZXIgYmVmb3JlIHBhc3NpbmcgaXQuXG4gICAgICBmb3JtYXQgPSAnY29udGVudCc7XG4gICAgfVxuICAgIG9pZCA9IGF3YWl0IF93cml0ZU9iamVjdCh7XG4gICAgICBmcyxcbiAgICAgIGdpdGRpcixcbiAgICAgIHR5cGUsXG4gICAgICBvYmplY3QsXG4gICAgICBvaWQsXG4gICAgICBmb3JtYXQsXG4gICAgfSk7XG4gICAgcmV0dXJuIG9pZFxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBlcnIuY2FsbGVyID0gJ2dpdC53cml0ZU9iamVjdCc7XG4gICAgdGhyb3cgZXJyXG4gIH1cbn1cblxuLy8gQHRzLWNoZWNrXG5cbi8qKlxuICogV3JpdGUgYSByZWYgd2hpY2ggcmVmZXJzIHRvIHRoZSBzcGVjaWZpZWQgU0hBLTEgb2JqZWN0IGlkLCBvciBhIHN5bWJvbGljIHJlZiB3aGljaCByZWZlcnMgdG8gdGhlIHNwZWNpZmllZCByZWYuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGFyZ3NcbiAqIEBwYXJhbSB7RnNDbGllbnR9IGFyZ3MuZnMgLSBhIGZpbGUgc3lzdGVtIGNsaWVudFxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLmRpcl0gLSBUaGUgW3dvcmtpbmcgdHJlZV0oZGlyLXZzLWdpdGRpci5tZCkgZGlyZWN0b3J5IHBhdGhcbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5naXRkaXI9am9pbihkaXIsJy5naXQnKV0gLSBbcmVxdWlyZWRdIFRoZSBbZ2l0IGRpcmVjdG9yeV0oZGlyLXZzLWdpdGRpci5tZCkgcGF0aFxuICogQHBhcmFtIHtzdHJpbmd9IGFyZ3MucmVmIC0gVGhlIG5hbWUgb2YgdGhlIHJlZiB0byB3cml0ZVxuICogQHBhcmFtIHtzdHJpbmd9IGFyZ3MudmFsdWUgLSBXaGVuIGBzeW1ib2xpY2AgaXMgZmFsc2UsIGEgcmVmIG9yIGFuIFNIQS0xIG9iamVjdCBpZC4gV2hlbiB0cnVlLCBhIHJlZiBzdGFydGluZyB3aXRoIGByZWZzL2AuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFthcmdzLmZvcmNlID0gZmFsc2VdIC0gSW5zdGVhZCBvZiB0aHJvd2luZyBhbiBlcnJvciBpZiBhIHJlZiBuYW1lZCBgcmVmYCBhbHJlYWR5IGV4aXN0cywgb3ZlcndyaXRlIHRoZSBleGlzdGluZyByZWYuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFthcmdzLnN5bWJvbGljID0gZmFsc2VdIC0gV2hldGhlciB0aGUgcmVmIGlzIHN5bWJvbGljIG9yIG5vdC5cbiAqXG4gKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn0gUmVzb2x2ZXMgc3VjY2Vzc2Z1bGx5IHdoZW4gZmlsZXN5c3RlbSBvcGVyYXRpb25zIGFyZSBjb21wbGV0ZVxuICpcbiAqIEBleGFtcGxlXG4gKiBhd2FpdCBnaXQud3JpdGVSZWYoe1xuICogICBmcyxcbiAqICAgZGlyOiAnL3R1dG9yaWFsJyxcbiAqICAgcmVmOiAncmVmcy9oZWFkcy9hbm90aGVyLWJyYW5jaCcsXG4gKiAgIHZhbHVlOiAnSEVBRCdcbiAqIH0pXG4gKiBhd2FpdCBnaXQud3JpdGVSZWYoe1xuICogICBmcyxcbiAqICAgZGlyOiAnL3R1dG9yaWFsJyxcbiAqICAgcmVmOiAnSEVBRCcsXG4gKiAgIHZhbHVlOiAncmVmcy9oZWFkcy9hbm90aGVyLWJyYW5jaCcsXG4gKiAgIGZvcmNlOiB0cnVlLFxuICogICBzeW1ib2xpYzogdHJ1ZVxuICogfSlcbiAqIGNvbnNvbGUubG9nKCdkb25lJylcbiAqXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHdyaXRlUmVmKHtcbiAgZnM6IF9mcyxcbiAgZGlyLFxuICBnaXRkaXIgPSBqb2luKGRpciwgJy5naXQnKSxcbiAgcmVmLFxuICB2YWx1ZSxcbiAgZm9yY2UgPSBmYWxzZSxcbiAgc3ltYm9saWMgPSBmYWxzZSxcbn0pIHtcbiAgdHJ5IHtcbiAgICBhc3NlcnRQYXJhbWV0ZXIoJ2ZzJywgX2ZzKTtcbiAgICBhc3NlcnRQYXJhbWV0ZXIoJ2dpdGRpcicsIGdpdGRpcik7XG4gICAgYXNzZXJ0UGFyYW1ldGVyKCdyZWYnLCByZWYpO1xuICAgIGFzc2VydFBhcmFtZXRlcigndmFsdWUnLCB2YWx1ZSk7XG5cbiAgICBjb25zdCBmcyA9IG5ldyBGaWxlU3lzdGVtKF9mcyk7XG5cbiAgICBpZiAocmVmICE9PSBjbGVhbkdpdFJlZi5jbGVhbihyZWYpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZFJlZk5hbWVFcnJvcihyZWYsIGNsZWFuR2l0UmVmLmNsZWFuKHJlZikpXG4gICAgfVxuXG4gICAgaWYgKCFmb3JjZSAmJiAoYXdhaXQgR2l0UmVmTWFuYWdlci5leGlzdHMoeyBmcywgZ2l0ZGlyLCByZWYgfSkpKSB7XG4gICAgICB0aHJvdyBuZXcgQWxyZWFkeUV4aXN0c0Vycm9yKCdyZWYnLCByZWYpXG4gICAgfVxuXG4gICAgaWYgKHN5bWJvbGljKSB7XG4gICAgICBhd2FpdCBHaXRSZWZNYW5hZ2VyLndyaXRlU3ltYm9saWNSZWYoe1xuICAgICAgICBmcyxcbiAgICAgICAgZ2l0ZGlyLFxuICAgICAgICByZWYsXG4gICAgICAgIHZhbHVlLFxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlID0gYXdhaXQgR2l0UmVmTWFuYWdlci5yZXNvbHZlKHtcbiAgICAgICAgZnMsXG4gICAgICAgIGdpdGRpcixcbiAgICAgICAgcmVmOiB2YWx1ZSxcbiAgICAgIH0pO1xuICAgICAgYXdhaXQgR2l0UmVmTWFuYWdlci53cml0ZVJlZih7XG4gICAgICAgIGZzLFxuICAgICAgICBnaXRkaXIsXG4gICAgICAgIHJlZixcbiAgICAgICAgdmFsdWUsXG4gICAgICB9KTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGVyci5jYWxsZXIgPSAnZ2l0LndyaXRlUmVmJztcbiAgICB0aHJvdyBlcnJcbiAgfVxufVxuXG4vLyBAdHMtY2hlY2tcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gYXJnc1xuICogQHBhcmFtIHtpbXBvcnQoJy4uL21vZGVscy9GaWxlU3lzdGVtLmpzJykuRmlsZVN5c3RlbX0gYXJncy5mc1xuICogQHBhcmFtIHtzdHJpbmd9IGFyZ3MuZ2l0ZGlyXG4gKiBAcGFyYW0ge1RhZ09iamVjdH0gYXJncy50YWdcbiAqXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxzdHJpbmc+fVxuICovXG5hc3luYyBmdW5jdGlvbiBfd3JpdGVUYWcoeyBmcywgZ2l0ZGlyLCB0YWcgfSkge1xuICAvLyBDb252ZXJ0IG9iamVjdCB0byBidWZmZXJcbiAgY29uc3Qgb2JqZWN0ID0gR2l0QW5ub3RhdGVkVGFnLmZyb20odGFnKS50b09iamVjdCgpO1xuICBjb25zdCBvaWQgPSBhd2FpdCBfd3JpdGVPYmplY3Qoe1xuICAgIGZzLFxuICAgIGdpdGRpcixcbiAgICB0eXBlOiAndGFnJyxcbiAgICBvYmplY3QsXG4gICAgZm9ybWF0OiAnY29udGVudCcsXG4gIH0pO1xuICByZXR1cm4gb2lkXG59XG5cbi8vIEB0cy1jaGVja1xuXG4vKipcbiAqIFdyaXRlIGFuIGFubm90YXRlZCB0YWcgb2JqZWN0IGRpcmVjdGx5XG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGFyZ3NcbiAqIEBwYXJhbSB7RnNDbGllbnR9IGFyZ3MuZnMgLSBhIGZpbGUgc3lzdGVtIGNsaWVudFxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLmRpcl0gLSBUaGUgW3dvcmtpbmcgdHJlZV0oZGlyLXZzLWdpdGRpci5tZCkgZGlyZWN0b3J5IHBhdGhcbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5naXRkaXI9am9pbihkaXIsJy5naXQnKV0gLSBbcmVxdWlyZWRdIFRoZSBbZ2l0IGRpcmVjdG9yeV0oZGlyLXZzLWdpdGRpci5tZCkgcGF0aFxuICogQHBhcmFtIHtUYWdPYmplY3R9IGFyZ3MudGFnIC0gVGhlIG9iamVjdCB0byB3cml0ZVxuICpcbiAqIEByZXR1cm5zIHtQcm9taXNlPHN0cmluZz59IFJlc29sdmVzIHN1Y2Nlc3NmdWxseSB3aXRoIHRoZSBTSEEtMSBvYmplY3QgaWQgb2YgdGhlIG5ld2x5IHdyaXR0ZW4gb2JqZWN0XG4gKiBAc2VlIFRhZ09iamVjdFxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBNYW51YWxseSBjcmVhdGUgYW4gYW5ub3RhdGVkIHRhZy5cbiAqIGxldCBzaGEgPSBhd2FpdCBnaXQucmVzb2x2ZVJlZih7IGZzLCBkaXI6ICcvdHV0b3JpYWwnLCByZWY6ICdIRUFEJyB9KVxuICogY29uc29sZS5sb2coJ2NvbW1pdCcsIHNoYSlcbiAqXG4gKiBsZXQgb2lkID0gYXdhaXQgZ2l0LndyaXRlVGFnKHtcbiAqICAgZnMsXG4gKiAgIGRpcjogJy90dXRvcmlhbCcsXG4gKiAgIHRhZzoge1xuICogICAgIG9iamVjdDogc2hhLFxuICogICAgIHR5cGU6ICdjb21taXQnLFxuICogICAgIHRhZzogJ215LXRhZycsXG4gKiAgICAgdGFnZ2VyOiB7XG4gKiAgICAgICBuYW1lOiAneW91ciBuYW1lJyxcbiAqICAgICAgIGVtYWlsOiAnZW1haWxAZXhhbXBsZS5jb20nLFxuICogICAgICAgdGltZXN0YW1wOiBNYXRoLmZsb29yKERhdGUubm93KCkvMTAwMCksXG4gKiAgICAgICB0aW1lem9uZU9mZnNldDogbmV3IERhdGUoKS5nZXRUaW1lem9uZU9mZnNldCgpXG4gKiAgICAgfSxcbiAqICAgICBtZXNzYWdlOiAnT3B0aW9uYWwgbWVzc2FnZSdcbiAqICAgfVxuICogfSlcbiAqXG4gKiBjb25zb2xlLmxvZygndGFnJywgb2lkKVxuICpcbiAqL1xuYXN5bmMgZnVuY3Rpb24gd3JpdGVUYWcoeyBmcywgZGlyLCBnaXRkaXIgPSBqb2luKGRpciwgJy5naXQnKSwgdGFnIH0pIHtcbiAgdHJ5IHtcbiAgICBhc3NlcnRQYXJhbWV0ZXIoJ2ZzJywgZnMpO1xuICAgIGFzc2VydFBhcmFtZXRlcignZ2l0ZGlyJywgZ2l0ZGlyKTtcbiAgICBhc3NlcnRQYXJhbWV0ZXIoJ3RhZycsIHRhZyk7XG5cbiAgICByZXR1cm4gYXdhaXQgX3dyaXRlVGFnKHtcbiAgICAgIGZzOiBuZXcgRmlsZVN5c3RlbShmcyksXG4gICAgICBnaXRkaXIsXG4gICAgICB0YWcsXG4gICAgfSlcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZXJyLmNhbGxlciA9ICdnaXQud3JpdGVUYWcnO1xuICAgIHRocm93IGVyclxuICB9XG59XG5cbi8vIEB0cy1jaGVja1xuXG4vKipcbiAqIFdyaXRlIGEgdHJlZSBvYmplY3QgZGlyZWN0bHlcbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gYXJnc1xuICogQHBhcmFtIHtGc0NsaWVudH0gYXJncy5mcyAtIGEgZmlsZSBzeXN0ZW0gY2xpZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MuZGlyXSAtIFRoZSBbd29ya2luZyB0cmVlXShkaXItdnMtZ2l0ZGlyLm1kKSBkaXJlY3RvcnkgcGF0aFxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLmdpdGRpcj1qb2luKGRpciwnLmdpdCcpXSAtIFtyZXF1aXJlZF0gVGhlIFtnaXQgZGlyZWN0b3J5XShkaXItdnMtZ2l0ZGlyLm1kKSBwYXRoXG4gKiBAcGFyYW0ge1RyZWVPYmplY3R9IGFyZ3MudHJlZSAtIFRoZSBvYmplY3QgdG8gd3JpdGVcbiAqXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxzdHJpbmc+fSBSZXNvbHZlcyBzdWNjZXNzZnVsbHkgd2l0aCB0aGUgU0hBLTEgb2JqZWN0IGlkIG9mIHRoZSBuZXdseSB3cml0dGVuIG9iamVjdC5cbiAqIEBzZWUgVHJlZU9iamVjdFxuICogQHNlZSBUcmVlRW50cnlcbiAqXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHdyaXRlVHJlZSh7IGZzLCBkaXIsIGdpdGRpciA9IGpvaW4oZGlyLCAnLmdpdCcpLCB0cmVlIH0pIHtcbiAgdHJ5IHtcbiAgICBhc3NlcnRQYXJhbWV0ZXIoJ2ZzJywgZnMpO1xuICAgIGFzc2VydFBhcmFtZXRlcignZ2l0ZGlyJywgZ2l0ZGlyKTtcbiAgICBhc3NlcnRQYXJhbWV0ZXIoJ3RyZWUnLCB0cmVlKTtcblxuICAgIHJldHVybiBhd2FpdCBfd3JpdGVUcmVlKHtcbiAgICAgIGZzOiBuZXcgRmlsZVN5c3RlbShmcyksXG4gICAgICBnaXRkaXIsXG4gICAgICB0cmVlLFxuICAgIH0pXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGVyci5jYWxsZXIgPSAnZ2l0LndyaXRlVHJlZSc7XG4gICAgdGhyb3cgZXJyXG4gIH1cbn1cblxuLy8gZGVmYXVsdCBleHBvcnRcbnZhciBpbmRleCA9IHtcbiAgRXJyb3JzLFxuICBTVEFHRSxcbiAgVFJFRSxcbiAgV09SS0RJUixcbiAgYWRkLFxuICBhZGROb3RlLFxuICBhZGRSZW1vdGUsXG4gIGFubm90YXRlZFRhZyxcbiAgYnJhbmNoLFxuICBjaGVja291dCxcbiAgY2xvbmUsXG4gIGNvbW1pdCxcbiAgZ2V0Q29uZmlnLFxuICBnZXRDb25maWdBbGwsXG4gIHNldENvbmZpZyxcbiAgY3VycmVudEJyYW5jaCxcbiAgZGVsZXRlQnJhbmNoLFxuICBkZWxldGVSZWYsXG4gIGRlbGV0ZVJlbW90ZSxcbiAgZGVsZXRlVGFnLFxuICBleHBhbmRPaWQsXG4gIGV4cGFuZFJlZixcbiAgZmFzdEZvcndhcmQsXG4gIGZldGNoLFxuICBmaW5kTWVyZ2VCYXNlLFxuICBmaW5kUm9vdCxcbiAgZ2V0UmVtb3RlSW5mbyxcbiAgZ2V0UmVtb3RlSW5mbzIsXG4gIGhhc2hCbG9iLFxuICBpbmRleFBhY2ssXG4gIGluaXQsXG4gIGlzRGVzY2VuZGVudCxcbiAgbGlzdEJyYW5jaGVzLFxuICBsaXN0RmlsZXMsXG4gIGxpc3ROb3RlcyxcbiAgbGlzdFJlbW90ZXMsXG4gIGxpc3RTZXJ2ZXJSZWZzLFxuICBsaXN0VGFncyxcbiAgbG9nLFxuICBtZXJnZSxcbiAgcGFja09iamVjdHMsXG4gIHB1bGwsXG4gIHB1c2gsXG4gIHJlYWRCbG9iLFxuICByZWFkQ29tbWl0LFxuICByZWFkTm90ZSxcbiAgcmVhZE9iamVjdCxcbiAgcmVhZFRhZyxcbiAgcmVhZFRyZWUsXG4gIHJlbW92ZSxcbiAgcmVtb3ZlTm90ZSxcbiAgcmVuYW1lQnJhbmNoLFxuICByZXNldEluZGV4LFxuICByZXNvbHZlUmVmLFxuICBzdGF0dXMsXG4gIHN0YXR1c01hdHJpeCxcbiAgdGFnLFxuICB2ZXJzaW9uLFxuICB3YWxrLFxuICB3cml0ZUJsb2IsXG4gIHdyaXRlQ29tbWl0LFxuICB3cml0ZU9iamVjdCxcbiAgd3JpdGVSZWYsXG4gIHdyaXRlVGFnLFxuICB3cml0ZVRyZWUsXG59O1xuXG5leHBvcnQgZGVmYXVsdCBpbmRleDtcbmV4cG9ydCB7IEVycm9ycywgU1RBR0UsIFRSRUUsIFdPUktESVIsIGFkZCwgYWRkTm90ZSwgYWRkUmVtb3RlLCBhbm5vdGF0ZWRUYWcsIGJyYW5jaCwgY2hlY2tvdXQsIGNsb25lLCBjb21taXQsIGN1cnJlbnRCcmFuY2gsIGRlbGV0ZUJyYW5jaCwgZGVsZXRlUmVmLCBkZWxldGVSZW1vdGUsIGRlbGV0ZVRhZywgZXhwYW5kT2lkLCBleHBhbmRSZWYsIGZhc3RGb3J3YXJkLCBmZXRjaCwgZmluZE1lcmdlQmFzZSwgZmluZFJvb3QsIGdldENvbmZpZywgZ2V0Q29uZmlnQWxsLCBnZXRSZW1vdGVJbmZvLCBnZXRSZW1vdGVJbmZvMiwgaGFzaEJsb2IsIGluZGV4UGFjaywgaW5pdCwgaXNEZXNjZW5kZW50LCBsaXN0QnJhbmNoZXMsIGxpc3RGaWxlcywgbGlzdE5vdGVzLCBsaXN0UmVtb3RlcywgbGlzdFNlcnZlclJlZnMsIGxpc3RUYWdzLCBsb2csIG1lcmdlLCBwYWNrT2JqZWN0cywgcHVsbCwgcHVzaCwgcmVhZEJsb2IsIHJlYWRDb21taXQsIHJlYWROb3RlLCByZWFkT2JqZWN0LCByZWFkVGFnLCByZWFkVHJlZSwgcmVtb3ZlLCByZW1vdmVOb3RlLCByZW5hbWVCcmFuY2gsIHJlc2V0SW5kZXgsIHJlc29sdmVSZWYsIHNldENvbmZpZywgc3RhdHVzLCBzdGF0dXNNYXRyaXgsIHRhZywgdmVyc2lvbiwgd2Fsaywgd3JpdGVCbG9iLCB3cml0ZUNvbW1pdCwgd3JpdGVPYmplY3QsIHdyaXRlUmVmLCB3cml0ZVRhZywgd3JpdGVUcmVlIH07XG4iLCJpbXBvcnQge1xuICAvKiBBcHAsXG4gIEJ1dHRvbkNvbXBvbmVudCxcbiAgTW9kYWwsXG4gIE5vdGljZSwgKi9cbiAgUGx1Z2luLFxuICAvKiBQbHVnaW5TZXR0aW5nVGFiLFxuICBTZXR0aW5nLFxuICBUZXh0Q29tcG9uZW50LCAqL1xuICBhZGRJY29uLFxufSBmcm9tIFwib2JzaWRpYW5cIjtcbmltcG9ydCBnaXQgZnJvbSBcImlzb21vcnBoaWMtZ2l0XCI7XG4vL2ltcG9ydCBodHRwIGZyb20gXCJpc29tb3JwaGljLWdpdC9odHRwL25vZGVcIjtcbmltcG9ydCBcIi4vc3R5bGVzL21haW4uc2Nzc1wiO1xuY29uc3QgZnMgPSByZXF1aXJlKFwiZnNcIik7XG5jb25zdCBwYXRoID0gcmVxdWlyZShcInBhdGhcIik7XG5jb25zdCB1dGlsID0gcmVxdWlyZShcInV0aWxcIik7XG5cbmNvbnN0IGxzdGF0ID0gdXRpbC5wcm9taXNpZnkoZnMubHN0YXQpO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBHaXRTdG9yZSBleHRlbmRzIFBsdWdpbiB7XG4gIC8vQHRzLWlnbm9yZVxuICBwcml2YXRlIEJBU0VQQVRIOiBzdHJpbmcgPSB0aGlzLmFwcC52YXVsdC5hZGFwdGVyLmJhc2VQYXRoO1xuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhpcyB2YXVsdCBjb250YWlucyBhIC5naXQgZm9sZGVyXG4gICAqIEByZXR1cm5zIGJvb2xlYW5cbiAgICovXG4gIGFzeW5jIGdpdElzSW5pdGlhbGl6ZWQoKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGdpdERpciA9IHBhdGguam9pbih0aGlzLkJBU0VQQVRILCBcIi5naXRcIik7XG4gICAgICBpZiAoZnMuZXhpc3RzU3luYyhnaXREaXIpKSB7XG4gICAgICAgIGNvbnN0IHN0YXRzID0gYXdhaXQgbHN0YXQoZ2l0RGlyKTtcbiAgICAgICAgY29uc3QgaXNJbml0ID0gc3RhdHMuaXNEaXJlY3RvcnkoKTtcbiAgICAgICAgY29uc29sZS5sb2coXCJnaXQgaW5pdFwiLCBpc0luaXQpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUud2FybihlcnIpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGluaXRHaXQoKSB7XG4gICAgYXdhaXQgZ2l0LmluaXQoeyBmcywgZGlyOiB0aGlzLkJBU0VQQVRIIH0pO1xuICB9XG5cbiAgYXN5bmMgb25sb2FkKCkge1xuICAgIGNvbnNvbGUubG9nKFwiTG9hZGluZyBnaXQgc3RvcmUuXCIpO1xuICAgIGFkZEljb24oXG4gICAgICBcImdpdC1jb21wYXJlXCIsXG4gICAgICBgPHN2ZyBpZz1cImdpdC1jb21wYXJlXCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHZpZXdCb3g9XCIwIDAgNTEyIDUxMlwiPjxwYXRoIGQ9XCJNMTAyLjQgNTEuMnYyNS42YzE0LjEgMCAyNS42IDExLjUgMjUuNiAyNS42IDAgMTQuMS0xMS41IDI1LjYtMjUuNiAyNS42LTE0LjEgMC0yNS42LTExLjUtMjUuNi0yNS42IDAtMTQuMSAxMS41LTI1LjYgMjUuNi0yNS42VjI1LjZDNjAgMjUuNiAyNS42IDYwIDI1LjYgMTAyLjRzMzQuNCA3Ni44IDc2LjggNzYuOCA3Ni44LTM0LjQgNzYuOC03Ni44LTM0LjQtNzYuOC03Ni44LTc2Ljh2MjUuNnpNNDA5LjYgMzU4LjRWMzg0YzE0LjEgMCAyNS42IDExLjUgMjUuNiAyNS42IDAgMTQuMS0xMS41IDI1LjYtMjUuNiAyNS42LTE0LjEgMC0yNS42LTExLjUtMjUuNi0yNS42IDAtMTQuMSAxMS41LTI1LjYgMjUuNi0yNS42di01MS4yYy00Mi40IDAtNzYuOCAzNC40LTc2LjggNzYuOHMzNC40IDc2LjggNzYuOCA3Ni44IDc2LjgtMzQuNCA3Ni44LTc2LjgtMzQuNC03Ni44LTc2LjgtNzYuOHYyNS42elwiLz48cGF0aCBkPVwiTTIzMC40IDEyOGgxMjhjMTQuMSAwIDI1LjYgMTEuNSAyNS42IDI1LjZ2MjA0LjhjMCAxNC4xIDExLjUgMjUuNiAyNS42IDI1LjZzMjUuNi0xMS41IDI1LjYtMjUuNlYxNTMuNmMwLTQyLjQtMzQuNC03Ni44LTc2LjgtNzYuOGgtMTI4Yy0xNC4xIDAtMjUuNiAxMS41LTI1LjYgMjUuNiAwIDE0LjEgMTEuNSAyNS42IDI1LjYgMjUuNnpcIi8+PHBhdGggZD1cIk0zMjUuMyAxNjEuMWwtNTguNy01OC43IDU4LjctNTguN2MxMC0xMCAxMC0yNi4yIDAtMzYuMi0xMC0xMC0yNi4yLTEwLTM2LjIgMGwtNzYuOCA3Ni44Yy00LjggNC44LTcuNSAxMS40LTcuNSAxOC4xIDAgNi43IDIuNyAxMy4zIDcuNSAxOC4xbDc2LjggNzYuOGMxMCAxMCAyNi4yIDEwIDM2LjIgMCAxMC0xMCAxMC0yNi4yIDAtMzYuMnpNMjgxLjYgMzg0aC0xMjhjLTE0LjEgMC0yNS42LTExLjUtMjUuNi0yNS42VjE1My42YzAtMTQuMS0xMS41LTI1LjYtMjUuNi0yNS42LTE0LjEgMC0yNS42IDExLjUtMjUuNiAyNS42djIwNC44YzAgNDIuNCAzNC40IDc2LjggNzYuOCA3Ni44aDEyOGMxNC4xIDAgMjUuNi0xMS41IDI1LjYtMjUuNiAwLTE0LjEtMTEuNS0yNS42LTI1LjYtMjUuNnpcIi8+PHBhdGggZD1cIk0xODYuNyAzNTAuOWw1OC43IDU4LjctNTguNyA1OC43Yy0xMCAxMC0xMCAyNi4yIDAgMzYuMiAxMCAxMCAyNi4yIDEwIDM2LjIgMGw3Ni44LTc2LjhjNC44LTQuOCA3LjUtMTEuNCA3LjUtMTguMSAwLTYuNy0yLjctMTMuMy03LjUtMTguMWwtNzYuOC03Ni44Yy0xMC0xMC0yNi4yLTEwLTM2LjIgMC0xMCAxMC0xMCAyNi4yIDAgMzYuMnpcIi8+PC9zdmc+YFxuICAgICk7XG4gICAgdGhpcy5hZGRSaWJib25JY29uKFwiZ2l0LWNvbXBhcmVcIiwgXCJnaXQgc3luY1wiLCAoZXZlKSA9PiB7XG4gICAgICBjb25zb2xlLmxvZyhldmUpO1xuICAgIH0pO1xuICAgIGNvbnN0IGdpdFJlYWR5ID0gYXdhaXQgdGhpcy5naXRJc0luaXRpYWxpemVkKCk7XG4gICAgaWYgKCFnaXRSZWFkeSkge1xuICAgICAgdGhpcy5pbml0R2l0KCk7XG4gICAgfVxuXG4gICAgbGV0IHN0YXR1cyA9IGF3YWl0IGdpdC5zdGF0dXMoe1xuICAgICAgZnMsXG4gICAgICBkaXI6IHRoaXMuQkFTRVBBVEgsXG4gICAgICBmaWxlcGF0aDogXCJyZWFkbWUubWRcIixcbiAgICB9KTtcbiAgICBjb25zb2xlLmxvZyhzdGF0dXMpO1xuICAgIGNvbnNvbGUubG9nKHRoaXMuQkFTRVBBVEgpO1xuICAgIC8qIHRoaXMucmVnaXN0ZXJPYnNpZGlhblByb3RvY29sSGFuZGxlcihcIm9wZW5cIiwgKCk9PntcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdvdmVycmlkZW4gb3BlbiBvYnNpZGlhbiBwcm90b2NvbCcpXG4gICAgICAgIH0pICovXG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJyZXF1aXJlJCQwIiwicmVxdWlyZSQkMSIsImJ1ZmZlciIsIkJ1ZmZlciIsIkhhc2giLCJaX0ZJWEVEIiwiWl9VTktOT1dOIiwiemVybyIsIk1JTl9NQVRDSCIsIk1BWF9NQVRDSCIsIkxFTkdUSF9DT0RFUyIsIkxJVEVSQUxTIiwiTF9DT0RFUyIsIkRfQ09ERVMiLCJCTF9DT0RFUyIsIkhFQVBfU0laRSIsIk1BWF9CSVRTIiwidXRpbHMiLCJaX05PX0ZMVVNIIiwiWl9GSU5JU0giLCJaX0JMT0NLIiwiWl9PSyIsIlpfU1RSRUFNX0VORCIsIlpfU1RSRUFNX0VSUk9SIiwiWl9EQVRBX0VSUk9SIiwiWl9CVUZfRVJST1IiLCJaX0RFRkFVTFRfQ09NUFJFU1NJT04iLCJaX0RFRkFVTFRfU1RSQVRFR1kiLCJaX0RFRkxBVEVEIiwiTUFYX1dCSVRTIiwibXNnIiwiYWRsZXIzMiIsImNyYzMyIiwiZGVmbGF0ZSIsInRvU3RyaW5nIiwiWlN0cmVhbSIsInpsaWJfZGVmbGF0ZSIsIkJBRCIsIlRZUEUiLCJFTk9VR0hfTEVOUyIsIkVOT1VHSF9ESVNUUyIsIkNPREVTIiwiTEVOUyIsIkRJU1RTIiwiaW5mbGF0ZV90YWJsZSIsImluZmxhdGUiLCJpbmZsYXRlX2Zhc3QiLCJ6bGliX2luZmxhdGUiLCJjIiwiR1poZWFkZXIiLCJBc3luY0xvY2siLCJwYWtvIiwiY2xlYW5HaXRSZWYiLCJkaWZmM01lcmdlIiwiUGx1Z2luIiwiZ2l0IiwiYWRkSWNvbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFFQSxJQUFJLFNBQVMsR0FBRyxVQUFVLElBQUksRUFBRTtBQUNoQyxDQUFDLElBQUksR0FBRyxJQUFJLElBQUksRUFBRSxDQUFDO0FBQ25CO0FB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LElBQUksQ0FBQyxFQUFFLEdBQUcsV0FBVTtBQUN0QixFQUFFLElBQUksQ0FBQyxFQUFFLEdBQUcsV0FBVTtBQUN0QixFQUFFLElBQUksQ0FBQyxFQUFFLEdBQUcsV0FBVTtBQUN0QjtBQUNBLEVBQUUsT0FBTyxJQUFJO0FBQ2IsRUFBQztBQUNEO0FBQ0EsU0FBUyxLQUFLLEVBQUUsR0FBRyxFQUFFO0FBQ3JCLEVBQUUsT0FBTyxDQUFDLEdBQUcsSUFBSSxDQUFDLEtBQUssR0FBRyxLQUFLLEVBQUUsQ0FBQztBQUNsQyxDQUFDO0FBQ0Q7QUFDQSxTQUFTLEtBQUssRUFBRSxHQUFHLEVBQUU7QUFDckIsRUFBRSxPQUFPLENBQUMsR0FBRyxJQUFJLENBQUMsS0FBSyxHQUFHLEtBQUssRUFBRSxDQUFDO0FBQ2xDLENBQUM7QUFDRDtBQUNBLFNBQVMsTUFBTSxFQUFFLEdBQUcsRUFBRTtBQUN0QixFQUFFLE9BQU8sQ0FBQyxHQUFHLElBQUksRUFBRSxLQUFLLEdBQUcsS0FBSyxDQUFDLENBQUM7QUFDbEMsQ0FBQztBQUNEO0FBQ0EsU0FBUyxFQUFFLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFO0FBQ3pCLEVBQUUsSUFBSSxDQUFDLEtBQUssQ0FBQyxFQUFFLE9BQU8sQ0FBQyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQzFDLEVBQUUsSUFBSSxDQUFDLEtBQUssQ0FBQyxFQUFFLE9BQU8sQ0FBQyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0FBQ2pELEVBQUUsT0FBTyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUM7QUFDbEIsQ0FBQztBQUNEO0FBQ0EsSUFBSSxDQUFDLFNBQVMsQ0FBQyxPQUFPLEdBQUcsVUFBVSxDQUFDLEVBQUU7QUFDdEMsRUFBRSxJQUFJLENBQUMsR0FBRyxJQUFJLENBQUMsR0FBRTtBQUNqQjtBQUNBLEVBQUUsSUFBSSxDQUFDLEdBQUcsSUFBSSxDQUFDLEVBQUUsR0FBRyxFQUFDO0FBQ3JCLEVBQUUsSUFBSSxDQUFDLEdBQUcsSUFBSSxDQUFDLEVBQUUsR0FBRyxFQUFDO0FBQ3JCLEVBQUUsSUFBSSxDQUFDLEdBQUcsSUFBSSxDQUFDLEVBQUUsR0FBRyxFQUFDO0FBQ3JCLEVBQUUsSUFBSSxDQUFDLEdBQUcsSUFBSSxDQUFDLEVBQUUsR0FBRyxFQUFDO0FBQ3JCLEVBQUUsSUFBSSxDQUFDLEdBQUcsSUFBSSxDQUFDLEVBQUUsR0FBRyxFQUFDO0FBQ3JCO0FBQ0EsRUFBRSxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsV0FBVyxDQUFDLENBQUMsR0FBRyxDQUFDLEVBQUM7QUFDMUQsRUFBRSxPQUFPLENBQUMsR0FBRyxFQUFFLEVBQUUsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxFQUFDO0FBQy9FO0FBQ0EsRUFBRSxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUFFO0FBQy9CLElBQUksSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxFQUFFLEVBQUM7QUFDdEIsSUFBSSxJQUFJLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMs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ckQsRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsU0FBUyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNyRCxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxTQUFTLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ3JELEVBQUUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLFNBQVMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDckQsRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsU0FBUyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNyRCxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxTQUFTLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ3JELEVBQUUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLFNBQVMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDckQsRUFBRSxLQUFLLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0FBQ2YsRUFBRTtBQUNGO0FBQ0EsQ0FBQyxPQUFPLE9BQU8sVUFBVSxLQUFLLFdBQVcsR0FBRyxJQUFJLFVBQVUsQ0FBQyxLQUFLLENBQUMsR0FBRyxLQUFLLENBQUM7QUFDMUUsQ0FBQztBQUNEO0FBQ0EsSUFBSSxDQUFDLEdBQUcsZ0JBQWdCLEVBQUUsQ0FBQztBQUMzQixTQUFTLFVBQVUsQ0FBQyxJQUFJLEVBQUUsSUFBSSxFQUFFO0FBQ2hDLENBQUMsSUFBSSxDQUFDLEdBQUcsSUFBSSxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxJQUFJLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQztBQUN4QyxDQUFDLElBQUksSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLEdBQUc7QUFDeEIsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUM7QUFDakQsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUM7QUFDakQsRUFBRTtBQUNGLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUM7QUFDNUQsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztBQUNmLENBQUM7QUFDRDtBQUNBLFNBQVMsU0FBUyxDQUFDLEdBQUcsRUFBRSxJQUFJLEVBQUU7QUFDOUIsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxNQUFNLEdBQUcsS0FBSyxFQUFFLE9BQU8sV0FBVyxDQUFDLEdBQUcsRUFBRSxJQUFJLENBQUMsQ0FBQztBQUN0RCxDQUFDLElBQUksQ0FBQyxHQUFHLElBQUksR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsR0FBRyxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUM7QUFDdkMsQ0FBQyxJQUFJLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxHQUFHO0FBQ3hCLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUM7QUFDckMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQztBQUNyQyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDO0FBQ3JDLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUM7QUFDckMsRUFBRTtBQUNGLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQztBQUNuRCxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO0FBQ2YsQ0FBQztBQUNEO0FBQ0EsU0FBUyxXQUFXLENBQUMsR0FBRyxFQUFFLElBQUksRUFBRTtBQUNoQyxDQUFDLElBQUksQ0FBQyxHQUFHLElBQUksR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsR0FBRyxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUM7QUFDdkMsQ0FBQyxJQUFJLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxHQUFHO0FBQ3hCLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUM7QUFDckMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQztBQUNyQyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDO0FBQ3JDLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUM7QUFDckMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQztBQUNyQyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDO0FBQ3JDLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUM7QUFDckMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQztBQUNyQyxFQUFFO0FBQ0YsQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDO0FBQ25ELENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7QUFDZixDQUFDO0FBQ0Q7QUFDQSxTQUFTLFNBQVMsQ0FBQyxHQUFHLEVBQUUsSUFBSSxFQUFFO0FBQzlCLENBQUMsSUFBSSxDQUFDLEdBQUcsSUFBSSxHQUFHLENBQUMsQ0FBQyxDQUFDO0FBQ25CLENBQUMsSUFBSSxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxHQUFHO0FBQzVDLEVBQUUsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxVQUFVLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQztBQUMxQixFQUFFLEdBQUcsQ0FBQyxHQUFHLElBQUksRUFBRTtBQUNmLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDO0FBQ2pDLEdBQUcsTUFBTSxHQUFHLENBQUMsR0FBRyxLQUFLLEVBQUU7QUFDdkIsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxHQUFHLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUM7QUFDakQsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxHQUFHLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUM7QUFDNUMsR0FBRyxNQUFNLEdBQUcsQ0FBQyxJQUFJLE1BQU0sSUFBSSxDQUFDLEdBQUcsTUFBTSxFQUFFO0FBQ3ZDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLElBQUksRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDLFVBQVUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQztBQUNqRCxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLEdBQUcsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQztBQUNoRCxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLEdBQUcsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQztBQUNqRCxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLEdBQUcsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUM7QUFDNUQsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxHQUFHLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUM7QUFDNUMsR0FBRyxNQUFNO0FBQ1QsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxH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Q0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUM5RDtBQUNBLElBQUksV0FBVztBQUNmLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDO0FBQ3hFO0FBQ0EsSUFBSSxZQUFZO0FBQ2hCLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUMxQztBQUNBLElBQUksUUFBUTtBQUNaLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGFBQWEsR0FBRyxHQUFHLENBQUM7QUFDeEI7QUFDQTtBQUNBLElBQUksWUFBWSxJQUFJLElBQUksS0FBSyxDQUFDLENBQUNKLFNBQU8sR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7QUFDakRMLE1BQUksQ0FBQyxZQUFZLENBQUMsQ0FBQztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLFlBQVksSUFBSSxJQUFJLEtBQUssQ0FBQ00sU0FBTyxHQUFHLENBQUMsQ0FBQyxDQUFDO0FBQzNDTixNQUFJLENBQUMsWUFBWSxDQUFDLENBQUM7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLFVBQVUsTUFBTSxJQUFJLEtBQUssQ0FBQyxhQUFhLENBQUMsQ0FBQztBQUM3Q0EsTUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLFlBQVksSUFBSSxJQUFJLEtBQUssQ0FBQ0UsV0FBUyxHQUFHRCxXQUFTLEdBQUcsQ0FBQyxDQUFDLENBQUM7QUFDekRELE1BQUksQ0FBQyxZQUFZLENBQUMsQ0FBQztBQUNuQjtBQUNBO0FBQ0EsSUFBSSxXQUFXLEtBQUssSUFBSSxLQUFLLENBQUNHLGNBQVksQ0FBQyxDQUFDO0FBQzVDSCxNQUFJLENBQUMsV0FBVyxDQUFDLENBQUM7QUFDbEI7QUFDQTtBQUNBLElBQUksU0FBUyxPQUFPLElBQUksS0FBSyxDQUFDTSxTQUFPLENBQUMsQ0FBQztBQUN2Q04sTUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLFNBQVMsY0FBYyxDQUFDLFdBQVcsRUFBRSxVQUFVLEVBQUUsVUFBVSxFQUFFLEtBQUssRUFBRSxVQUFVLEVBQUU7QUFDaEY7QUFDQSxFQUFFLElBQUksQ0FBQyxXQUFXLElBQUksV0FBVyxDQUFDO0FBQ2xDLEVBQUUsSUFBSSxDQUFDLFVBQVUsS0FBSyxVQUFVLENBQUM7QUFDakMsRUFBRSxJQUFJLENBQUMsVUFBVSxLQUFLLFVBQVUsQ0FBQztBQUNqQyxFQUFFLElBQUksQ0FBQyxLQUFLLFVBQVUsS0FBSyxDQUFDO0FBQzVCLEVBQUUsSUFBSSxDQUFDLFVBQVUsS0FBSyxVQUFVLENBQUM7QUFDakM7QUFDQTtBQUNBLEVBQUUsSUFBSSxDQUFDLFNBQVMsTUFBTSxXQUFXLElBQUksV0FBVyxDQUFDLE1BQU0sQ0FBQztBQUN4RCxDQUFDO0FBQ0Q7QUFDQTtBQUNBLElBQUksYUFBYSxDQUFDO0FBQ2xCLElBQUksYUFBYSxDQUFDO0FBQ2xCLElBQUksY0FBYyxDQUFDO0FBQ25CO0FBQ0E7QUFDQSxTQUFTLFFBQVEsQ0FBQyxRQUFRLEVBQUUsU0FBUyxFQUFFO0FBQ3ZDLEVBQUUsSUFBSSxDQUFDLFFBQVEsR0FBRyxRQUFRLENBQUM7QUFDM0IsRUFBRSxJQUFJLENBQUMsUUFBUSxHQUFHLENBQUMsQ0FBQztBQUNwQixFQUFFLElBQUksQ0FBQyxTQUFTLEdBQUcsU0FBUyxDQUFDO0FBQzdCLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxTQUFTLE1BQU0sQ0FBQyxJQUFJLEVBQUU7QUFDdEIsRUFBRSxPQUFPLElBQUksR0FBRyxHQUFHLEdBQUcsVUFBVSxDQUFDLElBQUksQ0FBQyxHQUFHLFVBQVUsQ0FBQyxHQUFHLElBQUksSUFBSSxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDeEUsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsU0FBUyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUU7QUFDekI7QUFDQTtBQUNBLEVBQUUsQ0FBQyxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsT0FBTyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxJQUFJLENBQUM7QUFDMUMsRUFBRSxDQUFDLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxPQUFPLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxLQUFLLENBQUMsSUFBSSxJQUFJLENBQUM7QUFDaEQsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsU0FBUyxDQUFDLENBQUMsRUFBRSxLQUFLLEVBQUUsTUFBTSxFQUFFO0FBQ3JDLEVBQUUsSUFBSSxDQUFDLENBQUMsUUFBUSxJQUFJLFFBQVEsR0FBRyxNQUFNLENBQUMsRUFBRTtBQUN4QyxJQUFJLENBQUMsQ0FBQyxNQUFNLElBQUksQ0FBQyxLQUFLLElBQUksQ0FBQyxDQUFDLFFBQVEsSUFBSSxNQUFNLENBQUM7QUFDL0MsSUFBSSxTQUFTLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQztBQUMzQixJQUFJLENBQUMsQ0FBQyxNQUFNLEdBQUcsS0FBSyxLQUFLLFFBQVEsR0FBRyxDQUFDLENBQUMsUUFBUSxDQUFDLENBQUM7QUFDaEQsSUFBSSxDQUFDLENBQUMsUUFBUSxJQUFJLE1BQU0sR0FBRyxRQUFRLENBQUM7QUFDcEMsR0FBRyxNQUFNO0FBQ1QsSUFBSSxDQUFDLENBQUMsTUFBTSxJQUFJLENBQUMsS0FBSyxJQUFJLENBQUMsQ0FBQyxRQUFRLElBQUksTUFBTSxDQUFDO0FBQy9DLElBQUksQ0FBQyxDQUFDLFFBQVEsSUFBSSxNQUFNLENBQUM7QUFDekIsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0EsU0FBUyxTQUFTLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxJQUFJLEVBQUU7QUFDL0IsRUFBRSxTQUFTLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLFdBQVcsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLFNBQVMsQ0FBQztBQUM5RCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLFVBQVUsQ0FBQyxJQUFJLEVBQUUsR0FBRyxFQUFFO0FBQy9CLEVBQUUsSUFBSSxHQUFHLEdBQUcsQ0FBQyxDQUFDO0FBQ2QsRUFBRSxHQUFHO0FBQ0wsSUFBSSxHQUFHLElBQUksSUFBSSxHQUFHLENBQUMsQ0FBQztBQUNwQixJQUFJ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akQsSUFBSSxVQUFVLENBQUMsQ0FBQyxFQUFFLElBQUksRUFBRSxDQUFDLGFBQWEsQ0FBQztBQUN2QztBQUNBO0FBQ0EsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLGFBQWEsQ0FBQztBQUM5QjtBQUNBLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLENBQUM7QUFDN0IsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsQ0FBQztBQUM3QjtBQUNBO0FBQ0EsSUFBSSxJQUFJLENBQUMsSUFBSSxHQUFHLENBQUMsQ0FBQyxZQUFZLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLFlBQVksSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsVUFBVTtBQUMxRSxJQUFJLENBQUMsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUM3RSxJQUFJLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxXQUFXLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxXQUFXLElBQUksQ0FBQztBQUM3RDtBQUNBO0FBQ0EsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsYUFBYSxHQUFHLElBQUksRUFBRSxDQUFDO0FBQ25DLElBQUksVUFBVSxDQUFDLENBQUMsRUFBRSxJQUFJLEVBQUUsQ0FBQyxhQUFhLENBQUM7QUFDdkM7QUFDQSxHQUFHLFFBQVEsQ0FBQyxDQUFDLFFBQVEsSUFBSSxDQUFDLEVBQUU7QUFDNUI7QUFDQSxFQUFFLENB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R0FBRyxhQUFhLENBQUM7QUFDdEQsTUFBTSxDQUFDLENBQUMsUUFBUSxJQUFJLENBQUMsQ0FBQyxNQUFNLEdBQUcsYUFBYSxDQUFDLEdBQUcsQ0FBQyxRQUFRO0FBQ3pEO0FBQ0EsRUFBRSxJQUFJLElBQUksR0FBRyxDQUFDLENBQUMsTUFBTSxDQUFDO0FBQ3RCO0FBQ0EsRUFBRSxJQUFJLEtBQUssR0FBRyxDQUFDLENBQUMsTUFBTSxDQUFDO0FBQ3ZCLEVBQUUsSUFBSSxJQUFJLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxJQUFJLE1BQU0sR0FBRyxDQUFDLENBQUMsUUFBUSxHQUFHLFNBQVMsQ0FBQztBQUN0QyxFQUFFLElBQUksU0FBUyxJQUFJLElBQUksQ0FBQyxJQUFJLEdBQUcsUUFBUSxHQUFHLENBQUMsQ0FBQyxDQUFDO0FBQzdDLEVBQUUsSUFBSSxRQUFRLEtBQUssSUFBSSxDQUFDLElBQUksR0FBRyxRQUFRLENBQUMsQ0FBQztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsSUFBSSxDQUFDLENBQUMsV0FBVyxJQUFJLENBQUMsQ0FBQyxVQUFVLEVBQUU7QUFDckMsSUFBSSxZQUFZLEtBQUssQ0FBQyxDQUFDO0FBQ3ZCLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxFQUFFLElBQUksVUFBVSxHQUFHLENBQUMsQ0FBQyxTQUFTLEVBQUUsRUFBRSxVQUFVLEdBQUcsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxFQUFFO0FBQzdEO0FBQ0E7QUFDQTtBQUNBLEVBQUUsR0FBRztBQUNMO0FBQ0EsSUFBSSxLQUFLLEdBQUcsU0FBUyxDQUFDO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxJQUFJLElBQUksQ0FBQyxLQUFLLEdBQUcsUUFBUSxDQUFDLFNBQVMsUUFBUTtBQUMvQyxRQUFRLElBQUksQ0FBQyxLQUFLLEdBQUcsUUFBUSxHQUFHLENB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QyxRQUFRLEdBQUcsU0FBUyxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxTQUFTLENBQUM7QUFDckcsVUFBVSxTQUFTLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsUUFBUSxHQUFHLENBQUMsQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQztBQUN0RSxVQUFVLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxRQUFRLENBQUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLFFBQVEsRUFBRSxDQUFDLENBQUMsWUFBWSxLQUFLLENBQUMsRUFBRTtBQUN6QyxRQUFRLENBQUMsQ0FBQyxRQUFRLEVBQUUsQ0FBQztBQUNyQixPQUFPO0FBQ1AsTUFBTTtBQUNOLFFBQVEsQ0FBQyxDQUFDLFFBQVEsSUFBSSxDQUFDLENBQUMsWUFBWSxDQUFDO0FBQ3JDLFFBQVEsQ0FBQyxDQUFDLFlBQVksR0FBRyxDQUFDLENBQUM7QUFDM0IsUUFBUSxDQUFDLENBQUMsS0FBSyxHQUFHLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxDQUFDO0FBQ3ZDO0FBQ0EsUUFBUSxDQUFDLENBQUMsS0FBSyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxJQUFJLENBQUMsQ0FBQyxVQUFVLElBQUksQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsUUFBUSxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxTQUFTLENBQUM7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSyxNQUFNO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsTUFBTSxNQUFNLEdBQUcsS0FBSyxDQUFDLFNBQVMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxDQUFD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QUFDQTtBQUNBLE1BQU0sTUFBTSxHQUFHLEtBQUssQ0FBQyxTQUFTLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxRQUFRLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxVQUFVLEVBQUUsQ0FBQyxDQUFDLFdBQVcsR0FBRyxTQUFTLENBQUMsQ0FBQztBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxDQUFDLENBQUMsU0FBUyxJQUFJLENBQUMsQ0FBQyxXQUFXLEdBQUcsQ0FBQyxDQUFDO0FBQ3ZDLE1BQU0sQ0FBQyxDQUFDLFdBQVcsSUFBSSxDQUFDLENBQUM7QUFDekIsTUFBTSxHQUFHO0FBQ1QsUUFBUSxJQUFJLEVBQUUsQ0FBQyxDQUFDLFFBQVEsSUFBSSxVQUFVLEVBQUU7QUFDeEM7QUFDQSxVQUFVLENBQUMsQ0FBQyxLQUFLLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLElBQUksQ0FBQyxDQUFDLFVBQVUsSUFBSSxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxRQUFRLEdBQUcsU0FBUyxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxTQUFTLENBQUM7QUFDckcsVUFBVSxTQUFTLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsUUFBUSxHQUFHLENBQUMsQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQztBQUN0RSxVQUFVLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxRQUFRLENBQUM7QUFDdkM7QUFDQSxTQUFTO0FBQ1QsT0FBTyxRQUFRLEVBQUUsQ0FBQyxDQUFDLFdBQVcsS0FBSyxDQUFDLEVBQUU7QUFDdEMsTUFBTSxDQUFDLENBQUMsZUFBZSxHQUFHLENBQUMsQ0FBQztBQUM1QixNQUFNLENBQUMsQ0FBQyxZQUFZLEdBQUcsU0FBUyxHQUFHLENBQUMsQ0FBQztBQUNyQyxNQUFNLENBQUMsQ0FBQyxRQUFRLEVBQUUs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RixVQUFRLEVBQUUsRUFBRSxPQUFPRSxNQUFJLENBQUMsRUFBRTtBQUMxQyxFQUFFLElBQUksQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDLEVBQUUsRUFBRSxPQUFPQyxjQUFZLENBQUMsRUFBRTtBQUMzQztBQUNBO0FBQ0EsRUFBRSxJQUFJLENBQUMsQ0FBQyxJQUFJLEtBQUssQ0FBQyxFQUFFO0FBQ3BCLElBQUksUUFBUSxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQyxDQUFDO0FBQ25DLElBQUksUUFBUSxDQUFDLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxLQUFLLElBQUksQ0FBQyxJQUFJLElBQUksQ0FBQyxDQUFDO0FBQzFDLElBQUksUUFBUSxDQUFDLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxLQUFLLElBQUksRUFBRSxJQUFJLElBQUksQ0FBQyxDQUFDO0FBQzNDLElBQUksUUFBUSxDQUFDLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxLQUFLLElBQUksRUFBRSxJQUFJLElBQUksQ0FBQyxDQUFDO0FBQzNDLElBQUksUUFBUSxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsUUFBUSxHQUFHLElBQUksQ0FBQyxDQUFDO0FBQ3RDLElBQUksUUFBUSxDQUFDLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxRQUFRLElBQUksQ0FBQyxJQUFJLElBQUksQ0FBQyxDQUFDO0FBQzdDLElBQUksUUFBUSxDQUFDLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxRQUFRLElBQUksRUFBRSxJQUFJLElBQUksQ0FBQyxDQUFDO0FBQzlDLElBQUksUUFBUSxDQUFDLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxRQUFRLElBQUksRUFBRSxJQUFJLElBQUksQ0FBQyxDQUFDO0FBQzlDLEdBQUc7QUFDSDtBQUNBLEVBQUU7QUFDRixJQUFJLFdBQVcsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLEtBQUssS0FBSyxFQUFFLENBQUMsQ0FBQztBQUN0QyxJQUFJLFdBQVcsQ0FBQyxDQUFD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LEdBQUcsQ0FBQyxDQUFDLENBQUM7QUFDckMsTUFBTSxJQUFJLENBQUMsRUFBRSxHQUFHLE1BQU0sTUFBTSxNQUFNLEVBQUU7QUFDcEMsUUFBUSxDQUFDLEdBQUcsT0FBTyxJQUFJLENBQUMsQ0FBQyxHQUFHLE1BQU0sS0FBSyxFQUFFLENBQUMsSUFBSSxFQUFFLEdBQUcsTUFBTSxDQUFDLENBQUM7QUFDM0QsUUFBUSxLQUFLLEVBQUUsQ0FBQztBQUNoQixPQUFPO0FBQ1AsS0FBSztBQUNMLElBQUksT0FBTyxJQUFJLENBQUMsR0FBRyxJQUFJLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxLQUFLLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxPQUFPLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQztBQUNsRSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEVBQUUsR0FBRyxHQUFHLElBQUlBLE1BQUssQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7QUFDaEM7QUFDQTtBQUNBLEVBQUUsS0FBSyxDQUFDLEdBQUcsQ0FBQyxFQUFFLEtBQUssR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLE9BQU8sRUFBRSxLQUFLLEVBQUUsRUFBRTtBQUMvQyxJQUFJLENBQUMsR0FBRyxHQUFHLENBQUMsVUFBVSxDQUFDLEtBQUssQ0FBQyxDQUFDO0FBQzlCLElBQUksSUFBSSxDQUFDLENBQUMsR0FBRyxNQUFNLE1BQU0sTUFBTSxLQUFLLEtBQUssR0FBRyxDQUFDLEdBQUcsT0FBTyxDQUFDLEVBQUU7QUFDMUQsTUFBTSxFQUFFLEdBQUcsR0FBRyxDQUFDLFVBQVUsQ0FBQyxLQUFLLEdBQUcsQ0FBQyxDQUFDLENBQUM7QUFDckMsTUFBTSxJQUFJLENBQUMsRUFBRSxHQUFHLE1BQU0sTUFBTSxNQUFNLEVBQUU7QUFDcEMsUUFBUSxDQUFDLEdBQUcsT0FBTyxJQUFJLENBQUMsQ0FBQyxHQUFHLE1BQU0sS0FBSyxFQUFFLENBQUMsSUFBSSxFQUFFLEdBQUcsTUFBTSxDQUFDLENBQUM7QUFDM0QsUUFBUSxLQUFLLEVBQUUsQ0FBQztB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RUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLENBQUMsRUFBRSxDQUFDO0FBQ2hFLENBQUMsQ0FBQztBQUNGO0FBQ0EsSUFBSSxJQUFJLEdBQUc7QUFDWCxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUU7QUFDaEUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUU7QUFDNUQsQ0FBQyxDQUFDO0FBQ0Y7QUFDQSxJQUFJLEtBQUssR0FBRztBQUNaLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxHQUFHLEVBQUUsR0FBRztBQUMzRCxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUk7QUFDeEQsRUFBRSxJQUFJLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUUsQ0FBQyxFQUFFLENBQUM7QUFDakMsQ0FBQyxDQUFDO0FBQ0Y7QUFDQSxJQUFJLElBQUksR0FBRztBQUNYLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFF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RUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLElBQUksRUFBRTtBQUM1QyxFQUFFLElBQUksSUFBSSxDQUFDO0FBQ1gsRUFBRSxJQUFJLEtBQUssR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDO0FBQ3pCO0FBQ0E7QUFDQSxFQUFFLElBQUksS0FBSyxDQUFDLE1BQU0sS0FBSyxJQUFJLEVBQUU7QUFDN0IsSUFBSSxLQUFLLENBQUMsS0FBSyxHQUFHLENBQUMsSUFBSSxLQUFLLENBQUMsS0FBSyxDQUFDO0FBQ25DLElBQUksS0FBSyxDQUFDLEtBQUssR0FBRyxDQUFDLENBQUM7QUFDcEIsSUFBSSxLQUFLLENBQUMsS0FBSyxHQUFHLENBQUMsQ0FBQztBQUNwQjtBQUNBLElBQUksS0FBSyxDQUFDLE1BQU0sR0FBRyxJQUFJM0IsTUFBSyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUM7QUFDL0MsR0FBRztBQUNIO0FBQ0E7QUFDQSxFQUFFLElBQUksSUFBSSxJQUFJLEtBQUssQ0FBQyxLQUFLLEVBQUU7QUFDM0IsSUFBSUEsTUFBSyxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsTUFBTSxFQUFFLEdBQUcsRUFBRSxHQUFHLEdBQUcsS0FBSyxDQUFDLEtBQUssRUFBRSxLQUFLLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQyxDQUFDO0FBQ3pFLElBQUksS0FBSyxDQUFDLEtBQUssR0FBRyxDQUFDLENBQUM7QUFDcEIsSUFBSSxLQUFLLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQyxLQUFLLENBQUM7QUFDOUIsR0FBRztBQUNILE9BQU87QUFDUCxJQUFJLElBQUksR0FBRyxLQUFLLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQyxLQUFLLENBQUM7QUFDckMsSUFBSSxJQUFJLElBQUksR0FBRyxJQUFJLEVBQUU7QUFDckIsTUFBTSxJQUFJLEdBQUcsSUFBSSxDQUFDO0FBQ2xCLEtBQUs7QUFDTDtBQUNBLElBQUlBLE1BQUssQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLE1BQU0sRUFBRSxHQUFHLEVB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QSxFQUFFLElBQUksRUFBRSxHQUFHLFdBQVcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7QUFDN0IsRUFBRSxJQUFJLEVBQUUsR0FBRyxXQUFXLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO0FBQzdCO0FBQ0EsRUFBRSxJQUFJLEtBQUssR0FBRyxFQUFFLENBQUM7QUFDakI7QUFDQSxFQUFFLFNBQVMsT0FBTyxDQUFDLENBQUMsRUFBRSxJQUFJLEVBQUU7QUFDNUIsSUFBSSxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ3ZFLEdBQUc7QUFDSCxFQUFFLEtBQUssQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsRUFBRSxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTtBQUNsQyxJQUFJLE9BQU8sQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7QUFDdEIsR0FBRztBQUNILEVBQUUsS0FBSyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxFQUFFLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO0FBQ2xDLElBQUksT0FBTyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztBQUN0QixHQUFHO0FBQ0gsRUFBRSxLQUFLLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxFQUFFLENBQUMsRUFBRTtBQUM1QixJQUFJLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDdEIsR0FBRyxDQUFDLENBQUM7QUFDTDtBQUNBLEVBQUUsSUFBSSxNQUFNLEdBQUcsRUFBRSxDQUFDO0FBQ2xCLEVBQUUsSUFBSSxZQUFZLEdBQUcsQ0FBQyxDQUFDO0FBQ3ZCO0FBQ0EsRUFBRSxTQUFTLFVBQVUsQ0FBQyxZQUFZLEVBQUU7QUFDcEMsSUFBSSxJQUFJLFlBQVksR0FBRyxZQUFZLEVBQUU7QUFDckMsTUFBTSxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLFlBQVksRUFBRSxZQUFZLEdBQUcsWUFBWSxDQUFDLENBQUMsQ0FBQztBQUNsRSxNQUFNLFlBQVksR0FBRyxZQUFZLENBQUM7QUFDbEMsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBLEVBQUUsS0FBSyxJQUFJLFNBQVMsR0FBRyxDQUFDLEVBQUUsU0FBUyxHQUFHLEtBQUssQ0FBQyxNQUFNLEVBQUUsU0FBUyxFQUFFLEVBQUU7QUFDakUsSUFBSSxJQUFJLGNBQWMsR0FBRyxTQUFTLENBQUM7QUFDbkMsSUFBSSxJQUFJLElBQUksR0FBRyxLQUFLLENBQUMsU0FBUyxDQUFDLENBQUM7QUFDaEMsSUFBSSxJQUFJLFNBQVMsR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDNUIsSUFBSSxJQUFJLFNBQVMsR0FBRyxTQUFTLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ3hDLElBQUksT0FBTyxTQUFTLEdBQUcsS0FBSyxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUU7QUFDekMsTUFBTSxJQUFJLGdCQUFnQixHQUFHLEtBQUssQ0FBQyxTQUFTLEdBQUcsQ0FBQyxDQUFDLENBQUM7QUFDbEQsTUFBTSxJQUFJLFFBQVEsR0FBRyxnQkFBZ0IsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUN6QyxNQUFNLElBQUksUUFBUSxHQUFHLFNBQVMsRUFBRSxNQUFNO0FBQ3RDLE1BQU0sU0FBUyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsU0FBUyxFQUFFLFFBQVEsR0FBRyxnQkFBZ0IsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ3RFLE1BQU0sU0FBUyxFQUFFLENBQUM7QUFDbEIsS0FBSztBQUNMO0FBQ0EsSUFBSSxVQUFVLENBQUMsU0FBUyxDQUFDLENBQUM7QUFDMUIsSUFBSSxJQUFJLGNBQWMsSUFBSSxTQUFTLEVBQUU7QUFDckM7QUFDQTtBQUNBO0FBQ0EsTUFBTSxJQUFJLElBQUksQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEVBQUU7QUFDdkIsUUFBUSxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ2pELE9BQU87QUFDUCxLQUFLLE1BQU07QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLElBQUksT0FBTyxHQUFHO0FBQ3BCLFFBQVEsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLE1BQU0sRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsTUFBTSxFQUFFLENBQUMsQ0FBQyxDQUFDO0FBQ3ZDLFFBQVEsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLE1BQU0sRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsTUFBTSxFQUFFLENBQUMsQ0FBQyxDQUFDO0FBQ3ZDLE9BQU8sQ0FBQztBQUNSLE1BQU0sS0FBSyxDQUFDLEdBQUcsY0FBYyxFQUFFLENBQUMsSUFBSSxTQUFTLEVBQUUsQ0FBQyxFQUFFLEVBQUU7QUFDcEQsUUFBUSxJQUFJLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ3hCLFFBQVEsSUFBSSxJQUFJLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQzNCLFFBQVEsSUFBSSxDQUFDLEdBQUcsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQzlCLFFBQVEsSUFBSSxJQUFJLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQzNCLFFBQVEsSUFBSSxJQUFJLEdBQUcsSUFBSSxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNsQyxRQUFRLElBQUksS0FBSyxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUM1QixRQUFRLElBQUksS0FBSyxHQUFHLEtBQUssR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDcEMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDckMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDckMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDcEMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDcEMsT0FBTztBQUNQLE1BQU0sSUFBSSxJQUFJLEdBQUcsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLFNBQVMsR0FBRyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUM3RCxNQUFNLElBQUksSUFBSSxHQUFHLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxTQUFTLEdBQUcsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDN0QsTUFBTSxJQUFJLElBQUksR0FBRyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksU0FBUyxHQUFHLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQzdELE1BQU0sSUFBSSxJQUFJLEdBQUcsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLFNB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QUM7QUFDbkQsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBLEVBQUUsT0FBTyxFQUFFLENBQUM7QUFDWixFQUFFLE9BQU8sTUFBTSxDQUFDO0FBQ2hCLENBQUM7QUFDRDtBQUNBLFNBQWMsR0FBRyxVQUFVOztBQ3JRM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxTQUFTLFNBQVMsS0FBSyxDQUFDO0FBQzlCLEVBQUUsV0FBVyxDQUFDLE9BQU8sRUFBRTtBQUN2QixJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQztBQUNuQjtBQUNBO0FBQ0EsSUFBSSxJQUFJLENBQUMsTUFBTSxHQUFHLEVBQUUsQ0FBQztBQUNyQixHQUFHO0FBQ0g7QUFDQSxFQUFFLE1BQU0sR0FBRztBQUNYO0FBQ0EsSUFBSSxPQUFPO0FBQ1gsTUFBTSxJQUFJLEVBQUUsSUFBSSxDQUFDLElBQUk7QUFDckIsTUFBTSxJQUFJLEVBQUUsSUFBSSxDQUFDLElB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QUMsS0FBSyxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsR0FBRyxDQUFDLEVBQUUsT0FBTyxHQUFHLENBQUMsRUFBRSxLQUFLLENBQUMsSUFBSSxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsTUFBTSxDQUFDLENBQUM7QUFDN0UsR0FBRztBQUNIO0FBQ0EsRUFBRSxhQUFhLFNBQVMsQ0FBQyxFQUFFLEVBQUUsRUFBRSxNQUFNLEVBQUUsR0FBRyxFQUFFLEVBQUU7QUFDOUMsSUFBSSxPQUFPLGFBQWEsQ0FBQyxVQUFVLENBQUMsRUFBRSxFQUFFLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUM7QUFDaEUsR0FBRztBQUNIO0FBQ0EsRUFBRSxhQUFhLFVBQVUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFLEVBQUU7QUFDaEQ7QUFDQSxJQUFJLE1BQU0sT0FBTyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsSUFBSSxFQUFFLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDakU7QUFDQSxJQUFJLElBQUksSUFBSSxHQUFHLE1BQU0sRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUUsTUFBTSxDQUFDLFlBQVksQ0FBQyxFQUFFLEVBQUUsUUFBUSxFQUFFLE1BQU0sRUFBRSxDQUFDLENBQUM7QUFDNUUsSUFBSSxNQUFNLE1BQU0sR0FBRyxhQUFhLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQzVDLElBQUksTUFBTSxVQUFVLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUM7QUFDeEMsSUFBSSxLQUFLLE1BQU0sR0FBRyxJQUFJLElBQUksRUFBRTtBQUM1QixNQUFNLElBQUksTUFBTSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEVBQUU7QUFDaEMsUUFBUSxNQUFNLENBQUMsTUFBTSxDQUFDLEdB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QyxJQUFJLE1BQU0sRUFBRSxFQUFFLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBRSxHQUFHLElBQUksQ0FBQztBQUN2QyxJQUFJLE1BQU0sR0FBRyxHQUFHLE1BQU0sSUFBSSxDQUFDLFVBQVUsQ0FBQztBQUN0QyxJQUFJLE1BQU0sR0FBRyxHQUFHLEdBQUcsQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLENBQUM7QUFDbEMsSUFBSSxJQUFJLENBQUMsR0FBRyxFQUFFLE1BQU0sSUFBSSxLQUFLLENBQUMsQ0FBQyxXQUFXLEVBQUUsUUFBUSxDQUFDLENBQUMsQ0FBQztBQUN2RCxJQUFJLE1BQU0sR0FBRyxHQUFHLEdBQUcsQ0FBQyxHQUFHLENBQUM7QUFDeEIsSUFBSSxJQUFJLENBQUMsR0FBRyxFQUFFLE1BQU0sSUFBSSxLQUFLLENBQUMsQ0FBQyxlQUFlLEVBQUUsSUFBSSxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDdEUsSUFBSSxJQUFJLEdBQUcsQ0FBQyxJQUFJLEtBQUssTUFBTSxFQUFFO0FBQzdCO0FBQ0EsTUFBTSxPQUFPLElBQUk7QUFDakIsS0FBSztBQUNMLElBQUksTUFBTSxFQUFFLElBQUksRUFBRSxNQUFNLEVBQUUsR0FBRyxNQUFNLFdBQVcsQ0FBQyxFQUFFLEVBQUUsRUFBRSxLQUFLLEVBQUUsTUFBTSxFQUFFLEdBQUcsRUFBRSxDQUFDLENBQUM7QUFDM0UsSUFBSSxJQUFJLElBQUksS0FBSyxHQUFHLENBQUMsSUFBSSxFQUFFO0FBQzNCLE1BQU0sTUFBTSxJQUFJLGVBQWUsQ0FBQyxHQUFHLEVBQUUsSUFBSSxFQUFFLEdBQUcsQ0FBQyxJQUFJLENBQUM7QUFDcEQsS0FBSztBQUNMLElBQUksTUFBTSxJQUFJLEdBQUcsT0FBTyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztBQUN0QztBQUNBLElBQUksS0FBSyxNQUFNLEtBQUssSUFBSSxJQUFJLEVBQUU7QUFDOUIsTUFBTSxHQUFHLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUUs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QUUsQ0FBQyxRQUFRLENBQUMsQ0FBQztBQUN0RCxNQUFNLElBQUksQ0FBQyxNQUFNLEdBQUcsRUFBRSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxRQUFRLENBQUMsQ0FBQztBQUN4RCxNQUFNLElBQUksQ0FBQyxRQUFRLEdBQUcsRUFBRSxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxRQUFRLENBQUMsQ0FBQztBQUM1RCxNQUFNLElBQUksQ0FBQyxTQUFTLEdBQUcsRUFBRSxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxRQUFRLENBQUMsQ0FBQztBQUM5RCxNQUFNLElBQUksQ0FBQyxRQUFRLEdBQUcsRUFBRSxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxRQUFRLENBQUMsQ0FBQztBQUM1RCxLQUFLLE1BQU07QUFDWCxNQUFNLElBQUksQ0FBQyxTQUFTLEdBQUcsSUFBSSxDQUFDLEVBQUUsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7QUFDbEQsTUFBTSxJQUFJLENBQUMsVUFBVSxHQUFHLElBQUksQ0FBQyxFQUFFLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO0FBQ3BELE1BQU0sSUFBSSxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUMsRUFBRSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztBQUM1QyxNQUFNLElBQUksQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7QUFDNUMsTUFBTSxJQUFJLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQyxFQUFFLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO0FBQzlDLE1BQU0sSUFBSSxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztBQUMxQyxNQUFNLElBQUksQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7QUFDNUMsTUFBTSxJQUFJLENBQUMsUUFBUSxHQUFHLElBQUksQ0FBQyxFQUFFLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO0FBQ2hELE1BQU0sSUFBSSxDQUFDLFNBQVMsR0FBRyxJQUFJLENBQUMsRUFBRSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztBQUNsRCxNQUFNLElBQUksQ0FBQyxRQUFRLEdBQUcsSUFBSSxDQUFDLEVBQUUsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7QUFDaEQsS0FBSztBQUNMLElBQUksSUFBSSxDQUFDLHNCQUFzQixHQUFHLEVBQUUsQ0FBQztBQUNyQyxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsTUFBTSxNQUFNLENBQUMsUUFBUSxFQUFFLE9BQU8sR0FBRyxFQUFFLEVBQUU7QUFDdkMsSUFBSSxJQUFJO0FBQ1IsTUFBTSxNQUFNLElBQUksQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLENBQUM7QUFDakMsTUFBTSxPQUFPLElBQUk7QUFDakIsS0FBSyxDQUFDLE9BQU8sR0FBRyxFQUFFO0FBQ2xCLE1BQU0sSUFBSSxHQUFHLENBQUMsSUFBSSxLQUFLLFFBQVEsSUFBSSxHQUFHLENBQUMsSUFBSSxLQUFLLFNBQVMsRUFBRTtBQUMzRCxRQUFRLE9BQU8sS0FBSztBQUNwQixPQUFPLE1BQU07QUFDYixRQUFRLE9BQU8sQ0FBQyxHQUFHLENBQUMsbURBQW1ELEVBQUUsR0FBRyxDQUFDLENBQUM7QUFDOUUsUUFBUSxNQUFNLEdBQUc7QUFDakIsT0FBTztBQUNQLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxNQUFNLElBQUksQ0FBQyxRQUFRLEVBQUUsT0FBTyxHQUFHLEVBQUUsRUFBRTtBQUNyQyxJQUFJLElBQUk7QUFDUixNQUFNLElBQUksTUFBTSxHQUFHLE1BQU0sSUFBSSxDQUFDLFNBQVMsQ0FBQyxRQUFRLEVBQUUsT0FBTyxDQUFDLENBQUM7QUFDM0Q7QUFDQSxNQUFNLElBQUksT0FBTyxNQUFNLEtBQUssUUFBUSxFQUFFO0FBQ3RDLFFBQVEsTUFBTSxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7QUFDckMsT0FBTztBQUNQLE1BQU0sT0FBTyxNQUFNO0FBQ25CLEtBQUssQ0FBQyxPQUFPLEdBQUcsRUFBRTtBQUNsQixNQUFNLE9BQU8sSUFBSTtBQUNqQixLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLE1BQU0sS0FBSyxDQUFDLFFBQVEsRUFBRSxRQUFRLEVBQUUsT0FBTyxHQUFHLEVBQUUsRUFBRTtBQUNoRCxJQUFJLElBQUk7QUFDUixNQUFNLE1BQU0sSUFBSSxDQUFDLFVBQVUsQ0FBQyxRQUFRLEVBQUUsUUFBUSxFQUFFLE9BQU8sQ0FBQyxDQUFDO0FBQ3pELE1BQU0sTUFBTTtBQUNaLEtBQUssQ0FBQyxPQUFPLEdBQUcsRUFBRTtBQUNsQjtBQUNBLE1BQU0sTUFBTSxJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDO0FBQzFDLE1BQU0sTUFBTSxJQUFJLENBQUMsVUFBVSxDQUFDLFFBQVEsRUFBRSxRQUFRLEVBQUUsT0FBTyxDQUFDLENBQUM7QUFDekQsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsTUFBTSxLQUFLLENBQUMsUUFBUSxFQUFFLFNBQVMsR0FBRyxLQUFLLEVBQUU7QUFDM0MsSUFBSSxJQUFJO0FBQ1IsTUFBTSxNQUFNLElBQUksQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLENBQUM7QUFDbEMsTUFBTSxNQUFNO0FBQ1osS0FBSyxDQUFDLE9BQU8sR0FBRyxFQUFFO0FBQ2xCO0FBQ0EsTUFBTSxJQUFJLEdBQUcsS0FBSyxJQUFJLEVBQUUsTUFBTTtBQUM5QjtBQUNBLE1BQU0sSUFBSSxHQUFHLENBQUMsSUFBSSxLQUFLLFFBQVEsRUFBRSxNQUFNO0FBQ3ZDO0FBQ0EsTUFBTSxJQUFJLFNBQVMsRUFBRSxNQUFNLEdBQUc7QUFDOUI7QUFDQSxNQUFNLElBQUksR0FBRyxDQUFDLElBQUksS0FBSyxRQUFRLEVBQUU7QUFDakMsUUFBUSxNQUFNLE1BQU0sR0FBRyxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUM7QUFDekM7QUFDQSxRQUFRLElBQUksTUFBTSxLQUFLLEdBQUcsSUFBSSxNQUFNLEtBQUssR0FBRyxJQUFJLE1BQU0sS0FBSyxRQUFRLEVBQUUsTUFBTSxHQUFHO0FBQzlFO0FBQ0EsUUFBUSxNQUFNLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLENBQUM7QUFDakMsUUFBUSxNQUFNLElBQUksQ0FBQyxLQUFLLENBQUMsUUFBUSxFQUFFLElBQUksQ0FBQyxDQUFDO0FBQ3pDLE9BQU87QUFDUCxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxNQUFNLEVBQUUsQ0FBQyxRQUFRLEVBQUU7QUFDckIsSUFBSSxJQUFJO0FBQ1IsTUFBTSxNQUFNLElBQUksQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUM7QUFDbkMsS0FBSyxDQUFDLE9BQU8sR0FBRyxFQUFFO0FBQ2xCLE1BQU0sSUFBSSxHQUFHLENBQUMsSUFBSSxLQUFLLFFBQVEsRUFBRSxNQUFNLEdBQUc7QUFDMUMsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsTUFBTSxLQUFLLENBQUMsUUFBUSxFQUFFO0FBQ3hCLElBQUksSUFBSTtBQUNSLE1BQU0sTUFBTSxJQUFJLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0FBQ2xDLEtBQUssQ0FBQyxPQUFPLEdBQUcsRUFBRTtBQUNsQixNQUFNLElBQUksR0FBRyxDQUFDLElBQUksS0FBSyxRQUFRLEVBQUUsTUFBTSxHQUFHO0FBQzFDLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLE1BQU0sT0FBTyxDQUFDLFFBQVEsRUFBRTtBQUMxQixJQUFJLElBQUk7QUFDUixNQUFNLE1BQU0sS0FBSyxHQUFHLE1BQU0sSUFBSSxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsQ0FBQztBQUNsRDtBQUNBO0FBQ0EsTUFBTSxLQUFLLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxDQUFDO0FBQ2pDLE1BQU0sT0FBTyxLQUFLO0FBQ2xCLEtBQUssQ0FBQyxPQUFPLEdBQUcsRUFBRTtBQUNsQixNQUFNLElBQUksR0FBRyxDQUFDLElBQUksS0FBSyxTQUFTLEVBQUUsT0FBTyxJQUFJO0FBQzdDLE1BQU0sT0FBTyxFQUFFO0FBQ2YsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsTUFBTSxXQUFXLENBQUMsR0FBRyxFQUFFO0FBQ3pCLElBQUksTUFBTSxPQUFPLEdBQUcsTUFBTSxJQUFJLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0FBQzdDLElBQUksTUFBTSxLQUFLLEdBQUcsTUFBTSxPQUFPLENBQUMsR0FBRztBQUNuQyxNQUFNLE9BQU8sQ0FBQyxHQUFHLENBQUMsTUFBTSxNQUFNLElBQUk7QUFDbEMsUUFBUSxNQUFNLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLE1BQU0sQ0FBQztBQUN2QyxRQUFRLE9BQU8sQ0FBQyxNQUFNLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLEVBQUUsV0FBVyxFQUFFO0FBQ3BELFlBQVksSUFBSSxDQUFDLFdBQVcsQ0FBQyxHQUFHLENBQUM7QUFDakMsWUFBWSxHQUFHO0FBQ2YsT0FBTyxDQUFDO0FBQ1IsS0FBSyxDQUFDO0FBQ04sSUFBSSxPQUFPLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDO0FBQ2xELEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxNQUFNLEtBQUssQ0FBQyxRQUFRLEVBQUU7QUFDeEIsSUFBSSxJQUFJO0FBQ1IsTUFBTSxNQUFNLEtBQUssR0FBRyxNQUFNLElBQUksQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLENBQUM7QUFDaEQsTUFBTSxPQUFPLEtBQUs7QUFDbEIsS0FBSyxDQUFDLE9BQU8sR0FBRyxFQUFFO0FBQ2xCLE1BQU0sSUFBSSxHQUFHLENBQUMsSUFBSSxLQUFLLFFBQVEsRUFBRTtBQUNqQyxRQUFRLE9BQU8sSUFBSTtBQUNuQixPQUFPO0FBQ1AsTUFBTSxNQUFNLEdBQUc7QUFDZixLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLE1BQU0sUUFBUSxDQUFDLFFBQVEsRUFBRSxJQUFJLEdBQUcsRUFBRSxRQUFRLEVBQUUsUUFBUSxFQUFFLEVBQUU7QUFDMUQ7QUFDQTtBQUNBLElBQUksSUFBSTtBQUNSLE1BQU0sT0FBTyxJQUFJLENBQUMsU0FBUyxDQUFDLFFBQVEsRUFBRSxJQUFJLENBQUM7QUFDM0MsS0FBSyxDQUFDLE9BQU8sR0FBRyxFQUFFO0FBQ2xCLE1BQU0sSUFBSSxHQUFHLENBQUMsSUFBSSxLQUFLLFFBQVEsRUFBRTtBQUNqQyxRQUFRLE9BQU8sSUFBSTtBQUNuQixPQUFPO0FBQ1AsTUFBTSxNQUFNLEdBQUc7QUFDZixLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxNQUFNLFNBQVMsQ0FBQyxRQUFRLEVBQUUsTUFBTSxFQUFFO0FBQ3BDLElBQUksT0FBTyxJQUFJLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLEVBQUUsUUFBUSxDQUFDO0FBQzNELEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQSxlQUFlLGdCQUFnQixDQUFDLEVBQUUsRUFBRSxFQUFFLE1BQU0sRUFBRSxNQUFNLEVBQUUsTUFBTSxFQUFFLEdBQUcsRUFBRSxFQUFFO0FBQ3JFLEVBQUUsSUFBSSxNQUFNLEtBQUssVUFBVSxFQUFFO0FBQzdCLElBQUksTUFBTSxJQUFJLGFBQWE7QUFDM0IsTUFBTSx1RUFBdUU7QUFDN0UsS0FBSztBQUNMLEdBQUc7QUFDSCxFQUFFLE1BQU0sTUFBTSxHQUFHLENBQUMsUUFBUSxFQUFFLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUM5RCxFQUFFLE1BQU0sUUFBUSxHQUFHLENBQUMsRUFBRSxNQUFNLENBQUMsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxDQUFDLENBQUM7QUFDekM7QUFDQTtBQUNBO0FBQ0EsRUFBRSxJQUFJLEVBQUUsTUFBTSxFQUFFLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxDQUFDLEVBQUUsTUFBTSxFQUFFLENBQUMsS0FBSyxDQUFDLFFBQVEsRUFBRSxNQUFNLENBQUMsQ0FBQztBQUNyRSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsSUFBSSx5QkFBeUIsR0FBRyxJQUFJLENBQUM7QUFDckM7QUFDQSxlQUFlLE9BQU8sQ0FBQyxNQUFNLEVBQUU7QUFDL0IsRUFBRSxJQUFJLHlCQUF5QixLQUFLLElBQUksRUFBRTtBQUMxQyxJQUFJLHlCQUF5QixHQUFHLHFCQUFxQixFQUFFLENBQUM7QUFDeEQsR0FBRztBQUNILEVBQUUsT0FBTyx5QkFBeUI7QUFDbEMsTUFBTSxjQUFjLENBQUMsTUFBTSxDQUFDO0FBQzVCLE1BQU1tQixNQUFJLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQztBQUMxQixDQUFDO0FBQ0Q7QUFDQSxlQUFlLGNBQWMsQ0FBQyxNQUFNLEVBQUU7QUFDdEMsRUFBRSxNQUFNLEVBQUUsR0FBRyxJQUFJLGlCQUFpQixDQUFDLFNBQVMsQ0FBQyxDQUFDO0FBQzlDLEVBQUUsTUFBTSxDQUFDLEdBQUcsSUFBSSxJQUFJLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLE1BQU0sRUFBRSxDQUFDLFdBQVcsQ0FBQyxFQUFFLENBQUMsQ0FBQztBQUN4RCxFQUFFLE9BQU8sSUFBSSxVQUFVLENBQUMsTUFBTSxJQUFJLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxXQUFXLEVBQUUsQ0FBQztBQUM1RCxDQUFDO0FBQ0Q7QUFDQSxTQUFTLHFCQUFxQixHQUFHO0FBQ2pDLEVBQUUsSUFBSTtBQUNOLElBQUksTUFBTSxFQUFFLEdBQUcsSUFBSSxpQkFBaUIsQ0FBQyxTQUFTLENBQUMsQ0FBQztBQUNoRDtBQUNBLElBQUksSUFBSSxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsTUFBTSxFQUFFLENBQUM7QUFDMUIsSUFBSSxJQUFJLEVBQUUsRUFBRSxPQUFPLElBQUk7QUFDdkIsR0FBRyxDQUFDLE9BQU8sQ0FBQyxFQUFFO0FBQ2Q7QUFDQSxHQUFHO0FBQ0gsRUFBRSxPQUFPLEtBQUs7QUFDZCxDQUFDO0FBQ0Q7QUFDQSxlQUFlLFlBQVksQ0FBQztBQUM1QixFQUFFLEVBQUU7QUFDSixFQUFFLE1BQU07QUFDUixFQUFFLElBQUk7QUFDTixFQUFFLE1BQU07QUFDUixFQUFFLE1BQU0sR0FBRyxTQUFTO0FBQ3BCLEVBQUUsR0FBRyxHQUFHLFNBQVM7QUFDakIsRUFBRSxNQUFNLEdBQUcsS0FBSztBQUNoQixDQUFDLEVBQUU7QUFDSCxFQUFFLElBQUksTUFBTSxLQUFLLFVBQVUsRUFBRTtBQUM3QixJQUFJLElBQUksTUFBTSxLQUFLLFNBQVMsRUFBRTtBQUM5QixNQUFNLE1BQU0sR0FBRyxTQUFTLENBQUMsSUFBSSxDQUFDLEVBQUUsSUFBSSxFQUFFLE1BQU0sRUFBRSxDQUFDLENBQUM7QUFDaEQsS0FBSztBQUNMLElBQUksR0FBRyxHQUFHLE1BQU0sTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0FBQy9CLElBQUksTUFBTSxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsTUFBTSxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztBQUNoRCxHQUFHO0FBQ0gsRUFBRSxJQUFJLENBQUMsTUFBTSxFQUFFO0FBQ2YsSUFBSSxNQUFNLGdCQUFnQixDQUFDLEVBQUUsRUFBRSxFQUFFLE1BQU0sRUFBRSxNQUFNLEVBQUUsTUFBTSxFQUFFLFVBQVUsRUFBRSxHQUFHLEVBQUUsQ0FBQyxDQUFDO0FBQzVFLEdBQUc7QUFDSCxFQUFFLE9BQU8sR0FBRztBQUNaLENBQUM7QUFDRDtBQUNBLFNBQVMsZUFBZSxDQUFDLElBQUksRUFBRSxLQUFLLEVBQUU7QUFDdEMsRUFBRSxJQUFJLEtBQUssS0FBSyxTQUFTLEVBQUU7QUFDM0IsSUFBSSxNQUFNLElBQUkscUJBQXFCLENBQUMsSUFBSSxDQUFDO0FBQ3pDLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHLENBQUM7QUFDbkIsRUFBRSxFQUFFLEVBQUUsR0FBRztBQUNULEVBQUUsR0FBRztBQUNMLEVBQUUsTUFBTSxHQUFHLElBQUksQ0FBQyxHQUFHLEVBQUUsTUFBTSxDQUFDO0FBQzVCLEVBQUUsUUFBUTtBQUNWLEVBQUUsS0FBSyxHQUFHLEVBQUU7QUFDWixDQUFDLEVBQUU7QUFDSCxFQUFFLElBQUk7QUFDTixJQUFJLGVBQWUsQ0FBQyxJQUFJLEVBQUUsR0FBRyxDQUFDLENBQUM7QUFDL0IsSUFBSSxlQUFlLENBQUMsS0FBSyxFQUFFLEdBQUcsQ0FBQyxDQUFDO0FBQ2hDLElBQUksZUFBZSxDQUFDLFFBQVEsRUFBRSxNQUFNLENBQUMsQ0FBQztBQUN0QyxJQUFJLGVBQWUsQ0FBQyxVQUFVLEVBQUUsUUFBUSxDQUFDLENBQUM7QUFDMUM7QUFDQSxJQUFJLE1BQU0sRUFBRSxHQUFHLElBQUksVUFBVSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0FBQ25DLElBQUksTUFBTSxlQUFlLENBQUMsT0FBTyxDQUFDLEVBQUUsRUFBRSxFQUFFLE1BQU0sRUFBRSxLQUFLLEVBQUUsRUFBRSxlQUFlLEtBQUssRUFBRTtBQUMvRSxNQUFNLE1BQU0sVUFBVSxDQUFDLEVBQUUsR0FBRyxFQUFFLE1BQU0sRUFBRSxFQUFFLEVBQUUsUUFBUSxFQUFFLEtBQUssRUFBRSxDQUFDLENBQUM7QUFDN0QsS0FBSyxDQUFDLENBQUM7QUFDUCxHQUFHLENBQUMsT0FBTyxHQUFHLEVBQUU7QUFDaEIsSUFBSSxHQUFHLENBQUMsTUFBTSxHQUFHLFNBQVMsQ0FBQztBQUMzQixJQUFJLE1BQU0sR0FBRztBQUNiLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQSxlQUFlLFVBQVUsQ0FBQyxFQUFFLEdBQUcsRUFBRSxNQUFNLEVBQUUsRUFBRSxFQUFFLFFBQVEsRUFBRSxLQUFLLEVBQUUsRUFBRTtBQUNoRTtBQUNBLEVBQUUsTUFBTSxPQUFPLEdBQUcsTUFBTSxnQkFBZ0IsQ0FBQyxTQUFTLENBQUM7QUFDbkQsSUFBSSxFQUFFO0FBQ04sSUFBSSxHQUFHO0FBQ1AsSUFBSSxNQUFNO0FBQ1YsSUFBSSxRQUFRO0FBQ1osR0FBRyxDQUFDLENBQUM7QUFDTCxFQUFFLElBQUksT0FBTyxFQUFFLE1BQU07QUFDckIsRUFBRSxNQUFNLEtBQUssR0FBRyxNQUFNLEVBQUUsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEdBQUcsRUFBRSxRQUFRLENBQUMsQ0FBQyxDQUFDO0FBQ3BELEVBQUUsSUFBSSxDQUFDLEtBQUssRUFBRSxNQUFNLElBQUksYUFBYSxDQUFDLFFBQVEsQ0FBQztBQUMvQyxFQUFFLElBQUksS0FBSyxDQUFDLFdBQVcsRUFBRSxFQUFFO0FBQzNCLElBQUksTUFBTSxRQUFRLEdBQUcsTUFBTSxFQUFFLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsUUFBUSxDQUFDLENBQUMsQ0FBQztBQUMzRCxJQUFJLE1BQU0sUUFBUSxHQUFHLFFBQVEsQ0FBQyxHQUFHLENBQUMsS0FBSztBQUN2QyxNQUFNLFVBQVUsQ0FBQyxFQUFFLEdBQUcsRUFBRSxNQUFNLEVBQUUsRUFBRSxFQUFFLFFBQVEsRUFBRSxJQUFJLENBQUMsUUFBUSxFQUFFLEtBQUssQ0FBQyxFQUFFLEtBQUssRUFBRSxDQUFDO0FBQzdFLEtBQUssQ0FBQztBQUNOLElBQUksTUFBTSxPQUFPLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxDQUFDO0FBQ2hDLEdBQUcsTUFBTTtBQUNULElBQUksTUFBTSxNQUFNLEdBQUcsS0FBSyxDQUFDLGNBQWMsRUFBRTtBQUN6QyxRQUFRLE1BQU0sRUFBRSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLFFBQVEsQ0FBQyxDQUFDO0FBQzlDLFFBQVEsTUFBTSxFQUFFLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsUUFBUSxDQUFDLENBQUMsQ0FBQztBQUMzQyxJQUFJLElBQUksTUFBTSxLQUFLLElBQUksRUFBRSxNQUFNLElBQUksYUFBYSxDQUFDLFFBQVEsQ0FBQztBQUMxRCxJQUFJLE1BQU0sR0FBRyxHQUFHLE1BQU0sWUFBWSxDQUFDLEVBQUUsRUFBRSxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUUsTUFBTSxFQUFFLE1BQU0sRUFBRSxDQUFDLENBQUM7QUFDekUsSUFBSSxLQUFLLENBQUMsTUFBTSxDQUFDLEVBQUUsUUFBUSxFQUFFLEtBQUssRUFBRSxHQUFHLEVBQUUsQ0FBQyxDQUFDO0FBQzNDLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPLENBQUM7QUFDdkIs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QUFDO0FBQzNCLEVBQUUsT0FBTyxHQUFHLENBQUMsTUFBTSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQztBQUNyQyxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sVUFBVSxDQUFDO0FBQ2pCLEVBQUUsT0FBTyxLQUFLLEdBQUc7QUFDakIsSUFBSSxPQUFPLE1BQU0sQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLE1BQU0sQ0FBQztBQUN0QyxHQUFHO0FBQ0g7QUFDQSxFQUFFLE9BQU8sS0FBSyxHQUFHO0FBQ2pCLElBQUksT0FBTyxNQUFNLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxNQUFNLENBQUM7QUFDdEMsR0FBRztBQUNIO0FBQ0EsRUFBRSxPQUFPLE1BQU0sQ0FBQyxJQUFJLEVBQUU7QUFDdEIsSUFBSSxJQUFJLE9BQU8sSUFBSSxLQUFLLFFBQVEsRUFBRTtBQUNsQyxNQUFNLElBQUksR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQy9CLEtBQUs7QUFDTCxJQUFJLE1BQU0sTUFBTSxHQUFHLElBQUksQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDO0FBQ25DLElBQUksTUFBTSxTQUFTLEdBQUcsTUFBTSxDQUFDLENBQUMsRUFBRSxNQUFNLENBQUMsQ0FBQztBQUN4QyxJQUFJLE9BQU8sTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLE1BQU0sQ0FBQyxJQUFJ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QVUsQ0FBQyxNQUFNLENBQUMsQ0FBQyxLQUFLLEVBQUUsR0FBRyxDQUFDLEVBQUUscUJBQXFCLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ2hGLElBQUkscUJBQXFCLEdBQUcsRUFBRSxDQUFDO0FBQy9CLEdBQUc7QUFDSCxFQUFFLEtBQUssTUFBTSxHQUFHLElBQUksUUFBUSxFQUFFO0FBQzlCLElBQUksVUFBVSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLENBQUMsUUFBUSxFQUFFLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDM0QsR0FBRztBQUNILEVBQUUsSUFBSSxLQUFLLEtBQUssSUFBSSxFQUFFO0FBQ3RCLElBQUksVUFBVSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLENBQUMsT0FBTyxFQUFFLEtBQUssQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDNUQsR0FBRztBQUNILEVBQUUsSUFBSSxLQUFLLEtBQUssSUFBSSxFQUFFO0FBQ3RCLElBQUksVUFBVSxDQUFDLElBQUk7QUFDbkIsTUFBTSxVQUFVLENBQUMsTUFBTSxDQUFDLENBQUMsYUFBYSxFQUFFLElBQUksQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLE9BQU8sRUFBRSxHQUFHLElBQUksQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDO0FBQy9FLEtBQUssQ0FBQztBQUNOLEdBQUc7QUFDSCxFQUFFLEtBQUssTUFBTSxHQUFHLElBQUksT0FBTyxFQUFFO0FBQzdCLElBQUksVUFBVSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLENBQUMsV0FBVyxFQUFFLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDOUQsR0FBRztBQUNILEVBQUUsVUFBVSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQztBQUN0QyxFQUFFLEtBQUssTUFBTSxHQUFHLElBQUksS0FBSyxFQUFFO0FBQzNCLElBQUks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RUFBRSxVQUFVLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMsQ0FBQyxNQUFNLEVBQUUsR0FBRyxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDN0Q7QUFDQSxFQUFFLElBQUksUUFBUSxJQUFJLE9BQU8sSUFBSSxNQUFNLEVBQUU7QUFDckMsSUFBSSxVQUFVLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDO0FBQ3hDLEdBQUc7QUFDSCxFQUFFLElBQUksUUFBUSxFQUFFLFVBQVUsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO0FBQzNELEVBQUUsSUFBSSxPQUFPLEVBQUUsVUFBVSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUM7QUFDN0QsRUFBRSxJQUFJLE1BQU0sRUFBRSxVQUFVLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMsQ0FBQyxXQUFXLEVBQUUsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDekUsRUFBRSxVQUFVLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDO0FBQ3RDLEVBQUUsT0FBTyxVQUFVO0FBQ25CLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUcsTUFBTSxXQUFXLENBQUMsRUFBRSxFQUFFLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBRSxHQUFHLEVBQUUsQ0FBQyxDQUFDO0FBQzNFLElBQUksTUFBTSxXQUFXLENBQUMsRUFBRSxLQUFLLEVBQUUsTUFBTSxFQUFFLEtBQUssRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFDO0FBQ3RELEdBQUc7QUFDSDtBQUNBLEVBQUUsTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDO0FBQy9CLEVBQUUsWUFBWSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztBQUM1QixFQUFFLE9BQU8sWUFBWTtBQUNyQixDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZLENBQUMsRUFBRSxFQUFFLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUUsS0FBSyxFQUFFLEVBQUU7QUFDaEUsRUFBRSxNQUFNLE9BQU8sR0FBRyxNQUFNLEtBQUssQ0FBQyxFQUFFLEVBQUUsRUFBRSxLQUFLLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRSxDQUFDLENBQUM7QUFDM0QsRUFBRSxNQUFNLFFBQVEsR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLE1BQU0sT0FBTyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUM7QUFDdkQsRUFBRSxNQUFNLFdBQVcsR0FBRyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDO0FBQzFELEVBQUUsTUFBTSxRQUFRLEdBQUcsQ0FBQyxLQUFLLEVBQUUsV0FBVyxDQUFDLEtBQUssQ0FBQyxDQUFDO0FBQzlDLEVBQUUsSUFBSSxLQUFLLEVBQUU7QUFDYixJQUFJLE1BQU0sRUFBRSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLENB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QUFNLEdBQUcsY0FBYyxDQUFDO0FBQ2hDLElBQUksTUFBTSxHQUFHO0FBQ2IsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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
